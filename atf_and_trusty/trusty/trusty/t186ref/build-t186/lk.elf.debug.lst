
t186ref/build-t186/lk.elf:     file format elf64-littleaarch64


Disassembly of section .text:

ffffffffea800000 <_start>:

.section .text.boot
FUNCTION(_start)
#if WITH_KERNEL_VM
    /* enable caches so atomics and spinlocks work */
    mrs     tmp, sctlr_el1
ffffffffea800000:	d5381009 	mrs	x9, sctlr_el1
    orr     tmp, tmp, #(1<<12) /* Enable icache */
ffffffffea800004:	b2740129 	orr	x9, x9, #0x1000
    orr     tmp, tmp, #(1<<2)  /* Enable dcache/ucache */
ffffffffea800008:	b27e0129 	orr	x9, x9, #0x4
    bic     tmp, tmp, #(1<<3)  /* Disable Stack Alignment Check */ /* TODO: don't use unaligned stacks */
ffffffffea80000c:	927cf929 	and	x9, x9, #0xfffffffffffffff7
    msr     sctlr_el1, tmp
ffffffffea800010:	d5181009 	msr	sctlr_el1, x9

    /* set up the mmu according to mmu_initial_mappings */

    /* load the base of the translation table and clear the table */
    adrp    page_table1, arm64_kernel_translation_table
ffffffffea800014:	d0000275 	adrp	x21, ffffffffea84e000 <arm64_kernel_translation_table>
    add     page_table1, page_table1, #:lo12:arm64_kernel_translation_table
ffffffffea800018:	910002b5 	add	x21, x21, #0x0

    /* Prepare tt_trampoline page table */
    /* Calculate pagetable physical addresses */
    adrp    page_table0, tt_trampoline
ffffffffea80001c:	f0000274 	adrp	x20, ffffffffea84f000 <tt_trampoline>
    add     page_table0, page_table0, #:lo12:tt_trampoline
ffffffffea800020:	91000294 	add	x20, x20, #0x0

#if WITH_SMP
    mov     tmp, x0
ffffffffea800024:	aa0003e9 	mov	x9, x0
    mov     tmp2,x1
ffffffffea800028:	aa0103ea 	mov	x10, x1
    mov     tmp3,x2
ffffffffea80002c:	aa0203f0 	mov	x16, x2
    mov     tmp4,x3
ffffffffea800030:	aa0303f1 	mov	x17, x3
    /* NV: read cpuid by arch_curr_cpu_num */
    bl      arch_curr_cpu_num
ffffffffea800034:	94000a9d 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
    mov     cpuid, x0
ffffffffea800038:	aa0003f3 	mov	x19, x0
    mov     x3, tmp4
ffffffffea80003c:	aa1103e3 	mov	x3, x17
    mov     x2, tmp3
ffffffffea800040:	aa1003e2 	mov	x2, x16
    mov     x1, tmp2
ffffffffea800044:	aa0a03e1 	mov	x1, x10
    mov     x0, tmp
ffffffffea800048:	aa0903e0 	mov	x0, x9
    cbnz    cpuid, .Lmmu_enable_secondary
ffffffffea80004c:	b5000eb3 	cbnz	x19, ffffffffea800220 <_start+0x220>
#endif

    mov     tmp, #0
ffffffffea800050:	d2800009 	mov	x9, #0x0                   	// #0

    /* walk through all the entries in the translation table, setting them up */
.Lclear_top_page_table_loop:
    str     xzr, [page_table1, tmp, lsl #3]
ffffffffea800054:	f8297abf 	str	xzr, [x21, x9, lsl #3]
    add     tmp, tmp, #1
ffffffffea800058:	91000529 	add	x9, x9, #0x1
    cmp     tmp, #MMU_KERNEL_PAGE_TABLE_ENTRIES_TOP
ffffffffea80005c:	f104013f 	cmp	x9, #0x100
    bne     .Lclear_top_page_table_loop
ffffffffea800060:	54ffffa1 	b.ne	ffffffffea800054 <_start+0x54>  // b.any

    /* load the address of the mmu_initial_mappings table and start processing */
    adrp    mmu_initial_mapping, mmu_initial_mappings
ffffffffea800064:	b00000d6 	adrp	x22, ffffffffea819000 <_mem_phys_base>
    add     mmu_initial_mapping, mmu_initial_mapping, #:lo12:mmu_initial_mappings
ffffffffea800068:	910062d6 	add	x22, x22, #0x18

.Linitial_mapping_loop:
    ldp     paddr, vaddr, [mmu_initial_mapping, #__MMU_INITIAL_MAPPING_PHYS_OFFSET]
ffffffffea80006c:	a9405ed8 	ldp	x24, x23, [x22]
    ldp     size, tmp, [mmu_initial_mapping, #__MMU_INITIAL_MAPPING_SIZE_OFFSET]
ffffffffea800070:	a94126da 	ldp	x26, x9, [x22, #16]

    tbzmask tmp, MMU_INITIAL_MAPPING_FLAG_DYNAMIC, .Lnot_dynamic
ffffffffea800074:	361800a9 	tbz	w9, #3, ffffffffea800088 <_start+0x88>
    adr     paddr, _start
ffffffffea800078:	10fffc58 	adr	x24, ffffffffea800000 <_start>
    mov     size, x0
ffffffffea80007c:	aa0003fa 	mov	x26, x0
    str     paddr, [mmu_initial_mapping, #__MMU_INITIAL_MAPPING_PHYS_OFFSET]
ffffffffea800080:	f90002d8 	str	x24, [x22]
    str     size, [mmu_initial_mapping, #__MMU_INITIAL_MAPPING_SIZE_OFFSET]
ffffffffea800084:	f9000ada 	str	x26, [x22, #16]

.Lnot_dynamic:
    /* if size == 0, end of list */
    cbz     size, .Linitial_mapping_done
ffffffffea800088:	b4000b3a 	cbz	x26, ffffffffea8001ec <_start+0x1ec>
    mov     mapping_size, size
ffffffffea80008c:	aa1a03f9 	mov	x25, x26

    /* set up the flags */
    tbzmask tmp, MMU_INITIAL_MAPPING_FLAG_UNCACHED, .Lnot_uncached
ffffffffea800090:	36080069 	tbz	w9, #1, ffffffffea80009c <_start+0x9c>
    ldr     attr, =MMU_INITIAL_MAP_STRONGLY_ORDERED
ffffffffea800094:	580012fb 	ldr	x27, ffffffffea8002f0 <_start+0x2f0>
    b       .Lmem_type_done
ffffffffea800098:	14000013 	b	ffffffffea8000e4 <_start+0xe4>
.Lnot_uncached:
    tbzmask tmp, MMU_INITIAL_MAPPING_FLAG_DEVICE, .Lnot_device
ffffffffea80009c:	36100069 	tbz	w9, #2, ffffffffea8000a8 <_start+0xa8>
    ldr     attr, =MMU_INITIAL_MAP_DEVICE
ffffffffea8000a0:	580012db 	ldr	x27, ffffffffea8002f8 <_start+0x2f8>
    b       .Lmem_type_done
ffffffffea8000a4:	14000010 	b	ffffffffea8000e4 <_start+0xe4>
.Lnot_device:

.Lmapping_size_loop:
    ldr     attr, =MMU_PTE_KERNEL_RO_FLAGS
ffffffffea8000a8:	580012db 	ldr	x27, ffffffffea800300 <_start+0x300>
    ldr     tmp, =__rodata_start
ffffffffea8000ac:	580012e9 	ldr	x9, ffffffffea800308 <_start+0x308>
    subs    size, tmp, vaddr
ffffffffea8000b0:	eb17013a 	subs	x26, x9, x23
    b.hi    .Lmem_type_done
ffffffffea8000b4:	54000188 	b.hi	ffffffffea8000e4 <_start+0xe4>  // b.pmore
    orr     attr, attr, #MMU_PTE_ATTR_PXN
ffffffffea8000b8:	b24b037b 	orr	x27, x27, #0x20000000000000
    ldr     tmp, =__data_start
ffffffffea8000bc:	580012a9 	ldr	x9, ffffffffea800310 <_start+0x310>
    subs    size, tmp, vaddr
ffffffffea8000c0:	eb17013a 	subs	x26, x9, x23
    b.hi    .Lmem_type_done
ffffffffea8000c4:	54000108 	b.hi	ffffffffea8000e4 <_start+0xe4>  // b.pmore
    ldr     attr, =MMU_PTE_KERNEL_DATA_FLAGS
ffffffffea8000c8:	5800129b 	ldr	x27, ffffffffea800318 <_start+0x318>
    ldr     tmp, =_end
ffffffffea8000cc:	580012a9 	ldr	x9, ffffffffea800320 <_start+0x320>
    subs    size, tmp, vaddr
ffffffffea8000d0:	eb17013a 	subs	x26, x9, x23
    b.lo    . /* Error: _end < vaddr */
ffffffffea8000d4:	54000003 	b.cc	ffffffffea8000d4 <_start+0xd4>  // b.lo, b.ul, b.last
    cmp     mapping_size, size
ffffffffea8000d8:	eb1a033f 	cmp	x25, x26
    b.lo    . /* Error: mapping_size < size => RAM size too small for data/bss */
ffffffffea8000dc:	54000003 	b.cc	ffffffffea8000dc <_start+0xdc>  // b.lo, b.ul, b.last
    mov     size, mapping_size
ffffffffea8000e0:	aa1903fa 	mov	x26, x25

.Lmem_type_done:
    subs    mapping_size, mapping_size, size
ffffffffea8000e4:	eb1a0339 	subs	x25, x25, x26
    b.lo    . /* Error: mapping_size < size (RAM size too small for code/rodata?) */
ffffffffea8000e8:	54000003 	b.cc	ffffffffea8000e8 <_start+0xe8>  // b.lo, b.ul, b.last

    /* Check that paddr, vaddr and size are page aligned */
    orr     tmp, vaddr, paddr
ffffffffea8000ec:	aa1802e9 	orr	x9, x23, x24
    orr     tmp, tmp, size
ffffffffea8000f0:	aa1a0129 	orr	x9, x9, x26
    tst     tmp, #(1 << MMU_KERNEL_PAGE_SIZE_SHIFT) - 1
ffffffffea8000f4:	f2402d3f 	tst	x9, #0xfff
    bne     . /* Error: not page aligned */
ffffffffea8000f8:	54000001 	b.ne	ffffffffea8000f8 <_start+0xf8>  // b.any

    /* Clear top bits of virtual address (should be all set) */
    eor     vaddr, vaddr, #(~0 << MMU_KERNEL_SIZE_SHIFT)
ffffffffea8000fc:	d2638af7 	eor	x23, x23, #0xffffffffe0000000

    /* Check that top bits were all set */
    tst     vaddr, #(~0 << MMU_KERNEL_SIZE_SHIFT)
ffffffffea800100:	f2638aff 	tst	x23, #0xffffffffe0000000
    bne     . /* Error: vaddr out of range */
ffffffffea800104:	54000001 	b.ne	ffffffffea800104 <_start+0x104>  // b.any

.Lmap_range_top_loop:
    /* Select top level page table */
    mov     page_table, page_table1
ffffffffea800108:	aa1503ed 	mov	x13, x21
    mov     idx_shift, #MMU_KERNEL_TOP_SHIFT
ffffffffea80010c:	d28002ac 	mov	x12, #0x15                  	// #21

    lsr     idx, vaddr, idx_shift
ffffffffea800110:	9acc26eb 	lsr	x11, x23, x12

.Lmap_range_one_table_loop:
    /* Check if current level allow block descriptors */
    cmp     idx_shift, #MMU_PTE_DESCRIPTOR_BLOCK_MAX_SHIFT
ffffffffea800114:	f100799f 	cmp	x12, #0x1e
    b.hi    .Lmap_range_need_page_table
ffffffffea800118:	54000308 	b.hi	ffffffffea800178 <_start+0x178>  // b.pmore

    /* Check if paddr and vaddr alignment allows a block descriptor */
    orr     tmp2, vaddr, paddr
ffffffffea80011c:	aa1802ea 	orr	x10, x23, x24
    lsr     tmp, tmp2, idx_shift
ffffffffea800120:	9acc2549 	lsr	x9, x10, x12
    lsl     tmp, tmp, idx_shift
ffffffffea800124:	9acc2129 	lsl	x9, x9, x12
    cmp     tmp, tmp2
ffffffffea800128:	eb0a013f 	cmp	x9, x10
    b.ne    .Lmap_range_need_page_table
ffffffffea80012c:	54000261 	b.ne	ffffffffea800178 <_start+0x178>  // b.any

    /* Check if size is large enough for a block mapping */
    lsr     tmp, size, idx_shift
ffffffffea800130:	9acc2749 	lsr	x9, x26, x12
    cbz     tmp, .Lmap_range_need_page_table
ffffffffea800134:	b4000229 	cbz	x9, ffffffffea800178 <_start+0x178>

    /* Select descriptor type, page for level 3, block for level 0-2 */
    orr     tmp, attr, #MMU_PTE_L3_DESCRIPTOR_PAGE
ffffffffea800138:	b2400769 	orr	x9, x27, #0x3
    cmp     idx_shift, MMU_KERNEL_PAGE_SIZE_SHIFT
ffffffffea80013c:	f100319f 	cmp	x12, #0xc
    beq     .Lmap_range_l3
ffffffffea800140:	54000040 	b.eq	ffffffffea800148 <_start+0x148>  // b.none
    orr     tmp, attr, #MMU_PTE_L012_DESCRIPTOR_BLOCK
ffffffffea800144:	b2400369 	orr	x9, x27, #0x1
.Lmap_range_l3:

    /* Write page table entry */
    orr     tmp, tmp, paddr
ffffffffea800148:	aa180129 	orr	x9, x9, x24
    str     tmp, [page_table, idx, lsl #3]
ffffffffea80014c:	f82b79a9 	str	x9, [x13, x11, lsl #3]

    /* Move to next page table entry */
    mov     tmp, #1
ffffffffea800150:	d2800029 	mov	x9, #0x1                   	// #1
    lsl     tmp, tmp, idx_shift
ffffffffea800154:	9acc2129 	lsl	x9, x9, x12
    add     vaddr, vaddr, tmp
ffffffffea800158:	8b0902f7 	add	x23, x23, x9
    add     paddr, paddr, tmp
ffffffffea80015c:	8b090318 	add	x24, x24, x9
    subs    size, size, tmp
ffffffffea800160:	eb09035a 	subs	x26, x26, x9
    /* TODO: add local loop if next entry is in the same page table */
    b.ne    .Lmap_range_top_loop /* size != 0 */
ffffffffea800164:	54fffd21 	b.ne	ffffffffea800108 <_start+0x108>  // b.any

    /* Restore top bits of virtual address (should be all set) */
    eor     vaddr, vaddr, #(~0 << MMU_KERNEL_SIZE_SHIFT)
ffffffffea800168:	d2638af7 	eor	x23, x23, #0xffffffffe0000000
    /* Move to next subtype of ram mmu_initial_mappings entry */
    cbnz     mapping_size, .Lmapping_size_loop
ffffffffea80016c:	b5fff9f9 	cbnz	x25, ffffffffea8000a8 <_start+0xa8>

    /* Move to next mmu_initial_mappings entry */
    add     mmu_initial_mapping, mmu_initial_mapping, __MMU_INITIAL_MAPPING_SIZE
ffffffffea800170:	9100a2d6 	add	x22, x22, #0x28
    b       .Linitial_mapping_loop
ffffffffea800174:	17ffffbe 	b	ffffffffea80006c <_start+0x6c>

.Lmap_range_need_page_table:
    /* Check if page table entry is unused */
    ldr     new_page_table, [page_table, idx, lsl #3]
ffffffffea800178:	f86b79ae 	ldr	x14, [x13, x11, lsl #3]
    cbnz    new_page_table, .Lmap_range_has_page_table
ffffffffea80017c:	b500024e 	cbnz	x14, ffffffffea8001c4 <_start+0x1c4>

    /* Calculate phys offset (needed for memory allocation) */
.Lphys_offset:
    adr     phys_offset, .Lphys_offset /* phys */
ffffffffea800180:	1000000f 	adr	x15, ffffffffea800180 <_start+0x180>
    ldr     tmp, =.Lphys_offset /* virt */
ffffffffea800184:	58000d29 	ldr	x9, ffffffffea800328 <_start+0x328>
    sub     phys_offset, tmp, phys_offset
ffffffffea800188:	cb0f012f 	sub	x15, x9, x15

    /* Allocate new page table */
    calloc_bootmem_aligned new_page_table, tmp, tmp2, MMU_KERNEL_PAGE_SIZE_SHIFT, phys_offset
ffffffffea80018c:	b00000ca 	adrp	x10, ffffffffea819000 <_mem_phys_base>
ffffffffea800190:	f947494e 	ldr	x14, [x10, #3728]
ffffffffea800194:	913ffdce 	add	x14, x14, #0xfff
ffffffffea800198:	9274cdce 	and	x14, x14, #0xfffffffffffff000
ffffffffea80019c:	914005c9 	add	x9, x14, #0x1, lsl #12
ffffffffea8001a0:	f9074949 	str	x9, [x10, #3728]
ffffffffea8001a4:	cb0f01ce 	sub	x14, x14, x15
ffffffffea8001a8:	cb0f0129 	sub	x9, x9, x15
ffffffffea8001ac:	aa0e03ea 	mov	x10, x14
ffffffffea8001b0:	a8817d5f 	stp	xzr, xzr, [x10], #16
ffffffffea8001b4:	eb09015f 	cmp	x10, x9
ffffffffea8001b8:	54ffffc3 	b.cc	ffffffffea8001b0 <_start+0x1b0>  // b.lo, b.ul, b.last

    /* Write page table entry (with allocated page table) */
    orr     new_page_table, new_page_table, #MMU_PTE_L012_DESCRIPTOR_TABLE
ffffffffea8001bc:	b24005ce 	orr	x14, x14, #0x3
    str     new_page_table, [page_table, idx, lsl #3]
ffffffffea8001c0:	f82b79ae 	str	x14, [x13, x11, lsl #3]

.Lmap_range_has_page_table:
    /* Check descriptor type */
    and     tmp, new_page_table, #MMU_PTE_DESCRIPTOR_MASK
ffffffffea8001c4:	924005c9 	and	x9, x14, #0x3
    cmp     tmp, #MMU_PTE_L012_DESCRIPTOR_TABLE
ffffffffea8001c8:	f1000d3f 	cmp	x9, #0x3
    b.ne    . /* Error: entry already in use (as a block entry) */
ffffffffea8001cc:	54000001 	b.ne	ffffffffea8001cc <_start+0x1cc>  // b.any

    /* switch to next page table level */
    bic     page_table, new_page_table, #MMU_PTE_DESCRIPTOR_MASK
ffffffffea8001d0:	927ef5cd 	and	x13, x14, #0xfffffffffffffffc
    mov     tmp, #~0
ffffffffea8001d4:	92800009 	mov	x9, #0xffffffffffffffff    	// #-1
    lsl     tmp, tmp, idx_shift
ffffffffea8001d8:	9acc2129 	lsl	x9, x9, x12
    bic     tmp, vaddr, tmp
ffffffffea8001dc:	8a2902e9 	bic	x9, x23, x9
    sub     idx_shift, idx_shift, #(MMU_KERNEL_PAGE_SIZE_SHIFT - 3)
ffffffffea8001e0:	d100258c 	sub	x12, x12, #0x9
    lsr     idx, tmp, idx_shift
ffffffffea8001e4:	9acc252b 	lsr	x11, x9, x12

    b       .Lmap_range_one_table_loop
ffffffffea8001e8:	17ffffcb 	b	ffffffffea800114 <_start+0x114>
.Linitial_mapping_done:

    /* Prepare tt_trampoline page table */

    /* Zero tt_trampoline translation tables */
    mov     tmp, #0
ffffffffea8001ec:	d2800009 	mov	x9, #0x0                   	// #0
.Lclear_tt_trampoline:
    str     xzr, [page_table0, tmp, lsl#3]
ffffffffea8001f0:	f8297a9f 	str	xzr, [x20, x9, lsl #3]
    add     tmp, tmp, #1
ffffffffea8001f4:	91000529 	add	x9, x9, #0x1
    cmp     tmp, #MMU_PAGE_TABLE_ENTRIES_IDENT
ffffffffea8001f8:	f108013f 	cmp	x9, #0x200
    blt     .Lclear_tt_trampoline
ffffffffea8001fc:	54ffffab 	b.lt	ffffffffea8001f0 <_start+0x1f0>  // b.tstop

    /* Setup mapping at phys -> phys */
    adr     tmp, .Lmmu_on_pc
ffffffffea800200:	10000329 	adr	x9, ffffffffea800264 <_start+0x264>
    lsr     tmp, tmp, #MMU_IDENT_TOP_SHIFT    /* tmp = paddr index */
ffffffffea800204:	d35efd29 	lsr	x9, x9, #30
    ldr     tmp2, =MMU_PTE_IDENT_FLAGS
ffffffffea800208:	5800094a 	ldr	x10, ffffffffea800330 <_start+0x330>
    add     tmp2, tmp2, tmp, lsl #MMU_IDENT_TOP_SHIFT  /* tmp2 = pt entry */
ffffffffea80020c:	8b09794a 	add	x10, x10, x9, lsl #30

    str     tmp2, [page_table0, tmp, lsl #3]     /* tt_trampoline[paddr index] = pt entry */
ffffffffea800210:	f8297a8a 	str	x10, [x20, x9, lsl #3]

#if WITH_SMP
    adr     tmp, page_tables_not_ready
ffffffffea800214:	100c7c69 	adr	x9, ffffffffea8191a0 <page_tables_not_ready>
    str     wzr, [tmp]
ffffffffea800218:	b900013f 	str	wzr, [x9]
    b       .Lpage_tables_ready
ffffffffea80021c:	14000004 	b	ffffffffea80022c <_start+0x22c>

.Lmmu_enable_secondary:
    adr     tmp, page_tables_not_ready
ffffffffea800220:	100c7c09 	adr	x9, ffffffffea8191a0 <page_tables_not_ready>
.Lpage_tables_not_ready:
    ldr     wtmp2, [tmp]
ffffffffea800224:	b940012a 	ldr	w10, [x9]
    cbnz    wtmp2, .Lpage_tables_not_ready
ffffffffea800228:	35ffffea 	cbnz	w10, ffffffffea800224 <_start+0x224>
#endif

    /* set up the mmu */

    /* Invalidate TLB */
    tlbi    vmalle1is
ffffffffea80022c:	d508831f 	tlbi	vmalle1is
    isb
ffffffffea800230:	d5033fdf 	isb
    dsb     sy
ffffffffea800234:	d5033f9f 	dsb	sy

    /* Initialize Memory Attribute Indirection Register */
    ldr     tmp, =MMU_MAIR_VAL
ffffffffea800238:	58000809 	ldr	x9, ffffffffea800338 <_start+0x338>
    msr     mair_el1, tmp
ffffffffea80023c:	d518a209 	msr	mair_el1, x9

    /* Initialize TCR_EL1 */
    /* set cacheable attributes on translation walk */
    /* (SMP extensions) non-shareable, inner write-back write-allocate */
    ldr     tmp, =MMU_TCR_FLAGS_IDENT
ffffffffea800240:	58000809 	ldr	x9, ffffffffea800340 <_start+0x340>
    msr     tcr_el1, tmp
ffffffffea800244:	d5182049 	msr	tcr_el1, x9

    isb
ffffffffea800248:	d5033fdf 	isb

    /* Write ttbr with phys addr of the translation table */
    msr     ttbr0_el1, page_table0
ffffffffea80024c:	d5182014 	msr	ttbr0_el1, x20
    msr     ttbr1_el1, page_table1
ffffffffea800250:	d5182035 	msr	ttbr1_el1, x21
    isb
ffffffffea800254:	d5033fdf 	isb

    /* Read SCTLR */
    mrs     tmp, sctlr_el1
ffffffffea800258:	d5381009 	mrs	x9, sctlr_el1

    /* Turn on the MMU */
    orr     tmp, tmp, #0x1
ffffffffea80025c:	b2400129 	orr	x9, x9, #0x1

    /* Write back SCTLR */
    msr     sctlr_el1, tmp
ffffffffea800260:	d5181009 	msr	sctlr_el1, x9
.Lmmu_on_pc:
    isb
ffffffffea800264:	d5033fdf 	isb

    /* Jump to virtual code address */
    ldr     tmp, =.Lmmu_on_vaddr
ffffffffea800268:	58000709 	ldr	x9, ffffffffea800348 <_start+0x348>
    br      tmp
ffffffffea80026c:	d61f0120 	br	x9

.Lmmu_on_vaddr:

    /* Disable trampoline page-table in ttbr0 */
    ldr     tmp, =MMU_TCR_FLAGS_KERNEL
ffffffffea800270:	58000709 	ldr	x9, ffffffffea800350 <_start+0x350>
    msr     tcr_el1, tmp
ffffffffea800274:	d5182049 	msr	tcr_el1, x9
    isb
ffffffffea800278:	d5033fdf 	isb


    /* Invalidate TLB */
    tlbi    vmalle1
ffffffffea80027c:	d508871f 	tlbi	vmalle1
    isb
ffffffffea800280:	d5033fdf 	isb

#if WITH_SMP
    cbnz    cpuid, .Lsecondary_boot
ffffffffea800284:	b5000193 	cbnz	x19, ffffffffea8002b4 <_start+0x2b4>
#endif
#endif /* WITH_KERNEL_VM */

    ldr tmp, =__stack_end
ffffffffea800288:	58000689 	ldr	x9, ffffffffea800358 <_start+0x358>
    mov sp, tmp
ffffffffea80028c:	9100013f 	mov	sp, x9

    /* clear bss */
.L__do_bss:
    /* clear out the bss */
    /* NOTE: relies on __bss_start and __bss_end being 8 byte aligned */
    ldr     tmp, =__bss_start
ffffffffea800290:	58000689 	ldr	x9, ffffffffea800360 <_start+0x360>
    ldr     tmp2, =__bss_end
ffffffffea800294:	580006aa 	ldr	x10, ffffffffea800368 <_start+0x368>
    sub     tmp2, tmp2, tmp
ffffffffea800298:	cb09014a 	sub	x10, x10, x9
    cbz     tmp2, .L__bss_loop_done
ffffffffea80029c:	b400008a 	cbz	x10, ffffffffea8002ac <_start+0x2ac>
.L__bss_loop:
    sub     tmp2, tmp2, #8
ffffffffea8002a0:	d100214a 	sub	x10, x10, #0x8
    str     xzr, [tmp], #8
ffffffffea8002a4:	f800853f 	str	xzr, [x9], #8
    cbnz    tmp2, .L__bss_loop
ffffffffea8002a8:	b5ffffca 	cbnz	x10, ffffffffea8002a0 <_start+0x2a0>
.L__bss_loop_done:

    bl  lk_main
ffffffffea8002ac:	94000eeb 	bl	ffffffffea803e58 <lk_main>
    b   .
ffffffffea8002b0:	14000000 	b	ffffffffea8002b0 <_start+0x2b0>

#if WITH_SMP
.Lsecondary_boot:
    and     tmp, cpuid, #0xff
ffffffffea8002b4:	92401e69 	and	x9, x19, #0xff
    cmp     tmp, #(1 << SMP_CPU_CLUSTER_SHIFT)
ffffffffea8002b8:	f104013f 	cmp	x9, #0x100
    bge     .Lunsupported_cpu_trap
ffffffffea8002bc:	5400016a 	b.ge	ffffffffea8002e8 <_start+0x2e8>  // b.tcont
    bic     cpuid, cpuid, #0xff
ffffffffea8002c0:	9278de73 	and	x19, x19, #0xffffffffffffff00
    orr     cpuid, tmp, cpuid, LSR #(8 - SMP_CPU_CLUSTER_SHIFT)
ffffffffea8002c4:	aa530133 	orr	x19, x9, x19, lsr #0

    cmp     cpuid, #SMP_MAX_CPUS
ffffffffea8002c8:	f100227f 	cmp	x19, #0x8
    bge     .Lunsupported_cpu_trap
ffffffffea8002cc:	540000ea 	b.ge	ffffffffea8002e8 <_start+0x2e8>  // b.tcont

    /* Set up the stack */
    ldr     tmp, =__stack_end
ffffffffea8002d0:	58000449 	ldr	x9, ffffffffea800358 <_start+0x358>
    mov     tmp2, #ARCH_DEFAULT_STACK_SIZE
ffffffffea8002d4:	d282000a 	mov	x10, #0x1000                	// #4096
    mul     tmp2, tmp2, cpuid
ffffffffea8002d8:	9b137d4a 	mul	x10, x10, x19
    sub     sp, tmp, tmp2
ffffffffea8002dc:	cb2a613f 	sub	sp, x9, x10

    mov     x0, cpuid
ffffffffea8002e0:	aa1303e0 	mov	x0, x19
    bl      arm64_secondary_entry
ffffffffea8002e4:	94000a17 	bl	ffffffffea802b40 <arm64_secondary_entry>

.Lunsupported_cpu_trap:
    wfe
ffffffffea8002e8:	d503205f 	wfe
    b       .Lunsupported_cpu_trap
ffffffffea8002ec:	17ffffff 	b	ffffffffea8002e8 <_start+0x2e8>
ffffffffea8002f0:	00000400 	.word	0x00000400
ffffffffea8002f4:	00600000 	.word	0x00600000
ffffffffea8002f8:	00000404 	.word	0x00000404
ffffffffea8002fc:	00600000 	.word	0x00600000
ffffffffea800300:	00000788 	.word	0x00000788
ffffffffea800304:	00400000 	.word	0x00400000
ffffffffea800308:	ea815000 	.word	0xea815000
ffffffffea80030c:	ffffffff 	.word	0xffffffff
ffffffffea800310:	ea819000 	.word	0xea819000
ffffffffea800314:	ffffffff 	.word	0xffffffff
ffffffffea800318:	00000708 	.word	0x00000708
ffffffffea80031c:	00600000 	.word	0x00600000
ffffffffea800320:	ea85e128 	.word	0xea85e128
ffffffffea800324:	ffffffff 	.word	0xffffffff
ffffffffea800328:	ea800180 	.word	0xea800180
ffffffffea80032c:	ffffffff 	.word	0xffffffff
ffffffffea800330:	00000709 	.word	0x00000709
ffffffffea800334:	00000000 	.word	0x00000000
ffffffffea800338:	00ff0400 	.word	0x00ff0400
ffffffffea80033c:	00000000 	.word	0x00000000
ffffffffea800340:	b5233519 	.word	0xb5233519
ffffffffea800344:	00000002 	.word	0x00000002
ffffffffea800348:	ea800270 	.word	0xea800270
ffffffffea80034c:	ffffffff 	.word	0xffffffff
ffffffffea800350:	b52335a7 	.word	0xb52335a7
ffffffffea800354:	00000002 	.word	0x00000002
ffffffffea800358:	ea858000 	.word	0xea858000
ffffffffea80035c:	ffffffff 	.word	0xffffffff
ffffffffea800360:	ea858000 	.word	0xea858000
ffffffffea800364:	ffffffff 	.word	0xffffffff
ffffffffea800368:	ea85e128 	.word	0xea85e128
ffffffffea80036c:	ffffffff 	.word	0xffffffff
	...

ffffffffea801000 <arm64_exception_base>:

FUNCTION(arm64_exception_base)

/* exceptions from current EL, using SP0 */
LOCAL_FUNCTION(arm64_sync_exc_current_el_SP0)
    invalid_exception 0
ffffffffea801000:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801004:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801008:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80100c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801010:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801014:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801018:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80101c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801020:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801024:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801028:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80102c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801030:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801034:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801038:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80103c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801040:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801044:	d5384021 	mrs	x1, elr_el1
ffffffffea801048:	d5384002 	mrs	x2, spsr_el1
ffffffffea80104c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801050:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea801054:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea801058:	910003e0 	mov	x0, sp
ffffffffea80105c:	94000777 	bl	ffffffffea802e38 <arm64_invalid_exception>
ffffffffea801060:	14000000 	b	ffffffffea801060 <arm64_exception_base+0x60>
	...

ffffffffea801080 <arm64_irq_current_el_SP0>:

.org 0x080
LOCAL_FUNCTION(arm64_irq_current_el_SP0)
    invalid_exception 1
ffffffffea801080:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801084:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801088:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80108c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801090:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801094:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801098:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80109c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8010a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8010a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8010a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8010ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8010b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8010b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8010b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8010bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8010c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8010c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8010c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8010cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8010d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8010d4:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8010d8:	910003e0 	mov	x0, sp
ffffffffea8010dc:	94000757 	bl	ffffffffea802e38 <arm64_invalid_exception>
ffffffffea8010e0:	14000000 	b	ffffffffea8010e0 <arm64_irq_current_el_SP0+0x60>
	...

ffffffffea801100 <arm64_fiq_current_el_SP0>:

.org 0x100
LOCAL_FUNCTION(arm64_fiq_current_el_SP0)
    invalid_exception 2
ffffffffea801100:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801104:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801108:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80110c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801110:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801114:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801118:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80111c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801120:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801124:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801128:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80112c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801130:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801134:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801138:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80113c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801140:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801144:	d5384021 	mrs	x1, elr_el1
ffffffffea801148:	d5384002 	mrs	x2, spsr_el1
ffffffffea80114c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801150:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea801154:	d2800041 	mov	x1, #0x2                   	// #2
ffffffffea801158:	910003e0 	mov	x0, sp
ffffffffea80115c:	94000737 	bl	ffffffffea802e38 <arm64_invalid_exception>
ffffffffea801160:	14000000 	b	ffffffffea801160 <arm64_fiq_current_el_SP0+0x60>
	...

ffffffffea801180 <arm64_err_exc_current_el_SP0>:

.org 0x180
LOCAL_FUNCTION(arm64_err_exc_current_el_SP0)
    invalid_exception 3
ffffffffea801180:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801184:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801188:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80118c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801190:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801194:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801198:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80119c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8011a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8011a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8011a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8011ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8011b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8011b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8011b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8011bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8011c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8011c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8011c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8011cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8011d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8011d4:	d2800061 	mov	x1, #0x3                   	// #3
ffffffffea8011d8:	910003e0 	mov	x0, sp
ffffffffea8011dc:	94000717 	bl	ffffffffea802e38 <arm64_invalid_exception>
ffffffffea8011e0:	14000000 	b	ffffffffea8011e0 <arm64_err_exc_current_el_SP0+0x60>
	...

ffffffffea801200 <arm64_sync_exc_current_el_SPx>:

/* exceptions from current EL, using SPx */
.org 0x200
LOCAL_FUNCTION(arm64_sync_exc_current_el_SPx)
    regsave_long
ffffffffea801200:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801204:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801208:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80120c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801210:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801214:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801218:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80121c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801220:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801224:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801228:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80122c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801230:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801234:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801238:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80123c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801240:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801244:	d5384021 	mrs	x1, elr_el1
ffffffffea801248:	d5384002 	mrs	x2, spsr_el1
ffffffffea80124c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801250:	a9100be1 	stp	x1, x2, [sp, #256]
    mov x0, sp
ffffffffea801254:	910003e0 	mov	x0, sp
    bl  arm64_sync_exception
ffffffffea801258:	9400069e 	bl	ffffffffea802cd0 <arm64_sync_exception>
    b  arm64_exc_shared_restore_long
ffffffffea80125c:	14000162 	b	ffffffffea8017e4 <arm64_exc_shared_restore_long>
	...

ffffffffea801280 <arm64_irq_current_el_SPx>:

.org 0x280
LOCAL_FUNCTION(arm64_irq_current_el_SPx)
    irq_exception
ffffffffea801280:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801284:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801288:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea80128c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801290:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea801294:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801298:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea80129c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8012a0:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8012a4:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8012a8:	910243e0 	add	x0, sp, #0x90
ffffffffea8012ac:	d5384021 	mrs	x1, elr_el1
ffffffffea8012b0:	d5384002 	mrs	x2, spsr_el1
ffffffffea8012b4:	a90903fe 	stp	x30, x0, [sp, #144]
ffffffffea8012b8:	a90a0be1 	stp	x1, x2, [sp, #160]
ffffffffea8012bc:	d50341ff 	msr	daifclr, #0x1
ffffffffea8012c0:	910003e0 	mov	x0, sp
ffffffffea8012c4:	94000d75 	bl	ffffffffea804898 <platform_irq>
ffffffffea8012c8:	b4000040 	cbz	x0, ffffffffea8012d0 <arm64_irq_current_el_SPx+0x50>
ffffffffea8012cc:	94001467 	bl	ffffffffea806468 <thread_preempt>
ffffffffea8012d0:	d50341df 	msr	daifset, #0x1
ffffffffea8012d4:	1400015b 	b	ffffffffea801840 <arm64_exc_shared_restore_short>
	...

ffffffffea801300 <arm64_fiq_current_el_SPx>:

.org 0x300
LOCAL_FUNCTION(arm64_fiq_current_el_SPx)
    regsave_short
ffffffffea801300:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801304:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801308:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea80130c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801310:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea801314:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801318:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea80131c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801320:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea801324:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801328:	910243e0 	add	x0, sp, #0x90
ffffffffea80132c:	d5384021 	mrs	x1, elr_el1
ffffffffea801330:	d5384002 	mrs	x2, spsr_el1
ffffffffea801334:	a90903fe 	stp	x30, x0, [sp, #144]
ffffffffea801338:	a90a0be1 	stp	x1, x2, [sp, #160]
    mov x0, sp
ffffffffea80133c:	910003e0 	mov	x0, sp
    bl  platform_fiq
ffffffffea801340:	94000dbc 	bl	ffffffffea804a30 <platform_fiq>
    b  arm64_exc_shared_restore_short
ffffffffea801344:	1400013f 	b	ffffffffea801840 <arm64_exc_shared_restore_short>
	...

ffffffffea801380 <arm64_err_exc_current_el_SPx>:

.org 0x380
LOCAL_FUNCTION(arm64_err_exc_current_el_SPx)
    invalid_exception 0x13
ffffffffea801380:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801384:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801388:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80138c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801390:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801394:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801398:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80139c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8013a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8013a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8013a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8013ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8013b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8013b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8013b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8013bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8013c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8013c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8013c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8013cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8013d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8013d4:	d2800261 	mov	x1, #0x13                  	// #19
ffffffffea8013d8:	910003e0 	mov	x0, sp
ffffffffea8013dc:	94000697 	bl	ffffffffea802e38 <arm64_invalid_exception>
ffffffffea8013e0:	14000000 	b	ffffffffea8013e0 <arm64_err_exc_current_el_SPx+0x60>
	...

ffffffffea801400 <arm64_sync_exc_lower_el_64>:

/* exceptions from lower EL, running arm64 */
.org 0x400
LOCAL_FUNCTION(arm64_sync_exc_lower_el_64)
    invalid_exception 0x20
ffffffffea801400:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801404:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801408:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80140c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801410:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801414:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801418:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80141c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801420:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801424:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801428:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80142c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801430:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801434:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801438:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80143c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801440:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801444:	d5384021 	mrs	x1, elr_el1
ffffffffea801448:	d5384002 	mrs	x2, spsr_el1
ffffffffea80144c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801450:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea801454:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea801458:	910003e0 	mov	x0, sp
ffffffffea80145c:	94000677 	bl	ffffffffea802e38 <arm64_invalid_exception>
ffffffffea801460:	14000000 	b	ffffffffea801460 <arm64_sync_exc_lower_el_64+0x60>
	...

ffffffffea801480 <arm64_irq_lower_el_64>:

.org 0x480
LOCAL_FUNCTION(arm64_irq_lower_el_64)
    invalid_exception 0x21
ffffffffea801480:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801484:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801488:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80148c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801490:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801494:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801498:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80149c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8014a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8014a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8014a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8014ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8014b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8014b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8014b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8014bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8014c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8014c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8014c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8014cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8014d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8014d4:	d2800421 	mov	x1, #0x21                  	// #33
ffffffffea8014d8:	910003e0 	mov	x0, sp
ffffffffea8014dc:	94000657 	bl	ffffffffea802e38 <arm64_invalid_exception>
ffffffffea8014e0:	14000000 	b	ffffffffea8014e0 <arm64_irq_lower_el_64+0x60>
	...

ffffffffea801500 <arm64_fiq_lower_el_64>:

.org 0x500
LOCAL_FUNCTION(arm64_fiq_lower_el_64)
    invalid_exception 0x22
ffffffffea801500:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801504:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801508:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80150c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801510:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801514:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801518:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80151c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801520:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801524:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801528:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80152c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801530:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801534:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801538:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80153c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801540:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801544:	d5384021 	mrs	x1, elr_el1
ffffffffea801548:	d5384002 	mrs	x2, spsr_el1
ffffffffea80154c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801550:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea801554:	d2800441 	mov	x1, #0x22                  	// #34
ffffffffea801558:	910003e0 	mov	x0, sp
ffffffffea80155c:	94000637 	bl	ffffffffea802e38 <arm64_invalid_exception>
ffffffffea801560:	14000000 	b	ffffffffea801560 <arm64_fiq_lower_el_64+0x60>
	...

ffffffffea801580 <arm64_err_exc_lower_el_64>:

.org 0x580
LOCAL_FUNCTION(arm64_err_exc_lower_el_64)
    invalid_exception 0x23
ffffffffea801580:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801584:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801588:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80158c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801590:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801594:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801598:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80159c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8015a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8015a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8015a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8015ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8015b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8015b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8015b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8015bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8015c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8015c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8015c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8015cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8015d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8015d4:	d2800461 	mov	x1, #0x23                  	// #35
ffffffffea8015d8:	910003e0 	mov	x0, sp
ffffffffea8015dc:	94000617 	bl	ffffffffea802e38 <arm64_invalid_exception>
ffffffffea8015e0:	14000000 	b	ffffffffea8015e0 <arm64_err_exc_lower_el_64+0x60>
	...

ffffffffea801600 <arm64_sync_exc_lower_el_32>:

/* exceptions from lower EL, running arm32 */
.org 0x600
LOCAL_FUNCTION(arm64_sync_exc_lower_el_32)
    regsave_long
ffffffffea801600:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801604:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801608:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80160c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801610:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801614:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801618:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80161c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801620:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801624:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801628:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80162c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801630:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801634:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801638:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80163c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801640:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801644:	d5384021 	mrs	x1, elr_el1
ffffffffea801648:	d5384002 	mrs	x2, spsr_el1
ffffffffea80164c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801650:	a9100be1 	stp	x1, x2, [sp, #256]
    mov x0, sp
ffffffffea801654:	910003e0 	mov	x0, sp
    bl  arm64_sync_exception
ffffffffea801658:	9400059e 	bl	ffffffffea802cd0 <arm64_sync_exception>
    b  arm64_exc_shared_restore_long
ffffffffea80165c:	14000062 	b	ffffffffea8017e4 <arm64_exc_shared_restore_long>
	...

ffffffffea801680 <arm64_irq_lower_el_32>:

.org 0x680
LOCAL_FUNCTION(arm64_irq_lower_el_32)
    irq_exception
ffffffffea801680:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801684:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801688:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea80168c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801690:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea801694:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801698:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea80169c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8016a0:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8016a4:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8016a8:	910243e0 	add	x0, sp, #0x90
ffffffffea8016ac:	d5384021 	mrs	x1, elr_el1
ffffffffea8016b0:	d5384002 	mrs	x2, spsr_el1
ffffffffea8016b4:	a90903fe 	stp	x30, x0, [sp, #144]
ffffffffea8016b8:	a90a0be1 	stp	x1, x2, [sp, #160]
ffffffffea8016bc:	d50341ff 	msr	daifclr, #0x1
ffffffffea8016c0:	910003e0 	mov	x0, sp
ffffffffea8016c4:	94000c75 	bl	ffffffffea804898 <platform_irq>
ffffffffea8016c8:	b4000040 	cbz	x0, ffffffffea8016d0 <arm64_irq_lower_el_32+0x50>
ffffffffea8016cc:	94001367 	bl	ffffffffea806468 <thread_preempt>
ffffffffea8016d0:	d50341df 	msr	daifset, #0x1
ffffffffea8016d4:	1400005b 	b	ffffffffea801840 <arm64_exc_shared_restore_short>
	...

ffffffffea801700 <arm64_fiq_lower_el_32>:

.org 0x700
LOCAL_FUNCTION(arm64_fiq_lower_el_32)
    regsave_short
ffffffffea801700:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801704:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801708:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea80170c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801710:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea801714:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801718:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea80171c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801720:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea801724:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801728:	910243e0 	add	x0, sp, #0x90
ffffffffea80172c:	d5384021 	mrs	x1, elr_el1
ffffffffea801730:	d5384002 	mrs	x2, spsr_el1
ffffffffea801734:	a90903fe 	stp	x30, x0, [sp, #144]
ffffffffea801738:	a90a0be1 	stp	x1, x2, [sp, #160]
    mov x0, sp
ffffffffea80173c:	910003e0 	mov	x0, sp
    bl  platform_fiq
ffffffffea801740:	94000cbc 	bl	ffffffffea804a30 <platform_fiq>
    b  arm64_exc_shared_restore_short
ffffffffea801744:	1400003f 	b	ffffffffea801840 <arm64_exc_shared_restore_short>
	...

ffffffffea801780 <arm64_err_exc_lower_el_32>:

.org 0x780
LOCAL_FUNCTION(arm64_err_exc_lower_el_32)
    invalid_exception 0x33
ffffffffea801780:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801784:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801788:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80178c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801790:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801794:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801798:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80179c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8017a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8017a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8017a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8017ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8017b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8017b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8017b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8017bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8017c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8017c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8017c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8017cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8017d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8017d4:	d2800661 	mov	x1, #0x33                  	// #51
ffffffffea8017d8:	910003e0 	mov	x0, sp
ffffffffea8017dc:	94000597 	bl	ffffffffea802e38 <arm64_invalid_exception>
ffffffffea8017e0:	14000000 	b	ffffffffea8017e0 <arm64_err_exc_lower_el_32+0x60>

ffffffffea8017e4 <arm64_exc_shared_restore_long>:

LOCAL_FUNCTION(arm64_exc_shared_restore_long)
    regrestore_long
ffffffffea8017e4:	f9407bfe 	ldr	x30, [sp, #240]
ffffffffea8017e8:	a9500be1 	ldp	x1, x2, [sp, #256]
ffffffffea8017ec:	d5184021 	msr	elr_el1, x1
ffffffffea8017f0:	d5184002 	msr	spsr_el1, x2
ffffffffea8017f4:	a8c107e0 	ldp	x0, x1, [sp], #16
ffffffffea8017f8:	a8c10fe2 	ldp	x2, x3, [sp], #16
ffffffffea8017fc:	a8c117e4 	ldp	x4, x5, [sp], #16
ffffffffea801800:	a8c11fe6 	ldp	x6, x7, [sp], #16
ffffffffea801804:	a8c127e8 	ldp	x8, x9, [sp], #16
ffffffffea801808:	a8c12fea 	ldp	x10, x11, [sp], #16
ffffffffea80180c:	a8c137ec 	ldp	x12, x13, [sp], #16
ffffffffea801810:	a8c13fee 	ldp	x14, x15, [sp], #16
ffffffffea801814:	a8c147f0 	ldp	x16, x17, [sp], #16
ffffffffea801818:	a8c14ff2 	ldp	x18, x19, [sp], #16
ffffffffea80181c:	a8c157f4 	ldp	x20, x21, [sp], #16
ffffffffea801820:	a8c15ff6 	ldp	x22, x23, [sp], #16
ffffffffea801824:	a8c167f8 	ldp	x24, x25, [sp], #16
ffffffffea801828:	a8c16ffa 	ldp	x26, x27, [sp], #16
ffffffffea80182c:	a8c177fc 	ldp	x28, x29, [sp], #16
ffffffffea801830:	910083ff 	add	sp, sp, #0x20
    exception_return
ffffffffea801834:	d69f03e0 	eret
ffffffffea801838:	d503379f 	dsb	nsh
ffffffffea80183c:	d5033fdf 	isb

ffffffffea801840 <arm64_exc_shared_restore_short>:

LOCAL_FUNCTION(arm64_exc_shared_restore_short)
       regrestore_short
ffffffffea801840:	f9404bfe 	ldr	x30, [sp, #144]
ffffffffea801844:	a94a0be1 	ldp	x1, x2, [sp, #160]
ffffffffea801848:	d5184021 	msr	elr_el1, x1
ffffffffea80184c:	d5184002 	msr	spsr_el1, x2
ffffffffea801850:	a8c107e0 	ldp	x0, x1, [sp], #16
ffffffffea801854:	a8c10fe2 	ldp	x2, x3, [sp], #16
ffffffffea801858:	a8c117e4 	ldp	x4, x5, [sp], #16
ffffffffea80185c:	a8c11fe6 	ldp	x6, x7, [sp], #16
ffffffffea801860:	a8c127e8 	ldp	x8, x9, [sp], #16
ffffffffea801864:	a8c12fea 	ldp	x10, x11, [sp], #16
ffffffffea801868:	a8c137ec 	ldp	x12, x13, [sp], #16
ffffffffea80186c:	a8c13fee 	ldp	x14, x15, [sp], #16
ffffffffea801870:	a8c147f0 	ldp	x16, x17, [sp], #16
ffffffffea801874:	910083ff 	add	sp, sp, #0x20
       exception_return
ffffffffea801878:	d69f03e0 	eret
ffffffffea80187c:	d503379f 	dsb	nsh
ffffffffea801880:	d5033fdf 	isb
ffffffffea801884:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801888 <platform_secondary_init>:
static uint denver_boot_map[] = {0, 1, 0xff, 0xff, 2, 3, 4, 5};
#endif

uint plat_arch_curr_cpu_num(void)
{
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801888:	d53800a1 	mrs	x1, mpidr_el1
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea80188c:	d53800a0 	mrs	x0, mpidr_el1
#if SOC_T186
	uint curr_cpu_num = (cpu_num + (cluster_num << 2));

	/* store boot CPU # for future reference */
	if (boot_cpu == 0xFF)
ffffffffea801890:	900000c3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea801894:	d348fc00 	lsr	x0, x0, #8
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801898:	12001c21 	and	w1, w1, #0xff
	if (boot_cpu == 0xFF)
ffffffffea80189c:	b9400c62 	ldr	w2, [x3, #12]
	uint curr_cpu_num = (cpu_num + (cluster_num << 2));
ffffffffea8018a0:	0b200820 	add	w0, w1, w0, uxtb #2
	if (boot_cpu == 0xFF)
ffffffffea8018a4:	7103fc5f 	cmp	w2, #0xff
ffffffffea8018a8:	54000061 	b.ne	ffffffffea8018b4 <platform_secondary_init+0x2c>  // b.any
		boot_cpu = curr_cpu_num;
ffffffffea8018ac:	2a0003e2 	mov	w2, w0
ffffffffea8018b0:	b9000c60 	str	w0, [x3, #12]

	/* return the CPU # from the proper map */
	if (boot_cpu == A57_0)
ffffffffea8018b4:	7100105f 	cmp	w2, #0x4
ffffffffea8018b8:	54000120 	b.eq	ffffffffea8018dc <platform_secondary_init+0x54>  // b.none
		return a57_boot_map[curr_cpu_num];
	else
		return denver_boot_map[curr_cpu_num];
ffffffffea8018bc:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8018c0:	91020021 	add	x1, x1, #0x80
ffffffffea8018c4:	b8607822 	ldr	w2, [x1, x0, lsl #2]

#if WITH_SMP

static void platform_secondary_init(uint level)
{
	dprintf(SPEW, "%s: Suryacpu_id 0x%x\n", __func__, plat_arch_curr_cpu_num());
ffffffffea8018c8:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8018cc:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8018d0:	9100c021 	add	x1, x1, #0x30
ffffffffea8018d4:	91064000 	add	x0, x0, #0x190
ffffffffea8018d8:	14004072 	b	ffffffffea811aa0 <_dprintf>
		return a57_boot_map[curr_cpu_num];
ffffffffea8018dc:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8018e0:	91018021 	add	x1, x1, #0x60
ffffffffea8018e4:	b8607822 	ldr	w2, [x1, x0, lsl #2]
	dprintf(SPEW, "%s: Suryacpu_id 0x%x\n", __func__, plat_arch_curr_cpu_num());
ffffffffea8018e8:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8018ec:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8018f0:	9100c021 	add	x1, x1, #0x30
ffffffffea8018f4:	91064000 	add	x0, x0, #0x190
ffffffffea8018f8:	1400406a 	b	ffffffffea811aa0 <_dprintf>
ffffffffea8018fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801900 <platform_prevent_ssb>:
 * by disabling memory disambiguation and speculative store buffering in
 * S-EL1 and S-EL0.
 *
 * This mitigation is only ran on Denver and Carmel (DENVER_PN4) cpus.
 */
static void platform_prevent_ssb(uint level) {
ffffffffea801900:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea801904:	910003fd 	mov	x29, sp
ffffffffea801908:	f9000bf3 	str	x19, [sp, #16]
	uint64_t midr = ARM64_READ_SYSREG(midr_el1);
ffffffffea80190c:	d5380013 	mrs	x19, midr_el1
	uint64_t actlr = 0;
	uint64_t mask = 0;

	/* Only apply workaround on Denver cores */
	if (!platform_is_denver_cpu())
ffffffffea801910:	940002ec 	bl	ffffffffea8024c0 <platform_is_denver_cpu>
ffffffffea801914:	72001c1f 	tst	w0, #0xff
ffffffffea801918:	54000260 	b.eq	ffffffffea801964 <platform_prevent_ssb+0x64>  // b.none
	/*
	 * Denver CPUs with DENVER_MIDR_PN3 or earlier, use different
	 * bits in the ACTLR_EL1/ACTLR_EL0 registers to disable
	 * speculative store buffer and memory disambiguation.
	 */
	switch(midr) {
ffffffffea80191c:	d2800400 	mov	x0, #0x20                  	// #32
ffffffffea801920:	f2a9c1e0 	movk	x0, #0x4e0f, lsl #16
ffffffffea801924:	eb00027f 	cmp	x19, x0
ffffffffea801928:	54000680 	b.eq	ffffffffea8019f8 <platform_prevent_ssb+0xf8>  // b.none
ffffffffea80192c:	54000229 	b.ls	ffffffffea801970 <platform_prevent_ssb+0x70>  // b.plast
ffffffffea801930:	d2800600 	mov	x0, #0x30                  	// #48
ffffffffea801934:	f2a9c1e0 	movk	x0, #0x4e0f, lsl #16
ffffffffea801938:	eb00027f 	cmp	x19, x0
ffffffffea80193c:	540005e0 	b.eq	ffffffffea8019f8 <platform_prevent_ssb+0xf8>  // b.none
ffffffffea801940:	d2800801 	mov	x1, #0x40                  	// #64
		mask = DENVER_CPU_DIS_MD_EL0 | DENVER_CPU_DIS_MD_EL1
			| DENVER_CPU_DIS_SSB_EL0 | DENVER_CPU_DIS_SSB_EL1;
		break;

	case DENVER_MIDR_PN4:
		mask = DENVER_PN4_CPU_DIS_MD_EL0 | DENVER_PN4_CPU_DIS_MD_EL1
ffffffffea801944:	d2807800 	mov	x0, #0x3c0                 	// #960
	switch(midr) {
ffffffffea801948:	f2a9c1e1 	movk	x1, #0x4e0f, lsl #16
ffffffffea80194c:	eb01027f 	cmp	x19, x1
ffffffffea801950:	540001c1 	b.ne	ffffffffea801988 <platform_prevent_ssb+0x88>  // b.any
			__func__, plat_arch_curr_cpu_num(), midr);
		break;
	}

	/* update actlr_el1 */
	actlr = ARM64_READ_SYSREG(actlr_el1);
ffffffffea801954:	d5381021 	mrs	x1, actlr_el1
	actlr |= mask;
ffffffffea801958:	aa010000 	orr	x0, x0, x1
	ARM64_WRITE_SYSREG(actlr_el1, actlr);
ffffffffea80195c:	d5181020 	msr	actlr_el1, x0
ffffffffea801960:	d5033fdf 	isb
}
ffffffffea801964:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801968:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80196c:	d65f03c0 	ret
	switch(midr) {
ffffffffea801970:	d2a9c1e0 	mov	x0, #0x4e0f0000            	// #1309605888
ffffffffea801974:	eb00027f 	cmp	x19, x0
ffffffffea801978:	54000400 	b.eq	ffffffffea8019f8 <platform_prevent_ssb+0xf8>  // b.none
ffffffffea80197c:	91004000 	add	x0, x0, #0x10
ffffffffea801980:	eb00027f 	cmp	x19, x0
ffffffffea801984:	540003a0 	b.eq	ffffffffea8019f8 <platform_prevent_ssb+0xf8>  // b.none
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801988:	d53800a1 	mrs	x1, mpidr_el1
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea80198c:	d53800a0 	mrs	x0, mpidr_el1
	if (boot_cpu == 0xFF)
ffffffffea801990:	900000c3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea801994:	d348fc00 	lsr	x0, x0, #8
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801998:	12001c21 	and	w1, w1, #0xff
	if (boot_cpu == 0xFF)
ffffffffea80199c:	b9400c62 	ldr	w2, [x3, #12]
	uint curr_cpu_num = (cpu_num + (cluster_num << 2));
ffffffffea8019a0:	0b200820 	add	w0, w1, w0, uxtb #2
	if (boot_cpu == 0xFF)
ffffffffea8019a4:	7103fc5f 	cmp	w2, #0xff
ffffffffea8019a8:	54000061 	b.ne	ffffffffea8019b4 <platform_prevent_ssb+0xb4>  // b.any
		boot_cpu = curr_cpu_num;
ffffffffea8019ac:	2a0003e2 	mov	w2, w0
ffffffffea8019b0:	b9000c60 	str	w0, [x3, #12]
	if (boot_cpu == A57_0)
ffffffffea8019b4:	7100105f 	cmp	w2, #0x4
ffffffffea8019b8:	540002c0 	b.eq	ffffffffea801a10 <platform_prevent_ssb+0x110>  // b.none
		return denver_boot_map[curr_cpu_num];
ffffffffea8019bc:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8019c0:	91020021 	add	x1, x1, #0x80
ffffffffea8019c4:	b8607822 	ldr	w2, [x1, x0, lsl #2]
		dprintf(CRITICAL, "%s: unable to apply cve_2018_3639 TZ"
ffffffffea8019c8:	aa1303e3 	mov	x3, x19
ffffffffea8019cc:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8019d0:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8019d4:	91012021 	add	x1, x1, #0x48
ffffffffea8019d8:	91050000 	add	x0, x0, #0x140
ffffffffea8019dc:	94004031 	bl	ffffffffea811aa0 <_dprintf>
	uint64_t mask = 0;
ffffffffea8019e0:	d2800000 	mov	x0, #0x0                   	// #0
	actlr = ARM64_READ_SYSREG(actlr_el1);
ffffffffea8019e4:	d5381021 	mrs	x1, actlr_el1
	actlr |= mask;
ffffffffea8019e8:	aa010000 	orr	x0, x0, x1
	ARM64_WRITE_SYSREG(actlr_el1, actlr);
ffffffffea8019ec:	d5181020 	msr	actlr_el1, x0
ffffffffea8019f0:	d5033fdf 	isb
ffffffffea8019f4:	17ffffdc 	b	ffffffffea801964 <platform_prevent_ssb+0x64>
		mask = DENVER_CPU_DIS_MD_EL0 | DENVER_CPU_DIS_MD_EL1
ffffffffea8019f8:	d283c000 	mov	x0, #0x1e00                	// #7680
	actlr = ARM64_READ_SYSREG(actlr_el1);
ffffffffea8019fc:	d5381021 	mrs	x1, actlr_el1
	actlr |= mask;
ffffffffea801a00:	aa010000 	orr	x0, x0, x1
	ARM64_WRITE_SYSREG(actlr_el1, actlr);
ffffffffea801a04:	d5181020 	msr	actlr_el1, x0
ffffffffea801a08:	d5033fdf 	isb
ffffffffea801a0c:	17ffffd6 	b	ffffffffea801964 <platform_prevent_ssb+0x64>
		return a57_boot_map[curr_cpu_num];
ffffffffea801a10:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801a14:	91018021 	add	x1, x1, #0x60
ffffffffea801a18:	b8607822 	ldr	w2, [x1, x0, lsl #2]
ffffffffea801a1c:	17ffffeb 	b	ffffffffea8019c8 <platform_prevent_ssb+0xc8>

ffffffffea801a20 <plat_arch_curr_cpu_num>:
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801a20:	d53800a1 	mrs	x1, mpidr_el1
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea801a24:	d53800a0 	mrs	x0, mpidr_el1
	if (boot_cpu == 0xFF)
ffffffffea801a28:	900000c3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea801a2c:	d348fc00 	lsr	x0, x0, #8
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801a30:	12001c21 	and	w1, w1, #0xff
	if (boot_cpu == 0xFF)
ffffffffea801a34:	b9400c62 	ldr	w2, [x3, #12]
	uint curr_cpu_num = (cpu_num + (cluster_num << 2));
ffffffffea801a38:	0b200820 	add	w0, w1, w0, uxtb #2
	if (boot_cpu == 0xFF)
ffffffffea801a3c:	7103fc5f 	cmp	w2, #0xff
ffffffffea801a40:	54000061 	b.ne	ffffffffea801a4c <plat_arch_curr_cpu_num+0x2c>  // b.any
		boot_cpu = curr_cpu_num;
ffffffffea801a44:	2a0003e2 	mov	w2, w0
ffffffffea801a48:	b9000c60 	str	w0, [x3, #12]
	if (boot_cpu == A57_0)
ffffffffea801a4c:	7100105f 	cmp	w2, #0x4
ffffffffea801a50:	540000a0 	b.eq	ffffffffea801a64 <plat_arch_curr_cpu_num+0x44>  // b.none
		return denver_boot_map[curr_cpu_num];
ffffffffea801a54:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801a58:	91020021 	add	x1, x1, #0x80
ffffffffea801a5c:	b8607820 	ldr	w0, [x1, x0, lsl #2]
}
ffffffffea801a60:	d65f03c0 	ret
		return a57_boot_map[curr_cpu_num];
ffffffffea801a64:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801a68:	91018021 	add	x1, x1, #0x60
ffffffffea801a6c:	b8607820 	ldr	w0, [x1, x0, lsl #2]
}
ffffffffea801a70:	d65f03c0 	ret
ffffffffea801a74:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801a78 <arch_sync_cache_range>:
}
ffffffffea801a78:	d65f03c0 	ret
ffffffffea801a7c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801a80 <platform_app_bootloader_epilog>:
{
ffffffffea801a80:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	asm volatile (
ffffffffea801a84:	529fe172 	mov	w18, #0xff0b                	// #65291
ffffffffea801a88:	72b05ff2 	movk	w18, #0x82ff, lsl #16
{
ffffffffea801a8c:	910003fd 	mov	x29, sp
	asm volatile (
ffffffffea801a90:	910043be 	add	x30, x29, #0x10
ffffffffea801a94:	aa1203e0 	mov	x0, x18
ffffffffea801a98:	a9400bc1 	ldp	x1, x2, [x30]
ffffffffea801a9c:	a94113c3 	ldp	x3, x4, [x30, #16]
ffffffffea801aa0:	a9421bc5 	ldp	x5, x6, [x30, #32]
ffffffffea801aa4:	d5033fdf 	isb
ffffffffea801aa8:	d4000003 	smc	#0x0
ffffffffea801aac:	aa0003f2 	mov	x18, x0
ffffffffea801ab0:	a90007c0 	stp	x0, x1, [x30]
ffffffffea801ab4:	a9010fc2 	stp	x2, x3, [x30, #16]
}
ffffffffea801ab8:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea801abc:	d65f03c0 	ret

ffffffffea801ac0 <platform_early_init>:
	arm_generic_timer_init(ARM_GENERIC_TIMER_INT, 0);
ffffffffea801ac0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea801ac4:	528003a0 	mov	w0, #0x1d                  	// #29
ffffffffea801ac8:	14000e74 	b	ffffffffea805498 <arm_generic_timer_init>
ffffffffea801acc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801ad0 <platform_init>:
{
ffffffffea801ad0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea801ad4:	910003fd 	mov	x29, sp
ffffffffea801ad8:	f9000bf3 	str	x19, [sp, #16]
ffffffffea801adc:	aa1e03f3 	mov	x19, x30
	if ((err = process_boot_params()) != NO_ERROR) {
ffffffffea801ae0:	940000b8 	bl	ffffffffea801dc0 <process_boot_params>
ffffffffea801ae4:	35000180 	cbnz	w0, ffffffffea801b14 <platform_init+0x44>
	platform_init_debug_port(debug_uart_id);
ffffffffea801ae8:	900000c0 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea801aec:	b9401000 	ldr	w0, [x0, #16]
ffffffffea801af0:	940001b2 	bl	ffffffffea8021b8 <platform_init_debug_port>
	dprintf(SPEW, "Initializing platform at trusty level\nTrying to initialize another UART......\n");
ffffffffea801af4:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801af8:	91034000 	add	x0, x0, #0xd0
ffffffffea801afc:	94003fe9 	bl	ffffffffea811aa0 <_dprintf>
}
ffffffffea801b00:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801b04:	a8c27bfd 	ldp	x29, x30, [sp], #32
	dprintf(0, "Check if it is working or not\n");
ffffffffea801b08:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801b0c:	91048000 	add	x0, x0, #0x120
ffffffffea801b10:	14003fe4 	b	ffffffffea811aa0 <_dprintf>
		panic("Fatal error: Failed to process boot params\n");
ffffffffea801b14:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801b18:	aa1303e0 	mov	x0, x19
ffffffffea801b1c:	91028021 	add	x1, x1, #0xa0
ffffffffea801b20:	9400405e 	bl	ffffffffea811c98 <_panic>
ffffffffea801b24:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801b28 <platform_init_mmu_mappings>:
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801b28:	d53800a1 	mrs	x1, mpidr_el1
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea801b2c:	d53800a0 	mrs	x0, mpidr_el1
	if (boot_cpu == 0xFF)
ffffffffea801b30:	900000c3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea801b34:	d348fc00 	lsr	x0, x0, #8
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801b38:	12001c21 	and	w1, w1, #0xff
	if (boot_cpu == 0xFF)
ffffffffea801b3c:	b9400c62 	ldr	w2, [x3, #12]
	uint curr_cpu_num = (cpu_num + (cluster_num << 2));
ffffffffea801b40:	0b200820 	add	w0, w1, w0, uxtb #2
	if (boot_cpu == 0xFF)
ffffffffea801b44:	7103fc5f 	cmp	w2, #0xff
ffffffffea801b48:	54000061 	b.ne	ffffffffea801b54 <platform_init_mmu_mappings+0x2c>  // b.any
		boot_cpu = curr_cpu_num;
ffffffffea801b4c:	2a0003e2 	mov	w2, w0
ffffffffea801b50:	b9000c60 	str	w0, [x3, #12]
	if (boot_cpu == A57_0)
ffffffffea801b54:	7100105f 	cmp	w2, #0x4
ffffffffea801b58:	540003e0 	b.eq	ffffffffea801bd4 <platform_init_mmu_mappings+0xac>  // b.none
		return denver_boot_map[curr_cpu_num];
ffffffffea801b5c:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801b60:	91020021 	add	x1, x1, #0x80
ffffffffea801b64:	b8607820 	ldr	w0, [x1, x0, lsl #2]
	if (plat_arch_curr_cpu_num() == 0) {
ffffffffea801b68:	35000340 	cbnz	w0, ffffffffea801bd0 <platform_init_mmu_mappings+0xa8>
{
ffffffffea801b6c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea801b70:	910003fd 	mov	x29, sp
ffffffffea801b74:	a9025bf5 	stp	x21, x22, [sp, #32]
			if (strcmp(m->name, ram_arena.name) == 0) {
ffffffffea801b78:	900000d6 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea801b7c:	9104c2c0 	add	x0, x22, #0x130
{
ffffffffea801b80:	a90153f3 	stp	x19, x20, [sp, #16]
		struct mmu_initial_mapping *m = mmu_initial_mappings;
ffffffffea801b84:	900000d3 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea801b88:	91006273 	add	x19, x19, #0x18
		for (uint i = 0; i < countof(mmu_initial_mappings); i++, m++) {
ffffffffea801b8c:	91046275 	add	x21, x19, #0x118
			if (strcmp(m->name, ram_arena.name) == 0) {
ffffffffea801b90:	f9400814 	ldr	x20, [x0, #16]
ffffffffea801b94:	d503201f 	nop
			if (!(m->flags & MMU_INITIAL_MAPPING_FLAG_DYNAMIC))
ffffffffea801b98:	b9401a60 	ldr	w0, [x19, #24]
			if (strcmp(m->name, ram_arena.name) == 0) {
ffffffffea801b9c:	aa1403e1 	mov	x1, x20
			if (!(m->flags & MMU_INITIAL_MAPPING_FLAG_DYNAMIC))
ffffffffea801ba0:	36180080 	tbz	w0, #3, ffffffffea801bb0 <platform_init_mmu_mappings+0x88>
			if (strcmp(m->name, ram_arena.name) == 0) {
ffffffffea801ba4:	f9401260 	ldr	x0, [x19, #32]
ffffffffea801ba8:	940046be 	bl	ffffffffea8136a0 <strcmp>
ffffffffea801bac:	340001c0 	cbz	w0, ffffffffea801be4 <platform_init_mmu_mappings+0xbc>
		for (uint i = 0; i < countof(mmu_initial_mappings); i++, m++) {
ffffffffea801bb0:	9100a273 	add	x19, x19, #0x28
ffffffffea801bb4:	eb15027f 	cmp	x19, x21
ffffffffea801bb8:	54ffff01 	b.ne	ffffffffea801b98 <platform_init_mmu_mappings+0x70>  // b.any
		pmm_add_arena(&ram_arena);
ffffffffea801bbc:	9104c2c0 	add	x0, x22, #0x130
}
ffffffffea801bc0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801bc4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801bc8:	a8c37bfd 	ldp	x29, x30, [sp], #48
		pmm_add_arena(&ram_arena);
ffffffffea801bcc:	14003b03 	b	ffffffffea8107d8 <pmm_add_arena>
ffffffffea801bd0:	d65f03c0 	ret
		return a57_boot_map[curr_cpu_num];
ffffffffea801bd4:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801bd8:	91018021 	add	x1, x1, #0x60
ffffffffea801bdc:	b8607820 	ldr	w0, [x1, x0, lsl #2]
ffffffffea801be0:	17ffffe2 	b	ffffffffea801b68 <platform_init_mmu_mappings+0x40>
				ram_arena.base = m->phys;
ffffffffea801be4:	9104c2c0 	add	x0, x22, #0x130
ffffffffea801be8:	f9400261 	ldr	x1, [x19]
				ram_arena.size = m->size;
ffffffffea801bec:	f9400a62 	ldr	x2, [x19, #16]
				ram_arena.flags = PMM_ARENA_FLAG_KMAP;
ffffffffea801bf0:	52800025 	mov	w5, #0x1                   	// #1
}
ffffffffea801bf4:	a94153f3 	ldp	x19, x20, [sp, #16]
				ram_arena.flags = PMM_ARENA_FLAG_KMAP;
ffffffffea801bf8:	b9001805 	str	w5, [x0, #24]
				ram_arena.size = m->size;
ffffffffea801bfc:	a9020801 	stp	x1, x2, [x0, #32]
		pmm_add_arena(&ram_arena);
ffffffffea801c00:	9104c2c0 	add	x0, x22, #0x130
}
ffffffffea801c04:	a9425bf5 	ldp	x21, x22, [sp, #32]
				_mem_size = m->size;
ffffffffea801c08:	900000c4 	adrp	x4, ffffffffea819000 <_mem_phys_base>
}
ffffffffea801c0c:	a8c37bfd 	ldp	x29, x30, [sp], #48
				_mem_phys_base = m->phys;
ffffffffea801c10:	900000c3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
				_mem_size = m->size;
ffffffffea801c14:	b9000882 	str	w2, [x4, #8]
				_mem_phys_base = m->phys;
ffffffffea801c18:	f9000061 	str	x1, [x3]
		pmm_add_arena(&ram_arena);
ffffffffea801c1c:	14003aef 	b	ffffffffea8107d8 <pmm_add_arena>

ffffffffea801c20 <comb_uart_putc>:
 * Indicates that we're only sending one byte at a time.
 */
#define MBOX_BYTE_COUNT	(1 << 24)

static void comb_uart_putc(char c)
{
ffffffffea801c20:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea801c24:	910003fd 	mov	x29, sp
ffffffffea801c28:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea801c2c:	12001c13 	and	w19, w0, #0xff
ffffffffea801c30:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (c == '\n')
		msg |= MBOX_FLUSH;
	while (readl(TEGRA_COMBUART_BASE) & (MBOX_INTR_TRIGGER)) {
		if (timed_out)
			return;
		if (current_time_hires() - start >= TX_TIMEOUT_US) {
ffffffffea801c34:	d29423f5 	mov	x21, #0xa11f                	// #41247
{
ffffffffea801c38:	a90363f7 	stp	x23, x24, [sp, #48]
	start = current_time_hires();
ffffffffea801c3c:	94000dfb 	bl	ffffffffea805428 <current_time_hires>
	uint32_t msg = MBOX_INTR_TRIGGER | MBOX_BYTE_COUNT | (uint8_t)(c & 0xff);
ffffffffea801c40:	52b02017 	mov	w23, #0x81000000            	// #-2130706432
ffffffffea801c44:	2a170277 	orr	w23, w19, w23
		msg |= MBOX_FLUSH;
ffffffffea801c48:	71002a7f 	cmp	w19, #0xa
	start = current_time_hires();
ffffffffea801c4c:	aa0003f6 	mov	x22, x0
	while (readl(TEGRA_COMBUART_BASE) & (MBOX_INTR_TRIGGER)) {
ffffffffea801c50:	929ffff3 	mov	x19, #0xffffffffffff0000    	// #-65536
		msg |= MBOX_FLUSH;
ffffffffea801c54:	320602e0 	orr	w0, w23, #0x4000000
ffffffffea801c58:	f00002b8 	adrp	x24, ffffffffea858000 <__bss_start>
ffffffffea801c5c:	1a970017 	csel	w23, w0, w23, eq  // eq = none
	while (readl(TEGRA_COMBUART_BASE) & (MBOX_INTR_TRIGGER)) {
ffffffffea801c60:	f2be3813 	movk	x19, #0xf1c0, lsl #16
		if (timed_out)
ffffffffea801c64:	91000314 	add	x20, x24, #0x0
		if (current_time_hires() - start >= TX_TIMEOUT_US) {
ffffffffea801c68:	f2a000f5 	movk	x21, #0x7, lsl #16
ffffffffea801c6c:	14000007 	b	ffffffffea801c88 <comb_uart_putc+0x68>
		if (timed_out)
ffffffffea801c70:	39400280 	ldrb	w0, [x20]
ffffffffea801c74:	35000120 	cbnz	w0, ffffffffea801c98 <comb_uart_putc+0x78>
		if (current_time_hires() - start >= TX_TIMEOUT_US) {
ffffffffea801c78:	94000dec 	bl	ffffffffea805428 <current_time_hires>
ffffffffea801c7c:	cb160000 	sub	x0, x0, x22
ffffffffea801c80:	eb15001f 	cmp	x0, x21
ffffffffea801c84:	54000148 	b.hi	ffffffffea801cac <comb_uart_putc+0x8c>  // b.pmore
	while (readl(TEGRA_COMBUART_BASE) & (MBOX_INTR_TRIGGER)) {
ffffffffea801c88:	b9400260 	ldr	w0, [x19]
ffffffffea801c8c:	37ffff20 	tbnz	w0, #31, ffffffffea801c70 <comb_uart_putc+0x50>
			timed_out = true;
			return;
		}
	}
	timed_out = false;
ffffffffea801c90:	3900031f 	strb	wzr, [x24]
	 *
	 * If EL3 does attempt to print debug messages at the same time as Trusty, messages might
	 * be corrupted. This is acceptable, because it should not cause any functional issues
	 * in Trusty or EL3.
	 */
	writel(msg, TEGRA_COMBUART_BASE);
ffffffffea801c94:	b9000277 	str	w23, [x19]
}
ffffffffea801c98:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801c9c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801ca0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801ca4:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea801ca8:	d65f03c0 	ret
			timed_out = true;
ffffffffea801cac:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea801cb0:	39000280 	strb	w0, [x20]
}
ffffffffea801cb4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801cb8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801cbc:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801cc0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea801cc4:	d65f03c0 	ret

ffffffffea801cc8 <platform_tegra_comb_uart_putc>:

void platform_tegra_comb_uart_putc(char c)
{
ffffffffea801cc8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea801ccc:	910003fd 	mov	x29, sp
ffffffffea801cd0:	f9000bf3 	str	x19, [sp, #16]
	if (c == '\0')
ffffffffea801cd4:	72001c13 	ands	w19, w0, #0xff
ffffffffea801cd8:	540000e0 	b.eq	ffffffffea801cf4 <platform_tegra_comb_uart_putc+0x2c>  // b.none
		return;
	if (c == '\n')
ffffffffea801cdc:	71002a7f 	cmp	w19, #0xa
ffffffffea801ce0:	54000100 	b.eq	ffffffffea801d00 <platform_tegra_comb_uart_putc+0x38>  // b.none
		comb_uart_putc('\r');
	comb_uart_putc(c);
ffffffffea801ce4:	2a1303e0 	mov	w0, w19
}
ffffffffea801ce8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801cec:	a8c27bfd 	ldp	x29, x30, [sp], #32
	comb_uart_putc(c);
ffffffffea801cf0:	17ffffcc 	b	ffffffffea801c20 <comb_uart_putc>
}
ffffffffea801cf4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801cf8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea801cfc:	d65f03c0 	ret
		comb_uart_putc('\r');
ffffffffea801d00:	528001a0 	mov	w0, #0xd                   	// #13
ffffffffea801d04:	97ffffc7 	bl	ffffffffea801c20 <comb_uart_putc>
	comb_uart_putc(c);
ffffffffea801d08:	2a1303e0 	mov	w0, w19
}
ffffffffea801d0c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801d10:	a8c27bfd 	ldp	x29, x30, [sp], #32
	comb_uart_putc(c);
ffffffffea801d14:	17ffffc3 	b	ffffffffea801c20 <comb_uart_putc>
#include <sys/types.h>

__WEAK void platform_tegra_comb_uart_putc(char c)
{
	(void)c;
}
ffffffffea801d18:	d65f03c0 	ret
ffffffffea801d1c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801d20 <platform_tegra_comb_uart_getc>:

int platform_tegra_comb_uart_getc(bool wait)
{
	(void)wait;
	return -1;
}
ffffffffea801d20:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea801d24:	d65f03c0 	ret

__WEAK int platform_tegra_comb_uart_getc(bool wait)
{
	(void)wait;
	return -1;
}
ffffffffea801d28:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea801d2c:	d65f03c0 	ret

ffffffffea801d30 <get_and_clear_eks_info>:

/* Structure to hold EKS information */
static eks_info_t eks_info;

status_t get_and_clear_eks_info(eks_info_t *info)
{
ffffffffea801d30:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea801d34:	910003fd 	mov	x29, sp
ffffffffea801d38:	f9000bf3 	str	x19, [sp, #16]
ffffffffea801d3c:	aa0003f3 	mov	x19, x0
	if (!platform_is_bootstrapping()) {
ffffffffea801d40:	9400012c 	bl	ffffffffea8021f0 <platform_is_bootstrapping>
ffffffffea801d44:	72001c1f 	tst	w0, #0xff
ffffffffea801d48:	540001c0 	b.eq	ffffffffea801d80 <get_and_clear_eks_info+0x50>  // b.none
		dprintf(CRITICAL, "%s: ERROR: Not allowed after boot\n", __func__);
		return ERR_NOT_ALLOWED;
	}
	if (info == NULL) {
ffffffffea801d4c:	b4000293 	cbz	x19, ffffffffea801d9c <get_and_clear_eks_info+0x6c>
		dprintf(CRITICAL, "%s: ERROR: Attempting to access NULL pointer\n", __func__);
		return ERR_INVALID_ARGS;
	}
	info->paddr = eks_info.paddr;
ffffffffea801d50:	f00002a1 	adrp	x1, ffffffffea858000 <__bss_start>
ffffffffea801d54:	91002022 	add	x2, x1, #0x8

	/* clear eks_info, so this method cannot be used again */
	eks_info.paddr = NULL;
	eks_info.blob_length = 0;

	return NO_ERROR;
ffffffffea801d58:	52800000 	mov	w0, #0x0                   	// #0
	info->paddr = eks_info.paddr;
ffffffffea801d5c:	f9400423 	ldr	x3, [x1, #8]
	eks_info.paddr = NULL;
ffffffffea801d60:	f900043f 	str	xzr, [x1, #8]
	info->blob_length = eks_info.blob_length;
ffffffffea801d64:	b9400841 	ldr	w1, [x2, #8]
	info->paddr = eks_info.paddr;
ffffffffea801d68:	f9000263 	str	x3, [x19]
	eks_info.blob_length = 0;
ffffffffea801d6c:	b900085f 	str	wzr, [x2, #8]
	info->blob_length = eks_info.blob_length;
ffffffffea801d70:	b9000a61 	str	w1, [x19, #8]
}
ffffffffea801d74:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801d78:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea801d7c:	d65f03c0 	ret
		dprintf(CRITICAL, "%s: ERROR: Not allowed after boot\n", __func__);
ffffffffea801d80:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801d84:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801d88:	91088021 	add	x1, x1, #0x220
ffffffffea801d8c:	9108e000 	add	x0, x0, #0x238
ffffffffea801d90:	94003f44 	bl	ffffffffea811aa0 <_dprintf>
		return ERR_NOT_ALLOWED;
ffffffffea801d94:	12800200 	mov	w0, #0xffffffef            	// #-17
ffffffffea801d98:	17fffff7 	b	ffffffffea801d74 <get_and_clear_eks_info+0x44>
		dprintf(CRITICAL, "%s: ERROR: Attempting to access NULL pointer\n", __func__);
ffffffffea801d9c:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801da0:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801da4:	91088021 	add	x1, x1, #0x220
ffffffffea801da8:	91098000 	add	x0, x0, #0x260
ffffffffea801dac:	94003f3d 	bl	ffffffffea811aa0 <_dprintf>
		return ERR_INVALID_ARGS;
ffffffffea801db0:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea801db4:	17fffff0 	b	ffffffffea801d74 <get_and_clear_eks_info+0x44>

ffffffffea801db8 <partner_process_boot_params>:
}

__WEAK status_t partner_process_boot_params(boot_params_t *boot_params)
{
	return NO_ERROR;
};
ffffffffea801db8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea801dbc:	d65f03c0 	ret

ffffffffea801dc0 <process_boot_params>:

status_t process_boot_params(void)
{
ffffffffea801dc0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea801dc4:	910003fd 	mov	x29, sp
	key_params *keys_params;
	size_t total_length, keys_length;
	uint32_t offset;
	status_t ret;
	/* get boot args */
	if ((ret = sm_get_boot_args((void **)&boot_params, &total_length))
ffffffffea801dc8:	910123a1 	add	x1, x29, #0x48
ffffffffea801dcc:	910103a0 	add	x0, x29, #0x40
ffffffffea801dd0:	94001a08 	bl	ffffffffea8085f0 <sm_get_boot_args>
ffffffffea801dd4:	35000180 	cbnz	w0, ffffffffea801e04 <process_boot_params+0x44>
ffffffffea801dd8:	f9000bb3 	str	x19, [x29, #16]
			!= NO_ERROR) {
		LTRACEF("sm_get_boot_args failed: %d\n", ret);
		return ret;
	}

	if (!boot_params) {
ffffffffea801ddc:	f94023b3 	ldr	x19, [x29, #64]
ffffffffea801de0:	b4000173 	cbz	x19, ffffffffea801e0c <process_boot_params+0x4c>
		ret = ERR_NOT_CONFIGURED;
		goto release_bootargs;
	}

	if (total_length < sizeof(boot_params_t)) {
ffffffffea801de4:	f94027a1 	ldr	x1, [x29, #72]
		ret = ERR_BAD_LEN;
ffffffffea801de8:	128003e0 	mov	w0, #0xffffffe0            	// #-32
	if (total_length < sizeof(boot_params_t)) {
ffffffffea801dec:	f1023c3f 	cmp	x1, #0x8f
ffffffffea801df0:	54000128 	b.hi	ffffffffea801e14 <process_boot_params+0x54>  // b.pmore
ffffffffea801df4:	b9003fa0 	str	w0, [x29, #60]
		return ret;
	}

release_bootargs:
	/* release boot args reference */
	sm_put_boot_args();
ffffffffea801df8:	94001a24 	bl	ffffffffea808688 <sm_put_boot_args>
ffffffffea801dfc:	b9403fa0 	ldr	w0, [x29, #60]
ffffffffea801e00:	f9400bb3 	ldr	x19, [x29, #16]

	return ret;
}
ffffffffea801e04:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea801e08:	d65f03c0 	ret
		ret = ERR_NOT_CONFIGURED;
ffffffffea801e0c:	128004a0 	mov	w0, #0xffffffda            	// #-38
ffffffffea801e10:	17fffff9 	b	ffffffffea801df4 <process_boot_params+0x34>
	device_uid[0] = boot_params_ptr->chip_uid[0];
ffffffffea801e14:	29409e63 	ldp	w3, w7, [x19, #4]
ffffffffea801e18:	b00002e1 	adrp	x1, ffffffffea85e000 <rb_data+0x18>
	device_uid[2] = boot_params_ptr->chip_uid[2];
ffffffffea801e1c:	29419666 	ldp	w6, w5, [x19, #12]
	device_uid[0] = boot_params_ptr->chip_uid[0];
ffffffffea801e20:	9100a020 	add	x0, x1, #0x28
	device_uid[3] = boot_params_ptr->chip_uid[3];
ffffffffea801e24:	b9401664 	ldr	w4, [x19, #20]
	debug_uart_id = boot_params_ptr->uart_id;
ffffffffea801e28:	900000c2 	adrp	x2, ffffffffea819000 <_mem_phys_base>
ffffffffea801e2c:	a901d7b4 	stp	x20, x21, [x29, #24]
	dest = memcpy((void *)&rb_data, (const void *)&(boot_params_ptr->rb_data),
ffffffffea801e30:	900002f4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea801e34:	913fa294 	add	x20, x20, #0xfe8
	device_uid[0] = boot_params_ptr->chip_uid[0];
ffffffffea801e38:	b9002827 	str	w7, [x1, #40]
	debug_uart_id = boot_params_ptr->uart_id;
ffffffffea801e3c:	b9001043 	str	w3, [x2, #16]
	dest = memcpy((void *)&rb_data, (const void *)&(boot_params_ptr->rb_data),
ffffffffea801e40:	91014261 	add	x1, x19, #0x50
	device_uid[2] = boot_params_ptr->chip_uid[2];
ffffffffea801e44:	29009406 	stp	w6, w5, [x0, #4]
	dest = memcpy((void *)&rb_data, (const void *)&(boot_params_ptr->rb_data),
ffffffffea801e48:	d2800802 	mov	x2, #0x40                  	// #64
	device_uid[3] = boot_params_ptr->chip_uid[3];
ffffffffea801e4c:	b9000c04 	str	w4, [x0, #12]
	keys_params = (key_params *)((uintptr_t)boot_params + offset);
ffffffffea801e50:	91024275 	add	x21, x19, #0x90
	dest = memcpy((void *)&rb_data, (const void *)&(boot_params_ptr->rb_data),
ffffffffea801e54:	aa1403e0 	mov	x0, x20
ffffffffea801e58:	94004536 	bl	ffffffffea813330 <memcpy>
	if (dest != (void *)&rb_data) {
ffffffffea801e5c:	eb00029f 	cmp	x20, x0
ffffffffea801e60:	540000e0 	b.eq	ffffffffea801e7c <process_boot_params+0xbc>  // b.none
		TRACEF("error while doing mem copy\n");
ffffffffea801e64:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801e68:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801e6c:	52800a42 	mov	w2, #0x52                  	// #82
ffffffffea801e70:	9107e021 	add	x1, x1, #0x1f8
ffffffffea801e74:	910a4000 	add	x0, x0, #0x290
ffffffffea801e78:	940044ee 	bl	ffffffffea813230 <_printf>
	keys_length = keys_params->encrypted_key_sz;
ffffffffea801e7c:	b9409273 	ldr	w19, [x19, #144]
ffffffffea801e80:	2a1303e3 	mov	w3, w19
        if (keys_length > MAXIMUM_ENCRYPTED_KEYS_SIZE) {
ffffffffea801e84:	f140807f 	cmp	x3, #0x20, lsl #12
ffffffffea801e88:	540001e9 	b.ls	ffffffffea801ec4 <process_boot_params+0x104>  // b.plast
		TRACEF("encrypted key length (%zu) exceeds maximum key length (%lu)\n",
ffffffffea801e8c:	52800fe2 	mov	w2, #0x7f                  	// #127
ffffffffea801e90:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801e94:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801e98:	91082021 	add	x1, x1, #0x208
ffffffffea801e9c:	d2a00044 	mov	x4, #0x20000               	// #131072
ffffffffea801ea0:	910ae000 	add	x0, x0, #0x2b8
ffffffffea801ea4:	940044e3 	bl	ffffffffea813230 <_printf>
		eks_info.paddr = NULL;
ffffffffea801ea8:	f00002a1 	adrp	x1, ffffffffea858000 <__bss_start>
ffffffffea801eac:	91002022 	add	x2, x1, #0x8
		goto release_bootargs;
ffffffffea801eb0:	a941d7b4 	ldp	x20, x21, [x29, #24]
		ret = ERR_BAD_LEN;
ffffffffea801eb4:	128003e0 	mov	w0, #0xffffffe0            	// #-32
		eks_info.paddr = NULL;
ffffffffea801eb8:	f900043f 	str	xzr, [x1, #8]
		eks_info.blob_length = 0;
ffffffffea801ebc:	b900085f 	str	wzr, [x2, #8]
		goto release_bootargs;
ffffffffea801ec0:	17ffffcd 	b	ffffffffea801df4 <process_boot_params+0x34>
	eks_info.paddr = kvaddr_to_paddr(keys_params);
ffffffffea801ec4:	aa1503e0 	mov	x0, x21
ffffffffea801ec8:	94003bf4 	bl	ffffffffea810e98 <kvaddr_to_paddr>
ffffffffea801ecc:	f00002a1 	adrp	x1, ffffffffea858000 <__bss_start>
ffffffffea801ed0:	91002022 	add	x2, x1, #0x8
ffffffffea801ed4:	f9000420 	str	x0, [x1, #8]
	ret = partner_process_boot_params(boot_params);
ffffffffea801ed8:	f94023a0 	ldr	x0, [x29, #64]
	eks_info.blob_length = keys_length;
ffffffffea801edc:	b9000853 	str	w19, [x2, #8]
	ret = partner_process_boot_params(boot_params);
ffffffffea801ee0:	97ffffb6 	bl	ffffffffea801db8 <partner_process_boot_params>
 	if (ret != NO_ERROR) {
ffffffffea801ee4:	35000060 	cbnz	w0, ffffffffea801ef0 <process_boot_params+0x130>
ffffffffea801ee8:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea801eec:	17ffffc2 	b	ffffffffea801df4 <process_boot_params+0x34>
ffffffffea801ef0:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea801ef4:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea801ef8:	17ffffc3 	b	ffffffffea801e04 <process_boot_params+0x44>
ffffffffea801efc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801f00 <uart_putc>:
{
	return *REG8(uart_base[port] + (reg << 2));
}

static int uart_putc(int port, char c )
{
ffffffffea801f00:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea801f04:	910003fd 	mov	x29, sp
ffffffffea801f08:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea801f0c:	2a0003f3 	mov	w19, w0
ffffffffea801f10:	a9025bf5 	stp	x21, x22, [sp, #32]
	lk_bigtime_t start = current_time_hires();

	while (!(read_uart_reg(port, UART_LSR) & (1<<5))) {
		if (timed_out)
			return -1;
		if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea801f14:	d29423f5 	mov	x21, #0xa11f                	// #41247
{
ffffffffea801f18:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea801f1c:	12001c37 	and	w23, w1, #0xff
ffffffffea801f20:	f90023f9 	str	x25, [sp, #64]
	lk_bigtime_t start = current_time_hires();
ffffffffea801f24:	94000d41 	bl	ffffffffea805428 <current_time_hires>
ffffffffea801f28:	aa0003f6 	mov	x22, x0
ffffffffea801f2c:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801f30:	910c8000 	add	x0, x0, #0x320
ffffffffea801f34:	f00002b8 	adrp	x24, ffffffffea858000 <__bss_start>
		if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea801f38:	f2a000f5 	movk	x21, #0x7, lsl #16
		if (timed_out)
ffffffffea801f3c:	91006314 	add	x20, x24, #0x18
ffffffffea801f40:	f873d819 	ldr	x25, [x0, w19, sxtw #3]
ffffffffea801f44:	91005333 	add	x19, x25, #0x14
	while (!(read_uart_reg(port, UART_LSR) & (1<<5))) {
ffffffffea801f48:	14000007 	b	ffffffffea801f64 <uart_putc+0x64>
		if (timed_out)
ffffffffea801f4c:	39400280 	ldrb	w0, [x20]
ffffffffea801f50:	35000200 	cbnz	w0, ffffffffea801f90 <uart_putc+0x90>
		if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea801f54:	94000d35 	bl	ffffffffea805428 <current_time_hires>
ffffffffea801f58:	cb160000 	sub	x0, x0, x22
ffffffffea801f5c:	eb15001f 	cmp	x0, x21
ffffffffea801f60:	54000268 	b.hi	ffffffffea801fac <uart_putc+0xac>  // b.pmore
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea801f64:	39400260 	ldrb	w0, [x19]
	while (!(read_uart_reg(port, UART_LSR) & (1<<5))) {
ffffffffea801f68:	362fff20 	tbz	w0, #5, ffffffffea801f4c <uart_putc+0x4c>
	*REG8(uart_base[port] + (reg << 2)) = data;
ffffffffea801f6c:	39000337 	strb	w23, [x25]
	}

	timed_out = false;

	write_uart_reg(port, UART_THR, c);
	return 0;
ffffffffea801f70:	52800000 	mov	w0, #0x0                   	// #0
	timed_out = false;
ffffffffea801f74:	3900631f 	strb	wzr, [x24, #24]
}
ffffffffea801f78:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801f7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801f80:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801f84:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea801f88:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea801f8c:	d65f03c0 	ret
			return -1;
ffffffffea801f90:	12800000 	mov	w0, #0xffffffff            	// #-1
}
ffffffffea801f94:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea801f98:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801f9c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801fa0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801fa4:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea801fa8:	d65f03c0 	ret
			timed_out = true;
ffffffffea801fac:	52800021 	mov	w1, #0x1                   	// #1
			return -1;
ffffffffea801fb0:	12800000 	mov	w0, #0xffffffff            	// #-1
			timed_out = true;
ffffffffea801fb4:	39000281 	strb	w1, [x20]
}
ffffffffea801fb8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801fbc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801fc0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801fc4:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea801fc8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea801fcc:	d65f03c0 	ret

ffffffffea801fd0 <platform_dputc>:

	return read_uart_reg(port, UART_RHR);
}

void platform_dputc(char c)
{
ffffffffea801fd0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea801fd4:	900000c1 	adrp	x1, ffffffffea819000 <_mem_phys_base>
{
ffffffffea801fd8:	910003fd 	mov	x29, sp
ffffffffea801fdc:	f9000bf3 	str	x19, [sp, #16]
ffffffffea801fe0:	12001c13 	and	w19, w0, #0xff
	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea801fe4:	b9418420 	ldr	w0, [x1, #388]
ffffffffea801fe8:	35000200 	cbnz	w0, ffffffffea802028 <platform_dputc+0x58>
ffffffffea801fec:	f9000fb4 	str	x20, [x29, #24]
ffffffffea801ff0:	900000d4 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea801ff4:	b9418280 	ldr	w0, [x20, #384]
ffffffffea801ff8:	34000160 	cbz	w0, ffffffffea802024 <platform_dputc+0x54>
		return;

	if (debug_port == TEGRA_COMBUART_ID) {
ffffffffea801ffc:	7103f81f 	cmp	w0, #0xfe
ffffffffea802000:	540001a0 	b.eq	ffffffffea802034 <platform_dputc+0x64>  // b.none
		platform_tegra_comb_uart_putc(c);
		return;
	}

	if (c == '\n') {
ffffffffea802004:	71002a7f 	cmp	w19, #0xa
ffffffffea802008:	54000200 	b.eq	ffffffffea802048 <platform_dputc+0x78>  // b.none
		uart_putc(debug_port, '\r');
	} else if (c == '\0') {
ffffffffea80200c:	340000d3 	cbz	w19, ffffffffea802024 <platform_dputc+0x54>
		return;
	}
	uart_putc(debug_port, c);
ffffffffea802010:	2a1303e1 	mov	w1, w19
ffffffffea802014:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea802018:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80201c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	uart_putc(debug_port, c);
ffffffffea802020:	17ffffb8 	b	ffffffffea801f00 <uart_putc>
ffffffffea802024:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea802028:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80202c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea802030:	d65f03c0 	ret
		platform_tegra_comb_uart_putc(c);
ffffffffea802034:	2a1303e0 	mov	w0, w19
ffffffffea802038:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea80203c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802040:	a8c27bfd 	ldp	x29, x30, [sp], #32
		platform_tegra_comb_uart_putc(c);
ffffffffea802044:	17ffff21 	b	ffffffffea801cc8 <platform_tegra_comb_uart_putc>
		uart_putc(debug_port, '\r');
ffffffffea802048:	528001a1 	mov	w1, #0xd                   	// #13
ffffffffea80204c:	97ffffad 	bl	ffffffffea801f00 <uart_putc>
ffffffffea802050:	b9418280 	ldr	w0, [x20, #384]
ffffffffea802054:	17ffffef 	b	ffffffffea802010 <platform_dputc+0x40>

ffffffffea802058 <platform_dgetc>:

int platform_dgetc(char *c, bool wait)
{
	int _c;

	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea802058:	f00000a2 	adrp	x2, ffffffffea819000 <_mem_phys_base>
ffffffffea80205c:	b9418442 	ldr	w2, [x2, #388]
ffffffffea802060:	35000a62 	cbnz	w2, ffffffffea8021ac <platform_dgetc+0x154>
{
ffffffffea802064:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea802068:	f00000a2 	adrp	x2, ffffffffea819000 <_mem_phys_base>
{
ffffffffea80206c:	910003fd 	mov	x29, sp
ffffffffea802070:	f9000ff4 	str	x20, [sp, #24]
	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea802074:	b9418054 	ldr	w20, [x2, #384]
ffffffffea802078:	34000694 	cbz	w20, ffffffffea802148 <platform_dgetc+0xf0>
ffffffffea80207c:	f9000bb3 	str	x19, [x29, #16]
		return -1;

	if (debug_port == TEGRA_COMBUART_ID) {
ffffffffea802080:	7103fa9f 	cmp	w20, #0xfe
ffffffffea802084:	f90017b6 	str	x22, [x29, #40]
ffffffffea802088:	aa0003f3 	mov	x19, x0
ffffffffea80208c:	12001c36 	and	w22, w1, #0xff
ffffffffea802090:	54000520 	b.eq	ffffffffea802134 <platform_dgetc+0xdc>  // b.none
ffffffffea802094:	f90013b5 	str	x21, [x29, #32]
ffffffffea802098:	a903e7b8 	stp	x24, x25, [x29, #56]
	lk_bigtime_t start = current_time_hires();
ffffffffea80209c:	94000ce3 	bl	ffffffffea805428 <current_time_hires>
ffffffffea8020a0:	aa0003f5 	mov	x21, x0
ffffffffea8020a4:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8020a8:	910c8000 	add	x0, x0, #0x320
ffffffffea8020ac:	f874d819 	ldr	x25, [x0, w20, sxtw #3]
ffffffffea8020b0:	91005334 	add	x20, x25, #0x14
	if (wait) {
ffffffffea8020b4:	35000216 	cbnz	w22, ffffffffea8020f4 <platform_dgetc+0x9c>
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea8020b8:	39405320 	ldrb	w0, [x25, #20]
		if (!(read_uart_reg(port, UART_LSR) & (1<<0)))
ffffffffea8020bc:	360006e0 	tbz	w0, #0, ffffffffea802198 <platform_dgetc+0x140>
ffffffffea8020c0:	d00002b8 	adrp	x24, ffffffffea858000 <__bss_start>
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea8020c4:	39400320 	ldrb	w0, [x25]
	timed_out = false;
ffffffffea8020c8:	3900671f 	strb	wzr, [x24, #25]
ffffffffea8020cc:	f94013b5 	ldr	x21, [x29, #32]
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea8020d0:	12001c00 	and	w0, w0, #0xff
ffffffffea8020d4:	a943e7b8 	ldp	x24, x25, [x29, #56]
	}

	if (_c < 0)
		return -1;

	*c = _c;
ffffffffea8020d8:	39000260 	strb	w0, [x19]
	return 0;
ffffffffea8020dc:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8020e0:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8020e4:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea8020e8:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea8020ec:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8020f0:	d65f03c0 	ret
ffffffffea8020f4:	f9001bb7 	str	x23, [x29, #48]
			if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea8020f8:	d29423f7 	mov	x23, #0xa11f                	// #41247
ffffffffea8020fc:	d00002b8 	adrp	x24, ffffffffea858000 <__bss_start>
ffffffffea802100:	f2a000f7 	movk	x23, #0x7, lsl #16
			if (timed_out)
ffffffffea802104:	91006716 	add	x22, x24, #0x19
ffffffffea802108:	14000007 	b	ffffffffea802124 <platform_dgetc+0xcc>
ffffffffea80210c:	394002c1 	ldrb	w1, [x22]
ffffffffea802110:	35000241 	cbnz	w1, ffffffffea802158 <platform_dgetc+0x100>
			if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea802114:	94000cc5 	bl	ffffffffea805428 <current_time_hires>
ffffffffea802118:	cb150000 	sub	x0, x0, x21
ffffffffea80211c:	eb17001f 	cmp	x0, x23
ffffffffea802120:	54000288 	b.hi	ffffffffea802170 <platform_dgetc+0x118>  // b.pmore
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea802124:	39400281 	ldrb	w1, [x20]
		while (!(read_uart_reg(port, UART_LSR) & (1<<0))) {
ffffffffea802128:	3607ff21 	tbz	w1, #0, ffffffffea80210c <platform_dgetc+0xb4>
ffffffffea80212c:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea802130:	17ffffe5 	b	ffffffffea8020c4 <platform_dgetc+0x6c>
		_c = platform_tegra_comb_uart_getc(wait);
ffffffffea802134:	2a1603e0 	mov	w0, w22
ffffffffea802138:	97fffefa 	bl	ffffffffea801d20 <platform_tegra_comb_uart_getc>
	if (_c < 0)
ffffffffea80213c:	36fffce0 	tbz	w0, #31, ffffffffea8020d8 <platform_dgetc+0x80>
ffffffffea802140:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea802144:	f94017b6 	ldr	x22, [x29, #40]
		return -1;
ffffffffea802148:	12800000 	mov	w0, #0xffffffff            	// #-1
}
ffffffffea80214c:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea802150:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea802154:	d65f03c0 	ret
ffffffffea802158:	f9400bb3 	ldr	x19, [x29, #16]
		return -1;
ffffffffea80215c:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea802160:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea802164:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea802168:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80216c:	17fffff8 	b	ffffffffea80214c <platform_dgetc+0xf4>
				timed_out = true;
ffffffffea802170:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea802174:	390002c1 	strb	w1, [x22]
		return -1;
ffffffffea802178:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea80217c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea802180:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea802184:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea802188:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea80218c:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea802190:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea802194:	d65f03c0 	ret
ffffffffea802198:	f9400bb3 	ldr	x19, [x29, #16]
		return -1;
ffffffffea80219c:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea8021a0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8021a4:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea8021a8:	17ffffe9 	b	ffffffffea80214c <platform_dgetc+0xf4>
ffffffffea8021ac:	12800000 	mov	w0, #0xffffffff            	// #-1
}
ffffffffea8021b0:	d65f03c0 	ret
ffffffffea8021b4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8021b8 <platform_init_debug_port>:

void platform_init_debug_port(unsigned int dbg_port)
{
	
	debug_port = dbg_port;
ffffffffea8021b8:	f00000a3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
	disable_debug = 1;
}

void platform_enable_debug_intf(void)
{
	disable_debug = 0;
ffffffffea8021bc:	f00000a2 	adrp	x2, ffffffffea819000 <_mem_phys_base>
{
ffffffffea8021c0:	2a0003e1 	mov	w1, w0
	dprintf(0, "DEBUG PORT ENABLED with %d\n", debug_port);
ffffffffea8021c4:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
	debug_port = dbg_port;
ffffffffea8021c8:	b9018061 	str	w1, [x3, #384]
	dprintf(0, "DEBUG PORT ENABLED with %d\n", debug_port);
ffffffffea8021cc:	910c0000 	add	x0, x0, #0x300
	disable_debug = 0;
ffffffffea8021d0:	b901845f 	str	wzr, [x2, #388]
	dprintf(0, "DEBUG PORT ENABLED with %d\n", debug_port);
ffffffffea8021d4:	14003e33 	b	ffffffffea811aa0 <_dprintf>

ffffffffea8021d8 <platform_disable_debug_intf>:
	disable_debug = 1;
ffffffffea8021d8:	f00000a0 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea8021dc:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8021e0:	b9018401 	str	w1, [x0, #388]
}
ffffffffea8021e4:	d65f03c0 	ret

ffffffffea8021e8 <tegra_platform_bootstrap_epilog>:
} platform_state = {
	.bootstrap_done = false,
};

// platform specific hook for epilog
__WEAK void tegra_platform_bootstrap_epilog(void) {}
ffffffffea8021e8:	d65f03c0 	ret
ffffffffea8021ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8021f0 <platform_is_bootstrapping>:
	.ns_dram_map_list_head = LIST_INITIAL_VALUE(platform_ctx.ns_dram_map_list_head)
};

bool platform_is_bootstrapping(void)
{
	return !platform_state.bootstrap_done;
ffffffffea8021f0:	d00002a0 	adrp	x0, ffffffffea858000 <__bss_start>
ffffffffea8021f4:	39408000 	ldrb	w0, [x0, #32]
}
ffffffffea8021f8:	52000000 	eor	w0, w0, #0x1
ffffffffea8021fc:	d65f03c0 	ret

ffffffffea802200 <platform_bootstrap_epilog>:
/*
 * Defining a common platform_bootstrap_epilog handler. If platform specific
 * cleanups are required, implement a platform specific epilog handler.
 */
void platform_bootstrap_epilog(void)
{
ffffffffea802200:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	platform_state.bootstrap_done = true;
ffffffffea802204:	d00002a0 	adrp	x0, ffffffffea858000 <__bss_start>
ffffffffea802208:	52800021 	mov	w1, #0x1                   	// #1
{
ffffffffea80220c:	910003fd 	mov	x29, sp
	platform_state.bootstrap_done = true;
ffffffffea802210:	39008001 	strb	w1, [x0, #32]
	tegra_platform_bootstrap_epilog();
ffffffffea802214:	97fffff5 	bl	ffffffffea8021e8 <tegra_platform_bootstrap_epilog>
	 * its impact on boot KPI
	 */
#if !defined(TRUSTY_TARGET_PLATFORM_EMBEDDED)
	dprintf(ALWAYS, "%s: trusty bootstrap complete\n", __func__);
#endif
}
ffffffffea802218:	a8c17bfd 	ldp	x29, x30, [sp], #16
	dprintf(ALWAYS, "%s: trusty bootstrap complete\n", __func__);
ffffffffea80221c:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802220:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802224:	910d4021 	add	x1, x1, #0x350
ffffffffea802228:	910e6000 	add	x0, x0, #0x398
ffffffffea80222c:	14003e1d 	b	ffffffffea811aa0 <_dprintf>

ffffffffea802230 <platform_arch_speculation_barrier>:

void platform_arch_speculation_barrier(void) {

#if defined(INSERT_SPECULATION_BARRIER)
	mb();
ffffffffea802230:	d5033f9f 	dsb	sy
	ISB;
ffffffffea802234:	d5033fdf 	isb
#endif

	return;
}
ffffffffea802238:	d65f03c0 	ret
ffffffffea80223c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802240 <platform_register_ns_dram_ranges>:

long platform_register_ns_dram_ranges(paddr_t ns_base, uint64_t ns_size)
{
ffffffffea802240:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
#define TOS_NS_MEM_MAP_MAGIC_VALUE (0xfeedbeef)
#define TOS_NS_MEM_MAP_CUR_VERSION (0x1)
	dprintf(SPEW, "%s: ns_base: %lx, ns_size: %llu\n", __func__, ns_base, ns_size);
ffffffffea802244:	aa0103e3 	mov	x3, x1
{
ffffffffea802248:	910003fd 	mov	x29, sp
ffffffffea80224c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea802250:	aa0003f4 	mov	x20, x0
ffffffffea802254:	f9001bf7 	str	x23, [sp, #48]
	dprintf(SPEW, "%s: ns_base: %lx, ns_size: %llu\n", __func__, ns_base, ns_size);
ffffffffea802258:	f0000097 	adrp	x23, ffffffffea815000 <__fault_handler_table_start>
{
ffffffffea80225c:	a9046bf9 	stp	x25, x26, [sp, #64]

	/*Register DRAM ranges only once*/
	if (platform_ctx.ns_dram_range_available)
ffffffffea802260:	f00000b9 	adrp	x25, ffffffffea819000 <_mem_phys_base>
	dprintf(SPEW, "%s: ns_base: %lx, ns_size: %llu\n", __func__, ns_base, ns_size);
ffffffffea802264:	910dc2fa 	add	x26, x23, #0x370
{
ffffffffea802268:	aa0103f3 	mov	x19, x1
	dprintf(SPEW, "%s: ns_base: %lx, ns_size: %llu\n", __func__, ns_base, ns_size);
ffffffffea80226c:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802270:	aa1403e2 	mov	x2, x20
ffffffffea802274:	910ee000 	add	x0, x0, #0x3b8
{
ffffffffea802278:	f90013f5 	str	x21, [sp, #32]
	dprintf(SPEW, "%s: ns_base: %lx, ns_size: %llu\n", __func__, ns_base, ns_size);
ffffffffea80227c:	aa1a03e1 	mov	x1, x26
ffffffffea802280:	94003e08 	bl	ffffffffea811aa0 <_dprintf>
	if (platform_ctx.ns_dram_range_available)
ffffffffea802284:	39462320 	ldrb	w0, [x25, #392]
ffffffffea802288:	35001160 	cbnz	w0, ffffffffea8024b4 <platform_register_ns_dram_ranges+0x274>
ffffffffea80228c:	f9002bbb 	str	x27, [x29, #80]
	vaddr_t vptr;
	long ret = NO_ERROR;

	offset = ns_base & (PAGE_SIZE - 1);
	aligned_addr = ROUNDDOWN(ns_base, PAGE_SIZE);
	aligned_size = ROUNDUP(ns_size + offset, PAGE_SIZE);
ffffffffea802290:	913ffe62 	add	x2, x19, #0xfff
	offset = ns_base & (PAGE_SIZE - 1);
ffffffffea802294:	92402e9b 	and	x27, x20, #0xfff
ffffffffea802298:	f9001fb8 	str	x24, [x29, #56]
	aligned_size = ROUNDUP(ns_size + offset, PAGE_SIZE);
ffffffffea80229c:	8b1b0042 	add	x2, x2, x27

	ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "cboot",
ffffffffea8022a0:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8022a4:	52800707 	mov	w7, #0x38                  	// #56
ffffffffea8022a8:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea8022ac:	9274ce85 	and	x5, x20, #0xfffffffffffff000
ffffffffea8022b0:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea8022b4:	9101e3a3 	add	x3, x29, #0x78
ffffffffea8022b8:	910f8021 	add	x1, x1, #0x3e0
ffffffffea8022bc:	900002f8 	adrp	x24, ffffffffea85e000 <rb_data+0x18>
ffffffffea8022c0:	9274cc42 	and	x2, x2, #0xfffffffffffff000
ffffffffea8022c4:	91034300 	add	x0, x24, #0xd0
ffffffffea8022c8:	94003c34 	bl	ffffffffea811398 <vmm_alloc_physical>
ffffffffea8022cc:	93407c15 	sxtw	x21, w0
			aligned_size, (void **)&vptr, PAGE_SIZE_SHIFT,
			aligned_addr, 0,
			ARCH_MMU_FLAG_NS | ARCH_MMU_FLAG_PERM_NO_EXECUTE |
			ARCH_MMU_FLAG_CACHED | ARCH_MMU_FLAG_PERM_RO);

	if (ret != NO_ERROR) {
ffffffffea8022d0:	b5000bf5 	cbnz	x21, ffffffffea80244c <platform_register_ns_dram_ranges+0x20c>
				"Trusty may fail to validate NS DRAM ranges\n"
				, __func__);
		return ret;
	}

	ns_mem_map = (tos_ns_mem_map_t *) (vptr + offset);
ffffffffea8022d4:	f9403fa1 	ldr	x1, [x29, #120]

	/* Memory sanitization check */
	if (ns_mem_map->magic != TOS_NS_MEM_MAP_MAGIC_VALUE) {
ffffffffea8022d8:	5297dde2 	mov	w2, #0xbeef                	// #48879
ffffffffea8022dc:	72bfdda2 	movk	w2, #0xfeed, lsl #16
ffffffffea8022e0:	b87b6823 	ldr	w3, [x1, x27]
ffffffffea8022e4:	f90017b6 	str	x22, [x29, #40]
	ns_mem_map = (tos_ns_mem_map_t *) (vptr + offset);
ffffffffea8022e8:	8b1b0036 	add	x22, x1, x27
	if (ns_mem_map->magic != TOS_NS_MEM_MAP_MAGIC_VALUE) {
ffffffffea8022ec:	6b02007f 	cmp	w3, w2
ffffffffea8022f0:	540008a1 	b.ne	ffffffffea802404 <platform_register_ns_dram_ranges+0x1c4>  // b.any
		ret = ERR_INVALID_ARGS;
		goto lbl_free_vmm;
	}

	/* Check supported API version */
	if (ns_mem_map->ver != TOS_NS_MEM_MAP_CUR_VERSION) {
ffffffffea8022f4:	b94006c3 	ldr	w3, [x22, #4]
ffffffffea8022f8:	7100047f 	cmp	w3, #0x1
ffffffffea8022fc:	54000c21 	b.ne	ffffffffea802480 <platform_register_ns_dram_ranges+0x240>  // b.any
				ns_mem_map->ver);
		ret = ERR_INVALID_ARGS;
		goto lbl_free_vmm;
	}

	for (map_index = 0; map_index < ns_mem_map->num; map_index++) {
ffffffffea802300:	b9400ac0 	ldr	w0, [x22, #8]
ffffffffea802304:	f9002fbc 	str	x28, [x29, #88]
ffffffffea802308:	5280001c 	mov	w28, #0x0                   	// #0
ffffffffea80230c:	34000cc0 	cbz	w0, ffffffffea8024a4 <platform_register_ns_dram_ranges+0x264>

#define list_add_after(entry, new_entry) list_add_head(entry, new_entry)

static inline void list_add_tail(struct list_node *list, struct list_node *item)
{
	item->prev = list->prev;
ffffffffea802310:	9106233a 	add	x26, x25, #0x188
			goto err_free_dram_map;
		}
		memcpy(&dram_map_node->ns_dram_entry, &ns_mem_map->mappings[map_index],
				sizeof(tos_ns_mem_map_entry_t));

		dprintf(SPEW, "%s: base: %llx size: %llu entry size: %zu\n", __func__,
ffffffffea802314:	f000009b 	adrp	x27, ffffffffea815000 <__fault_handler_table_start>
	item->next = list;
ffffffffea802318:	91002340 	add	x0, x26, #0x8
ffffffffea80231c:	9116237b 	add	x27, x27, #0x588
ffffffffea802320:	f90037a0 	str	x0, [x29, #104]
ffffffffea802324:	14000010 	b	ffffffffea802364 <platform_register_ns_dram_ranges+0x124>
		memcpy(&dram_map_node->ns_dram_entry, &ns_mem_map->mappings[map_index],
ffffffffea802328:	94004402 	bl	ffffffffea813330 <memcpy>
		dprintf(SPEW, "%s: base: %llx size: %llu entry size: %zu\n", __func__,
ffffffffea80232c:	f8410682 	ldr	x2, [x20], #16
ffffffffea802330:	910dc2e1 	add	x1, x23, #0x370
ffffffffea802334:	f9400663 	ldr	x3, [x19, #8]
ffffffffea802338:	d2800204 	mov	x4, #0x10                  	// #16
ffffffffea80233c:	aa1b03e0 	mov	x0, x27
ffffffffea802340:	94003dd8 	bl	ffffffffea811aa0 <_dprintf>
	item->prev = list->prev;
ffffffffea802344:	f9400740 	ldr	x0, [x26, #8]
	item->next = list;
ffffffffea802348:	f94037a1 	ldr	x1, [x29, #104]
ffffffffea80234c:	a9010660 	stp	x0, x1, [x19, #16]
	for (map_index = 0; map_index < ns_mem_map->num; map_index++) {
ffffffffea802350:	b9400ac1 	ldr	w1, [x22, #8]
	list->prev->next = item;
ffffffffea802354:	f9000414 	str	x20, [x0, #8]
	list->prev = item;
ffffffffea802358:	f9000754 	str	x20, [x26, #8]
ffffffffea80235c:	6b1c003f 	cmp	w1, w28
ffffffffea802360:	54000a09 	b.ls	ffffffffea8024a0 <platform_register_ns_dram_ranges+0x260>  // b.plast
		tos_ns_dram_map_node_t *dram_map_node = calloc(1, sizeof(tos_ns_dram_map_node_t));
ffffffffea802364:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea802368:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80236c:	940043df 	bl	ffffffffea8132e8 <calloc>
ffffffffea802370:	aa0003f3 	mov	x19, x0
		memcpy(&dram_map_node->ns_dram_entry, &ns_mem_map->mappings[map_index],
ffffffffea802374:	d28001c1 	mov	x1, #0xe                   	// #14
		dprintf(SPEW, "%s: base: %llx size: %llu entry size: %zu\n", __func__,
ffffffffea802378:	aa0003f4 	mov	x20, x0
		memcpy(&dram_map_node->ns_dram_entry, &ns_mem_map->mappings[map_index],
ffffffffea80237c:	8b3c5021 	add	x1, x1, w28, uxtw #4
ffffffffea802380:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea802384:	8b0102c1 	add	x1, x22, x1
	for (map_index = 0; map_index < ns_mem_map->num; map_index++) {
ffffffffea802388:	1100079c 	add	w28, w28, #0x1
		if (NULL == dram_map_node) {
ffffffffea80238c:	b5fffce0 	cbnz	x0, ffffffffea802328 <platform_register_ns_dram_ranges+0xe8>

	platform_ctx.ns_dram_range_available = true;

	if (0) {
err_free_dram_map:
		list_for_every_entry_safe (&platform_ctx.ns_dram_map_list_head, map_node,
ffffffffea802390:	91062339 	add	x25, x25, #0x188
			dprintf(CRITICAL, "%s: FATAL: unable to allocate memory. "
ffffffffea802394:	910dc2e1 	add	x1, x23, #0x370
ffffffffea802398:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80239c:	91148000 	add	x0, x0, #0x520
ffffffffea8023a0:	94003dc0 	bl	ffffffffea811aa0 <_dprintf>
		list_for_every_entry_safe (&platform_ctx.ns_dram_map_list_head, map_node,
ffffffffea8023a4:	91002334 	add	x20, x25, #0x8
ffffffffea8023a8:	f9400b20 	ldr	x0, [x25, #16]
ffffffffea8023ac:	d1004001 	sub	x1, x0, #0x10
ffffffffea8023b0:	eb14001f 	cmp	x0, x20
ffffffffea8023b4:	f9400c22 	ldr	x2, [x1, #24]
ffffffffea8023b8:	d1004053 	sub	x19, x2, #0x10
ffffffffea8023bc:	540001c0 	b.eq	ffffffffea8023f4 <platform_register_ns_dram_ranges+0x1b4>  // b.none

#define list_add_before(entry, new_entry) list_add_tail(entry, new_entry)

static inline void list_delete(struct list_node *item)
{
	item->next->prev = item->prev;
ffffffffea8023c0:	f9400823 	ldr	x3, [x1, #16]
				tmp_map_node, tos_ns_dram_map_node_t, node) {
			list_delete(&map_node->node);
			free(map_node);
ffffffffea8023c4:	aa0103e0 	mov	x0, x1
ffffffffea8023c8:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea8023cc:	f9400823 	ldr	x3, [x1, #16]
ffffffffea8023d0:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea8023d4:	a9017c3f 	stp	xzr, xzr, [x1, #16]
ffffffffea8023d8:	940043d4 	bl	ffffffffea813328 <free>
		list_for_every_entry_safe (&platform_ctx.ns_dram_map_list_head, map_node,
ffffffffea8023dc:	f9400e62 	ldr	x2, [x19, #24]
ffffffffea8023e0:	91004260 	add	x0, x19, #0x10
ffffffffea8023e4:	aa1303e1 	mov	x1, x19
ffffffffea8023e8:	eb14001f 	cmp	x0, x20
ffffffffea8023ec:	d1004053 	sub	x19, x2, #0x10
ffffffffea8023f0:	54fffe81 	b.ne	ffffffffea8023c0 <platform_register_ns_dram_ranges+0x180>  // b.any
			ret = ERR_NO_MEMORY;
ffffffffea8023f4:	92800095 	mov	x21, #0xfffffffffffffffb    	// #-5
ffffffffea8023f8:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea8023fc:	f9403fa1 	ldr	x1, [x29, #120]
ffffffffea802400:	14000007 	b	ffffffffea80241c <platform_register_ns_dram_ranges+0x1dc>
		dprintf(CRITICAL, "%s: FATAL: unable to locate magic value "
ffffffffea802404:	aa1a03e1 	mov	x1, x26
ffffffffea802408:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80240c:	91110000 	add	x0, x0, #0x440
ffffffffea802410:	94003da4 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea802414:	f9403fa1 	ldr	x1, [x29, #120]
		ret = ERR_INVALID_ARGS;
ffffffffea802418:	928000f5 	mov	x21, #0xfffffffffffffff8    	// #-8
			map_node = NULL;
		}
	}
lbl_free_vmm:
	vmm_free_region(vmm_get_kernel_aspace(), vptr);
ffffffffea80241c:	91034300 	add	x0, x24, #0xd0
ffffffffea802420:	94003c40 	bl	ffffffffea811520 <vmm_free_region>
	return ret;
ffffffffea802424:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea802428:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80242c:	f9402bbb 	ldr	x27, [x29, #80]
}
ffffffffea802430:	aa1503e0 	mov	x0, x21
ffffffffea802434:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea802438:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80243c:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea802440:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea802444:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea802448:	d65f03c0 	ret
		dprintf(CRITICAL, "%s: FATAL: unable to map shared memory. "
ffffffffea80244c:	aa1a03e1 	mov	x1, x26
ffffffffea802450:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802454:	910fa000 	add	x0, x0, #0x3e8
ffffffffea802458:	94003d92 	bl	ffffffffea811aa0 <_dprintf>
}
ffffffffea80245c:	aa1503e0 	mov	x0, x21
		return ret;
ffffffffea802460:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea802464:	f9402bbb 	ldr	x27, [x29, #80]
}
ffffffffea802468:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80246c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea802470:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea802474:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea802478:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80247c:	d65f03c0 	ret
		dprintf(CRITICAL, "%s: FATAL: unsupported version "
ffffffffea802480:	aa1a03e1 	mov	x1, x26
ffffffffea802484:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802488:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80248c:	9112e000 	add	x0, x0, #0x4b8
ffffffffea802490:	94003d84 	bl	ffffffffea811aa0 <_dprintf>
		ret = ERR_INVALID_ARGS;
ffffffffea802494:	928000f5 	mov	x21, #0xfffffffffffffff8    	// #-8
ffffffffea802498:	f9403fa1 	ldr	x1, [x29, #120]
		goto lbl_free_vmm;
ffffffffea80249c:	17ffffe0 	b	ffffffffea80241c <platform_register_ns_dram_ranges+0x1dc>
ffffffffea8024a0:	f9403fa1 	ldr	x1, [x29, #120]
	platform_ctx.ns_dram_range_available = true;
ffffffffea8024a4:	52800020 	mov	w0, #0x1                   	// #1
lbl_free_vmm:
ffffffffea8024a8:	f9402fbc 	ldr	x28, [x29, #88]
	platform_ctx.ns_dram_range_available = true;
ffffffffea8024ac:	39062320 	strb	w0, [x25, #392]
lbl_free_vmm:
ffffffffea8024b0:	17ffffdb 	b	ffffffffea80241c <platform_register_ns_dram_ranges+0x1dc>
		return ERR_ALREADY_EXISTS;
ffffffffea8024b4:	928001b5 	mov	x21, #0xfffffffffffffff2    	// #-14
ffffffffea8024b8:	17ffffde 	b	ffffffffea802430 <platform_register_ns_dram_ranges+0x1f0>
ffffffffea8024bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8024c0 <platform_is_denver_cpu>:
 * - Returns true if the cpu is Denver (or Carmel)
 * - Returns false otherwise
 */
bool platform_is_denver_cpu(void)
{
	uint64_t midr = ARM64_READ_SYSREG(midr_el1);
ffffffffea8024c0:	d5380000 	mrs	x0, midr_el1
	uint64_t impl = (midr >> MIDR_IMPL_SHIFT) & MIDR_IMPL_MASK;
ffffffffea8024c4:	53187c00 	lsr	w0, w0, #24

	if (impl == DENVER_IMPL)
ffffffffea8024c8:	f101381f 	cmp	x0, #0x4e
		return true;
	else
		return false;
}
ffffffffea8024cc:	1a9f17e0 	cset	w0, eq  // eq = none
ffffffffea8024d0:	d65f03c0 	ret
ffffffffea8024d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8024d8 <ioctl_map_eks_to_user>:
{
	return uthread_is_valid_range(uthread_get_current(), addr, size);
}

int32_t ioctl_map_eks_to_user(ioctl_map_eks_params p)
{
ffffffffea8024d8:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
ffffffffea8024dc:	910003fd 	mov	x29, sp
ffffffffea8024e0:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea8024e4:	aa0003f4 	mov	x20, x0
ffffffffea8024e8:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea8024ec:	aa0103f5 	mov	x21, x1
ffffffffea8024f0:	d360fc16 	lsr	x22, x0, #32
ffffffffea8024f4:	d360fc37 	lsr	x23, x1, #32
ffffffffea8024f8:	f9001ff8 	str	x24, [sp, #56]
}

/* use the cpu local thread context pointer to store current_thread */
static inline struct thread *get_current_thread(void)
{
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea8024fc:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea802500:	f9415800 	ldr	x0, [x0, #688]
ffffffffea802504:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802508:	2a1403e1 	mov	w1, w20
ffffffffea80250c:	94004803 	bl	ffffffffea814518 <uthread_is_valid_range>
	if (!valid_address((vaddr_t)p.eks_addr_ptr, sizeof(uint32_t)))
ffffffffea802510:	72001c1f 	tst	w0, #0xff
ffffffffea802514:	54000d40 	b.eq	ffffffffea8026bc <ioctl_map_eks_to_user+0x1e4>  // b.none
ffffffffea802518:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea80251c:	f9415800 	ldr	x0, [x0, #688]
ffffffffea802520:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802524:	aa1603e1 	mov	x1, x22
ffffffffea802528:	940047fc 	bl	ffffffffea814518 <uthread_is_valid_range>
		return ERR_INVALID_ARGS;
	if (!valid_address((vaddr_t)p.eks_size_ptr, sizeof(uint32_t)))
ffffffffea80252c:	72001c1f 	tst	w0, #0xff
ffffffffea802530:	54000c60 	b.eq	ffffffffea8026bc <ioctl_map_eks_to_user+0x1e4>  // b.none
ffffffffea802534:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea802538:	f9415800 	ldr	x0, [x0, #688]
ffffffffea80253c:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802540:	2a1503e1 	mov	w1, w21
ffffffffea802544:	940047f5 	bl	ffffffffea814518 <uthread_is_valid_range>
		return ERR_INVALID_ARGS;
	if (!valid_address((vaddr_t)p.map_addr_ptr, sizeof(uint32_t)))
ffffffffea802548:	72001c1f 	tst	w0, #0xff
ffffffffea80254c:	54000b80 	b.eq	ffffffffea8026bc <ioctl_map_eks_to_user+0x1e4>  // b.none
ffffffffea802550:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea802554:	f9415800 	ldr	x0, [x0, #688]
ffffffffea802558:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea80255c:	aa1703e1 	mov	x1, x23
ffffffffea802560:	940047ee 	bl	ffffffffea814518 <uthread_is_valid_range>
		return ERR_INVALID_ARGS;
	if (!valid_address((vaddr_t)p.map_size_ptr, sizeof(uint32_t)))
ffffffffea802564:	72001c1f 	tst	w0, #0xff
ffffffffea802568:	54000aa0 	b.eq	ffffffffea8026bc <ioctl_map_eks_to_user+0x1e4>  // b.none
		return ERR_INVALID_ARGS;

	status_t ret = NO_ERROR;
	eks_info_t info = {0};
ffffffffea80256c:	910243a0 	add	x0, x29, #0x90
ffffffffea802570:	a9bf7c1f 	stp	xzr, xzr, [x0, #-16]!

	/*
	 * Get eks struct's physical address and length
	 * saved in kernel context
	 */
	ret = get_and_clear_eks_info(&info);
ffffffffea802574:	97fffdef 	bl	ffffffffea801d30 <get_and_clear_eks_info>
ffffffffea802578:	2a0003f8 	mov	w24, w0
	if (ret != NO_ERROR) {
ffffffffea80257c:	350008a0 	cbnz	w0, ffffffffea802690 <ioctl_map_eks_to_user+0x1b8>
		dprintf(CRITICAL, "%s: ERROR: failed to retrieve eks info from kernel\n", __func__);
		return ret;
	}
	if (info.paddr == NULL) {
ffffffffea802580:	f94043a0 	ldr	x0, [x29, #128]
ffffffffea802584:	b4000aa0 	cbz	x0, ffffffffea8026d8 <ioctl_map_eks_to_user+0x200>
ffffffffea802588:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80258c:	f90023b9 	str	x25, [x29, #64]
		dprintf(CRITICAL, "%s: ERROR: ioctl called more than once\n", __func__);
		return ERR_NOT_ALLOWED;
	}

	/* map to userspace */
	vaddr_t vaddr = 0U;
ffffffffea802590:	f9002fbf 	str	xzr, [x29, #88]
ffffffffea802594:	d538d081 	mrs	x1, tpidr_el1
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea802598:	f9415821 	ldr	x1, [x1, #688]

	paddr_t paddr = ROUNDDOWN((paddr_t)info.paddr, PAGE_SIZE);
ffffffffea80259c:	9274cc19 	and	x25, x0, #0xfffffffffffff000
	size_t offset = (paddr_t)info.paddr - paddr;
ffffffffea8025a0:	cb190013 	sub	x19, x0, x25
ffffffffea8025a4:	910243a2 	add	x2, x29, #0x90
	size_t size = ROUNDUP(info.blob_length + offset, PAGE_SIZE);
ffffffffea8025a8:	b9408ba3 	ldr	w3, [x29, #136]
static inline __ALWAYS_INLINE
status_t uthread_map_contig(uthread_t *ut, vaddr_t *vaddrp, paddr_t paddr,
		size_t size, u_int flags, u_int align)
{
	flags = flags | UTM_PHYS_CONTIG;
	return uthread_map(ut, vaddrp, &paddr, size, flags, align);
ffffffffea8025ac:	52820005 	mov	w5, #0x1000                	// #4096
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea8025b0:	f9404820 	ldr	x0, [x1, #144]
ffffffffea8025b4:	52800c24 	mov	w4, #0x61                  	// #97
ffffffffea8025b8:	f81e8c59 	str	x25, [x2, #-24]!
	size_t size = ROUNDUP(info.blob_length + offset, PAGE_SIZE);
ffffffffea8025bc:	913ffc63 	add	x3, x3, #0xfff
ffffffffea8025c0:	8b130063 	add	x3, x3, x19
ffffffffea8025c4:	910163a1 	add	x1, x29, #0x58

	ret = uthread_map_contig(trusty_app->ut, &vaddr,
ffffffffea8025c8:	f9402c00 	ldr	x0, [x0, #88]
	size_t size = ROUNDUP(info.blob_length + offset, PAGE_SIZE);
ffffffffea8025cc:	9274cc63 	and	x3, x3, #0xfffffffffffff000
ffffffffea8025d0:	f90033a3 	str	x3, [x29, #96]
ffffffffea8025d4:	94004619 	bl	ffffffffea813e38 <uthread_map>
ffffffffea8025d8:	2a0003f8 	mov	w24, w0
			paddr, size,
			(uint32_t)UTM_R | (uint32_t)UTM_NS_MEM,
			UT_MAP_ALIGN_4KB);

	if (ret != NO_ERROR) {
ffffffffea8025dc:	350003c0 	cbnz	w0, ffffffffea802654 <ioctl_map_eks_to_user+0x17c>
		dprintf(CRITICAL, "%s error: failed to map eks physical address: %x, %u\n", __func__,
			(unsigned int)paddr, (unsigned int)size);
		return ret;
	}

	key_params* keys_params = (key_params *)(vaddr + offset);
ffffffffea8025e0:	f9402fa4 	ldr	x4, [x29, #88]
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea8025e4:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea8025e8:	9101a3a1 	add	x1, x29, #0x68
ffffffffea8025ec:	2a1403e0 	mov	w0, w20
ffffffffea8025f0:	8b040263 	add	x3, x19, x4
	vaddr_t key_string_addr = (vaddr_t)keys_params->encrypted_keys;
	vaddr_t key_size = keys_params->encrypted_key_sz;
ffffffffea8025f4:	b8646a64 	ldr	w4, [x19, x4]
	vaddr_t key_string_addr = (vaddr_t)keys_params->encrypted_keys;
ffffffffea8025f8:	8b020063 	add	x3, x3, x2
	vaddr_t key_size = keys_params->encrypted_key_sz;
ffffffffea8025fc:	a90693a3 	stp	x3, x4, [x29, #104]
ffffffffea802600:	940044c6 	bl	ffffffffea813918 <arch_copy_to_user>
ffffffffea802604:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802608:	9101c3a1 	add	x1, x29, #0x70
ffffffffea80260c:	2a1603e0 	mov	w0, w22
ffffffffea802610:	940044c2 	bl	ffffffffea813918 <arch_copy_to_user>
ffffffffea802614:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802618:	910163a1 	add	x1, x29, #0x58
ffffffffea80261c:	2a1503e0 	mov	w0, w21
ffffffffea802620:	940044be 	bl	ffffffffea813918 <arch_copy_to_user>
ffffffffea802624:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802628:	910183a1 	add	x1, x29, #0x60
ffffffffea80262c:	2a1703e0 	mov	w0, w23
ffffffffea802630:	940044ba 	bl	ffffffffea813918 <arch_copy_to_user>
ffffffffea802634:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea802638:	f94023b9 	ldr	x25, [x29, #64]
	copy_to_user((user_addr_t)p.eks_size_ptr, &key_size, sizeof(uint32_t));
	copy_to_user((user_addr_t)p.map_addr_ptr, &vaddr, sizeof(uint32_t));
	copy_to_user((user_addr_t)p.map_size_ptr, &size, sizeof(uint32_t));

	return NO_ERROR;
}
ffffffffea80263c:	2a1803e0 	mov	w0, w24
ffffffffea802640:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea802644:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea802648:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80264c:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea802650:	d65f03c0 	ret
		dprintf(CRITICAL, "%s error: failed to map eks physical address: %x, %u\n", __func__,
ffffffffea802654:	b94063a3 	ldr	w3, [x29, #96]
ffffffffea802658:	2a1903e2 	mov	w2, w25
ffffffffea80265c:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802660:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802664:	9116e021 	add	x1, x1, #0x5b8
ffffffffea802668:	9118c000 	add	x0, x0, #0x630
ffffffffea80266c:	94003d0d 	bl	ffffffffea811aa0 <_dprintf>
		return ret;
ffffffffea802670:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea802674:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea802678:	2a1803e0 	mov	w0, w24
ffffffffea80267c:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea802680:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea802684:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea802688:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80268c:	d65f03c0 	ret
		dprintf(CRITICAL, "%s: ERROR: failed to retrieve eks info from kernel\n", __func__);
ffffffffea802690:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802694:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802698:	9116e021 	add	x1, x1, #0x5b8
ffffffffea80269c:	91174000 	add	x0, x0, #0x5d0
ffffffffea8026a0:	94003d00 	bl	ffffffffea811aa0 <_dprintf>
}
ffffffffea8026a4:	2a1803e0 	mov	w0, w24
ffffffffea8026a8:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea8026ac:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8026b0:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea8026b4:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea8026b8:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea8026bc:	128000f8 	mov	w24, #0xfffffff8            	// #-8
}
ffffffffea8026c0:	2a1803e0 	mov	w0, w24
ffffffffea8026c4:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8026c8:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea8026cc:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea8026d0:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea8026d4:	d65f03c0 	ret
		dprintf(CRITICAL, "%s: ERROR: ioctl called more than once\n", __func__);
ffffffffea8026d8:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8026dc:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8026e0:	9116e021 	add	x1, x1, #0x5b8
		return ERR_NOT_ALLOWED;
ffffffffea8026e4:	12800218 	mov	w24, #0xffffffef            	// #-17
		dprintf(CRITICAL, "%s: ERROR: ioctl called more than once\n", __func__);
ffffffffea8026e8:	91182000 	add	x0, x0, #0x608
ffffffffea8026ec:	94003ced 	bl	ffffffffea811aa0 <_dprintf>
		return ERR_NOT_ALLOWED;
ffffffffea8026f0:	17ffffd3 	b	ffffffffea80263c <ioctl_map_eks_to_user+0x164>
ffffffffea8026f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8026f8 <sys_std_platform_ioctl_partner>:
}

int32_t sys_std_platform_ioctl_partner(uint32_t fd, uint32_t cmd, user_addr_t user_ptr);

int32_t __WEAK sys_std_platform_ioctl_partner(uint32_t fd, uint32_t cmd, user_addr_t user_ptr)
{
ffffffffea8026f8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	dprintf(ALWAYS, "Unsupported IOCTL request: %d\n", cmd);
ffffffffea8026fc:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802700:	911a8000 	add	x0, x0, #0x6a0
{
ffffffffea802704:	910003fd 	mov	x29, sp
	dprintf(ALWAYS, "Unsupported IOCTL request: %d\n", cmd);
ffffffffea802708:	94003ce6 	bl	ffffffffea811aa0 <_dprintf>
	return ERR_NOT_SUPPORTED;
}
ffffffffea80270c:	128002e0 	mov	w0, #0xffffffe8            	// #-24
ffffffffea802710:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea802714:	d65f03c0 	ret

ffffffffea802718 <sys_std_platform_ioctl>:

int32_t sys_std_platform_ioctl(uint32_t fd, uint32_t cmd, user_addr_t user_ptr)
{
ffffffffea802718:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	int32_t ret = 0;
	DEBUG_ASSERT( fd == 3 ); // sys_fd of ioctl

	switch ( cmd ) {
ffffffffea80271c:	52800023 	mov	w3, #0x1                   	// #1
ffffffffea802720:	72a40003 	movk	w3, #0x2000, lsl #16
ffffffffea802724:	6b03003f 	cmp	w1, w3
{
ffffffffea802728:	910003fd 	mov	x29, sp
	switch ( cmd ) {
ffffffffea80272c:	540003e1 	b.ne	ffffffffea8027a8 <sys_std_platform_ioctl+0x90>  // b.any
ffffffffea802730:	f9000bb3 	str	x19, [x29, #16]
ffffffffea802734:	2a0203f3 	mov	w19, w2
ffffffffea802738:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea80273c:	f9415800 	ldr	x0, [x0, #688]
ffffffffea802740:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea802744:	2a1303e1 	mov	w1, w19
ffffffffea802748:	94004774 	bl	ffffffffea814518 <uthread_is_valid_range>
		case IOCTL_MAP_EKS_TO_USER:

			if (!valid_address((vaddr_t)user_ptr,
ffffffffea80274c:	72001c1f 	tst	w0, #0xff
ffffffffea802750:	54000141 	b.ne	ffffffffea802778 <sys_std_platform_ioctl+0x60>  // b.any
					sizeof(ioctl_map_eks_params))) {
				dprintf(CRITICAL, "%s error: Invalid arguments\n",
ffffffffea802754:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802758:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80275c:	9119a021 	add	x1, x1, #0x668
ffffffffea802760:	911a0000 	add	x0, x0, #0x680
ffffffffea802764:	94003ccf 	bl	ffffffffea811aa0 <_dprintf>
						__func__);
				return ERR_INVALID_ARGS;
ffffffffea802768:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80276c:	128000e0 	mov	w0, #0xfffffff8            	// #-8

		default:
			ret = sys_std_platform_ioctl_partner(fd, cmd, user_ptr);
        }
	return ret;
}
ffffffffea802770:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea802774:	d65f03c0 	ret
			if (!platform_is_bootstrapping()) {
ffffffffea802778:	97fffe9e 	bl	ffffffffea8021f0 <platform_is_bootstrapping>
ffffffffea80277c:	72001c1f 	tst	w0, #0xff
ffffffffea802780:	540001a1 	b.ne	ffffffffea8027b4 <sys_std_platform_ioctl+0x9c>  // b.any
				dprintf(CRITICAL, "%s: ERROR: Not allowed after boot\n",
ffffffffea802784:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802788:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80278c:	9119a021 	add	x1, x1, #0x668
ffffffffea802790:	9108e000 	add	x0, x0, #0x238
ffffffffea802794:	94003cc3 	bl	ffffffffea811aa0 <_dprintf>
				return ERR_NOT_ALLOWED;
ffffffffea802798:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80279c:	12800200 	mov	w0, #0xffffffef            	// #-17
}
ffffffffea8027a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8027a4:	d65f03c0 	ret
			ret = sys_std_platform_ioctl_partner(fd, cmd, user_ptr);
ffffffffea8027a8:	97ffffd4 	bl	ffffffffea8026f8 <sys_std_platform_ioctl_partner>
}
ffffffffea8027ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8027b0:	d65f03c0 	ret
	return arch_copy_from_user(kdest, usrc, len);
ffffffffea8027b4:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea8027b8:	2a1303e1 	mov	w1, w19
ffffffffea8027bc:	910083a0 	add	x0, x29, #0x20
ffffffffea8027c0:	9400445e 	bl	ffffffffea813938 <arch_copy_from_user>
			return ioctl_map_eks_to_user(params);
ffffffffea8027c4:	a94207a0 	ldp	x0, x1, [x29, #32]
ffffffffea8027c8:	97ffff44 	bl	ffffffffea8024d8 <ioctl_map_eks_to_user>
ffffffffea8027cc:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea8027d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8027d4:	d65f03c0 	ret

ffffffffea8027d8 <trusty_hyp_check_guest_pa_valid>:
	(void) buf_pa_start;
	(void) buf_size;
	(void) guest;

	return NO_ERROR;
}
ffffffffea8027d8:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea8027dc:	d65f03c0 	ret

ffffffffea8027e0 <trusty_hyp_check_guest_access>:
{
	(void) guest;
	(void) peer;

	return NO_ERROR;
}
ffffffffea8027e0:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8027e4:	d65f03c0 	ret

ffffffffea8027e8 <arm64_context_switch>:
#include <arch/asm_macros.h>

/* void arm64_context_switch(vaddr_t *old_sp, vaddr_t new_sp); */
FUNCTION(arm64_context_switch)
    /* save old frame */
    push x28, x29
ffffffffea8027e8:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
    push x26, x27
ffffffffea8027ec:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
    push x24, x25
ffffffffea8027f0:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
    push x22, x23
ffffffffea8027f4:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
    push x20, x21
ffffffffea8027f8:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
    push x18, x19
ffffffffea8027fc:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
    str  x30, [sp,#-8]!
ffffffffea802800:	f81f8ffe 	str	x30, [sp, #-8]!

    /* save old sp */
    mov  x15, sp
ffffffffea802804:	910003ef 	mov	x15, sp
    str  x15, [x0]
ffffffffea802808:	f900000f 	str	x15, [x0]

    /* load new sp */
    mov  sp, x1
ffffffffea80280c:	9100003f 	mov	sp, x1

    /* restore new frame */
    ldr  x30, [sp], #8
ffffffffea802810:	f84087fe 	ldr	x30, [sp], #8
    pop  x18, x19
ffffffffea802814:	a8c14ff2 	ldp	x18, x19, [sp], #16
    pop  x20, x21
ffffffffea802818:	a8c157f4 	ldp	x20, x21, [sp], #16
    pop  x22, x23
ffffffffea80281c:	a8c15ff6 	ldp	x22, x23, [sp], #16
    pop  x24, x25
ffffffffea802820:	a8c167f8 	ldp	x24, x25, [sp], #16
    pop  x26, x27
ffffffffea802824:	a8c16ffa 	ldp	x26, x27, [sp], #16
    pop  x28, x29
ffffffffea802828:	a8c177fc 	ldp	x28, x29, [sp], #16

    ret
ffffffffea80282c:	d65f03c0 	ret

ffffffffea802830 <arm64_el3_to_el1>:

FUNCTION(arm64_el3_to_el1)
    /* set EL2 to 64bit */
    mrs x0, scr_el3
ffffffffea802830:	d53e1100 	mrs	x0, scr_el3
    orr x0, x0, #(1<<10)
ffffffffea802834:	b2760000 	orr	x0, x0, #0x400
    msr scr_el3, x0
ffffffffea802838:	d51e1100 	msr	scr_el3, x0

    /* set EL1 to 64bit */
    mov x0, #(1<<31)
ffffffffea80283c:	d2b00000 	mov	x0, #0x80000000            	// #2147483648
    msr hcr_el2, x0
ffffffffea802840:	d51c1100 	msr	hcr_el2, x0

    /* disable EL2 coprocessor traps */
    mov x0, #0x33ff
ffffffffea802844:	d2867fe0 	mov	x0, #0x33ff                	// #13311
    msr cptr_el2, x0
ffffffffea802848:	d51c1140 	msr	cptr_el2, x0

    /* disable EL1 FPU traps */
    mov x0, #(0b11<<20)
ffffffffea80284c:	d2a00600 	mov	x0, #0x300000              	// #3145728
    msr cpacr_el1, x0
ffffffffea802850:	d5181040 	msr	cpacr_el1, x0

    /* set up the EL1 bounce interrupt */
    mov x0, sp
ffffffffea802854:	910003e0 	mov	x0, sp
    msr sp_el1, x0
ffffffffea802858:	d51c4100 	msr	sp_el1, x0

    adr x0, .Ltarget
ffffffffea80285c:	10000100 	adr	x0, ffffffffea80287c <arm64_el3_to_el1+0x4c>
    msr elr_el3, x0
ffffffffea802860:	d51e4020 	msr	elr_el3, x0

    mov x0, #((0b1111 << 6) | (0b0101)) /* EL1h runlevel */
ffffffffea802864:	d28078a0 	mov	x0, #0x3c5                 	// #965
    msr spsr_el3, x0
ffffffffea802868:	d51e4000 	msr	spsr_el3, x0
    isb
ffffffffea80286c:	d5033fdf 	isb

    exception_return
ffffffffea802870:	d69f03e0 	eret
ffffffffea802874:	d503379f 	dsb	nsh
ffffffffea802878:	d5033fdf 	isb

.Ltarget:
    ret
ffffffffea80287c:	d65f03c0 	ret

ffffffffea802880 <arch_spin_trylock>:
#include <asm.h>

.text

FUNCTION(arch_spin_trylock)
	mov	x2, x0
ffffffffea802880:	aa0003e2 	mov	x2, x0
	mov	x1, #1
ffffffffea802884:	d2800021 	mov	x1, #0x1                   	// #1
	ldaxr	x0, [x2]
ffffffffea802888:	c85ffc40 	ldaxr	x0, [x2]
	cbnz	x0, 1f
ffffffffea80288c:	b5000040 	cbnz	x0, ffffffffea802894 <arch_spin_trylock+0x14>
	stxr	w0, x1, [x2]
ffffffffea802890:	c8007c41 	stxr	w0, x1, [x2]
1:
	ret
ffffffffea802894:	d65f03c0 	ret

ffffffffea802898 <arch_spin_lock>:

FUNCTION(arch_spin_lock)
	mov	x1, #1
ffffffffea802898:	d2800021 	mov	x1, #0x1                   	// #1
	sevl
ffffffffea80289c:	d50320bf 	sevl
1:
	wfe
ffffffffea8028a0:	d503205f 	wfe
	ldaxr	x2, [x0]
ffffffffea8028a4:	c85ffc02 	ldaxr	x2, [x0]
	cbnz	x2, 1b
ffffffffea8028a8:	b5ffffc2 	cbnz	x2, ffffffffea8028a0 <arch_spin_lock+0x8>
	stxr	w2, x1, [x0]
ffffffffea8028ac:	c8027c01 	stxr	w2, x1, [x0]
	cbnz	w2, 1b
ffffffffea8028b0:	35ffff82 	cbnz	w2, ffffffffea8028a0 <arch_spin_lock+0x8>
	ret
ffffffffea8028b4:	d65f03c0 	ret

ffffffffea8028b8 <arch_spin_unlock>:

FUNCTION(arch_spin_unlock)
	stlr	xzr, [x0]
ffffffffea8028b8:	c89ffc1f 	stlr	xzr, [x0]
	ret
ffffffffea8028bc:	d65f03c0 	ret

ffffffffea8028c0 <arch_clean_cache_range>:
    dsb     sy
.endm

    /* void arch_flush_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_cache_range)
    cache_range_op dc cvac         // clean cache to PoC by MVA
ffffffffea8028c0:	8b010002 	add	x2, x0, x1
ffffffffea8028c4:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea8028c8:	d50b7a23 	dc	cvac, x3
ffffffffea8028cc:	91008063 	add	x3, x3, #0x20
ffffffffea8028d0:	eb02007f 	cmp	x3, x2
ffffffffea8028d4:	54ffffa3 	b.cc	ffffffffea8028c8 <arch_clean_cache_range+0x8>  // b.lo, b.ul, b.last
ffffffffea8028d8:	d5033f9f 	dsb	sy
    ret
ffffffffea8028dc:	d65f03c0 	ret

ffffffffea8028e0 <arch_clean_invalidate_cache_range>:

    /* void arch_flush_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_invalidate_cache_range)
    cache_range_op dc civac        // clean & invalidate dcache to PoC by MVA
ffffffffea8028e0:	8b010002 	add	x2, x0, x1
ffffffffea8028e4:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea8028e8:	d50b7e23 	dc	civac, x3
ffffffffea8028ec:	91008063 	add	x3, x3, #0x20
ffffffffea8028f0:	eb02007f 	cmp	x3, x2
ffffffffea8028f4:	54ffffa3 	b.cc	ffffffffea8028e8 <arch_clean_invalidate_cache_range+0x8>  // b.lo, b.ul, b.last
ffffffffea8028f8:	d5033f9f 	dsb	sy
    ret
ffffffffea8028fc:	d65f03c0 	ret

ffffffffea802900 <arch_invalidate_cache_range>:

    /* void arch_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_invalidate_cache_range)
    cache_range_op dc ivac         // invalidate dcache to PoC by MVA
ffffffffea802900:	8b010002 	add	x2, x0, x1
ffffffffea802904:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea802908:	d5087623 	dc	ivac, x3
ffffffffea80290c:	91008063 	add	x3, x3, #0x20
ffffffffea802910:	eb02007f 	cmp	x3, x2
ffffffffea802914:	54ffffa3 	b.cc	ffffffffea802908 <arch_invalidate_cache_range+0x8>  // b.lo, b.ul, b.last
ffffffffea802918:	d5033f9f 	dsb	sy
    ret
ffffffffea80291c:	d65f03c0 	ret

    /* void arch_sync_cache_range(addr_t start, size_t len); */
FUNCTION(arch_sync_cache_range)
    cache_range_op dc cvau         // clean dcache to PoU by MVA
ffffffffea802920:	8b010002 	add	x2, x0, x1
ffffffffea802924:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea802928:	d50b7b23 	dc	cvau, x3
ffffffffea80292c:	91008063 	add	x3, x3, #0x20
ffffffffea802930:	eb02007f 	cmp	x3, x2
ffffffffea802934:	54ffffa3 	b.cc	ffffffffea802928 <arch_invalidate_cache_range+0x28>  // b.lo, b.ul, b.last
ffffffffea802938:	d5033f9f 	dsb	sy
    cache_range_op ic ivau         // invalidate icache to PoU by MVA
ffffffffea80293c:	8b010002 	add	x2, x0, x1
ffffffffea802940:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea802944:	d50b7523 	ic	ivau, x3
ffffffffea802948:	91008063 	add	x3, x3, #0x20
ffffffffea80294c:	eb02007f 	cmp	x3, x2
ffffffffea802950:	54ffffa3 	b.cc	ffffffffea802944 <arch_invalidate_cache_range+0x44>  // b.lo, b.ul, b.last
ffffffffea802954:	d5033f9f 	dsb	sy
    ret
ffffffffea802958:	d65f03c0 	ret

ffffffffea80295c <arch_clean_dcache>:

FUNCTION(arch_clean_dcache)
    mrs x9, clidr_el1
ffffffffea80295c:	d5390029 	mrs	x9, clidr_el1
    lsl x3, x0, #LEVEL_SHIFT
ffffffffea802960:	d37ff803 	lsl	x3, x0, #1
    sub x10, x3, #2
ffffffffea802964:	d100086a 	sub	x10, x3, #0x2
    mov x0, #DCCSW
ffffffffea802968:	d2800040 	mov	x0, #0x2                   	// #2
    bl do_dcsw_op
ffffffffea80296c:	94000002 	bl	ffffffffea802974 <do_dcsw_op>
    ret
ffffffffea802970:	d65f03c0 	ret

ffffffffea802974 <do_dcsw_op>:
	mov	x10, xzr
	b	do_dcsw_op
	.endm

FUNCTION(do_dcsw_op)
	cbz	x3, exit
ffffffffea802974:	b40003c3 	cbz	x3, ffffffffea8029ec <exit>
	adr	x14, dcsw_loop_table	// compute inner loop address
ffffffffea802978:	100003ce 	adr	x14, ffffffffea8029f0 <dcsw_loop_table>
	add	x14, x14, x0, lsl #5	// inner loop is 8x32-bit instructions
ffffffffea80297c:	8b0015ce 	add	x14, x14, x0, lsl #5
	mov	x0, x9
ffffffffea802980:	aa0903e0 	mov	x0, x9
	mov	w8, #1
ffffffffea802984:	52800028 	mov	w8, #0x1                   	// #1

ffffffffea802988 <loop1>:
loop1:
	add	x2, x10, x10, lsr #1	// work out 3x current cache level
ffffffffea802988:	8b4a0542 	add	x2, x10, x10, lsr #1
	lsr	x1, x0, x2		// extract cache type bits from clidr
ffffffffea80298c:	9ac22401 	lsr	x1, x0, x2
	and	x1, x1, #7		// mask the bits for current cache only
ffffffffea802990:	92400821 	and	x1, x1, #0x7
	cmp	x1, #2			// see what cache we have at this level
ffffffffea802994:	f100083f 	cmp	x1, #0x2
	b.lt	level_done		// nothing to do if no cache or icache
ffffffffea802998:	540001eb 	b.lt	ffffffffea8029d4 <level_done>  // b.tstop

	msr	csselr_el1, x10		// select current cache level in csselr
ffffffffea80299c:	d51a000a 	msr	csselr_el1, x10
	isb				// isb to sych the new cssr&csidr
ffffffffea8029a0:	d5033fdf 	isb
	mrs	x1, ccsidr_el1		// read the new ccsidr
ffffffffea8029a4:	d5390001 	mrs	x1, ccsidr_el1
	and	x2, x1, #7		// extract the length of the cache lines
ffffffffea8029a8:	92400822 	and	x2, x1, #0x7
	add	x2, x2, #4		// add 4 (line length offset)
ffffffffea8029ac:	91001042 	add	x2, x2, #0x4
	ubfx	x4, x1, #3, #10		// maximum way number
ffffffffea8029b0:	d3433024 	ubfx	x4, x1, #3, #10
	clz	w5, w4			// bit position of way size increment
ffffffffea8029b4:	5ac01085 	clz	w5, w4
	lsl	w9, w4, w5		// w9 = aligned max way number
ffffffffea8029b8:	1ac52089 	lsl	w9, w4, w5
	lsl	w16, w8, w5		// w16 = way number loop decrement
ffffffffea8029bc:	1ac52110 	lsl	w16, w8, w5
	orr	w9, w10, w9		// w9 = combine way and cache number
ffffffffea8029c0:	2a090149 	orr	w9, w10, w9
	ubfx	w6, w1, #13, #15	// w6 = max set number
ffffffffea8029c4:	530d6c26 	ubfx	w6, w1, #13, #15
	lsl	w17, w8, w2		// w17 = set number loop decrement
ffffffffea8029c8:	1ac22111 	lsl	w17, w8, w2
	dsb	sy			// barrier before we start this level
ffffffffea8029cc:	d5033f9f 	dsb	sy
	br	x14			// jump to DC operation specific loop
ffffffffea8029d0:	d61f01c0 	br	x14

ffffffffea8029d4 <level_done>:

	b	level_done
	.endm

level_done:
	add	x10, x10, #2		// increment cache number
ffffffffea8029d4:	9100094a 	add	x10, x10, #0x2
	cmp	x3, x10
ffffffffea8029d8:	eb0a007f 	cmp	x3, x10
	b.gt    loop1
ffffffffea8029dc:	54fffd6c 	b.gt	ffffffffea802988 <loop1>
	msr	csselr_el1, xzr		// select cache level 0 in csselr
ffffffffea8029e0:	d51a001f 	msr	csselr_el1, xzr
	dsb	sy			// barrier to complete final cache operation
ffffffffea8029e4:	d5033f9f 	dsb	sy
	isb
ffffffffea8029e8:	d5033fdf 	isb

ffffffffea8029ec <exit>:
exit:
	ret
ffffffffea8029ec:	d65f03c0 	ret

ffffffffea8029f0 <dcsw_loop_table>:

dcsw_loop_table:
	dcsw_loop isw
ffffffffea8029f0:	1ac220c7 	lsl	w7, w6, w2

ffffffffea8029f4 <loop3_isw>:
ffffffffea8029f4:	2a07012b 	orr	w11, w9, w7
ffffffffea8029f8:	d508764b 	dc	isw, x11
ffffffffea8029fc:	6b1100e7 	subs	w7, w7, w17
ffffffffea802a00:	54ffffaa 	b.ge	ffffffffea8029f4 <loop3_isw>  // b.tcont
ffffffffea802a04:	eb100129 	subs	x9, x9, x16
ffffffffea802a08:	54ffff4a 	b.ge	ffffffffea8029f0 <dcsw_loop_table>  // b.tcont
ffffffffea802a0c:	17fffff2 	b	ffffffffea8029d4 <level_done>

ffffffffea802a10 <loop2_cisw>:
	dcsw_loop cisw
ffffffffea802a10:	1ac220c7 	lsl	w7, w6, w2

ffffffffea802a14 <loop3_cisw>:
ffffffffea802a14:	2a07012b 	orr	w11, w9, w7
ffffffffea802a18:	d5087e4b 	dc	cisw, x11
ffffffffea802a1c:	6b1100e7 	subs	w7, w7, w17
ffffffffea802a20:	54ffffaa 	b.ge	ffffffffea802a14 <loop3_cisw>  // b.tcont
ffffffffea802a24:	eb100129 	subs	x9, x9, x16
ffffffffea802a28:	54ffff4a 	b.ge	ffffffffea802a10 <loop2_cisw>  // b.tcont
ffffffffea802a2c:	17ffffea 	b	ffffffffea8029d4 <level_done>

ffffffffea802a30 <loop2_csw>:
	dcsw_loop csw
ffffffffea802a30:	1ac220c7 	lsl	w7, w6, w2

ffffffffea802a34 <loop3_csw>:
ffffffffea802a34:	2a07012b 	orr	w11, w9, w7
ffffffffea802a38:	d5087a4b 	dc	csw, x11
ffffffffea802a3c:	6b1100e7 	subs	w7, w7, w17
ffffffffea802a40:	54ffffaa 	b.ge	ffffffffea802a34 <loop3_csw>  // b.tcont
ffffffffea802a44:	eb100129 	subs	x9, x9, x16
ffffffffea802a48:	54ffff4a 	b.ge	ffffffffea802a30 <loop2_csw>  // b.tcont
ffffffffea802a4c:	17ffffe2 	b	ffffffffea8029d4 <level_done>

ffffffffea802a50 <dcsw_op_louis>:


FUNCTION(dcsw_op_louis)
	dcsw_op #LOUIS_SHIFT, #CLIDR_FIELD_WIDTH, #LEVEL_SHIFT
ffffffffea802a50:	d5390029 	mrs	x9, clidr_el1
ffffffffea802a54:	d3555d23 	ubfx	x3, x9, #21, #3
ffffffffea802a58:	d37ff863 	lsl	x3, x3, #1
ffffffffea802a5c:	aa1f03ea 	mov	x10, xzr
ffffffffea802a60:	17ffffc5 	b	ffffffffea802974 <do_dcsw_op>

ffffffffea802a64 <dcsw_op_all>:


FUNCTION(dcsw_op_all)
	dcsw_op #LOC_SHIFT, #CLIDR_FIELD_WIDTH, #LEVEL_SHIFT
ffffffffea802a64:	d5390029 	mrs	x9, clidr_el1
ffffffffea802a68:	d3586923 	ubfx	x3, x9, #24, #3
ffffffffea802a6c:	d37ff863 	lsl	x3, x3, #1
ffffffffea802a70:	aa1f03ea 	mov	x10, xzr
ffffffffea802a74:	17ffffc0 	b	ffffffffea802974 <do_dcsw_op>

ffffffffea802a78 <dcsw_op_level1>:
	 * The main function, do_dcsw_op requires:
	 * x0: The operation type (0-2), as defined in arch.h
	 * ---------------------------------------------------------------
	 */
FUNCTION(dcsw_op_level1)
	dcsw_op_level #(1 << LEVEL_SHIFT)
ffffffffea802a78:	d5390029 	mrs	x9, clidr_el1
ffffffffea802a7c:	d2800043 	mov	x3, #0x2                   	// #2
ffffffffea802a80:	d100086a 	sub	x10, x3, #0x2
ffffffffea802a84:	17ffffbc 	b	ffffffffea802974 <do_dcsw_op>

ffffffffea802a88 <dcsw_op_level2>:
	 * The main function, do_dcsw_op requires:
	 * x0: The operation type (0-2), as defined in arch.h
	 * ---------------------------------------------------------------
	 */
FUNCTION(dcsw_op_level2)
	dcsw_op_level #(2 << LEVEL_SHIFT)
ffffffffea802a88:	d5390029 	mrs	x9, clidr_el1
ffffffffea802a8c:	d2800083 	mov	x3, #0x4                   	// #4
ffffffffea802a90:	d100086a 	sub	x10, x3, #0x2
ffffffffea802a94:	17ffffb8 	b	ffffffffea802974 <do_dcsw_op>

ffffffffea802a98 <dcsw_op_level3>:
	 * The main function, do_dcsw_op requires:
	 * x0: The operation type (0-2), as defined in arch.h
	 * ---------------------------------------------------------------
	 */
FUNCTION(dcsw_op_level3)
	dcsw_op_level #(3 << LEVEL_SHIFT)
ffffffffea802a98:	d5390029 	mrs	x9, clidr_el1
ffffffffea802a9c:	d28000c3 	mov	x3, #0x6                   	// #6
ffffffffea802aa0:	d100086a 	sub	x10, x3, #0x2
ffffffffea802aa4:	17ffffb4 	b	ffffffffea802974 <do_dcsw_op>

ffffffffea802aa8 <arch_curr_cpu_num>:
#endif
/* NV: Move this function from arch\arm64\include\arch\arch_ops.h */
inline uint arch_curr_cpu_num(void)
{
    /* NV: Define plat_arch_curr_cpu_num in platform code */
    return plat_arch_curr_cpu_num();
ffffffffea802aa8:	17fffbde 	b	ffffffffea801a20 <plat_arch_curr_cpu_num>
ffffffffea802aac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802ab0 <arch_early_init>:
}

static void arm64_cpu_early_init(void)
{
    /* set the vector base */
    ARM64_WRITE_SYSREG(VBAR_EL1, (uint64_t)&arm64_exception_base);
ffffffffea802ab0:	f0ffffe0 	adrp	x0, ffffffffea801000 <arm64_exception_base>
ffffffffea802ab4:	91000000 	add	x0, x0, #0x0
ffffffffea802ab8:	d518c000 	msr	vbar_el1, x0
ffffffffea802abc:	d5033fdf 	isb

    /* switch to EL1 */
    unsigned int current_el = ARM64_READ_SYSREG(CURRENTEL) >> 2;
ffffffffea802ac0:	d5384240 	mrs	x0, currentel
ffffffffea802ac4:	d342fc00 	lsr	x0, x0, #2
    if (current_el > 1) {
ffffffffea802ac8:	7100041f 	cmp	w0, #0x1
ffffffffea802acc:	540000e9 	b.ls	ffffffffea802ae8 <arch_early_init+0x38>  // b.plast

    arch_enable_fiqs();
}

void arch_early_init(void)
{
ffffffffea802ad0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea802ad4:	910003fd 	mov	x29, sp
        arm64_el3_to_el1();
ffffffffea802ad8:	97ffff56 	bl	ffffffffea802830 <arm64_el3_to_el1>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea802adc:	d50341ff 	msr	daifclr, #0x1
    arm64_cpu_early_init();
    platform_init_mmu_mappings();
}
ffffffffea802ae0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    platform_init_mmu_mappings();
ffffffffea802ae4:	17fffc11 	b	ffffffffea801b28 <platform_init_mmu_mappings>
ffffffffea802ae8:	d50341ff 	msr	daifclr, #0x1
ffffffffea802aec:	17fffc0f 	b	ffffffffea801b28 <platform_init_mmu_mappings>

ffffffffea802af0 <arch_init>:

void arch_init(void)
{
ffffffffea802af0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802af4:	910003fd 	mov	x29, sp
ffffffffea802af8:	f9000bf3 	str	x19, [sp, #16]
    arch_mp_init_percpu();
ffffffffea802afc:	940001e9 	bl	ffffffffea8032a0 <arch_mp_init_percpu>

#if WITH_SMP
    LTRACEF("midr_el1 0x%llx\n", ARM64_READ_SYSREG(midr_el1));

    secondaries_to_init = SMP_MAX_CPUS - 1; /* TODO: get count from somewhere else, or add cpus as they boot */
ffffffffea802b00:	d00002a0 	adrp	x0, ffffffffea858000 <__bss_start>
ffffffffea802b04:	528000e1 	mov	w1, #0x7                   	// #7
}

/* interrupts should already be disabled */
static inline void spin_unlock(spin_lock_t *lock)
{
    arch_spin_unlock(lock);
ffffffffea802b08:	f00000b3 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea802b0c:	9106a273 	add	x19, x19, #0x1a8
ffffffffea802b10:	b9002401 	str	w1, [x0, #36]

    lk_init_secondary_cpus(secondaries_to_init);
ffffffffea802b14:	b9402400 	ldr	w0, [x0, #36]
ffffffffea802b18:	94000566 	bl	ffffffffea8040b0 <lk_init_secondary_cpus>
ffffffffea802b1c:	aa1303e0 	mov	x0, x19
ffffffffea802b20:	97ffff66 	bl	ffffffffea8028b8 <arch_spin_unlock>

    /* release the secondary cpus */
    spin_unlock(&arm_boot_cpu_lock);

    /* flush the release of the lock, since the secondary cpus are running without cache on */
    arch_clean_cache_range((addr_t)&arm_boot_cpu_lock, sizeof(arm_boot_cpu_lock));
ffffffffea802b24:	aa1303e0 	mov	x0, x19
#endif
}
ffffffffea802b28:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802b2c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    arch_clean_cache_range((addr_t)&arm_boot_cpu_lock, sizeof(arm_boot_cpu_lock));
ffffffffea802b30:	d2800101 	mov	x1, #0x8                   	// #8
ffffffffea802b34:	17ffff63 	b	ffffffffea8028c0 <arch_clean_cache_range>

ffffffffea802b38 <arch_idle>:
{
}

void arch_idle(void)
{
    __asm__ volatile("wfi");
ffffffffea802b38:	d503207f 	wfi
}
ffffffffea802b3c:	d65f03c0 	ret

ffffffffea802b40 <arm64_secondary_entry>:
    PANIC_UNIMPLEMENTED;
}

#if WITH_SMP
void arm64_secondary_entry(ulong asm_cpu_num)
{
ffffffffea802b40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802b44:	910003fd 	mov	x29, sp
ffffffffea802b48:	f9000bf3 	str	x19, [sp, #16]
ffffffffea802b4c:	aa0003f3 	mov	x19, x0
    return plat_arch_curr_cpu_num();
ffffffffea802b50:	97fffbb4 	bl	ffffffffea801a20 <plat_arch_curr_cpu_num>
    uint cpu = arch_curr_cpu_num();
    if (cpu != asm_cpu_num)
ffffffffea802b54:	eb20427f 	cmp	x19, w0, uxtw
ffffffffea802b58:	54000080 	b.eq	ffffffffea802b68 <arm64_secondary_entry+0x28>  // b.none
    /* we're done, tell the main cpu we're up */
    atomic_add(&secondaries_to_init, -1);
    __asm__ volatile("sev");

    lk_secondary_cpu_entry();
}
ffffffffea802b5c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802b60:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea802b64:	d65f03c0 	ret
    ARM64_WRITE_SYSREG(VBAR_EL1, (uint64_t)&arm64_exception_base);
ffffffffea802b68:	f0ffffe0 	adrp	x0, ffffffffea801000 <arm64_exception_base>
ffffffffea802b6c:	91000000 	add	x0, x0, #0x0
ffffffffea802b70:	d518c000 	msr	vbar_el1, x0
ffffffffea802b74:	d5033fdf 	isb
    unsigned int current_el = ARM64_READ_SYSREG(CURRENTEL) >> 2;
ffffffffea802b78:	d5384240 	mrs	x0, currentel
ffffffffea802b7c:	d342fc00 	lsr	x0, x0, #2
    if (current_el > 1) {
ffffffffea802b80:	7100041f 	cmp	w0, #0x1
ffffffffea802b84:	54000049 	b.ls	ffffffffea802b8c <arm64_secondary_entry+0x4c>  // b.plast
        arm64_el3_to_el1();
ffffffffea802b88:	97ffff2a 	bl	ffffffffea802830 <arm64_el3_to_el1>
ffffffffea802b8c:	d50341ff 	msr	daifclr, #0x1
    arch_spin_lock(lock);
ffffffffea802b90:	f00000b3 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea802b94:	9106a273 	add	x19, x19, #0x1a8
ffffffffea802b98:	aa1303e0 	mov	x0, x19
ffffffffea802b9c:	97ffff3f 	bl	ffffffffea802898 <arch_spin_lock>
    arch_spin_unlock(lock);
ffffffffea802ba0:	aa1303e0 	mov	x0, x19
ffffffffea802ba4:	97ffff45 	bl	ffffffffea8028b8 <arch_spin_unlock>
    lk_init_level(LK_INIT_FLAG_SECONDARY_CPUS, LK_INIT_LEVEL_EARLIEST, LK_INIT_LEVEL_THREADING - 1);
ffffffffea802ba8:	52800040 	mov	w0, #0x2                   	// #2
ffffffffea802bac:	12bfff22 	mov	w2, #0x6ffff               	// #458751
ffffffffea802bb0:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea802bb4:	9400041d 	bl	ffffffffea803c28 <lk_init_level>
    arch_mp_init_percpu();
ffffffffea802bb8:	940001ba 	bl	ffffffffea8032a0 <arch_mp_init_percpu>
    return __atomic_fetch_add(ptr, val, __ATOMIC_RELAXED);
ffffffffea802bbc:	d00002a0 	adrp	x0, ffffffffea858000 <__bss_start>
ffffffffea802bc0:	91009000 	add	x0, x0, #0x24
ffffffffea802bc4:	885f7c01 	ldxr	w1, [x0]
ffffffffea802bc8:	51000421 	sub	w1, w1, #0x1
ffffffffea802bcc:	88027c01 	stxr	w2, w1, [x0]
ffffffffea802bd0:	35ffffa2 	cbnz	w2, ffffffffea802bc4 <arm64_secondary_entry+0x84>
    __asm__ volatile("sev");
ffffffffea802bd4:	d503209f 	sev
}
ffffffffea802bd8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802bdc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    lk_secondary_cpu_entry();
ffffffffea802be0:	14000518 	b	ffffffffea804040 <lk_secondary_cpu_entry>
ffffffffea802be4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802be8 <dump_iframe>:
#if HAVE_STACKTRACE
void arm64_print_stacktrace(struct arm64_iframe_long *iframe);
#endif

static void dump_iframe(const struct arm64_iframe_long *iframe)
{
ffffffffea802be8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802bec:	910003fd 	mov	x29, sp
ffffffffea802bf0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea802bf4:	aa0003f3 	mov	x19, x0
    printf("iframe %p:\n", iframe);
ffffffffea802bf8:	aa1303e1 	mov	x1, x19
ffffffffea802bfc:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802c00:	911e0000 	add	x0, x0, #0x780
ffffffffea802c04:	9400418b 	bl	ffffffffea813230 <_printf>
    printf("x0  0x%16llx x1  0x%16llx x2  0x%16llx x3  0x%16llx\n", iframe->r[0], iframe->r[1], iframe->r[2], iframe->r[3]);
ffffffffea802c08:	a9400a61 	ldp	x1, x2, [x19]
ffffffffea802c0c:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802c10:	a9411263 	ldp	x3, x4, [x19, #16]
ffffffffea802c14:	911e4000 	add	x0, x0, #0x790
ffffffffea802c18:	94004186 	bl	ffffffffea813230 <_printf>
    printf("x4  0x%16llx x5  0x%16llx x6  0x%16llx x7  0x%16llx\n", iframe->r[4], iframe->r[5], iframe->r[6], iframe->r[7]);
ffffffffea802c1c:	a9420a61 	ldp	x1, x2, [x19, #32]
ffffffffea802c20:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802c24:	a9431263 	ldp	x3, x4, [x19, #48]
ffffffffea802c28:	911f2000 	add	x0, x0, #0x7c8
ffffffffea802c2c:	94004181 	bl	ffffffffea813230 <_printf>
    printf("x8  0x%16llx x9  0x%16llx x10 0x%16llx x11 0x%16llx\n", iframe->r[8], iframe->r[9], iframe->r[10], iframe->r[11]);
ffffffffea802c30:	a9440a61 	ldp	x1, x2, [x19, #64]
ffffffffea802c34:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802c38:	a9451263 	ldp	x3, x4, [x19, #80]
ffffffffea802c3c:	91200000 	add	x0, x0, #0x800
ffffffffea802c40:	9400417c 	bl	ffffffffea813230 <_printf>
    printf("x12 0x%16llx x13 0x%16llx x14 0x%16llx x15 0x%16llx\n", iframe->r[12], iframe->r[13], iframe->r[14], iframe->r[15]);
ffffffffea802c44:	a9460a61 	ldp	x1, x2, [x19, #96]
ffffffffea802c48:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802c4c:	a9471263 	ldp	x3, x4, [x19, #112]
ffffffffea802c50:	9120e000 	add	x0, x0, #0x838
ffffffffea802c54:	94004177 	bl	ffffffffea813230 <_printf>
    printf("x16 0x%16llx x17 0x%16llx x18 0x%16llx x19 0x%16llx\n", iframe->r[16], iframe->r[17], iframe->r[18], iframe->r[19]);
ffffffffea802c58:	a9480a61 	ldp	x1, x2, [x19, #128]
ffffffffea802c5c:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802c60:	a9491263 	ldp	x3, x4, [x19, #144]
ffffffffea802c64:	9121c000 	add	x0, x0, #0x870
ffffffffea802c68:	94004172 	bl	ffffffffea813230 <_printf>
    printf("x20 0x%16llx x21 0x%16llx x22 0x%16llx x23 0x%16llx\n", iframe->r[20], iframe->r[21], iframe->r[22], iframe->r[23]);
ffffffffea802c6c:	a94a0a61 	ldp	x1, x2, [x19, #160]
ffffffffea802c70:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802c74:	a94b1263 	ldp	x3, x4, [x19, #176]
ffffffffea802c78:	9122a000 	add	x0, x0, #0x8a8
ffffffffea802c7c:	9400416d 	bl	ffffffffea813230 <_printf>
    printf("x24 0x%16llx x25 0x%16llx x26 0x%16llx x27 0x%16llx\n", iframe->r[24], iframe->r[25], iframe->r[26], iframe->r[27]);
ffffffffea802c80:	a94c0a61 	ldp	x1, x2, [x19, #192]
ffffffffea802c84:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802c88:	a94d1263 	ldp	x3, x4, [x19, #208]
ffffffffea802c8c:	91238000 	add	x0, x0, #0x8e0
ffffffffea802c90:	94004168 	bl	ffffffffea813230 <_printf>
    printf("x28 0x%16llx x29 0x%16llx lr  0x%16llx sp  0x%16llx\n", iframe->r[28], iframe->r[29], iframe->r[30], iframe->r[31]);
ffffffffea802c94:	a94e0a61 	ldp	x1, x2, [x19, #224]
ffffffffea802c98:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802c9c:	a94f1263 	ldp	x3, x4, [x19, #240]
ffffffffea802ca0:	91246000 	add	x0, x0, #0x918
ffffffffea802ca4:	94004163 	bl	ffffffffea813230 <_printf>
    printf("elr 0x%16llx\n", iframe->elr);
ffffffffea802ca8:	f9408261 	ldr	x1, [x19, #256]
ffffffffea802cac:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802cb0:	91254000 	add	x0, x0, #0x950
ffffffffea802cb4:	9400415f 	bl	ffffffffea813230 <_printf>
    printf("spsr 0x%16llx\n", iframe->spsr);
ffffffffea802cb8:	f9408661 	ldr	x1, [x19, #264]
ffffffffea802cbc:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
}
ffffffffea802cc0:	f9400bf3 	ldr	x19, [sp, #16]
    printf("spsr 0x%16llx\n", iframe->spsr);
ffffffffea802cc4:	91258000 	add	x0, x0, #0x960
}
ffffffffea802cc8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    printf("spsr 0x%16llx\n", iframe->spsr);
ffffffffea802ccc:	14004159 	b	ffffffffea813230 <_printf>

ffffffffea802cd0 <arm64_sync_exception>:

void arm64_sync_exception(struct arm64_iframe_long *iframe)
{
ffffffffea802cd0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea802cd4:	910003fd 	mov	x29, sp
ffffffffea802cd8:	a90153f3 	stp	x19, x20, [sp, #16]
    struct fault_handler_table_entry *fault_handler;
    uint32_t esr = ARM64_READ_SYSREG(esr_el1);
ffffffffea802cdc:	d5385214 	mrs	x20, esr_el1
    uint32_t ec = esr >> 26;
ffffffffea802ce0:	531a7e93 	lsr	w19, w20, #26
    uint32_t il = (esr >> 25) & 0x1;
    uint32_t iss = esr & ((1<<24) - 1);

#ifdef WITH_LIB_SYSCALL
    if (ec == 0x15 || ec == 0x11) { // syscall 64/32
ffffffffea802ce4:	121d7a61 	and	w1, w19, #0xfffffffb
ffffffffea802ce8:	7100443f 	cmp	w1, #0x11
ffffffffea802cec:	540008c0 	b.eq	ffffffffea802e04 <arm64_sync_exception+0x134>  // b.none
        return;
    }
#endif

    /* floating point */
    if (ec == 0x07) {
ffffffffea802cf0:	71001e7f 	cmp	w19, #0x7
ffffffffea802cf4:	54000940 	b.eq	ffffffffea802e1c <arm64_sync_exception+0x14c>  // b.none
ffffffffea802cf8:	f90013b5 	str	x21, [x29, #32]
        arm64_fpu_exception(iframe);
        return;
    }

    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
ffffffffea802cfc:	f0000082 	adrp	x2, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802d00:	f9001bb7 	str	x23, [x29, #48]
ffffffffea802d04:	9100c042 	add	x2, x2, #0x30
ffffffffea802d08:	aa0003f5 	mov	x21, x0
ffffffffea802d0c:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802d10:	91000004 	add	x4, x0, #0x0
ffffffffea802d14:	aa1e03f7 	mov	x23, x30
ffffffffea802d18:	eb02009f 	cmp	x4, x2
ffffffffea802d1c:	54000242 	b.cs	ffffffffea802d64 <arm64_sync_exception+0x94>  // b.hs, b.nlast
        if (fault_handler->pc == iframe->elr) {
ffffffffea802d20:	f9400000 	ldr	x0, [x0]
ffffffffea802d24:	f94082a5 	ldr	x5, [x21, #256]
ffffffffea802d28:	eb0000bf 	cmp	x5, x0
ffffffffea802d2c:	540005e0 	b.eq	ffffffffea802de8 <arm64_sync_exception+0x118>  // b.none
ffffffffea802d30:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802d34:	91003c42 	add	x2, x2, #0xf
ffffffffea802d38:	91004000 	add	x0, x0, #0x10
ffffffffea802d3c:	cb000042 	sub	x2, x2, x0
ffffffffea802d40:	927cec42 	and	x2, x2, #0xfffffffffffffff0
ffffffffea802d44:	8b000042 	add	x2, x2, x0
ffffffffea802d48:	14000004 	b	ffffffffea802d58 <arm64_sync_exception+0x88>
ffffffffea802d4c:	f8410403 	ldr	x3, [x0], #16
ffffffffea802d50:	eb05007f 	cmp	x3, x5
ffffffffea802d54:	540004a0 	b.eq	ffffffffea802de8 <arm64_sync_exception+0x118>  // b.none
    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
ffffffffea802d58:	aa0003e4 	mov	x4, x0
ffffffffea802d5c:	eb02001f 	cmp	x0, x2
ffffffffea802d60:	54ffff61 	b.ne	ffffffffea802d4c <arm64_sync_exception+0x7c>  // b.any
ffffffffea802d64:	f90017b6 	str	x22, [x29, #40]
            iframe->elr = fault_handler->fault_handler;
            return;
        }
    }

    printf("sync_exception\n");
ffffffffea802d68:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>

#if HAVE_STACKTRACE
    printf("-----------------------------------------------\n");
ffffffffea802d6c:	f0000096 	adrp	x22, ffffffffea815000 <__fault_handler_table_start>
    printf("sync_exception\n");
ffffffffea802d70:	911b8000 	add	x0, x0, #0x6e0
    printf("-----------------------------------------------\n");
ffffffffea802d74:	911bc2d6 	add	x22, x22, #0x6f0
    printf("sync_exception\n");
ffffffffea802d78:	9400412e 	bl	ffffffffea813230 <_printf>
    printf("-----------------------------------------------\n");
ffffffffea802d7c:	aa1603e0 	mov	x0, x22
ffffffffea802d80:	9400412c 	bl	ffffffffea813230 <_printf>
    printf(" [Stack Trace]\n\n");
ffffffffea802d84:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802d88:	911ca000 	add	x0, x0, #0x728
ffffffffea802d8c:	94004129 	bl	ffffffffea813230 <_printf>
    arm64_print_stacktrace(iframe);
ffffffffea802d90:	aa1503e0 	mov	x0, x21
ffffffffea802d94:	94000129 	bl	ffffffffea803238 <arm64_print_stacktrace>
    printf("-----------------------------------------------\n");
ffffffffea802d98:	aa1603e0 	mov	x0, x22
ffffffffea802d9c:	94004125 	bl	ffffffffea813230 <_printf>
#endif

    dump_iframe(iframe);
ffffffffea802da0:	aa1503e0 	mov	x0, x21
ffffffffea802da4:	97ffff91 	bl	ffffffffea802be8 <dump_iframe>

    printf("ESR 0x%x: ec 0x%x, il 0x%x, iss 0x%x\n", esr, ec, il, iss);
ffffffffea802da8:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802dac:	12005e84 	and	w4, w20, #0xffffff
ffffffffea802db0:	53196683 	ubfx	w3, w20, #25, #1
ffffffffea802db4:	2a1303e2 	mov	w2, w19
ffffffffea802db8:	2a1403e1 	mov	w1, w20
ffffffffea802dbc:	911d0000 	add	x0, x0, #0x740
ffffffffea802dc0:	9400411c 	bl	ffffffffea813230 <_printf>

    if (ec == 0x15) { // syscall
ffffffffea802dc4:	7100567f 	cmp	w19, #0x15
ffffffffea802dc8:	54000301 	b.ne	ffffffffea802e28 <arm64_sync_exception+0x158>  // b.any
        printf("syscall\n");
ffffffffea802dcc:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea802dd0:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
        return;
    }

    panic("die\n");
}
ffffffffea802dd4:	a94153f3 	ldp	x19, x20, [sp, #16]
        printf("syscall\n");
ffffffffea802dd8:	911da000 	add	x0, x0, #0x768
ffffffffea802ddc:	f9401bb7 	ldr	x23, [x29, #48]
}
ffffffffea802de0:	a8c47bfd 	ldp	x29, x30, [sp], #64
        printf("syscall\n");
ffffffffea802de4:	14004113 	b	ffffffffea813230 <_printf>
            iframe->elr = fault_handler->fault_handler;
ffffffffea802de8:	f9400480 	ldr	x0, [x4, #8]
            return;
ffffffffea802dec:	f9401bb7 	ldr	x23, [x29, #48]
            iframe->elr = fault_handler->fault_handler;
ffffffffea802df0:	f90082a0 	str	x0, [x21, #256]
}
ffffffffea802df4:	a94153f3 	ldp	x19, x20, [sp, #16]
            return;
ffffffffea802df8:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea802dfc:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea802e00:	d65f03c0 	ret
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea802e04:	d50341ff 	msr	daifclr, #0x1
        arm64_syscall(iframe);
ffffffffea802e08:	940042a2 	bl	ffffffffea813890 <arm64_syscall>
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea802e0c:	d50341df 	msr	daifset, #0x1
}
ffffffffea802e10:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea802e14:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea802e18:	d65f03c0 	ret
ffffffffea802e1c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea802e20:	a8c47bfd 	ldp	x29, x30, [sp], #64
        arm64_fpu_exception(iframe);
ffffffffea802e24:	14000029 	b	ffffffffea802ec8 <arm64_fpu_exception>
    panic("die\n");
ffffffffea802e28:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802e2c:	aa1703e0 	mov	x0, x23
ffffffffea802e30:	911de021 	add	x1, x1, #0x778
ffffffffea802e34:	94003b99 	bl	ffffffffea811c98 <_panic>

ffffffffea802e38 <arm64_invalid_exception>:

void arm64_invalid_exception(struct arm64_iframe_long *iframe, unsigned int which)
{
ffffffffea802e38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802e3c:	910003fd 	mov	x29, sp
ffffffffea802e40:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea802e44:	aa1e03f3 	mov	x19, x30
ffffffffea802e48:	aa0003f4 	mov	x20, x0
    printf("invalid exception, which 0x%x\n", which);
ffffffffea802e4c:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802e50:	911b0000 	add	x0, x0, #0x6c0
ffffffffea802e54:	940040f7 	bl	ffffffffea813230 <_printf>
    dump_iframe(iframe);
ffffffffea802e58:	aa1403e0 	mov	x0, x20
ffffffffea802e5c:	97ffff63 	bl	ffffffffea802be8 <dump_iframe>

    panic("die\n");
ffffffffea802e60:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802e64:	aa1303e0 	mov	x0, x19
ffffffffea802e68:	911de021 	add	x1, x1, #0x778
ffffffffea802e6c:	94003b8b 	bl	ffffffffea811c98 <_panic>

ffffffffea802e70 <arm64_fpu_save_state>:
                     :: "r"(fpstate), "r"(fpstate->fpcr), "r"(fpstate->fpsr));
}

void arm64_fpu_save_state(struct thread *t)
{
    struct fpstate *fpstate = &t->arch.fpstate;
ffffffffea802e70:	91016000 	add	x0, x0, #0x58
    __asm__ volatile("stp     q0, q1, [%2, #(0 * 32)]\n"
ffffffffea802e74:	ad000400 	stp	q0, q1, [x0]
ffffffffea802e78:	ad010c02 	stp	q2, q3, [x0, #32]
ffffffffea802e7c:	ad021404 	stp	q4, q5, [x0, #64]
ffffffffea802e80:	ad031c06 	stp	q6, q7, [x0, #96]
ffffffffea802e84:	ad042408 	stp	q8, q9, [x0, #128]
ffffffffea802e88:	ad052c0a 	stp	q10, q11, [x0, #160]
ffffffffea802e8c:	ad06340c 	stp	q12, q13, [x0, #192]
ffffffffea802e90:	ad073c0e 	stp	q14, q15, [x0, #224]
ffffffffea802e94:	ad084410 	stp	q16, q17, [x0, #256]
ffffffffea802e98:	ad094c12 	stp	q18, q19, [x0, #288]
ffffffffea802e9c:	ad0a5414 	stp	q20, q21, [x0, #320]
ffffffffea802ea0:	ad0b5c16 	stp	q22, q23, [x0, #352]
ffffffffea802ea4:	ad0c6418 	stp	q24, q25, [x0, #384]
ffffffffea802ea8:	ad0d6c1a 	stp	q26, q27, [x0, #416]
ffffffffea802eac:	ad0e741c 	stp	q28, q29, [x0, #448]
ffffffffea802eb0:	ad0f7c1e 	stp	q30, q31, [x0, #480]
ffffffffea802eb4:	d53b4402 	mrs	x2, fpcr
ffffffffea802eb8:	d53b4421 	mrs	x1, fpsr
ffffffffea802ebc:	b9020002 	str	w2, [x0, #512]
ffffffffea802ec0:	b9020401 	str	w1, [x0, #516]
                     "mrs     %1, fpsr\n"
                     : "=r"(fpstate->fpcr), "=r"(fpstate->fpsr)
                     : "r"(fpstate));

    LTRACEF("thread %s, fpcr %x, fpsr %x\n", t->name, fpstate->fpcr, fpstate->fpsr);
}
ffffffffea802ec4:	d65f03c0 	ret

ffffffffea802ec8 <arm64_fpu_exception>:

void arm64_fpu_exception(struct arm64_iframe_long *iframe)
{
    uint32_t cpacr = ARM64_READ_SYSREG(cpacr_el1);
ffffffffea802ec8:	d5381040 	mrs	x0, cpacr_el1
    if (((cpacr >> 20) & 3) != 3) {
ffffffffea802ecc:	53145401 	ubfx	w1, w0, #20, #2
ffffffffea802ed0:	71000c3f 	cmp	w1, #0x3
ffffffffea802ed4:	54000540 	b.eq	ffffffffea802f7c <arm64_fpu_exception+0xb4>  // b.none
{
ffffffffea802ed8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
        cpacr |= 3 << 20;
ffffffffea802edc:	320c0400 	orr	w0, w0, #0x300000
{
ffffffffea802ee0:	910003fd 	mov	x29, sp
ffffffffea802ee4:	f9000bf3 	str	x19, [sp, #16]
        ARM64_WRITE_SYSREG(cpacr_el1, cpacr);
ffffffffea802ee8:	d5181040 	msr	cpacr_el1, x0
ffffffffea802eec:	d5033fdf 	isb
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea802ef0:	d538d093 	mrs	x19, tpidr_el1
    uint cpu = arch_curr_cpu_num();
ffffffffea802ef4:	97fffeed 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
    if (fpstate == current_fpstate[cpu] && fpstate->current_cpu == cpu) {
ffffffffea802ef8:	2a0003e3 	mov	w3, w0
ffffffffea802efc:	d00002a2 	adrp	x2, ffffffffea858000 <__bss_start>
ffffffffea802f00:	9100a044 	add	x4, x2, #0x28
    struct fpstate *fpstate = &t->arch.fpstate;
ffffffffea802f04:	91016261 	add	x1, x19, #0x58
    if (fpstate == current_fpstate[cpu] && fpstate->current_cpu == cpu) {
ffffffffea802f08:	f8637884 	ldr	x4, [x4, x3, lsl #3]
ffffffffea802f0c:	eb04003f 	cmp	x1, x4
ffffffffea802f10:	54000380 	b.eq	ffffffffea802f80 <arm64_fpu_exception+0xb8>  // b.none
    current_fpstate[cpu] = fpstate;
ffffffffea802f14:	9100a042 	add	x2, x2, #0x28
    fpstate->current_cpu = cpu;
ffffffffea802f18:	b9020820 	str	w0, [x1, #520]
    __asm__ volatile("ldp     q0, q1, [%0, #(0 * 32)]\n"
ffffffffea802f1c:	b9420424 	ldr	w4, [x1, #516]
ffffffffea802f20:	b9420020 	ldr	w0, [x1, #512]
    current_fpstate[cpu] = fpstate;
ffffffffea802f24:	f8237841 	str	x1, [x2, x3, lsl #3]
    __asm__ volatile("ldp     q0, q1, [%0, #(0 * 32)]\n"
ffffffffea802f28:	ad400420 	ldp	q0, q1, [x1]
ffffffffea802f2c:	ad410c22 	ldp	q2, q3, [x1, #32]
ffffffffea802f30:	ad421424 	ldp	q4, q5, [x1, #64]
ffffffffea802f34:	ad431c26 	ldp	q6, q7, [x1, #96]
ffffffffea802f38:	ad442428 	ldp	q8, q9, [x1, #128]
ffffffffea802f3c:	ad452c2a 	ldp	q10, q11, [x1, #160]
ffffffffea802f40:	ad46342c 	ldp	q12, q13, [x1, #192]
ffffffffea802f44:	ad473c2e 	ldp	q14, q15, [x1, #224]
ffffffffea802f48:	ad484430 	ldp	q16, q17, [x1, #256]
ffffffffea802f4c:	ad494c32 	ldp	q18, q19, [x1, #288]
ffffffffea802f50:	ad4a5434 	ldp	q20, q21, [x1, #320]
ffffffffea802f54:	ad4b5c36 	ldp	q22, q23, [x1, #352]
ffffffffea802f58:	ad4c6438 	ldp	q24, q25, [x1, #384]
ffffffffea802f5c:	ad4d6c3a 	ldp	q26, q27, [x1, #416]
ffffffffea802f60:	ad4e743c 	ldp	q28, q29, [x1, #448]
ffffffffea802f64:	ad4f7c3e 	ldp	q30, q31, [x1, #480]
ffffffffea802f68:	d51b4400 	msr	fpcr, x0
ffffffffea802f6c:	d51b4424 	msr	fpsr, x4
        arm64_fpu_load_state(get_current_thread());
        return;
    }
}
ffffffffea802f70:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802f74:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea802f78:	d65f03c0 	ret
ffffffffea802f7c:	d65f03c0 	ret
    if (fpstate == current_fpstate[cpu] && fpstate->current_cpu == cpu) {
ffffffffea802f80:	b9420824 	ldr	w4, [x1, #520]
ffffffffea802f84:	6b04001f 	cmp	w0, w4
ffffffffea802f88:	54fffc61 	b.ne	ffffffffea802f14 <arm64_fpu_exception+0x4c>  // b.any
ffffffffea802f8c:	17fffff9 	b	ffffffffea802f70 <arm64_fpu_exception+0xa8>

ffffffffea802f90 <initial_thread_func>:

extern void arm64_context_switch(addr_t *old_sp, addr_t new_sp);

static void initial_thread_func(void) __NO_RETURN;
static void initial_thread_func(void)
{
ffffffffea802f90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802f94:	910003fd 	mov	x29, sp
ffffffffea802f98:	f9000bf3 	str	x19, [sp, #16]
ffffffffea802f9c:	d538d093 	mrs	x19, tpidr_el1
ffffffffea802fa0:	f00002c0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea802fa4:	912ea000 	add	x0, x0, #0xba8
ffffffffea802fa8:	97fffe44 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea802fac:	d50342ff 	msr	daifclr, #0x2

    /* release the thread lock that was implicitly held across the reschedule */
    spin_unlock(&thread_lock);
    arch_enable_ints();

    ret = current_thread->entry(current_thread->arg);
ffffffffea802fb0:	f9413e61 	ldr	x1, [x19, #632]
ffffffffea802fb4:	f9414260 	ldr	x0, [x19, #640]
ffffffffea802fb8:	d63f0020 	blr	x1

    LTRACEF("initial_thread_func: thread %p exiting with %d\n", current_thread, ret);

    thread_exit(ret);
ffffffffea802fbc:	94000ffb 	bl	ffffffffea806fa8 <thread_exit>

ffffffffea802fc0 <arch_thread_initialize>:
}

void arch_thread_initialize(thread_t *t)
{
ffffffffea802fc0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!

    struct context_switch_frame *frame = (struct context_switch_frame *)(stack_top);
    frame--;

    // fill it in
    memset(frame, 0, sizeof(*frame));
ffffffffea802fc4:	d2800d02 	mov	x2, #0x68                  	// #104
ffffffffea802fc8:	52800001 	mov	w1, #0x0                   	// #0
{
ffffffffea802fcc:	910003fd 	mov	x29, sp
ffffffffea802fd0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea802fd4:	aa0003f4 	mov	x20, x0
    vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
ffffffffea802fd8:	f9413413 	ldr	x19, [x0, #616]
ffffffffea802fdc:	f9413800 	ldr	x0, [x0, #624]
{
ffffffffea802fe0:	f90013f5 	str	x21, [sp, #32]
    vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
ffffffffea802fe4:	8b000273 	add	x19, x19, x0
    stack_top = ROUNDDOWN(stack_top, 16);
ffffffffea802fe8:	927cee73 	and	x19, x19, #0xfffffffffffffff0
    frame--;
ffffffffea802fec:	d101a275 	sub	x21, x19, #0x68
    memset(frame, 0, sizeof(*frame));
ffffffffea802ff0:	aa1503e0 	mov	x0, x21
ffffffffea802ff4:	9400418b 	bl	ffffffffea813620 <memset>
    frame->lr = (vaddr_t)&initial_thread_func;
ffffffffea802ff8:	90000000 	adrp	x0, ffffffffea802000 <platform_dputc+0x30>
ffffffffea802ffc:	913e4000 	add	x0, x0, #0xf90
ffffffffea803000:	f8198260 	stur	x0, [x19, #-104]

    /* Set this to enable OS stack traces on exceptions */
    extern vaddr_t arch_stack_trace_epoch;
    arch_stack_trace_epoch = (vaddr_t)&initial_thread_func;
ffffffffea803004:	f00002c1 	adrp	x1, ffffffffea85e000 <rb_data+0x18>

    // set the stack pointer
    t->arch.sp = (vaddr_t)frame;
ffffffffea803008:	f9002a95 	str	x21, [x20, #80]
    arch_stack_trace_epoch = (vaddr_t)&initial_thread_func;
ffffffffea80300c:	f9001c20 	str	x0, [x1, #56]
}
ffffffffea803010:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea803014:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea803018:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80301c:	d65f03c0 	ret

ffffffffea803020 <arch_context_switch>:

void arch_context_switch(thread_t *oldthread, thread_t *newthread)
{
ffffffffea803020:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea803024:	910003fd 	mov	x29, sp
ffffffffea803028:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80302c:	aa0003f4 	mov	x20, x0
ffffffffea803030:	f90013f5 	str	x21, [sp, #32]
ffffffffea803034:	aa0103f5 	mov	x21, x1
void arm64_fpu_exception(struct arm64_iframe_long *iframe);
void arm64_fpu_save_state(struct thread *thread);

static inline void arm64_fpu_pre_context_switch(struct thread *thread)
{
    uint32_t cpacr = ARM64_READ_SYSREG(cpacr_el1);
ffffffffea803038:	d5381053 	mrs	x19, cpacr_el1
    if ((cpacr >> 20) & 3) {
ffffffffea80303c:	720c067f 	tst	w19, #0x300000
ffffffffea803040:	540000a0 	b.eq	ffffffffea803054 <arch_context_switch+0x34>  // b.none
        arm64_fpu_save_state(thread);
ffffffffea803044:	97ffff8b 	bl	ffffffffea802e70 <arm64_fpu_save_state>
        cpacr &= ~(3 << 20);
ffffffffea803048:	120a7673 	and	w19, w19, #0xffcfffff
        ARM64_WRITE_SYSREG(cpacr_el1, cpacr);
ffffffffea80304c:	d5181053 	msr	cpacr_el1, x19
ffffffffea803050:	d5033fdf 	isb
    LTRACEF("old %p (%s), new %p (%s)\n", oldthread, oldthread->name, newthread, newthread->name);
    arm64_fpu_pre_context_switch(oldthread);
#if WITH_SMP
    DSB; /* broadcast tlb operations in case the thread moves to another cpu */
ffffffffea803054:	d5033f9f 	dsb	sy
#endif
    arm64_context_switch(&oldthread->arch.sp, newthread->arch.sp);
ffffffffea803058:	91014280 	add	x0, x20, #0x50
ffffffffea80305c:	f9402aa1 	ldr	x1, [x21, #80]
}
ffffffffea803060:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea803064:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea803068:	a8c37bfd 	ldp	x29, x30, [sp], #48
    arm64_context_switch(&oldthread->arch.sp, newthread->arch.sp);
ffffffffea80306c:	17fffddf 	b	ffffffffea8027e8 <arm64_context_switch>

ffffffffea803070 <arch_print_stacktrace>:
/* For arm64 this is set in arm64/thread.c to the initial_thread_func function */
vaddr_t arch_stack_trace_epoch;
extern vaddr_t arch_stack_trace_epoch;

void arch_print_stacktrace(vaddr_t p_fp, vaddr_t p_sp, vaddr_t p_pc)
{
ffffffffea803070:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea803074:	910003fd 	mov	x29, sp
ffffffffea803078:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80307c:	aa0003f3 	mov	x19, x0
ffffffffea803080:	f90023f9 	str	x25, [sp, #64]
ffffffffea803084:	aa0203f4 	mov	x20, x2
ffffffffea803088:	aa0103f9 	mov	x25, x1
	uint32_t tcount = 0U;
	vaddr_t fp = p_fp;
	vaddr_t sp = p_sp;
	vaddr_t pc = p_pc;

	if (0UL == pc) {
ffffffffea80308c:	b40006c2 	cbz	x2, ffffffffea803164 <arch_print_stacktrace+0xf4>
		dprintf(CRITICAL, "[ PC value zero => potential corruption, tracing anyway ]\n");
	}

	if ((0UL == fp) || (0UL == sp)) {
ffffffffea803090:	f100027f 	cmp	x19, #0x0
ffffffffea803094:	fa401b24 	ccmp	x25, #0x0, #0x4, ne  // ne = any
ffffffffea803098:	54000720 	b.eq	ffffffffea80317c <arch_print_stacktrace+0x10c>  // b.none
ffffffffea80309c:	f9001fb8 	str	x24, [x29, #56]
		dprintf(CRITICAL, "[ => fp=0x%016lX, sp=0x%016lX, pc=0x%016lX ]\n",
			fp, sp, pc);
		goto fail;
	}

	if (0UL == arch_stack_trace_epoch) {
ffffffffea8030a0:	f00002d8 	adrp	x24, ffffffffea85e000 <rb_data+0x18>
ffffffffea8030a4:	f9401f00 	ldr	x0, [x24, #56]
ffffffffea8030a8:	b4000500 	cbz	x0, ffffffffea803148 <arch_print_stacktrace+0xd8>
ffffffffea8030ac:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8030b0:	aa1903f6 	mov	x22, x25
ffffffffea8030b4:	f9001bb7 	str	x23, [x29, #48]
	uint32_t tcount = 0U;
ffffffffea8030b8:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea8030bc:	d0000097 	adrp	x23, ffffffffea815000 <__fault_handler_table_start>
		dprintf(CRITICAL, "[ Stack tracing disabled ]\n");
		goto fail;
	}

	while (tcount < MAX_STACK_TRACE_DEPTH) {
		dprintf(CRITICAL, "[ %02u ] => pc: 0x%016lX  sp: 0x%016lX\n", tcount, pc, sp);
ffffffffea8030c0:	912862f7 	add	x23, x23, #0xa18
ffffffffea8030c4:	1400000f 	b	ffffffffea803100 <arch_print_stacktrace+0x90>
		}

		/* ARM-64 stack && frame pointers aligned to 64 bit
		 * boundary, detect simple stack corruption
		 */
		if ((fp & 0xfUL) != 0UL) {
ffffffffea8030c8:	f2400e7f 	tst	x19, #0xf
ffffffffea8030cc:	54000801 	b.ne	ffffffffea8031cc <arch_print_stacktrace+0x15c>  // b.any
		}

		/* Native Arm-64 instructions are aligned to 32 bit word
		 * boundary, detect simple PC corruption
		 */
		if ((pc & 0x3UL) != 0UL) {
ffffffffea8030d0:	f240069f 	tst	x20, #0x3
ffffffffea8030d4:	54000861 	b.ne	ffffffffea8031e0 <arch_print_stacktrace+0x170>  // b.any
				      pc);
			break;
		}

		sp = fp;
		pc = *REG64(fp+8UL);
ffffffffea8030d8:	f9400660 	ldr	x0, [x19, #8]
ffffffffea8030dc:	aa1303f6 	mov	x22, x19

		if (pc != arch_stack_trace_epoch) {
			pc = pc - 4UL; /* LR = PC at function-call + 4 */
		}

		fp = *REG64(fp);
ffffffffea8030e0:	f9400262 	ldr	x2, [x19]
		if (pc != arch_stack_trace_epoch) {
ffffffffea8030e4:	f9401f14 	ldr	x20, [x24, #56]
			pc = pc - 4UL; /* LR = PC at function-call + 4 */
ffffffffea8030e8:	d1001001 	sub	x1, x0, #0x4
ffffffffea8030ec:	eb14001f 	cmp	x0, x20
ffffffffea8030f0:	9a941034 	csel	x20, x1, x20, ne  // ne = any
	while (tcount < MAX_STACK_TRACE_DEPTH) {
ffffffffea8030f4:	7100cabf 	cmp	w21, #0x32
ffffffffea8030f8:	540007e0 	b.eq	ffffffffea8031f4 <arch_print_stacktrace+0x184>  // b.none
		fp = *REG64(fp);
ffffffffea8030fc:	aa0203f3 	mov	x19, x2
		dprintf(CRITICAL, "[ %02u ] => pc: 0x%016lX  sp: 0x%016lX\n", tcount, pc, sp);
ffffffffea803100:	2a1503e1 	mov	w1, w21
ffffffffea803104:	aa1603e3 	mov	x3, x22
ffffffffea803108:	aa1403e2 	mov	x2, x20
ffffffffea80310c:	aa1703e0 	mov	x0, x23
ffffffffea803110:	94003a64 	bl	ffffffffea811aa0 <_dprintf>
		tcount++;
ffffffffea803114:	110006b5 	add	w21, w21, #0x1
		if ((0UL == fp) || (fp < sp)) {
ffffffffea803118:	f100027f 	cmp	x19, #0x0
ffffffffea80311c:	fa5312c2 	ccmp	x22, x19, #0x2, ne  // ne = any
ffffffffea803120:	54fffd49 	b.ls	ffffffffea8030c8 <arch_print_stacktrace+0x58>  // b.plast
	}

	stack_size = sp - p_sp;
ffffffffea803124:	cb1902c1 	sub	x1, x22, x25
	if (stack_size >= (uint64_t)ARCH_DEFAULT_STACK_SIZE) {
ffffffffea803128:	f13ffc3f 	cmp	x1, #0xfff
ffffffffea80312c:	54000408 	b.hi	ffffffffea8031ac <arch_print_stacktrace+0x13c>  // b.pmore
ffffffffea803130:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea803134:	a94363b7 	ldp	x23, x24, [x29, #48]
		dprintf(CRITICAL, "\n [ Configured stack trace depth (%u) exeeded -- trace terminated ]\n",
			      MAX_STACK_TRACE_DEPTH);
	}
fail:
	return;
}
ffffffffea803138:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80313c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea803140:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea803144:	d65f03c0 	ret
ffffffffea803148:	a94153f3 	ldp	x19, x20, [sp, #16]
		dprintf(CRITICAL, "[ Stack tracing disabled ]\n");
ffffffffea80314c:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803150:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea803154:	912d2000 	add	x0, x0, #0xb48
}
ffffffffea803158:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80315c:	a8c57bfd 	ldp	x29, x30, [sp], #80
		dprintf(CRITICAL, "[ Stack tracing disabled ]\n");
ffffffffea803160:	14003a50 	b	ffffffffea811aa0 <_dprintf>
		dprintf(CRITICAL, "[ PC value zero => potential corruption, tracing anyway ]\n");
ffffffffea803164:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803168:	9125c000 	add	x0, x0, #0x970
ffffffffea80316c:	94003a4d 	bl	ffffffffea811aa0 <_dprintf>
	if ((0UL == fp) || (0UL == sp)) {
ffffffffea803170:	f100027f 	cmp	x19, #0x0
ffffffffea803174:	fa401b24 	ccmp	x25, #0x0, #0x4, ne  // ne = any
ffffffffea803178:	54fff921 	b.ne	ffffffffea80309c <arch_print_stacktrace+0x2c>  // b.any
		dprintf(CRITICAL, "[ No frame/stack register values => no stack traces ]\n");
ffffffffea80317c:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803180:	9126c000 	add	x0, x0, #0x9b0
ffffffffea803184:	94003a47 	bl	ffffffffea811aa0 <_dprintf>
		dprintf(CRITICAL, "[ => fp=0x%016lX, sp=0x%016lX, pc=0x%016lX ]\n",
ffffffffea803188:	aa1403e3 	mov	x3, x20
ffffffffea80318c:	aa1903e2 	mov	x2, x25
ffffffffea803190:	aa1303e1 	mov	x1, x19
}
ffffffffea803194:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea803198:	a94153f3 	ldp	x19, x20, [sp, #16]
		dprintf(CRITICAL, "[ => fp=0x%016lX, sp=0x%016lX, pc=0x%016lX ]\n",
ffffffffea80319c:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
}
ffffffffea8031a0:	a8c57bfd 	ldp	x29, x30, [sp], #80
		dprintf(CRITICAL, "[ => fp=0x%016lX, sp=0x%016lX, pc=0x%016lX ]\n",
ffffffffea8031a4:	9127a000 	add	x0, x0, #0x9e8
ffffffffea8031a8:	14003a3e 	b	ffffffffea811aa0 <_dprintf>
		dprintf(CRITICAL, "\n Using %llu bytes - STACK OVERFLOW !!!\n",
ffffffffea8031ac:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8031b0:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8031b4:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea8031b8:	912b4000 	add	x0, x0, #0xad0
}
ffffffffea8031bc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8031c0:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea8031c4:	a8c57bfd 	ldp	x29, x30, [sp], #80
		dprintf(CRITICAL, "\n Using %llu bytes - STACK OVERFLOW !!!\n",
ffffffffea8031c8:	14003a36 	b	ffffffffea811aa0 <_dprintf>
			dprintf(CRITICAL,
ffffffffea8031cc:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8031d0:	aa1303e1 	mov	x1, x19
ffffffffea8031d4:	91290000 	add	x0, x0, #0xa40
ffffffffea8031d8:	94003a32 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea8031dc:	17ffffd2 	b	ffffffffea803124 <arch_print_stacktrace+0xb4>
			dprintf(CRITICAL,
ffffffffea8031e0:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8031e4:	aa1403e1 	mov	x1, x20
ffffffffea8031e8:	912a2000 	add	x0, x0, #0xa88
ffffffffea8031ec:	94003a2d 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea8031f0:	17ffffcd 	b	ffffffffea803124 <arch_print_stacktrace+0xb4>
	stack_size = sp - p_sp;
ffffffffea8031f4:	cb190261 	sub	x1, x19, x25
	if (stack_size >= (uint64_t)ARCH_DEFAULT_STACK_SIZE) {
ffffffffea8031f8:	f13ffc3f 	cmp	x1, #0xfff
ffffffffea8031fc:	54000148 	b.hi	ffffffffea803224 <arch_print_stacktrace+0x1b4>  // b.pmore
		dprintf(CRITICAL, "\n [ Configured stack trace depth (%u) exeeded -- trace terminated ]\n",
ffffffffea803200:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea803204:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803208:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80320c:	52800641 	mov	w1, #0x32                  	// #50
}
ffffffffea803210:	a94153f3 	ldp	x19, x20, [sp, #16]
		dprintf(CRITICAL, "\n [ Configured stack trace depth (%u) exeeded -- trace terminated ]\n",
ffffffffea803214:	912c0000 	add	x0, x0, #0xb00
}
ffffffffea803218:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80321c:	a8c57bfd 	ldp	x29, x30, [sp], #80
		dprintf(CRITICAL, "\n [ Configured stack trace depth (%u) exeeded -- trace terminated ]\n",
ffffffffea803220:	14003a20 	b	ffffffffea811aa0 <_dprintf>
		dprintf(CRITICAL, "\n Using %llu bytes - STACK OVERFLOW !!!\n",
ffffffffea803224:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803228:	912b4000 	add	x0, x0, #0xad0
ffffffffea80322c:	94003a1d 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea803230:	17fffff4 	b	ffffffffea803200 <arch_print_stacktrace+0x190>
ffffffffea803234:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803238 <arm64_print_stacktrace>:

/* Stack tracer for the Arm-64 exception handler */
void arm64_print_stacktrace(const struct arm64_iframe_long *iframe)
{
ffffffffea803238:	aa0003e2 	mov	x2, x0
	vaddr_t fp, sp, pc;

	if (NULL == iframe) {
ffffffffea80323c:	b4000080 	cbz	x0, ffffffffea80324c <arm64_print_stacktrace+0x14>

	fp = iframe->r[29];
	sp = iframe->r[31];
	pc = iframe->elr;

	arch_print_stacktrace(fp, sp, pc);
ffffffffea803240:	f9407400 	ldr	x0, [x0, #232]
ffffffffea803244:	a94f8841 	ldp	x1, x2, [x2, #248]
ffffffffea803248:	17ffff8a 	b	ffffffffea803070 <arch_print_stacktrace>
		dprintf(CRITICAL, "[ No iframe, no stack traces ]\n");
ffffffffea80324c:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803250:	912da000 	add	x0, x0, #0xb68
ffffffffea803254:	14003a13 	b	ffffffffea811aa0 <_dprintf>

ffffffffea803258 <arm_ipi_generic_handler>:
enum handler_return arm_ipi_generic_handler(void *arg)
{
    LTRACEF("cpu %u, arg %p\n", arch_curr_cpu_num(), arg);

    return INT_NO_RESCHEDULE;
}
ffffffffea803258:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80325c:	d65f03c0 	ret

ffffffffea803260 <arm_ipi_reschedule_handler>:

enum handler_return arm_ipi_reschedule_handler(void *arg)
{
    LTRACEF("cpu %u, arg %p\n", arch_curr_cpu_num(), arg);

    return mp_mbx_reschedule_irq();
ffffffffea803260:	14001104 	b	ffffffffea807670 <mp_mbx_reschedule_irq>
ffffffffea803264:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803268 <arch_mp_send_ipi>:
    if (target != 0) {
ffffffffea803268:	72001c02 	ands	w2, w0, #0xff
ffffffffea80326c:	54000061 	b.ne	ffffffffea803278 <arch_mp_send_ipi+0x10>  // b.any
}
ffffffffea803270:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea803274:	d65f03c0 	ret
{
ffffffffea803278:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80327c:	2a0103e0 	mov	w0, w1
        arm_gic_sgi(gic_ipi_num, ARM_GIC_SGI_FLAG_NS, target);
ffffffffea803280:	11003800 	add	w0, w0, #0xe
ffffffffea803284:	52800081 	mov	w1, #0x4                   	// #4
{
ffffffffea803288:	910003fd 	mov	x29, sp
        arm_gic_sgi(gic_ipi_num, ARM_GIC_SGI_FLAG_NS, target);
ffffffffea80328c:	94000553 	bl	ffffffffea8047d8 <arm_gic_sgi>
}
ffffffffea803290:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea803294:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea803298:	d65f03c0 	ret
ffffffffea80329c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8032a0 <arch_mp_init_percpu>:
}

void arch_mp_init_percpu(void)
{
ffffffffea8032a0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    register_int_handler(MP_IPI_GENERIC + GIC_IPI_BASE, &arm_ipi_generic_handler, 0);
ffffffffea8032a4:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea8032a8:	528001c0 	mov	w0, #0xe                   	// #14
ffffffffea8032ac:	90000001 	adrp	x1, ffffffffea803000 <arch_thread_initialize+0x40>
{
ffffffffea8032b0:	910003fd 	mov	x29, sp
    register_int_handler(MP_IPI_GENERIC + GIC_IPI_BASE, &arm_ipi_generic_handler, 0);
ffffffffea8032b4:	91096021 	add	x1, x1, #0x258
ffffffffea8032b8:	94000488 	bl	ffffffffea8044d8 <register_int_handler>
    register_int_handler(MP_IPI_RESCHEDULE + GIC_IPI_BASE, &arm_ipi_reschedule_handler, 0);

    //unmask_interrupt(MP_IPI_GENERIC);
    //unmask_interrupt(MP_IPI_RESCHEDULE);
}
ffffffffea8032bc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    register_int_handler(MP_IPI_RESCHEDULE + GIC_IPI_BASE, &arm_ipi_reschedule_handler, 0);
ffffffffea8032c0:	90000001 	adrp	x1, ffffffffea803000 <arch_thread_initialize+0x40>
ffffffffea8032c4:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea8032c8:	91098021 	add	x1, x1, #0x260
ffffffffea8032cc:	528001e0 	mov	w0, #0xf                   	// #15
ffffffffea8032d0:	14000482 	b	ffffffffea8044d8 <register_int_handler>
ffffffffea8032d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8032d8 <arm64_mmu_unmap_pt>:
    paddr_t page_table_paddr;

    LTRACEF("vaddr 0x%lx, vaddr_rel 0x%lx, size 0x%lx, index shift %d, page_size_shift %d, page_table %p\n",
            vaddr, vaddr_rel, size, index_shift, page_size_shift, page_table);

    while (size) {
ffffffffea8032d8:	b4000762 	cbz	x2, ffffffffea8033c4 <arm64_mmu_unmap_pt+0xec>
{
ffffffffea8032dc:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    int count = 1U << (page_size_shift - 3);
ffffffffea8032e0:	51000c8b 	sub	w11, w4, #0x3
        block_size = 1UL << index_shift;
ffffffffea8032e4:	d2800028 	mov	x8, #0x1                   	// #1
ffffffffea8032e8:	2a0603ea 	mov	w10, w6
    int count = 1U << (page_size_shift - 3);
ffffffffea8032ec:	1acb210b 	lsl	w11, w8, w11
{
ffffffffea8032f0:	910003fd 	mov	x29, sp
ffffffffea8032f4:	5100056c 	sub	w12, w11, #0x1
ffffffffea8032f8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8032fc:	aa0003f6 	mov	x22, x0
ffffffffea803300:	d2800100 	mov	x0, #0x8                   	// #8
ffffffffea803304:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea803308:	a90363f7 	stp	x23, x24, [sp, #48]
        block_size = 1UL << index_shift;
ffffffffea80330c:	9ac32107 	lsl	x7, x8, x3
{
ffffffffea803310:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea803314:	aa0103f5 	mov	x21, x1
ffffffffea803318:	a90573fb 	stp	x27, x28, [sp, #80]
ffffffffea80331c:	aa1e03f9 	mov	x25, x30
ffffffffea803320:	aa0203f4 	mov	x20, x2
ffffffffea803324:	2a0303f7 	mov	w23, w3
ffffffffea803328:	2a0403fb 	mov	w27, w4
ffffffffea80332c:	aa0503fc 	mov	x28, x5
        block_mask = block_size - 1;
ffffffffea803330:	d10004e9 	sub	x9, x7, #0x1
            page_table[index] = MMU_PTE_DESCRIPTOR_INVALID;
            CF;
            if (asid == MMU_ARM64_GLOBAL_ASID)
                ARM64_TLBI(vaae1is, vaddr >> 12);
            else
                ARM64_TLBI(vae1is, vaddr >> 12 | (vaddr_t)asid << 48);
ffffffffea803334:	d3503d4d 	lsl	x13, x10, #48
ffffffffea803338:	8b2c4c0c 	add	x12, x0, w12, uxtw #3
    size_t size = 1U << page_size_shift;
ffffffffea80333c:	1ac42108 	lsl	w8, w8, w4
        vaddr_rem = vaddr_rel & block_mask;
ffffffffea803340:	8a15013a 	and	x26, x9, x21
        index = vaddr_rel >> index_shift;
ffffffffea803344:	9ad726b8 	lsr	x24, x21, x23
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea803348:	cb1a00f3 	sub	x19, x7, x26
ffffffffea80334c:	eb14027f 	cmp	x19, x20
        pte = page_table[index];
ffffffffea803350:	f8787b80 	ldr	x0, [x28, x24, lsl #3]
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea803354:	9a949273 	csel	x19, x19, x20, ls  // ls = plast
        if (index_shift > page_size_shift &&
ffffffffea803358:	6b1b02ff 	cmp	w23, w27
ffffffffea80335c:	54000089 	b.ls	ffffffffea80336c <arm64_mmu_unmap_pt+0x94>  // b.plast
            (pte & MMU_PTE_DESCRIPTOR_MASK) == MMU_PTE_L012_DESCRIPTOR_TABLE) {
ffffffffea803360:	92400403 	and	x3, x0, #0x3
        if (index_shift > page_size_shift &&
ffffffffea803364:	f1000c7f 	cmp	x3, #0x3
ffffffffea803368:	54000300 	b.eq	ffffffffea8033c8 <arm64_mmu_unmap_pt+0xf0>  // b.none
        } else if (pte) {
ffffffffea80336c:	b4000100 	cbz	x0, ffffffffea80338c <arm64_mmu_unmap_pt+0xb4>
            page_table[index] = MMU_PTE_DESCRIPTOR_INVALID;
ffffffffea803370:	f8387b9f 	str	xzr, [x28, x24, lsl #3]
            CF;
ffffffffea803374:	d34cfec0 	lsr	x0, x22, #12
            if (asid == MMU_ARM64_GLOBAL_ASID)
ffffffffea803378:	3100055f 	cmn	w10, #0x1
ffffffffea80337c:	540001e0 	b.eq	ffffffffea8033b8 <arm64_mmu_unmap_pt+0xe0>  // b.none
                ARM64_TLBI(vae1is, vaddr >> 12 | (vaddr_t)asid << 48);
ffffffffea803380:	aa0001a0 	orr	x0, x13, x0
ffffffffea803384:	d5088320 	tlbi	vae1is, x0
ffffffffea803388:	d5033fdf 	isb
        } else {
            LTRACEF("pte %p[0x%lx] already clear\n", page_table, index);
        }
        vaddr += chunk_size;
ffffffffea80338c:	8b1302d6 	add	x22, x22, x19
        vaddr_rel += chunk_size;
ffffffffea803390:	8b1302b5 	add	x21, x21, x19
    while (size) {
ffffffffea803394:	eb130294 	subs	x20, x20, x19
ffffffffea803398:	54fffd41 	b.ne	ffffffffea803340 <arm64_mmu_unmap_pt+0x68>  // b.any
        size -= chunk_size;
    }
}
ffffffffea80339c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8033a0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8033a4:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8033a8:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea8033ac:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea8033b0:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea8033b4:	d65f03c0 	ret
                ARM64_TLBI(vaae1is, vaddr >> 12);
ffffffffea8033b8:	d5088360 	tlbi	vaae1is, x0
ffffffffea8033bc:	d5033fdf 	isb
ffffffffea8033c0:	17fffff3 	b	ffffffffea80338c <arm64_mmu_unmap_pt+0xb4>
ffffffffea8033c4:	d65f03c0 	ret
ffffffffea8033c8:	b9007ba8 	str	w8, [x29, #120]
            page_table_paddr = pte & MMU_PTE_OUTPUT_ADDR_MASK;
ffffffffea8033cc:	92748c00 	and	x0, x0, #0xfffffffff000
ffffffffea8033d0:	a906b3a0 	stp	x0, x12, [x29, #104]
ffffffffea8033d4:	b90087ab 	str	w11, [x29, #132]
ffffffffea8033d8:	a9089fa9 	stp	x9, x7, [x29, #136]
ffffffffea8033dc:	a9098fad 	stp	x13, x3, [x29, #152]
ffffffffea8033e0:	b900abaa 	str	w10, [x29, #168]
            next_page_table = paddr_to_kvaddr(page_table_paddr);
ffffffffea8033e4:	94003697 	bl	ffffffffea810e40 <paddr_to_kvaddr>
            arm64_mmu_unmap_pt(vaddr, vaddr_rem, chunk_size,
ffffffffea8033e8:	b940abaa 	ldr	w10, [x29, #168]
            next_page_table = paddr_to_kvaddr(page_table_paddr);
ffffffffea8033ec:	aa0003ef 	mov	x15, x0
            arm64_mmu_unmap_pt(vaddr, vaddr_rem, chunk_size,
ffffffffea8033f0:	f94053a3 	ldr	x3, [x29, #160]
ffffffffea8033f4:	aa0f03e5 	mov	x5, x15
ffffffffea8033f8:	2a0a03e6 	mov	w6, w10
ffffffffea8033fc:	b900a3aa 	str	w10, [x29, #160]
ffffffffea803400:	4b1b0063 	sub	w3, w3, w27
ffffffffea803404:	f90057af 	str	x15, [x29, #168]
ffffffffea803408:	aa1603e0 	mov	x0, x22
ffffffffea80340c:	aa1a03e1 	mov	x1, x26
ffffffffea803410:	2a1b03e4 	mov	w4, w27
ffffffffea803414:	aa1303e2 	mov	x2, x19
ffffffffea803418:	0b170063 	add	w3, w3, w23
ffffffffea80341c:	97ffffaf 	bl	ffffffffea8032d8 <arm64_mmu_unmap_pt>
            if (chunk_size == block_size ||
ffffffffea803420:	a9489fa9 	ldp	x9, x7, [x29, #136]
ffffffffea803424:	b9407ba8 	ldr	w8, [x29, #120]
ffffffffea803428:	b94087ab 	ldr	w11, [x29, #132]
ffffffffea80342c:	eb1300ff 	cmp	x7, x19
ffffffffea803430:	b940a3aa 	ldr	w10, [x29, #160]
ffffffffea803434:	f9403bac 	ldr	x12, [x29, #112]
ffffffffea803438:	f9404fad 	ldr	x13, [x29, #152]
ffffffffea80343c:	f94057af 	ldr	x15, [x29, #168]
ffffffffea803440:	54000180 	b.eq	ffffffffea803470 <arm64_mmu_unmap_pt+0x198>  // b.none
    for (i = 0; i < count; i++) {
ffffffffea803444:	7100017f 	cmp	w11, #0x0
ffffffffea803448:	5400014d 	b.le	ffffffffea803470 <arm64_mmu_unmap_pt+0x198>
        if (pte != MMU_PTE_DESCRIPTOR_INVALID) {
ffffffffea80344c:	f94001e0 	ldr	x0, [x15]
ffffffffea803450:	b5fff9e0 	cbnz	x0, ffffffffea80338c <arm64_mmu_unmap_pt+0xb4>
ffffffffea803454:	910021e0 	add	x0, x15, #0x8
ffffffffea803458:	8b0c01e2 	add	x2, x15, x12
ffffffffea80345c:	14000003 	b	ffffffffea803468 <arm64_mmu_unmap_pt+0x190>
ffffffffea803460:	f8408401 	ldr	x1, [x0], #8
ffffffffea803464:	b5fff941 	cbnz	x1, ffffffffea80338c <arm64_mmu_unmap_pt+0xb4>
    for (i = 0; i < count; i++) {
ffffffffea803468:	eb00005f 	cmp	x2, x0
ffffffffea80346c:	54ffffa1 	b.ne	ffffffffea803460 <arm64_mmu_unmap_pt+0x188>  // b.any
                page_table[index] = MMU_PTE_DESCRIPTOR_INVALID;
ffffffffea803470:	f8387b9f 	str	xzr, [x28, x24, lsl #3]
                __asm__ volatile("dmb ishst" ::: "memory");
ffffffffea803474:	d5033abf 	dmb	ishst
ffffffffea803478:	f9003fac 	str	x12, [x29, #120]
    if (size >= PAGE_SIZE) {
ffffffffea80347c:	713ffd1f 	cmp	w8, #0xfff
ffffffffea803480:	2910a3aa 	stp	w10, w8, [x29, #132]
ffffffffea803484:	b90093ab 	str	w11, [x29, #144]
ffffffffea803488:	a9099fa9 	stp	x9, x7, [x29, #152]
ffffffffea80348c:	f90057ad 	str	x13, [x29, #168]
ffffffffea803490:	54000209 	b.ls	ffffffffea8034d0 <arm64_mmu_unmap_pt+0x1f8>  // b.plast
        page = address_to_page(paddr);
ffffffffea803494:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea803498:	940034b6 	bl	ffffffffea810770 <address_to_page>
        if (!page)
ffffffffea80349c:	2950a3aa 	ldp	w10, w8, [x29, #132]
ffffffffea8034a0:	b94093ab 	ldr	w11, [x29, #144]
ffffffffea8034a4:	f9403fac 	ldr	x12, [x29, #120]
ffffffffea8034a8:	a9499fa9 	ldp	x9, x7, [x29, #152]
ffffffffea8034ac:	f94057ad 	ldr	x13, [x29, #168]
ffffffffea8034b0:	b4000200 	cbz	x0, ffffffffea8034f0 <arm64_mmu_unmap_pt+0x218>
ffffffffea8034b4:	f9003fac 	str	x12, [x29, #120]
ffffffffea8034b8:	2910a3aa 	stp	w10, w8, [x29, #132]
ffffffffea8034bc:	b90093ab 	str	w11, [x29, #144]
ffffffffea8034c0:	a9099fa9 	stp	x9, x7, [x29, #152]
ffffffffea8034c4:	f90057ad 	str	x13, [x29, #168]
        pmm_free_page(page);
ffffffffea8034c8:	940035e4 	bl	ffffffffea810c58 <pmm_free_page>
ffffffffea8034cc:	14000003 	b	ffffffffea8034d8 <arm64_mmu_unmap_pt+0x200>
        heap_free(vaddr);
ffffffffea8034d0:	aa0f03e0 	mov	x0, x15
ffffffffea8034d4:	94003b81 	bl	ffffffffea8122d8 <heap_free>
ffffffffea8034d8:	2950a3aa 	ldp	w10, w8, [x29, #132]
ffffffffea8034dc:	b94093ab 	ldr	w11, [x29, #144]
ffffffffea8034e0:	f9403fac 	ldr	x12, [x29, #120]
ffffffffea8034e4:	a9499fa9 	ldp	x9, x7, [x29, #152]
ffffffffea8034e8:	f94057ad 	ldr	x13, [x29, #168]
ffffffffea8034ec:	17ffffa8 	b	ffffffffea80338c <arm64_mmu_unmap_pt+0xb4>
            panic("bad page table paddr 0x%lx\n", paddr);
ffffffffea8034f0:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea8034f4:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8034f8:	aa1903e0 	mov	x0, x25
ffffffffea8034fc:	91348021 	add	x1, x1, #0xd20
ffffffffea803500:	940039e6 	bl	ffffffffea811c98 <_panic>
ffffffffea803504:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803508 <arch_mmu_query>:
{
ffffffffea803508:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    if (vaddr < kernel_base) {
ffffffffea80350c:	92a40003 	mov	x3, #0xffffffffdfffffff    	// #-536870913
ffffffffea803510:	eb03001f 	cmp	x0, x3
{
ffffffffea803514:	910003fd 	mov	x29, sp
    if (vaddr < kernel_base) {
ffffffffea803518:	54000c09 	b.ls	ffffffffea803698 <arch_mmu_query+0x190>  // b.plast
ffffffffea80351c:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea803520:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea803524:	aa0103f6 	mov	x22, x1
    vaddr_rem = vaddr - kernel_base;
ffffffffea803528:	d2a40001 	mov	x1, #0x20000000            	// #536870912
ffffffffea80352c:	8b010013 	add	x19, x0, x1
        pte = page_table[index];
ffffffffea803530:	f0000240 	adrp	x0, ffffffffea84e000 <arm64_kernel_translation_table>
ffffffffea803534:	91000000 	add	x0, x0, #0x0
        index = vaddr_rem >> index_shift;
ffffffffea803538:	d355fe61 	lsr	x1, x19, #21
ffffffffea80353c:	aa0203f5 	mov	x21, x2
ffffffffea803540:	92405274 	and	x20, x19, #0x1fffff
        pte = page_table[index];
ffffffffea803544:	f8617801 	ldr	x1, [x0, x1, lsl #3]
        pte_addr = pte & MMU_PTE_OUTPUT_ADDR_MASK;
ffffffffea803548:	92748c20 	and	x0, x1, #0xfffffffff000
        if (descriptor_type == MMU_PTE_DESCRIPTOR_INVALID)
ffffffffea80354c:	72000422 	ands	w2, w1, #0x3
ffffffffea803550:	54000460 	b.eq	ffffffffea8035dc <arch_mmu_query+0xd4>  // b.none
ffffffffea803554:	f9001bb7 	str	x23, [x29, #48]
        if (descriptor_type == ((index_shift > MMU_KERNEL_PAGE_SIZE_SHIFT) ?
ffffffffea803558:	7100045f 	cmp	w2, #0x1
ffffffffea80355c:	aa1e03f7 	mov	x23, x30
ffffffffea803560:	54000180 	b.eq	ffffffffea803590 <arch_mmu_query+0x88>  // b.none
        if (index_shift <= MMU_KERNEL_PAGE_SIZE_SHIFT ||
ffffffffea803564:	71000c5f 	cmp	w2, #0x3
ffffffffea803568:	540002c1 	b.ne	ffffffffea8035c0 <arch_mmu_query+0xb8>  // b.any
        page_table = paddr_to_kvaddr(pte_addr);
ffffffffea80356c:	94003635 	bl	ffffffffea810e40 <paddr_to_kvaddr>
ffffffffea803570:	d34c5261 	ubfx	x1, x19, #12, #9
        vaddr_rem -= (vaddr_t)index << index_shift;
ffffffffea803574:	cb013294 	sub	x20, x20, x1, lsl #12
        pte = page_table[index];
ffffffffea803578:	f8617801 	ldr	x1, [x0, x1, lsl #3]
        pte_addr = pte & MMU_PTE_OUTPUT_ADDR_MASK;
ffffffffea80357c:	92748c20 	and	x0, x1, #0xfffffffff000
        if (descriptor_type == MMU_PTE_DESCRIPTOR_INVALID)
ffffffffea803580:	72000422 	ands	w2, w1, #0x3
ffffffffea803584:	540002a0 	b.eq	ffffffffea8035d8 <arch_mmu_query+0xd0>  // b.none
        if (descriptor_type == ((index_shift > MMU_KERNEL_PAGE_SIZE_SHIFT) ?
ffffffffea803588:	71000c5f 	cmp	w2, #0x3
ffffffffea80358c:	540001a1 	b.ne	ffffffffea8035c0 <arch_mmu_query+0xb8>  // b.any
    if (paddr)
ffffffffea803590:	b4000076 	cbz	x22, ffffffffea80359c <arch_mmu_query+0x94>
        *paddr = pte_addr + vaddr_rem;
ffffffffea803594:	8b000294 	add	x20, x20, x0
ffffffffea803598:	f90002d4 	str	x20, [x22]
    if (flags) {
ffffffffea80359c:	b40005d5 	cbz	x21, ffffffffea803654 <arch_mmu_query+0x14c>
            *flags |= ARCH_MMU_FLAG_NS;
ffffffffea8035a0:	121b0020 	and	w0, w1, #0x20
ffffffffea8035a4:	b90002a0 	str	w0, [x21]
        switch (pte & MMU_PTE_ATTR_ATTR_INDEX_MASK) {
ffffffffea8035a8:	927e0822 	and	x2, x1, #0x1c
ffffffffea8035ac:	f100105f 	cmp	x2, #0x4
ffffffffea8035b0:	54000660 	b.eq	ffffffffea80367c <arch_mmu_query+0x174>  // b.none
ffffffffea8035b4:	f100205f 	cmp	x2, #0x8
ffffffffea8035b8:	54000200 	b.eq	ffffffffea8035f8 <arch_mmu_query+0xf0>  // b.none
ffffffffea8035bc:	b40001a2 	cbz	x2, ffffffffea8035f0 <arch_mmu_query+0xe8>
                PANIC_UNIMPLEMENTED;
ffffffffea8035c0:	d0000082 	adrp	x2, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8035c4:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8035c8:	912e2042 	add	x2, x2, #0xb88
ffffffffea8035cc:	91306021 	add	x1, x1, #0xc18
ffffffffea8035d0:	aa1703e0 	mov	x0, x23
ffffffffea8035d4:	940039b1 	bl	ffffffffea811c98 <_panic>
ffffffffea8035d8:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea8035dc:	a94153b3 	ldp	x19, x20, [x29, #16]
            return ERR_NOT_FOUND;
ffffffffea8035e0:	12800020 	mov	w0, #0xfffffffe            	// #-2
ffffffffea8035e4:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea8035e8:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8035ec:	d65f03c0 	ret
                *flags |= ARCH_MMU_FLAG_UNCACHED;
ffffffffea8035f0:	32000000 	orr	w0, w0, #0x1
ffffffffea8035f4:	b90002a0 	str	w0, [x21]
        switch (pte & MMU_PTE_ATTR_AP_MASK) {
ffffffffea8035f8:	927a0420 	and	x0, x1, #0xc0
ffffffffea8035fc:	f102001f 	cmp	x0, #0x80
ffffffffea803600:	54000440 	b.eq	ffffffffea803688 <arch_mmu_query+0x180>  // b.none
ffffffffea803604:	f103001f 	cmp	x0, #0xc0
ffffffffea803608:	54000320 	b.eq	ffffffffea80366c <arch_mmu_query+0x164>  // b.none
ffffffffea80360c:	f101001f 	cmp	x0, #0x40
ffffffffea803610:	54000081 	b.ne	ffffffffea803620 <arch_mmu_query+0x118>  // b.any
                *flags |= ARCH_MMU_FLAG_PERM_USER;
ffffffffea803614:	b94002a0 	ldr	w0, [x21]
ffffffffea803618:	321e0000 	orr	w0, w0, #0x4
ffffffffea80361c:	b90002a0 	str	w0, [x21]
        if ((pte & MMU_PTE_ATTR_UXN) && (pte & MMU_PTE_ATTR_PXN)) {
ffffffffea803620:	924b0421 	and	x1, x1, #0x60000000000000
ffffffffea803624:	d2e00c00 	mov	x0, #0x60000000000000      	// #27021597764222976
ffffffffea803628:	eb00003f 	cmp	x1, x0
ffffffffea80362c:	54000141 	b.ne	ffffffffea803654 <arch_mmu_query+0x14c>  // b.any
            *flags |= ARCH_MMU_FLAG_PERM_NO_EXECUTE;
ffffffffea803630:	b94002a1 	ldr	w1, [x21]
    return 0;
ffffffffea803634:	52800000 	mov	w0, #0x0                   	// #0
            *flags |= ARCH_MMU_FLAG_PERM_NO_EXECUTE;
ffffffffea803638:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80363c:	321c0021 	orr	w1, w1, #0x10
ffffffffea803640:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea803644:	b90002a1 	str	w1, [x21]
ffffffffea803648:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea80364c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea803650:	d65f03c0 	ret
    return 0;
ffffffffea803654:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea803658:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80365c:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea803660:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea803664:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea803668:	d65f03c0 	ret
                *flags |= ARCH_MMU_FLAG_PERM_USER | ARCH_MMU_FLAG_PERM_RO;
ffffffffea80366c:	b94002a0 	ldr	w0, [x21]
ffffffffea803670:	321e0400 	orr	w0, w0, #0xc
ffffffffea803674:	b90002a0 	str	w0, [x21]
                break;
ffffffffea803678:	17ffffea 	b	ffffffffea803620 <arch_mmu_query+0x118>
                *flags |= ARCH_MMU_FLAG_UNCACHED_DEVICE;
ffffffffea80367c:	321f0000 	orr	w0, w0, #0x2
ffffffffea803680:	b90002a0 	str	w0, [x21]
                break;
ffffffffea803684:	17ffffdd 	b	ffffffffea8035f8 <arch_mmu_query+0xf0>
                *flags |= ARCH_MMU_FLAG_PERM_RO;
ffffffffea803688:	b94002a0 	ldr	w0, [x21]
ffffffffea80368c:	321d0000 	orr	w0, w0, #0x8
ffffffffea803690:	b90002a0 	str	w0, [x21]
                break;
ffffffffea803694:	17ffffe3 	b	ffffffffea803620 <arch_mmu_query+0x118>
        TRACEF("vaddr 0x%lx < base 0x%lx\n", vaddr, kernel_base);
ffffffffea803698:	d0000085 	adrp	x5, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80369c:	aa0003e3 	mov	x3, x0
ffffffffea8036a0:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8036a4:	b2638be4 	mov	x4, #0xffffffffe0000000    	// #-536870912
ffffffffea8036a8:	52800d02 	mov	w2, #0x68                  	// #104
ffffffffea8036ac:	912e2021 	add	x1, x1, #0xb88
ffffffffea8036b0:	912fc0a0 	add	x0, x5, #0xbf0
ffffffffea8036b4:	94003edf 	bl	ffffffffea813230 <_printf>
        return ERR_INVALID_ARGS;
ffffffffea8036b8:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea8036bc:	17ffffcb 	b	ffffffffea8035e8 <arch_mmu_query+0xe0>

ffffffffea8036c0 <arm64_mmu_map_pt>:
static int arm64_mmu_map_pt(vaddr_t vaddr_in, vaddr_t vaddr_rel_in,
                            paddr_t paddr_in,
                            size_t size_in, pte_t attrs,
                            uint index_shift, uint page_size_shift,
                            pte_t *page_table, uint asid)
{
ffffffffea8036c0:	d10383ff 	sub	sp, sp, #0xe0
ffffffffea8036c4:	aa0103e8 	mov	x8, x1
ffffffffea8036c8:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea8036cc:	910043fd 	add	x29, sp, #0x10
ffffffffea8036d0:	f90037be 	str	x30, [x29, #104]
ffffffffea8036d4:	a90887a3 	stp	x3, x1, [x29, #136]

    LTRACEF("vaddr 0x%lx, vaddr_rel 0x%lx, paddr 0x%lx, size 0x%lx, attrs 0x%llx, index shift %d, page_size_shift %d, page_table %p\n",
            vaddr, vaddr_rel, paddr, size, attrs,
            index_shift, page_size_shift, page_table);

    if ((vaddr_rel | paddr | size) & ((1UL << page_size_shift) - 1)) {
ffffffffea8036d8:	aa030041 	orr	x1, x2, x3
{
ffffffffea8036dc:	f9002ffa 	str	x26, [sp, #88]
    if ((vaddr_rel | paddr | size) & ((1UL << page_size_shift) - 1)) {
ffffffffea8036e0:	aa080021 	orr	x1, x1, x8
{
ffffffffea8036e4:	f9004fa0 	str	x0, [x29, #152]
ffffffffea8036e8:	aa0203fa 	mov	x26, x2
ffffffffea8036ec:	a90b1fa4 	stp	x4, x7, [x29, #176]
    if ((vaddr_rel | paddr | size) & ((1UL << page_size_shift) - 1)) {
ffffffffea8036f0:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
ffffffffea8036f4:	9ac62042 	lsl	x2, x2, x6
ffffffffea8036f8:	ea22003f 	bics	xzr, x1, x2
ffffffffea8036fc:	540014c1 	b.ne	ffffffffea803994 <arm64_mmu_map_pt+0x2d4>  // b.any
        TRACEF("not page aligned\n");
        return ERR_INVALID_ARGS;
    }

    while (size) {
ffffffffea803700:	b40012a3 	cbz	x3, ffffffffea803954 <arm64_mmu_map_pt+0x294>
ffffffffea803704:	a9025bb5 	stp	x21, x22, [x29, #32]
        block_size = 1UL << index_shift;
ffffffffea803708:	d2800035 	mov	x21, #0x1                   	// #1
ffffffffea80370c:	a90573bb 	stp	x27, x28, [x29, #80]
    size_t size = 1U << page_size_shift;
ffffffffea803710:	1ac622a0 	lsl	w0, w21, w6
    vaddr_t vaddr_rel = vaddr_rel_in;
ffffffffea803714:	a948efbc 	ldp	x28, x27, [x29, #136]
    size_t size = 1U << page_size_shift;
ffffffffea803718:	f90053a0 	str	x0, [x29, #160]
ffffffffea80371c:	b900aba0 	str	w0, [x29, #168]
        count = size / PAGE_SIZE;
ffffffffea803720:	d34cfc00 	lsr	x0, x0, #12
ffffffffea803724:	f90023b9 	str	x25, [x29, #64]
            next_page_table = arm64_mmu_get_page_table(index, page_size_shift,
                                                       page_table);
            if (!next_page_table)
                goto err;

            ret = arm64_mmu_map_pt(vaddr, vaddr_rem, paddr, chunk_size, attrs,
ffffffffea803728:	11000cb9 	add	w25, w5, #0x3
        count = size / PAGE_SIZE;
ffffffffea80372c:	290e03a0 	stp	w0, w0, [x29, #112]
        ret = arch_mmu_query((vaddr_t)vaddr, paddrp, NULL);
ffffffffea803730:	aa1c03e0 	mov	x0, x28
ffffffffea803734:	a90153b3 	stp	x19, x20, [x29, #16]
        block_size = 1UL << index_shift;
ffffffffea803738:	9ac522b5 	lsl	x21, x21, x5
ffffffffea80373c:	a90363b7 	stp	x23, x24, [x29, #48]
            ret = arm64_mmu_map_pt(vaddr, vaddr_rem, paddr, chunk_size, attrs,
ffffffffea803740:	4b060321 	sub	w1, w25, w6
        ret = arch_mmu_query((vaddr_t)vaddr, paddrp, NULL);
ffffffffea803744:	aa1b03fc 	mov	x28, x27
ffffffffea803748:	2a0603f7 	mov	w23, w6
ffffffffea80374c:	2a0503f3 	mov	w19, w5
        block_mask = block_size - 1;
ffffffffea803750:	d10006b6 	sub	x22, x21, #0x1
    vaddr_t vaddr = vaddr_in;
ffffffffea803754:	f9404fb4 	ldr	x20, [x29, #152]
        ret = arch_mmu_query((vaddr_t)vaddr, paddrp, NULL);
ffffffffea803758:	aa0003fb 	mov	x27, x0
            ret = arm64_mmu_map_pt(vaddr, vaddr_rem, paddr, chunk_size, attrs,
ffffffffea80375c:	b900afa1 	str	w1, [x29, #172]
ffffffffea803760:	1400000f 	b	ffffffffea80379c <arm64_mmu_map_pt+0xdc>
                                   page_size_shift, next_page_table, asid);
            if (ret)
                goto err;
        } else {
            pte = page_table[index];
            if (pte) {
ffffffffea803764:	b5001024 	cbnz	x4, ffffffffea803968 <arm64_mmu_map_pt+0x2a8>
                TRACEF("page table entry already in use, index 0x%lx, 0x%llx\n",
                       index, pte);
                goto err;
            }

            pte = paddr | attrs;
ffffffffea803768:	f9405ba0 	ldr	x0, [x29, #176]
            if (index_shift > page_size_shift)
                pte |= MMU_PTE_L012_DESCRIPTOR_BLOCK;
ffffffffea80376c:	6b1302ff 	cmp	w23, w19
            pte = paddr | attrs;
ffffffffea803770:	aa1a0000 	orr	x0, x0, x26
                pte |= MMU_PTE_L012_DESCRIPTOR_BLOCK;
ffffffffea803774:	b2400001 	orr	x1, x0, #0x1
ffffffffea803778:	b2400400 	orr	x0, x0, #0x3
ffffffffea80377c:	9a812000 	csel	x0, x0, x1, cs  // cs = hs, nlast
            else
                pte |= MMU_PTE_L3_DESCRIPTOR_PAGE;

            LTRACEF("pte %p[0x%lx] = 0x%llx\n", page_table, index, pte);
            page_table[index] = pte;
ffffffffea803780:	f9405fa1 	ldr	x1, [x29, #184]
ffffffffea803784:	f8397820 	str	x0, [x1, x25, lsl #3]
        }
        vaddr += chunk_size;
ffffffffea803788:	8b180294 	add	x20, x20, x24
        vaddr_rel += chunk_size;
ffffffffea80378c:	8b18039c 	add	x28, x28, x24
        paddr += chunk_size;
ffffffffea803790:	8b18035a 	add	x26, x26, x24
    while (size) {
ffffffffea803794:	eb18037b 	subs	x27, x27, x24
ffffffffea803798:	54000d40 	b.eq	ffffffffea803940 <arm64_mmu_map_pt+0x280>  // b.none
        vaddr_rem = vaddr_rel & block_mask;
ffffffffea80379c:	8a1c02cc 	and	x12, x22, x28
ffffffffea8037a0:	f9405fa0 	ldr	x0, [x29, #184]
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea8037a4:	cb0c02a8 	sub	x8, x21, x12
        index = vaddr_rel >> index_shift;
ffffffffea8037a8:	9ad32799 	lsr	x25, x28, x19
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea8037ac:	eb1b011f 	cmp	x8, x27
        if (((vaddr_rel | paddr) & block_mask) ||
ffffffffea8037b0:	aa1a0381 	orr	x1, x28, x26
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea8037b4:	9a9b9118 	csel	x24, x8, x27, ls  // ls = plast
ffffffffea8037b8:	f8797804 	ldr	x4, [x0, x25, lsl #3]
        if (((vaddr_rel | paddr) & block_mask) ||
ffffffffea8037bc:	ea16003f 	tst	x1, x22
ffffffffea8037c0:	54000081 	b.ne	ffffffffea8037d0 <arm64_mmu_map_pt+0x110>  // b.any
            (chunk_size != block_size) ||
ffffffffea8037c4:	eb1802bf 	cmp	x21, x24
ffffffffea8037c8:	7a5e0a62 	ccmp	w19, #0x1e, #0x2, eq  // eq = none
ffffffffea8037cc:	54fffcc9 	b.ls	ffffffffea803764 <arm64_mmu_map_pt+0xa4>  // b.plast
    switch (pte & MMU_PTE_DESCRIPTOR_MASK) {
ffffffffea8037d0:	92400480 	and	x0, x4, #0x3
ffffffffea8037d4:	f100041f 	cmp	x0, #0x1
ffffffffea8037d8:	540002c0 	b.eq	ffffffffea803830 <arm64_mmu_map_pt+0x170>  // b.none
ffffffffea8037dc:	b4000520 	cbz	x0, ffffffffea803880 <arm64_mmu_map_pt+0x1c0>
ffffffffea8037e0:	f1000c1f 	cmp	x0, #0x3
ffffffffea8037e4:	54000e81 	b.ne	ffffffffea8039b4 <arm64_mmu_map_pt+0x2f4>  // b.any
        paddr = pte & MMU_PTE_OUTPUT_ADDR_MASK;
ffffffffea8037e8:	92748c80 	and	x0, x4, #0xfffffffff000
ffffffffea8037ec:	f90043ac 	str	x12, [x29, #128]
ffffffffea8037f0:	f90067a0 	str	x0, [x29, #200]
        return paddr_to_kvaddr(paddr);
ffffffffea8037f4:	94003593 	bl	ffffffffea810e40 <paddr_to_kvaddr>
ffffffffea8037f8:	f94043ac 	ldr	x12, [x29, #128]
ffffffffea8037fc:	aa0003e7 	mov	x7, x0
            if (!next_page_table)
ffffffffea803800:	b4000187 	cbz	x7, ffffffffea803830 <arm64_mmu_map_pt+0x170>
            ret = arm64_mmu_map_pt(vaddr, vaddr_rem, paddr, chunk_size, attrs,
ffffffffea803804:	b940afa5 	ldr	w5, [x29, #172]
ffffffffea803808:	2a1703e6 	mov	w6, w23
ffffffffea80380c:	f9405ba4 	ldr	x4, [x29, #176]
ffffffffea803810:	aa0c03e1 	mov	x1, x12
ffffffffea803814:	b940d3a0 	ldr	w0, [x29, #208]
ffffffffea803818:	aa1803e3 	mov	x3, x24
ffffffffea80381c:	b90003e0 	str	w0, [sp]
ffffffffea803820:	aa1a03e2 	mov	x2, x26
ffffffffea803824:	aa1403e0 	mov	x0, x20
ffffffffea803828:	97ffffa6 	bl	ffffffffea8036c0 <arm64_mmu_map_pt>
            if (ret)
ffffffffea80382c:	34fffae0 	cbz	w0, ffffffffea803788 <arm64_mmu_map_pt+0xc8>
ffffffffea803830:	aa1b03fc 	mov	x28, x27
    }

    return 0;

err:
    arm64_mmu_unmap_pt(vaddr_in, vaddr_rel_in, size_in - size,
ffffffffea803834:	a94887a0 	ldp	x0, x1, [x29, #136]
ffffffffea803838:	2a1703e4 	mov	w4, w23
ffffffffea80383c:	b940d3a6 	ldr	w6, [x29, #208]
ffffffffea803840:	2a1303e3 	mov	w3, w19
ffffffffea803844:	cb1c0002 	sub	x2, x0, x28
ffffffffea803848:	f9404fa0 	ldr	x0, [x29, #152]
ffffffffea80384c:	f9405fa5 	ldr	x5, [x29, #184]
ffffffffea803850:	97fffea2 	bl	ffffffffea8032d8 <arm64_mmu_unmap_pt>
                       index_shift, page_size_shift, page_table, asid);
    DSB;
ffffffffea803854:	d5033f9f 	dsb	sy
    return ERR_GENERIC;
ffffffffea803858:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80385c:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea803860:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea803864:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea803868:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80386c:	a94573bb 	ldp	x27, x28, [x29, #80]
}
ffffffffea803870:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea803874:	f9402ffa 	ldr	x26, [sp, #88]
ffffffffea803878:	910383ff 	add	sp, sp, #0xe0
ffffffffea80387c:	d65f03c0 	ret
    if (size >= PAGE_SIZE) {
ffffffffea803880:	b940aba0 	ldr	w0, [x29, #168]
ffffffffea803884:	713ffc1f 	cmp	w0, #0xfff
ffffffffea803888:	54000329 	b.ls	ffffffffea8038ec <arm64_mmu_map_pt+0x22c>  // b.plast
        ret = pmm_alloc_contiguous(count, page_size_shift, paddrp, NULL);
ffffffffea80388c:	b94073a0 	ldr	w0, [x29, #112]
ffffffffea803890:	2a1703e1 	mov	w1, w23
ffffffffea803894:	f90043ac 	str	x12, [x29, #128]
ffffffffea803898:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea80389c:	910323a2 	add	x2, x29, #0xc8
ffffffffea8038a0:	9400350a 	bl	ffffffffea810cc8 <pmm_alloc_contiguous>
        if (ret != count)
ffffffffea8038a4:	b94077a1 	ldr	w1, [x29, #116]
ffffffffea8038a8:	f94043ac 	ldr	x12, [x29, #128]
ffffffffea8038ac:	6b00003f 	cmp	w1, w0
ffffffffea8038b0:	540006e1 	b.ne	ffffffffea80398c <arm64_mmu_map_pt+0x2cc>  // b.any
        vaddr = paddr_to_kvaddr(paddr);
ffffffffea8038b4:	f94067a0 	ldr	x0, [x29, #200]
ffffffffea8038b8:	f9003fac 	str	x12, [x29, #120]
ffffffffea8038bc:	94003561 	bl	ffffffffea810e40 <paddr_to_kvaddr>
ffffffffea8038c0:	f90043a0 	str	x0, [x29, #128]
        memset(vaddr, MMU_PTE_DESCRIPTOR_INVALID, 1U << page_size_shift);
ffffffffea8038c4:	f94053a2 	ldr	x2, [x29, #160]
ffffffffea8038c8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8038cc:	94003f55 	bl	ffffffffea813620 <memset>
        __asm__ volatile("dmb ishst" ::: "memory");
ffffffffea8038d0:	d5033abf 	dmb	ishst
        page_table[index] = pte;
ffffffffea8038d4:	f9405fa1 	ldr	x1, [x29, #184]
        pte = paddr | MMU_PTE_L012_DESCRIPTOR_TABLE;
ffffffffea8038d8:	f94067a0 	ldr	x0, [x29, #200]
ffffffffea8038dc:	a9479fac 	ldp	x12, x7, [x29, #120]
ffffffffea8038e0:	b2400400 	orr	x0, x0, #0x3
        page_table[index] = pte;
ffffffffea8038e4:	f8397820 	str	x0, [x1, x25, lsl #3]
ffffffffea8038e8:	17ffffc6 	b	ffffffffea803800 <arm64_mmu_map_pt+0x140>
        vaddr = heap_alloc(size, size);
ffffffffea8038ec:	b940aba1 	ldr	w1, [x29, #168]
ffffffffea8038f0:	f94053a0 	ldr	x0, [x29, #160]
ffffffffea8038f4:	f9003fac 	str	x12, [x29, #120]
ffffffffea8038f8:	940039b6 	bl	ffffffffea811fd0 <heap_alloc>
        if (!vaddr)
ffffffffea8038fc:	f90043a0 	str	x0, [x29, #128]
ffffffffea803900:	b4000460 	cbz	x0, ffffffffea80398c <arm64_mmu_map_pt+0x2cc>
        ret = arch_mmu_query((vaddr_t)vaddr, paddrp, NULL);
ffffffffea803904:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea803908:	910323a1 	add	x1, x29, #0xc8
ffffffffea80390c:	97fffeff 	bl	ffffffffea803508 <arch_mmu_query>
        if (ret) {
ffffffffea803910:	a9478fac 	ldp	x12, x3, [x29, #120]
ffffffffea803914:	34fffd00 	cbz	w0, ffffffffea8038b4 <arm64_mmu_map_pt+0x1f4>
ffffffffea803918:	aa1b03fc 	mov	x28, x27
            heap_free(vaddr);
ffffffffea80391c:	aa0303e0 	mov	x0, x3
ffffffffea803920:	94003a6e 	bl	ffffffffea8122d8 <heap_free>
            TRACEF("failed to allocate page table\n");
ffffffffea803924:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803928:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80392c:	52801da2 	mov	w2, #0xed                  	// #237
ffffffffea803930:	912e6021 	add	x1, x1, #0xb98
ffffffffea803934:	9132e000 	add	x0, x0, #0xcb8
ffffffffea803938:	94003e3e 	bl	ffffffffea813230 <_printf>
ffffffffea80393c:	17ffffbe 	b	ffffffffea803834 <arm64_mmu_map_pt+0x174>
ffffffffea803940:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea803944:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea803948:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80394c:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea803950:	a94573bb 	ldp	x27, x28, [x29, #80]
    return 0;
ffffffffea803954:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea803958:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea80395c:	f9402ffa 	ldr	x26, [sp, #88]
ffffffffea803960:	910383ff 	add	sp, sp, #0xe0
ffffffffea803964:	d65f03c0 	ret
ffffffffea803968:	aa1b03fc 	mov	x28, x27
                TRACEF("page table entry already in use, index 0x%lx, 0x%llx\n",
ffffffffea80396c:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803970:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803974:	aa1903e3 	mov	x3, x25
ffffffffea803978:	528030e2 	mov	w2, #0x187                 	// #391
ffffffffea80397c:	912ee021 	add	x1, x1, #0xbb8
ffffffffea803980:	91338000 	add	x0, x0, #0xce0
ffffffffea803984:	94003e2b 	bl	ffffffffea813230 <_printf>
                goto err;
ffffffffea803988:	17ffffab 	b	ffffffffea803834 <arm64_mmu_map_pt+0x174>
ffffffffea80398c:	aa1b03fc 	mov	x28, x27
ffffffffea803990:	17ffffe5 	b	ffffffffea803924 <arm64_mmu_map_pt+0x264>
        TRACEF("not page aligned\n");
ffffffffea803994:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803998:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80399c:	52802d62 	mov	w2, #0x16b                 	// #363
ffffffffea8039a0:	912ee021 	add	x1, x1, #0xbb8
ffffffffea8039a4:	91326000 	add	x0, x0, #0xc98
ffffffffea8039a8:	94003e22 	bl	ffffffffea813230 <_printf>
        return ERR_INVALID_ARGS;
ffffffffea8039ac:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea8039b0:	17ffffb0 	b	ffffffffea803870 <arm64_mmu_map_pt+0x1b0>
        PANIC_UNIMPLEMENTED;
ffffffffea8039b4:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea8039b8:	d0000082 	adrp	x2, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8039bc:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8039c0:	912e6042 	add	x2, x2, #0xb98
ffffffffea8039c4:	91306021 	add	x1, x1, #0xc18
ffffffffea8039c8:	940038b4 	bl	ffffffffea811c98 <_panic>
ffffffffea8039cc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8039d0 <arm64_mmu_map>:

int arm64_mmu_map(vaddr_t vaddr, paddr_t paddr, size_t size, pte_t attrs,
                  vaddr_t vaddr_base, uint top_size_shift,
                  uint top_index_shift, uint page_size_shift,
                  pte_t *top_page_table, uint asid)
{
ffffffffea8039d0:	d10083ff 	sub	sp, sp, #0x20
    int ret;
    vaddr_t vaddr_rel = vaddr - vaddr_base;
    vaddr_t vaddr_rel_max = 1UL << top_size_shift;
ffffffffea8039d4:	d2800028 	mov	x8, #0x1                   	// #1
ffffffffea8039d8:	9ac52108 	lsl	x8, x8, x5
    vaddr_t vaddr_rel = vaddr - vaddr_base;
ffffffffea8039dc:	cb040009 	sub	x9, x0, x4

    LTRACEF("vaddr 0x%lx, paddr 0x%lx, size 0x%lx, attrs 0x%llx, asid 0x%x\n",
            vaddr, paddr, size, attrs, asid);

    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea8039e0:	cb020105 	sub	x5, x8, x2
{
ffffffffea8039e4:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea8039e8:	910043fd 	add	x29, sp, #0x10
    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea8039ec:	eb0900bf 	cmp	x5, x9
{
ffffffffea8039f0:	2a0603e5 	mov	w5, w6
ffffffffea8039f4:	2a0703e6 	mov	w6, w7
    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea8039f8:	fa422100 	ccmp	x8, x2, #0x0, cs  // cs = hs, nlast
{
ffffffffea8039fc:	f9400ba7 	ldr	x7, [x29, #16]
    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803a00:	540001a3 	b.cc	ffffffffea803a34 <arm64_mmu_map+0x64>  // b.lo, b.ul, b.last
        TRACEF("vaddr 0x%lx, size 0x%lx out of range vaddr 0x%lx, size 0x%lx\n",
               vaddr, size, vaddr_base, vaddr_rel_max);
        return ERR_INVALID_ARGS;
    }

    if (!top_page_table) {
ffffffffea803a04:	b4000327 	cbz	x7, ffffffffea803a68 <arm64_mmu_map+0x98>
        TRACEF("page table is NULL\n");
        return ERR_INVALID_ARGS;
    }

    ret = arm64_mmu_map_pt(vaddr, vaddr_rel, paddr, size, attrs,
ffffffffea803a08:	b9401ba4 	ldr	w4, [x29, #24]
ffffffffea803a0c:	b90003e4 	str	w4, [sp]
ffffffffea803a10:	aa0303e4 	mov	x4, x3
ffffffffea803a14:	aa0203e3 	mov	x3, x2
ffffffffea803a18:	aa0103e2 	mov	x2, x1
ffffffffea803a1c:	aa0903e1 	mov	x1, x9
ffffffffea803a20:	97ffff28 	bl	ffffffffea8036c0 <arm64_mmu_map_pt>
                           top_index_shift, page_size_shift, top_page_table, asid);
    DSB;
ffffffffea803a24:	d5033f9f 	dsb	sy
    return ret;
}
ffffffffea803a28:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea803a2c:	910083ff 	add	sp, sp, #0x20
ffffffffea803a30:	d65f03c0 	ret
ffffffffea803a34:	aa0003ea 	mov	x10, x0
        TRACEF("vaddr 0x%lx, size 0x%lx out of range vaddr 0x%lx, size 0x%lx\n",
ffffffffea803a38:	aa0403e5 	mov	x5, x4
ffffffffea803a3c:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803a40:	aa0203e4 	mov	x4, x2
ffffffffea803a44:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803a48:	aa0803e6 	mov	x6, x8
ffffffffea803a4c:	aa0a03e3 	mov	x3, x10
ffffffffea803a50:	52803622 	mov	w2, #0x1b1                 	// #433
ffffffffea803a54:	912f4021 	add	x1, x1, #0xbd0
ffffffffea803a58:	9130c000 	add	x0, x0, #0xc30
ffffffffea803a5c:	94003df5 	bl	ffffffffea813230 <_printf>
        return ERR_INVALID_ARGS;
ffffffffea803a60:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803a64:	17fffff1 	b	ffffffffea803a28 <arm64_mmu_map+0x58>
        TRACEF("page table is NULL\n");
ffffffffea803a68:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803a6c:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803a70:	528036c2 	mov	w2, #0x1b6                 	// #438
ffffffffea803a74:	912f4021 	add	x1, x1, #0xbd0
ffffffffea803a78:	9131e000 	add	x0, x0, #0xc78
ffffffffea803a7c:	94003ded 	bl	ffffffffea813230 <_printf>
ffffffffea803a80:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803a84:	17ffffe9 	b	ffffffffea803a28 <arm64_mmu_map+0x58>

ffffffffea803a88 <arm64_mmu_unmap>:

int arm64_mmu_unmap(vaddr_t vaddr, size_t size,
                    vaddr_t vaddr_base, uint top_size_shift,
                    uint top_index_shift, uint page_size_shift,
                    pte_t *top_page_table, uint asid)
{
ffffffffea803a88:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    vaddr_t vaddr_rel = vaddr - vaddr_base;
    vaddr_t vaddr_rel_max = 1UL << top_size_shift;
ffffffffea803a8c:	d2800028 	mov	x8, #0x1                   	// #1
ffffffffea803a90:	9ac32108 	lsl	x8, x8, x3
    vaddr_t vaddr_rel = vaddr - vaddr_base;
ffffffffea803a94:	cb020009 	sub	x9, x0, x2

    LTRACEF("vaddr 0x%lx, size 0x%lx, asid 0x%x\n", vaddr, size, asid);

    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803a98:	cb01010b 	sub	x11, x8, x1
{
ffffffffea803a9c:	910003fd 	mov	x29, sp
    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803aa0:	eb09017f 	cmp	x11, x9
ffffffffea803aa4:	fa412100 	ccmp	x8, x1, #0x0, cs  // cs = hs, nlast
ffffffffea803aa8:	540001a3 	b.cc	ffffffffea803adc <arm64_mmu_unmap+0x54>  // b.lo, b.ul, b.last
ffffffffea803aac:	2a0403e3 	mov	w3, w4
ffffffffea803ab0:	2a0503e4 	mov	w4, w5
ffffffffea803ab4:	aa0603e5 	mov	x5, x6
        TRACEF("vaddr 0x%lx, size 0x%lx out of range vaddr 0x%lx, size 0x%lx\n",
               vaddr, size, vaddr_base, vaddr_rel_max);
        return ERR_INVALID_ARGS;
    }

    if (!top_page_table) {
ffffffffea803ab8:	b40002c6 	cbz	x6, ffffffffea803b10 <arm64_mmu_unmap+0x88>
        TRACEF("page table is NULL\n");
        return ERR_INVALID_ARGS;
    }

    arm64_mmu_unmap_pt(vaddr, vaddr_rel, size,
ffffffffea803abc:	aa0103e2 	mov	x2, x1
ffffffffea803ac0:	2a0703e6 	mov	w6, w7
ffffffffea803ac4:	aa0903e1 	mov	x1, x9
ffffffffea803ac8:	97fffe04 	bl	ffffffffea8032d8 <arm64_mmu_unmap_pt>
                       top_index_shift, page_size_shift, top_page_table, asid);
    DSB;
ffffffffea803acc:	d5033f9f 	dsb	sy
    return 0;
ffffffffea803ad0:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea803ad4:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea803ad8:	d65f03c0 	ret
ffffffffea803adc:	aa0003ea 	mov	x10, x0
        TRACEF("vaddr 0x%lx, size 0x%lx out of range vaddr 0x%lx, size 0x%lx\n",
ffffffffea803ae0:	d0000087 	adrp	x7, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803ae4:	aa0203e5 	mov	x5, x2
ffffffffea803ae8:	aa0103e4 	mov	x4, x1
ffffffffea803aec:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803af0:	aa0803e6 	mov	x6, x8
ffffffffea803af4:	aa0a03e3 	mov	x3, x10
ffffffffea803af8:	52803982 	mov	w2, #0x1cc                 	// #460
ffffffffea803afc:	912f80e1 	add	x1, x7, #0xbe0
ffffffffea803b00:	9130c000 	add	x0, x0, #0xc30
ffffffffea803b04:	94003dcb 	bl	ffffffffea813230 <_printf>
        return ERR_INVALID_ARGS;
ffffffffea803b08:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803b0c:	17fffff2 	b	ffffffffea803ad4 <arm64_mmu_unmap+0x4c>
        TRACEF("page table is NULL\n");
ffffffffea803b10:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803b14:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803b18:	52803a22 	mov	w2, #0x1d1                 	// #465
ffffffffea803b1c:	912f8021 	add	x1, x1, #0xbe0
ffffffffea803b20:	9131e000 	add	x0, x0, #0xc78
ffffffffea803b24:	94003dc3 	bl	ffffffffea813230 <_printf>
ffffffffea803b28:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803b2c:	17ffffea 	b	ffffffffea803ad4 <arm64_mmu_unmap+0x4c>

ffffffffea803b30 <arch_mmu_map>:

int arch_mmu_map(vaddr_t vaddr, paddr_t paddr, uint count, uint flags)
{
ffffffffea803b30:	d10083ff 	sub	sp, sp, #0x20
ffffffffea803b34:	2a0303e4 	mov	w4, w3
    switch (flags & ARCH_MMU_FLAG_CACHE_MASK) {
ffffffffea803b38:	12000463 	and	w3, w3, #0x3
    return arm64_mmu_map(vaddr, paddr, count * PAGE_SIZE,
ffffffffea803b3c:	d3747c42 	ubfiz	x2, x2, #12, #32
    switch (flags & ARCH_MMU_FLAG_CACHE_MASK) {
ffffffffea803b40:	7100047f 	cmp	w3, #0x1
{
ffffffffea803b44:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea803b48:	910043fd 	add	x29, sp, #0x10
    switch (flags & ARCH_MMU_FLAG_CACHE_MASK) {
ffffffffea803b4c:	54000500 	b.eq	ffffffffea803bec <arch_mmu_map+0xbc>  // b.none
ffffffffea803b50:	34000423 	cbz	w3, ffffffffea803bd4 <arch_mmu_map+0xa4>
ffffffffea803b54:	7100087f 	cmp	w3, #0x2
ffffffffea803b58:	54000221 	b.ne	ffffffffea803b9c <arch_mmu_map+0x6c>  // b.any
            attr |= MMU_PTE_ATTR_DEVICE;
ffffffffea803b5c:	d2808083 	mov	x3, #0x404                 	// #1028
    switch (flags & (ARCH_MMU_FLAG_PERM_USER | ARCH_MMU_FLAG_PERM_RO)) {
ffffffffea803b60:	121e0485 	and	w5, w4, #0xc
ffffffffea803b64:	710020bf 	cmp	w5, #0x8
ffffffffea803b68:	540003e0 	b.eq	ffffffffea803be4 <arch_mmu_map+0xb4>  // b.none
ffffffffea803b6c:	710030bf 	cmp	w5, #0xc
ffffffffea803b70:	54000420 	b.eq	ffffffffea803bf4 <arch_mmu_map+0xc4>  // b.none
            attr |= MMU_PTE_ATTR_AP_P_RW_U_RW;
ffffffffea803b74:	b27a0066 	orr	x6, x3, #0x40
ffffffffea803b78:	710010bf 	cmp	w5, #0x4
ffffffffea803b7c:	9a8300c3 	csel	x3, x6, x3, eq  // eq = none
        attr |= MMU_PTE_ATTR_UXN | MMU_PTE_ATTR_PXN;
ffffffffea803b80:	f27c009f 	tst	x4, #0x10
ffffffffea803b84:	b24b0465 	orr	x5, x3, #0x60000000000000
ffffffffea803b88:	9a8310a3 	csel	x3, x5, x3, ne  // ne = any
            attr |= MMU_PTE_ATTR_NON_SECURE;
ffffffffea803b8c:	f27b009f 	tst	x4, #0x20
ffffffffea803b90:	b27b0064 	orr	x4, x3, #0x20
ffffffffea803b94:	9a831083 	csel	x3, x4, x3, ne  // ne = any
ffffffffea803b98:	14000002 	b	ffffffffea803ba0 <arch_mmu_map+0x70>
            return ERR_INVALID_ARGS;
ffffffffea803b9c:	928000e3 	mov	x3, #0xfffffffffffffff8    	// #-8
    return arm64_mmu_map(vaddr, paddr, count * PAGE_SIZE,
ffffffffea803ba0:	12800005 	mov	w5, #0xffffffff            	// #-1
ffffffffea803ba4:	f0000244 	adrp	x4, ffffffffea84e000 <arm64_kernel_translation_table>
ffffffffea803ba8:	b9000be5 	str	w5, [sp, #8]
ffffffffea803bac:	91000084 	add	x4, x4, #0x0
ffffffffea803bb0:	f90003e4 	str	x4, [sp]
ffffffffea803bb4:	52800187 	mov	w7, #0xc                   	// #12
ffffffffea803bb8:	528002a6 	mov	w6, #0x15                  	// #21
ffffffffea803bbc:	528003a5 	mov	w5, #0x1d                  	// #29
ffffffffea803bc0:	b2638be4 	mov	x4, #0xffffffffe0000000    	// #-536870912
ffffffffea803bc4:	97ffff83 	bl	ffffffffea8039d0 <arm64_mmu_map>
                         mmu_flags_to_pte_attr(flags),
                         ~0UL << MMU_KERNEL_SIZE_SHIFT, MMU_KERNEL_SIZE_SHIFT,
                         MMU_KERNEL_TOP_SHIFT, MMU_KERNEL_PAGE_SIZE_SHIFT,
                         arm64_kernel_translation_table, MMU_ARM64_GLOBAL_ASID);
}
ffffffffea803bc8:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea803bcc:	910083ff 	add	sp, sp, #0x20
ffffffffea803bd0:	d65f03c0 	ret
    switch (flags & (ARCH_MMU_FLAG_PERM_USER | ARCH_MMU_FLAG_PERM_RO)) {
ffffffffea803bd4:	121e0485 	and	w5, w4, #0xc
            attr |= MMU_PTE_ATTR_NORMAL_MEMORY | MMU_PTE_ATTR_SH_INNER_SHAREABLE;
ffffffffea803bd8:	d280e103 	mov	x3, #0x708                 	// #1800
    switch (flags & (ARCH_MMU_FLAG_PERM_USER | ARCH_MMU_FLAG_PERM_RO)) {
ffffffffea803bdc:	710020bf 	cmp	w5, #0x8
ffffffffea803be0:	54fffc61 	b.ne	ffffffffea803b6c <arch_mmu_map+0x3c>  // b.any
            attr |= MMU_PTE_ATTR_AP_P_RO_U_NA;
ffffffffea803be4:	b2790063 	orr	x3, x3, #0x80
ffffffffea803be8:	17ffffe6 	b	ffffffffea803b80 <arch_mmu_map+0x50>
            attr |= MMU_PTE_ATTR_STRONGLY_ORDERED;
ffffffffea803bec:	d2808003 	mov	x3, #0x400                 	// #1024
ffffffffea803bf0:	17ffffdc 	b	ffffffffea803b60 <arch_mmu_map+0x30>
            attr |= MMU_PTE_ATTR_AP_P_RO_U_RO;
ffffffffea803bf4:	b27a0463 	orr	x3, x3, #0xc0
ffffffffea803bf8:	17ffffe2 	b	ffffffffea803b80 <arch_mmu_map+0x50>
ffffffffea803bfc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803c00 <arch_mmu_unmap>:

int arch_mmu_unmap(vaddr_t vaddr, uint count)
{
    return arm64_mmu_unmap(vaddr, count * PAGE_SIZE,
ffffffffea803c00:	f0000246 	adrp	x6, ffffffffea84e000 <arm64_kernel_translation_table>
ffffffffea803c04:	12800007 	mov	w7, #0xffffffff            	// #-1
ffffffffea803c08:	910000c6 	add	x6, x6, #0x0
ffffffffea803c0c:	52800185 	mov	w5, #0xc                   	// #12
ffffffffea803c10:	528002a4 	mov	w4, #0x15                  	// #21
ffffffffea803c14:	528003a3 	mov	w3, #0x1d                  	// #29
ffffffffea803c18:	b2638be2 	mov	x2, #0xffffffffe0000000    	// #-536870912
ffffffffea803c1c:	d3747c21 	ubfiz	x1, x1, #12, #32
ffffffffea803c20:	17ffff9a 	b	ffffffffea803a88 <arm64_mmu_unmap>
ffffffffea803c24:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803c28 <lk_init_level>:

extern const struct lk_init_struct __lk_init[];
extern const struct lk_init_struct __lk_init_end[];

void lk_init_level(enum lk_init_flags required_flag, uint start_level, uint stop_level)
{
ffffffffea803c28:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea803c2c:	910003fd 	mov	x29, sp
ffffffffea803c30:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea803c34:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea803c38:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea803c3c:	f90023f9 	str	x25, [sp, #64]
    LTRACEF("flags %#x, start_level %#x, stop_level %#x\n",
            required_flag, start_level, stop_level);

    ASSERT(start_level > 0);
ffffffffea803c40:	34000781 	cbz	w1, ffffffffea803d30 <lk_init_level+0x108>
ffffffffea803c44:	b00000b9 	adrp	x25, ffffffffea818000 <__func__.2340+0xc8>
ffffffffea803c48:	b00000b4 	adrp	x20, ffffffffea818000 <__func__.2340+0xc8>
        /* search for the lowest uncalled hook to call */
        LTRACEF("last %p, last_called_level %#x\n", last, last_called_level);

        const struct lk_init_struct *found = NULL;
        bool seen_last = false;
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
ffffffffea803c4c:	91040339 	add	x25, x25, #0x100
ffffffffea803c50:	910b2294 	add	x20, x20, #0x2c8
ffffffffea803c54:	2a0003f5 	mov	w21, w0
ffffffffea803c58:	2a0103f8 	mov	w24, w1
ffffffffea803c5c:	2a0203f7 	mov	w23, w2
    uint last_called_level = start_level - 1;
ffffffffea803c60:	51000425 	sub	w5, w1, #0x1
    const struct lk_init_struct *last = NULL;
ffffffffea803c64:	d2800013 	mov	x19, #0x0                   	// #0
            LTRACEF("looking at %p (%s) level %#x, flags %#x, seen_last %d\n", ptr, ptr->name, ptr->level, ptr->flags, seen_last);

            if (ptr == last)
                seen_last = true;
ffffffffea803c68:	52800036 	mov	w22, #0x1                   	// #1
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
ffffffffea803c6c:	eb14033f 	cmp	x25, x20
ffffffffea803c70:	54000500 	b.eq	ffffffffea803d10 <lk_init_level+0xe8>  // b.none
ffffffffea803c74:	d503201f 	nop
ffffffffea803c78:	aa1903e3 	mov	x3, x25
        bool seen_last = false;
ffffffffea803c7c:	52800004 	mov	w4, #0x0                   	// #0
        const struct lk_init_struct *found = NULL;
ffffffffea803c80:	d2800006 	mov	x6, #0x0                   	// #0
ffffffffea803c84:	14000004 	b	ffffffffea803c94 <lk_init_level+0x6c>
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
ffffffffea803c88:	91006063 	add	x3, x3, #0x18
ffffffffea803c8c:	eb14007f 	cmp	x3, x20
ffffffffea803c90:	54000300 	b.eq	ffffffffea803cf0 <lk_init_level+0xc8>  // b.none

            /* reject the easy ones */
            if (!(ptr->flags & required_flag))
ffffffffea803c94:	b9400460 	ldr	w0, [x3, #4]
                seen_last = true;
ffffffffea803c98:	eb03027f 	cmp	x19, x3
ffffffffea803c9c:	1a961084 	csel	w4, w4, w22, ne  // ne = any
            if (!(ptr->flags & required_flag))
ffffffffea803ca0:	6a0002bf 	tst	w21, w0
ffffffffea803ca4:	54ffff20 	b.eq	ffffffffea803c88 <lk_init_level+0x60>  // b.none
                continue;
            if (ptr->level > stop_level)
ffffffffea803ca8:	b9400060 	ldr	w0, [x3]
                continue;
            if (ptr->level < last_called_level)
ffffffffea803cac:	6b0000bf 	cmp	w5, w0
ffffffffea803cb0:	7a579002 	ccmp	w0, w23, #0x2, ls  // ls = plast
ffffffffea803cb4:	54fffea8 	b.hi	ffffffffea803c88 <lk_init_level+0x60>  // b.pmore
                continue;
            if (found && found->level <= ptr->level)
ffffffffea803cb8:	b4000086 	cbz	x6, ffffffffea803cc8 <lk_init_level+0xa0>
ffffffffea803cbc:	b94000c2 	ldr	w2, [x6]
ffffffffea803cc0:	6b02001f 	cmp	w0, w2
ffffffffea803cc4:	54fffe22 	b.cs	ffffffffea803c88 <lk_init_level+0x60>  // b.hs, b.nlast
                continue;

            /* keep the lowest one we haven't called yet */
            if (ptr->level >= start_level && ptr->level > last_called_level) {
ffffffffea803cc8:	6b0000bf 	cmp	w5, w0
ffffffffea803ccc:	7a583000 	ccmp	w0, w24, #0x0, cc  // cc = lo, ul, last
ffffffffea803cd0:	540002c2 	b.cs	ffffffffea803d28 <lk_init_level+0x100>  // b.hs, b.nlast

            /* if we're at the same level as the last one we called and we've
             * already passed over it this time around, we can mark this one
             * and early terminate the loop.
             */
            if (ptr->level == last_called_level && ptr != last && seen_last) {
ffffffffea803cd4:	6b0000bf 	cmp	w5, w0
ffffffffea803cd8:	54fffd81 	b.ne	ffffffffea803c88 <lk_init_level+0x60>  // b.any
ffffffffea803cdc:	7100009f 	cmp	w4, #0x0
ffffffffea803ce0:	fa431264 	ccmp	x19, x3, #0x4, ne  // ne = any
ffffffffea803ce4:	54fffd20 	b.eq	ffffffffea803c88 <lk_init_level+0x60>  // b.none
ffffffffea803ce8:	aa0303f3 	mov	x19, x3
ffffffffea803cec:	14000004 	b	ffffffffea803cfc <lk_init_level+0xd4>
                found = ptr;
                break;
            }
        }

        if (!found)
ffffffffea803cf0:	b4000106 	cbz	x6, ffffffffea803d10 <lk_init_level+0xe8>
ffffffffea803cf4:	b94000c0 	ldr	w0, [x6]
ffffffffea803cf8:	aa0603f3 	mov	x19, x6
        if (found->level >= EARLIEST_TRACE_LEVEL) {
            printf("INIT: cpu %d, calling hook %p (%s) at level %#x, flags %#x\n",
                   arch_curr_cpu_num(), found->hook, found->name, found->level, found->flags);
        }
#endif
        found->hook(found->level);
ffffffffea803cfc:	f9400661 	ldr	x1, [x19, #8]
ffffffffea803d00:	d63f0020 	blr	x1
        last_called_level = found->level;
ffffffffea803d04:	b9400265 	ldr	w5, [x19]
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
ffffffffea803d08:	eb14033f 	cmp	x25, x20
ffffffffea803d0c:	54fffb61 	b.ne	ffffffffea803c78 <lk_init_level+0x50>  // b.any
        last = found;
    }
}
ffffffffea803d10:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea803d14:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea803d18:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea803d1c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea803d20:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea803d24:	d65f03c0 	ret
ffffffffea803d28:	aa0303e6 	mov	x6, x3
ffffffffea803d2c:	17ffffd7 	b	ffffffffea803c88 <lk_init_level+0x60>
    ASSERT(start_level > 0);
ffffffffea803d30:	d0000084 	adrp	x4, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803d34:	d0000082 	adrp	x2, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803d38:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803d3c:	91350084 	add	x4, x4, #0xd40
ffffffffea803d40:	52800663 	mov	w3, #0x33                  	// #51
ffffffffea803d44:	91354042 	add	x2, x2, #0xd50
ffffffffea803d48:	9135a021 	add	x1, x1, #0xd68
ffffffffea803d4c:	aa1e03e0 	mov	x0, x30
ffffffffea803d50:	940037d2 	bl	ffffffffea811c98 <_panic>
ffffffffea803d54:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803d58 <bootstrap2>:
	// become the idle thread and enable interrupts to start the scheduler
	thread_become_idle();
}

static int bootstrap2(void *arg)
{
ffffffffea803d58:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	dprintf(SPEW, "top of bootstrap2()\n");
ffffffffea803d5c:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803d60:	91362000 	add	x0, x0, #0xd88
{
ffffffffea803d64:	910003fd 	mov	x29, sp
	dprintf(SPEW, "top of bootstrap2()\n");
ffffffffea803d68:	9400374e 	bl	ffffffffea811aa0 <_dprintf>
};

void lk_init_level(enum lk_init_flags flags, uint start_level, uint stop_level);

static inline void lk_primary_cpu_init_level(uint start_level, uint stop_level) {
	lk_init_level(LK_INIT_FLAG_PRIMARY_CPU, start_level, stop_level);
ffffffffea803d6c:	12bfff02 	mov	w2, #0x7ffff               	// #524287
ffffffffea803d70:	52a000e1 	mov	w1, #0x70000               	// #458752
ffffffffea803d74:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803d78:	97ffffac 	bl	ffffffffea803c28 <lk_init_level>

	lk_primary_cpu_init_level(LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_ARCH - 1);
	arch_init();
ffffffffea803d7c:	97fffb5d 	bl	ffffffffea802af0 <arch_init>

	// initialize the rest of the platform
	dprintf(0, "initializing platform at trusty\n");
ffffffffea803d80:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803d84:	91368000 	add	x0, x0, #0xda0
ffffffffea803d88:	94003746 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea803d8c:	12bffee2 	mov	w2, #0x8ffff               	// #589823
ffffffffea803d90:	52a00101 	mov	w1, #0x80000               	// #524288
ffffffffea803d94:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803d98:	97ffffa4 	bl	ffffffffea803c28 <lk_init_level>
	lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH, LK_INIT_LEVEL_PLATFORM - 1);
	platform_init();
ffffffffea803d9c:	97fff74d 	bl	ffffffffea801ad0 <platform_init>
	tegra_boot_profiler_record("bootstrap2: platform_init done");
ffffffffea803da0:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803da4:	91372000 	add	x0, x0, #0xdc8
ffffffffea803da8:	94000e42 	bl	ffffffffea8076b0 <tegra_boot_profiler_record>

	// initialize the target
	dprintf(SPEW, "initializing target at trusty\n");
ffffffffea803dac:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803db0:	9137a000 	add	x0, x0, #0xde8
ffffffffea803db4:	9400373b 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea803db8:	12bffec2 	mov	w2, #0x9ffff               	// #655359
ffffffffea803dbc:	52a00121 	mov	w1, #0x90000               	// #589824
ffffffffea803dc0:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803dc4:	97ffff99 	bl	ffffffffea803c28 <lk_init_level>
	lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM, LK_INIT_LEVEL_TARGET - 1);
	target_init();
ffffffffea803dc8:	940031bc 	bl	ffffffffea8104b8 <target_init>
	tegra_boot_profiler_record("bootstrap2: target_init done");
ffffffffea803dcc:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803dd0:	91382000 	add	x0, x0, #0xe08
ffffffffea803dd4:	94000e37 	bl	ffffffffea8076b0 <tegra_boot_profiler_record>

	dprintf(SPEW, "calling apps_init()\n");
ffffffffea803dd8:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803ddc:	9138a000 	add	x0, x0, #0xe28
ffffffffea803de0:	94003730 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea803de4:	12bffea2 	mov	w2, #0xaffff               	// #720895
ffffffffea803de8:	52a00141 	mov	w1, #0xa0000               	// #655360
ffffffffea803dec:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803df0:	97ffff8e 	bl	ffffffffea803c28 <lk_init_level>
	lk_primary_cpu_init_level(LK_INIT_LEVEL_TARGET, LK_INIT_LEVEL_APPS - 1);
	apps_init();
ffffffffea803df4:	940000ef 	bl	ffffffffea8041b0 <apps_init>
	tegra_boot_profiler_record("bootstrap2: apps_init done");
ffffffffea803df8:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803dfc:	91390000 	add	x0, x0, #0xe40
ffffffffea803e00:	94000e2c 	bl	ffffffffea8076b0 <tegra_boot_profiler_record>
ffffffffea803e04:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea803e08:	52a00161 	mov	w1, #0xb0000               	// #720896
ffffffffea803e0c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803e10:	97ffff86 	bl	ffffffffea803c28 <lk_init_level>

	lk_primary_cpu_init_level(LK_INIT_LEVEL_APPS, LK_INIT_LEVEL_LAST);

	dprintf(SPEW, "calling platform_bootstrap_epilog\n");
ffffffffea803e14:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803e18:	91398000 	add	x0, x0, #0xe60
ffffffffea803e1c:	94003721 	bl	ffffffffea811aa0 <_dprintf>
	platform_bootstrap_epilog();
ffffffffea803e20:	97fff8f8 	bl	ffffffffea802200 <platform_bootstrap_epilog>

	return 0;
}
ffffffffea803e24:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea803e28:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea803e2c:	d65f03c0 	ret

ffffffffea803e30 <secondary_cpu_bootstrap2>:
	dprintf(SPEW, "entering scheduler on cpu %d\n", cpu);
	thread_secondary_cpu_entry();
}

static int secondary_cpu_bootstrap2(void *arg)
{
ffffffffea803e30:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	/* secondary cpu initialize from threading level up. 0 to threading was handled in arch */
	lk_init_level(LK_INIT_FLAG_SECONDARY_CPUS, LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_LAST);
ffffffffea803e34:	52800040 	mov	w0, #0x2                   	// #2
ffffffffea803e38:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea803e3c:	52a000e1 	mov	w1, #0x70000               	// #458752
{
ffffffffea803e40:	910003fd 	mov	x29, sp
	lk_init_level(LK_INIT_FLAG_SECONDARY_CPUS, LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_LAST);
ffffffffea803e44:	97ffff79 	bl	ffffffffea803c28 <lk_init_level>

	return 0;
}
ffffffffea803e48:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea803e4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea803e50:	d65f03c0 	ret
ffffffffea803e54:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803e58 <lk_main>:
{
ffffffffea803e58:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea803e5c:	910003fd 	mov	x29, sp
ffffffffea803e60:	a90153f3 	stp	x19, x20, [sp, #16]
	lk_boot_args[0] = arg0;
ffffffffea803e64:	f00002d4 	adrp	x20, ffffffffea85e000 <rb_data+0x18>
ffffffffea803e68:	91010293 	add	x19, x20, #0x40
{
ffffffffea803e6c:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea803e70:	a90363f7 	stp	x23, x24, [sp, #48]
	lk_boot_args[0] = arg0;
ffffffffea803e74:	f9002280 	str	x0, [x20, #64]
	lk_boot_args[2] = arg2;
ffffffffea803e78:	a9008a61 	stp	x1, x2, [x19, #8]
	lk_boot_args[3] = arg3;
ffffffffea803e7c:	f9000e63 	str	x3, [x19, #24]
	early_tstamps.start = tegra_boot_profiler_get_timestamp();
ffffffffea803e80:	94000e0a 	bl	ffffffffea8076a8 <tegra_boot_profiler_get_timestamp>
ffffffffea803e84:	2a0003f8 	mov	w24, w0
	thread_init_early();
ffffffffea803e88:	940009f2 	bl	ffffffffea806650 <thread_init_early>
ffffffffea803e8c:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea803e90:	2a0103e0 	mov	w0, w1
ffffffffea803e94:	529fffe2 	mov	w2, #0xffff                	// #65535
ffffffffea803e98:	97ffff64 	bl	ffffffffea803c28 <lk_init_level>
	arch_early_init();
ffffffffea803e9c:	97fffb05 	bl	ffffffffea802ab0 <arch_early_init>
	early_tstamps.arch_init = tegra_boot_profiler_get_timestamp();
ffffffffea803ea0:	94000e02 	bl	ffffffffea8076a8 <tegra_boot_profiler_get_timestamp>
ffffffffea803ea4:	2a0003f7 	mov	w23, w0
ffffffffea803ea8:	12bfffc2 	mov	w2, #0x1ffff               	// #131071
ffffffffea803eac:	52a00021 	mov	w1, #0x10000               	// #65536
ffffffffea803eb0:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803eb4:	97ffff5d 	bl	ffffffffea803c28 <lk_init_level>
	platform_early_init();
ffffffffea803eb8:	97fff702 	bl	ffffffffea801ac0 <platform_early_init>
	early_tstamps.platform_init = tegra_boot_profiler_get_timestamp();
ffffffffea803ebc:	94000dfb 	bl	ffffffffea8076a8 <tegra_boot_profiler_get_timestamp>
ffffffffea803ec0:	2a0003f6 	mov	w22, w0
ffffffffea803ec4:	12bfffa2 	mov	w2, #0x2ffff               	// #196607
ffffffffea803ec8:	52a00041 	mov	w1, #0x20000               	// #131072
ffffffffea803ecc:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803ed0:	97ffff56 	bl	ffffffffea803c28 <lk_init_level>
	target_early_init();
ffffffffea803ed4:	94003177 	bl	ffffffffea8104b0 <target_early_init>
	early_tstamps.target_init = tegra_boot_profiler_get_timestamp();
ffffffffea803ed8:	94000df4 	bl	ffffffffea8076a8 <tegra_boot_profiler_get_timestamp>
ffffffffea803edc:	2a0003f5 	mov	w21, w0
	dprintf(INFO, "\nwelcome to lk/MP\n\n");
ffffffffea803ee0:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803ee4:	913c4000 	add	x0, x0, #0xf10
ffffffffea803ee8:	940036ee 	bl	ffffffffea811aa0 <_dprintf>
	dprintf(INFO, "boot args 0x%lx 0x%lx 0x%lx 0x%lx\n",
ffffffffea803eec:	f9402281 	ldr	x1, [x20, #64]
ffffffffea803ef0:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803ef4:	a9408e62 	ldp	x2, x3, [x19, #8]
ffffffffea803ef8:	913ca000 	add	x0, x0, #0xf28
ffffffffea803efc:	f9400e64 	ldr	x4, [x19, #24]
	while (ctor != &__ctor_end) {
ffffffffea803f00:	d0000254 	adrp	x20, ffffffffea84d000 <__ctor_list>
	dprintf(INFO, "boot args 0x%lx 0x%lx 0x%lx 0x%lx\n",
ffffffffea803f04:	940036e7 	bl	ffffffffea811aa0 <_dprintf>
	dprintf(SPEW, "calling constructors\n");
ffffffffea803f08:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803f0c:	913d4000 	add	x0, x0, #0xf50
ffffffffea803f10:	940036e4 	bl	ffffffffea811aa0 <_dprintf>
	while (ctor != &__ctor_end) {
ffffffffea803f14:	d0000240 	adrp	x0, ffffffffea84d000 <__ctor_list>
ffffffffea803f18:	91000281 	add	x1, x20, #0x0
ffffffffea803f1c:	91002000 	add	x0, x0, #0x8
ffffffffea803f20:	eb00003f 	cmp	x1, x0
ffffffffea803f24:	540001a0 	b.eq	ffffffffea803f58 <lk_main+0x100>  // b.none
ffffffffea803f28:	d0000254 	adrp	x20, ffffffffea84d000 <__ctor_list>
ffffffffea803f2c:	91002294 	add	x20, x20, #0x8
ffffffffea803f30:	cb140014 	sub	x20, x0, x20
	ctor = &__ctor_list;
ffffffffea803f34:	aa0103f3 	mov	x19, x1
ffffffffea803f38:	927df294 	and	x20, x20, #0xfffffffffffffff8
ffffffffea803f3c:	91002294 	add	x20, x20, #0x8
ffffffffea803f40:	8b010294 	add	x20, x20, x1
ffffffffea803f44:	d503201f 	nop
		func();
ffffffffea803f48:	f8408660 	ldr	x0, [x19], #8
ffffffffea803f4c:	d63f0000 	blr	x0
	while (ctor != &__ctor_end) {
ffffffffea803f50:	eb14027f 	cmp	x19, x20
ffffffffea803f54:	54ffffa1 	b.ne	ffffffffea803f48 <lk_main+0xf0>  // b.any
	dprintf(SPEW, "initializing heap\n");
ffffffffea803f58:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803f5c:	913da000 	add	x0, x0, #0xf68
ffffffffea803f60:	940036d0 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea803f64:	12bfff82 	mov	w2, #0x3ffff               	// #262143
ffffffffea803f68:	52a00061 	mov	w1, #0x30000               	// #196608
ffffffffea803f6c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803f70:	97ffff2e 	bl	ffffffffea803c28 <lk_init_level>
	heap_init();
ffffffffea803f74:	9400390b 	bl	ffffffffea8123a0 <heap_init>
ffffffffea803f78:	12bfff42 	mov	w2, #0x5ffff               	// #393215
ffffffffea803f7c:	52a00081 	mov	w1, #0x40000               	// #262144
ffffffffea803f80:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803f84:	97ffff29 	bl	ffffffffea803c28 <lk_init_level>
	kernel_init();
ffffffffea803f88:	94000670 	bl	ffffffffea805948 <kernel_init>
	early_tstamps.kernel_init = tegra_boot_profiler_get_timestamp();
ffffffffea803f8c:	94000dc7 	bl	ffffffffea8076a8 <tegra_boot_profiler_get_timestamp>
ffffffffea803f90:	2a0003f3 	mov	w19, w0
ffffffffea803f94:	12bfff22 	mov	w2, #0x6ffff               	// #458751
ffffffffea803f98:	52a000c1 	mov	w1, #0x60000               	// #393216
ffffffffea803f9c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803fa0:	97ffff22 	bl	ffffffffea803c28 <lk_init_level>
	tegra_boot_profiler_init(NULL);
ffffffffea803fa4:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea803fa8:	94000dbc 	bl	ffffffffea807698 <tegra_boot_profiler_init>
	tegra_boot_profiler_prerecorded("lk_main: start", tstamp.start);
ffffffffea803fac:	2a1803e1 	mov	w1, w24
ffffffffea803fb0:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803fb4:	913e0000 	add	x0, x0, #0xf80
ffffffffea803fb8:	94000dc0 	bl	ffffffffea8076b8 <tegra_boot_profiler_prerecorded>
	tegra_boot_profiler_prerecorded("lk_main: arch_early_init", tstamp.arch_init);
ffffffffea803fbc:	2a1703e1 	mov	w1, w23
ffffffffea803fc0:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803fc4:	913e4000 	add	x0, x0, #0xf90
ffffffffea803fc8:	94000dbc 	bl	ffffffffea8076b8 <tegra_boot_profiler_prerecorded>
	tegra_boot_profiler_prerecorded("lk_main: platform_early_init", tstamp.platform_init);
ffffffffea803fcc:	2a1603e1 	mov	w1, w22
ffffffffea803fd0:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803fd4:	913ec000 	add	x0, x0, #0xfb0
ffffffffea803fd8:	94000db8 	bl	ffffffffea8076b8 <tegra_boot_profiler_prerecorded>
	tegra_boot_profiler_prerecorded("lk_main: target_early_init", tstamp.target_init);
ffffffffea803fdc:	2a1503e1 	mov	w1, w21
ffffffffea803fe0:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803fe4:	913f4000 	add	x0, x0, #0xfd0
ffffffffea803fe8:	94000db4 	bl	ffffffffea8076b8 <tegra_boot_profiler_prerecorded>
	tegra_boot_profiler_prerecorded("lk_main: kernel_init", tstamp.kernel_init);
ffffffffea803fec:	2a1303e1 	mov	w1, w19
ffffffffea803ff0:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803ff4:	913fc000 	add	x0, x0, #0xff0
ffffffffea803ff8:	94000db0 	bl	ffffffffea8076b8 <tegra_boot_profiler_prerecorded>
	dprintf(SPEW, "creating bootstrap completion thread\n");
ffffffffea803ffc:	f0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804000:	91002000 	add	x0, x0, #0x8
ffffffffea804004:	940036a7 	bl	ffffffffea811aa0 <_dprintf>
	thread_t *t = thread_create("bootstrap2", &bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
ffffffffea804008:	f0ffffe1 	adrp	x1, ffffffffea803000 <arch_thread_initialize+0x40>
ffffffffea80400c:	91356021 	add	x1, x1, #0xd58
ffffffffea804010:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea804014:	52800203 	mov	w3, #0x10                  	// #16
ffffffffea804018:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea80401c:	d0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804020:	9100c000 	add	x0, x0, #0x30
ffffffffea804024:	9400087d 	bl	ffffffffea806218 <thread_create>
	t->pinned_cpu = 0;
ffffffffea804028:	b9003c1f 	str	wzr, [x0, #60]
	thread_t *t = thread_create("bootstrap2", &bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
ffffffffea80402c:	aa0003f3 	mov	x19, x0
	thread_detach(t);
ffffffffea804030:	94000b90 	bl	ffffffffea806e70 <thread_detach>
	thread_resume(t);
ffffffffea804034:	aa1303e0 	mov	x0, x19
ffffffffea804038:	940008d8 	bl	ffffffffea806398 <thread_resume>
	thread_become_idle();
ffffffffea80403c:	940009c3 	bl	ffffffffea806748 <thread_become_idle>

ffffffffea804040 <lk_secondary_cpu_entry>:
{
ffffffffea804040:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea804044:	910003fd 	mov	x29, sp
	uint cpu = arch_curr_cpu_num();
ffffffffea804048:	97fffa98 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea80404c:	2a0003e1 	mov	w1, w0
	if (cpu > secondary_bootstrap_thread_count) {
ffffffffea804050:	900002a0 	adrp	x0, ffffffffea858000 <__bss_start>
ffffffffea804054:	b9406803 	ldr	w3, [x0, #104]
ffffffffea804058:	6b01007f 	cmp	w3, w1
ffffffffea80405c:	540000c2 	b.cs	ffffffffea804074 <lk_secondary_cpu_entry+0x34>  // b.hs, b.nlast
}
ffffffffea804060:	a8c27bfd 	ldp	x29, x30, [sp], #32
		dprintf(CRITICAL, "Invalid secondary cpu num %d, SMP_MAX_CPUS %d, secondary_bootstrap_thread_count %d\n",
ffffffffea804064:	d0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804068:	52800102 	mov	w2, #0x8                   	// #8
ffffffffea80406c:	91010000 	add	x0, x0, #0x40
ffffffffea804070:	1400368c 	b	ffffffffea811aa0 <_dprintf>
ffffffffea804074:	b9001fa1 	str	w1, [x29, #28]
	thread_secondary_cpu_init_early();
ffffffffea804078:	940009da 	bl	ffffffffea8067e0 <thread_secondary_cpu_init_early>
	thread_resume(secondary_bootstrap_threads[cpu - 1]);
ffffffffea80407c:	b9401fa1 	ldr	w1, [x29, #28]
ffffffffea804080:	900002a0 	adrp	x0, ffffffffea858000 <__bss_start>
ffffffffea804084:	9101c000 	add	x0, x0, #0x70
ffffffffea804088:	b9001fa1 	str	w1, [x29, #28]
ffffffffea80408c:	51000422 	sub	w2, w1, #0x1
ffffffffea804090:	f8627800 	ldr	x0, [x0, x2, lsl #3]
ffffffffea804094:	940008c1 	bl	ffffffffea806398 <thread_resume>
	dprintf(SPEW, "entering scheduler on cpu %d\n", cpu);
ffffffffea804098:	b9401fa1 	ldr	w1, [x29, #28]
ffffffffea80409c:	d0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8040a0:	91026000 	add	x0, x0, #0x98
ffffffffea8040a4:	9400367f 	bl	ffffffffea811aa0 <_dprintf>
	thread_secondary_cpu_entry();
ffffffffea8040a8:	94000a16 	bl	ffffffffea806900 <thread_secondary_cpu_entry>
ffffffffea8040ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8040b0 <lk_init_secondary_cpus>:

void lk_init_secondary_cpus(uint secondary_cpu_count)
{
ffffffffea8040b0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	if (secondary_cpu_count >= SMP_MAX_CPUS) {
ffffffffea8040b4:	71001c1f 	cmp	w0, #0x7
{
ffffffffea8040b8:	910003fd 	mov	x29, sp
ffffffffea8040bc:	f90017f6 	str	x22, [sp, #40]
ffffffffea8040c0:	2a0003f6 	mov	w22, w0
	if (secondary_cpu_count >= SMP_MAX_CPUS) {
ffffffffea8040c4:	54000508 	b.hi	ffffffffea804164 <lk_init_secondary_cpus+0xb4>  // b.pmore
		dprintf(CRITICAL, "Invalid secondary_cpu_count %d, SMP_MAX_CPUS %d\n",
			secondary_cpu_count, SMP_MAX_CPUS);
		secondary_cpu_count = SMP_MAX_CPUS - 1;
	}
	for (uint i = 0; i < secondary_cpu_count; i++) {
ffffffffea8040c8:	34000440 	cbz	w0, ffffffffea804150 <lk_init_secondary_cpus+0xa0>
ffffffffea8040cc:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea8040d0:	f90013b5 	str	x21, [x29, #32]
ffffffffea8040d4:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea8040d8:	f90023b9 	str	x25, [x29, #64]
ffffffffea8040dc:	900002b5 	adrp	x21, ffffffffea858000 <__bss_start>
ffffffffea8040e0:	b0000099 	adrp	x25, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8040e4:	f0fffff8 	adrp	x24, ffffffffea803000 <arch_thread_initialize+0x40>
ffffffffea8040e8:	b0000097 	adrp	x23, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8040ec:	9101c2b5 	add	x21, x21, #0x70
		dprintf(SPEW, "creating bootstrap completion thread for cpu %d\n", i + 1);
ffffffffea8040f0:	913b0339 	add	x25, x25, #0xec0
		thread_t *t = thread_create("secondarybootstrap2",
ffffffffea8040f4:	9138c318 	add	x24, x24, #0xe30
ffffffffea8040f8:	913be2f7 	add	x23, x23, #0xef8
		secondary_cpu_count = SMP_MAX_CPUS - 1;
ffffffffea8040fc:	52800013 	mov	w19, #0x0                   	// #0
		dprintf(SPEW, "creating bootstrap completion thread for cpu %d\n", i + 1);
ffffffffea804100:	11000673 	add	w19, w19, #0x1
ffffffffea804104:	aa1903e0 	mov	x0, x25
ffffffffea804108:	2a1303e1 	mov	w1, w19
ffffffffea80410c:	94003665 	bl	ffffffffea811aa0 <_dprintf>
		thread_t *t = thread_create("secondarybootstrap2",
ffffffffea804110:	aa1803e1 	mov	x1, x24
ffffffffea804114:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea804118:	52800203 	mov	w3, #0x10                  	// #16
ffffffffea80411c:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea804120:	aa1703e0 	mov	x0, x23
ffffffffea804124:	9400083d 	bl	ffffffffea806218 <thread_create>
					    &secondary_cpu_bootstrap2, NULL,
					    DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
		t->pinned_cpu = i + 1;
ffffffffea804128:	b9003c13 	str	w19, [x0, #60]
		thread_t *t = thread_create("secondarybootstrap2",
ffffffffea80412c:	aa0003f4 	mov	x20, x0
		thread_detach(t);
ffffffffea804130:	94000b50 	bl	ffffffffea806e70 <thread_detach>
		secondary_bootstrap_threads[i] = t;
ffffffffea804134:	f80086b4 	str	x20, [x21], #8
	for (uint i = 0; i < secondary_cpu_count; i++) {
ffffffffea804138:	6b16027f 	cmp	w19, w22
ffffffffea80413c:	54fffe23 	b.cc	ffffffffea804100 <lk_init_secondary_cpus+0x50>  // b.lo, b.ul, b.last
ffffffffea804140:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea804144:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea804148:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80414c:	f94023b9 	ldr	x25, [x29, #64]
	}
	secondary_bootstrap_thread_count = secondary_cpu_count;
ffffffffea804150:	900002a0 	adrp	x0, ffffffffea858000 <__bss_start>
ffffffffea804154:	b9006816 	str	w22, [x0, #104]
}
ffffffffea804158:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80415c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea804160:	d65f03c0 	ret
		dprintf(CRITICAL, "Invalid secondary_cpu_count %d, SMP_MAX_CPUS %d\n",
ffffffffea804164:	2a0003e1 	mov	w1, w0
ffffffffea804168:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80416c:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea804170:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804174:	52800102 	mov	w2, #0x8                   	// #8
		secondary_cpu_count = SMP_MAX_CPUS - 1;
ffffffffea804178:	528000f6 	mov	w22, #0x7                   	// #7
ffffffffea80417c:	f90013b5 	str	x21, [x29, #32]
		dprintf(CRITICAL, "Invalid secondary_cpu_count %d, SMP_MAX_CPUS %d\n",
ffffffffea804180:	913a2000 	add	x0, x0, #0xe88
ffffffffea804184:	f90023b9 	str	x25, [x29, #64]
ffffffffea804188:	94003646 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea80418c:	17ffffd4 	b	ffffffffea8040dc <lk_init_secondary_cpus+0x2c>

ffffffffea804190 <app_thread_entry>:
		}
	}
}

static int app_thread_entry(void *arg)
{
ffffffffea804190:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	const struct app_descriptor *app = (const struct app_descriptor *)arg;

	app->entry(app, NULL);
ffffffffea804194:	d2800001 	mov	x1, #0x0                   	// #0
{
ffffffffea804198:	910003fd 	mov	x29, sp
	app->entry(app, NULL);
ffffffffea80419c:	f9400802 	ldr	x2, [x0, #16]
ffffffffea8041a0:	d63f0040 	blr	x2

	return 0;
}
ffffffffea8041a4:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8041a8:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8041ac:	d65f03c0 	ret

ffffffffea8041b0 <apps_init>:
{
ffffffffea8041b0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea8041b4:	b00000a0 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea8041b8:	913fa000 	add	x0, x0, #0xfe8
{
ffffffffea8041bc:	910003fd 	mov	x29, sp
ffffffffea8041c0:	f9000bf3 	str	x19, [sp, #16]
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea8041c4:	b00000b3 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea8041c8:	913fa261 	add	x1, x19, #0xfe8
ffffffffea8041cc:	eb00003f 	cmp	x1, x0
ffffffffea8041d0:	54000760 	b.eq	ffffffffea8042bc <apps_init+0x10c>  // b.none
ffffffffea8041d4:	a901d7b4 	stp	x20, x21, [x29, #24]
ffffffffea8041d8:	d00000b5 	adrp	x21, ffffffffea81a000 <__trusty_app_start>
ffffffffea8041dc:	910042b5 	add	x21, x21, #0x10
ffffffffea8041e0:	aa0103f4 	mov	x20, x1
ffffffffea8041e4:	cb150015 	sub	x21, x0, x21
ffffffffea8041e8:	d29999a0 	mov	x0, #0xcccd                	// #52429
ffffffffea8041ec:	f2b99980 	movk	x0, #0xcccc, lsl #16
ffffffffea8041f0:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea8041f4:	f2d99980 	movk	x0, #0xcccc, lsl #32
ffffffffea8041f8:	d343feb5 	lsr	x21, x21, #3
ffffffffea8041fc:	f2e19980 	movk	x0, #0xccc, lsl #48
ffffffffea804200:	9b007eb5 	mul	x21, x21, x0
ffffffffea804204:	9240f2b5 	and	x21, x21, #0x1fffffffffffffff
ffffffffea804208:	910006b5 	add	x21, x21, #0x1
ffffffffea80420c:	8b150ab5 	add	x21, x21, x21, lsl #2
ffffffffea804210:	8b150c35 	add	x21, x1, x21, lsl #3
ffffffffea804214:	d503201f 	nop
		if (app->init)
ffffffffea804218:	f9400681 	ldr	x1, [x20, #8]
			app->init(app);
ffffffffea80421c:	aa1403e0 	mov	x0, x20
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea804220:	9100a294 	add	x20, x20, #0x28
		if (app->init)
ffffffffea804224:	b4000041 	cbz	x1, ffffffffea80422c <apps_init+0x7c>
			app->init(app);
ffffffffea804228:	d63f0020 	blr	x1
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea80422c:	eb15029f 	cmp	x20, x21
ffffffffea804230:	54ffff41 	b.ne	ffffffffea804218 <apps_init+0x68>  // b.any

static void start_app(const struct app_descriptor *app)
{
	uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;

	printf("starting app %s\n", app->name);
ffffffffea804234:	d0000096 	adrp	x22, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
	thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
ffffffffea804238:	90000015 	adrp	x21, ffffffffea804000 <lk_main+0x1a8>
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea80423c:	913fa273 	add	x19, x19, #0xfe8
	printf("starting app %s\n", app->name);
ffffffffea804240:	9102e2d6 	add	x22, x22, #0xb8
	thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
ffffffffea804244:	910642b5 	add	x21, x21, #0x190
ffffffffea804248:	14000004 	b	ffffffffea804258 <apps_init+0xa8>
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea80424c:	9100a273 	add	x19, x19, #0x28
ffffffffea804250:	eb14027f 	cmp	x19, x20
ffffffffea804254:	54000300 	b.eq	ffffffffea8042b4 <apps_init+0x104>  // b.none
		if (app->entry && (app->flags & APP_FLAG_DONT_START_ON_BOOT) == 0) {
ffffffffea804258:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80425c:	b4ffff80 	cbz	x0, ffffffffea80424c <apps_init+0x9c>
ffffffffea804260:	b9401a61 	ldr	w1, [x19, #24]
ffffffffea804264:	3707ff41 	tbnz	w1, #0, ffffffffea80424c <apps_init+0x9c>
	printf("starting app %s\n", app->name);
ffffffffea804268:	aa1603e0 	mov	x0, x22
	uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;
ffffffffea80426c:	d2820017 	mov	x23, #0x1000                	// #4096
ffffffffea804270:	36080041 	tbz	w1, #1, ffffffffea804278 <apps_init+0xc8>
ffffffffea804274:	b9402277 	ldr	w23, [x19, #32]
	printf("starting app %s\n", app->name);
ffffffffea804278:	f9400261 	ldr	x1, [x19]
ffffffffea80427c:	94003bed 	bl	ffffffffea813230 <_printf>
	thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
ffffffffea804280:	f9400260 	ldr	x0, [x19]
ffffffffea804284:	aa1703e4 	mov	x4, x23
ffffffffea804288:	aa1303e2 	mov	x2, x19
ffffffffea80428c:	aa1503e1 	mov	x1, x21
ffffffffea804290:	52800203 	mov	w3, #0x10                  	// #16
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea804294:	9100a273 	add	x19, x19, #0x28
	thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
ffffffffea804298:	940007e0 	bl	ffffffffea806218 <thread_create>
ffffffffea80429c:	aa0003f7 	mov	x23, x0
	thread_detach(t);
ffffffffea8042a0:	94000af4 	bl	ffffffffea806e70 <thread_detach>
	thread_resume(t);
ffffffffea8042a4:	aa1703e0 	mov	x0, x23
ffffffffea8042a8:	9400083c 	bl	ffffffffea806398 <thread_resume>
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea8042ac:	eb14027f 	cmp	x19, x20
ffffffffea8042b0:	54fffd41 	b.ne	ffffffffea804258 <apps_init+0xa8>  // b.any
ffffffffea8042b4:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea8042b8:	a942dfb6 	ldp	x22, x23, [x29, #40]
}
ffffffffea8042bc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8042c0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8042c4:	d65f03c0 	ret

ffffffffea8042c8 <arm_gic_init_percpu>:
}

static void arm_gic_init_percpu(uint level)
{
#if WITH_LIB_SM
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8042c8:	929bffe2 	mov	x2, #0xffffffffffff2000    	// #-57344
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea8042cc:	929defe1 	mov	x1, #0xffffffffffff1080    	// #-61312
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8042d0:	f2be2802 	movk	x2, #0xf140, lsl #16
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea8042d4:	f2be2801 	movk	x1, #0xf140, lsl #16
#else
	GICREG(0, GICC_CTLR) = 1; // enable GIC0
#endif
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea8042d8:	929bff60 	mov	x0, #0xffffffffffff2004    	// #-57340
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8042dc:	52800163 	mov	w3, #0xb                   	// #11
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea8042e0:	f2be2800 	movk	x0, #0xf140, lsl #16
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8042e4:	b9000043 	str	w3, [x2]
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea8042e8:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea8042ec:	b9000022 	str	w2, [x1]
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea8042f0:	52801fe1 	mov	w1, #0xff                  	// #255
ffffffffea8042f4:	b9000001 	str	w1, [x0]
}
ffffffffea8042f8:	d65f03c0 	ret
ffffffffea8042fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804300 <update_fiq_targets>:
}

static u_int current_fiq[8] = { 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff };

static bool update_fiq_targets(u_int cpu, bool enable, u_int triggered_fiq, bool resume_gicd)
{
ffffffffea804300:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	return (GICREG(0, GICD_TYPER) >> 5) & 0x7;
ffffffffea804304:	929dff64 	mov	x4, #0xffffffffffff1004    	// #-61436
ffffffffea804308:	f2be2804 	movk	x4, #0xf140, lsl #16
{
ffffffffea80430c:	910003fd 	mov	x29, sp
ffffffffea804310:	a90153f3 	stp	x19, x20, [sp, #16]
	u_int i, j;
	u_long mask;
	u_int fiq;
	bool smp = arm_gic_max_cpu() > 0;
	bool ret = false;
ffffffffea804314:	52800013 	mov	w19, #0x0                   	// #0
	return (GICREG(0, GICD_TYPER) >> 5) & 0x7;
ffffffffea804318:	b9400094 	ldr	w20, [x4]
{
ffffffffea80431c:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea804320:	12001c36 	and	w22, w1, #0xff
ffffffffea804324:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea804328:	2a0203f5 	mov	w21, w2
ffffffffea80432c:	12001c77 	and	w23, w3, #0xff
ffffffffea804330:	f90023f9 	str	x25, [sp, #64]
    arch_spin_lock(lock);
ffffffffea804334:	900002b8 	adrp	x24, ffffffffea858000 <__bss_start>
ffffffffea804338:	2a0003f9 	mov	w25, w0
ffffffffea80433c:	91046300 	add	x0, x24, #0x118
ffffffffea804340:	97fff956 	bl	ffffffffea802898 <arch_spin_lock>
			fiq = i * BITMAP_BITS_PER_WORD + j;
			if (fiq == triggered_fiq)
				ret = true;
			LTRACEF("cpu %d, irq %i, enable %d\n", cpu, fiq, enable);
			if (smp)
				arm_gic_set_target_locked(fiq, 1U << cpu, enable ? ~0 : 0);
ffffffffea804344:	5280002d 	mov	w13, #0x1                   	// #1
ffffffffea804348:	900002ae 	adrp	x14, ffffffffea858000 <__bss_start>
ffffffffea80434c:	1ad921ad 	lsl	w13, w13, w25
			mask &= ~(1UL << j);
ffffffffea804350:	d280002a 	mov	x10, #0x1                   	// #1
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804354:	b00000ab 	adrp	x11, ffffffffea819000 <_mem_phys_base>
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804358:	929fffe9 	mov	x9, #0xffffffffffff0000    	// #-65536
	return (GICREG(0, GICD_TYPER) >> 5) & 0x7;
ffffffffea80435c:	d3451e94 	ubfx	x20, x20, #5, #3
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804360:	12001dad 	and	w13, w13, #0xff
		mask = enabled_fiq_mask[i];
ffffffffea804364:	9102c1ce 	add	x14, x14, #0xb0
				ret = true;
ffffffffea804368:	2a0a03e2 	mov	w2, w10
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea80436c:	9108e16b 	add	x11, x11, #0x238
				arm_gic_set_target_locked(fiq, 1U << cpu, enable ? ~0 : 0);
ffffffffea804370:	4b1603e1 	neg	w1, w22
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804374:	d2800003 	mov	x3, #0x0                   	// #0
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804378:	f2be2809 	movk	x9, #0xf140, lsl #16
ffffffffea80437c:	d503201f 	nop
		mask = enabled_fiq_mask[i];
ffffffffea804380:	f86379c6 	ldr	x6, [x14, x3, lsl #3]
		while (mask) {
ffffffffea804384:	b4000386 	cbz	x6, ffffffffea8043f4 <update_fiq_targets+0xf4>
ffffffffea804388:	531a646c 	lsl	w12, w3, #6
ffffffffea80438c:	d503201f 	nop
}

/* find first zero bit starting from LSB */
static inline unsigned long _ffz(unsigned long x)
{
	return __builtin_ffsl(~x) - 1;
ffffffffea804390:	dac000c0 	rbit	x0, x6
ffffffffea804394:	f10000df 	cmp	x6, #0x0
ffffffffea804398:	dac01000 	clz	x0, x0
ffffffffea80439c:	5a9f1000 	csinv	w0, w0, wzr, ne  // ne = any
			fiq = i * BITMAP_BITS_PER_WORD + j;
ffffffffea8043a0:	0b000184 	add	w4, w12, w0
				ret = true;
ffffffffea8043a4:	6b15009f 	cmp	w4, w21
			mask &= ~(1UL << j);
ffffffffea8043a8:	9ac02140 	lsl	x0, x10, x0
	u_int reg = irq / 4;
ffffffffea8043ac:	53027c87 	lsr	w7, w4, #2
	u_int shift = 8 * (irq % 4);
ffffffffea8043b0:	531d0488 	ubfiz	w8, w4, #3, #2
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea8043b4:	111800ef 	add	w15, w7, #0x600
			mask &= ~(1UL << j);
ffffffffea8043b8:	8a2000c6 	bic	x6, x6, x0
	enable_mask = (enable_mask << shift) & cpu_mask;
ffffffffea8043bc:	1ac82025 	lsl	w5, w1, w8
				ret = true;
ffffffffea8043c0:	1a821273 	csel	w19, w19, w2, ne  // ne = any
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea8043c4:	531e75ef 	lsl	w15, w15, #2
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea8043c8:	1ac821a8 	lsl	w8, w13, w8
			if (smp)
ffffffffea8043cc:	340002d4 	cbz	w20, ffffffffea804424 <update_fiq_targets+0x124>
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea8043d0:	b8677970 	ldr	w16, [x11, x7, lsl #2]
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea8043d4:	b86f4920 	ldr	w0, [x9, w15, uxtw]
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea8043d8:	4a1000a0 	eor	w0, w5, w16
ffffffffea8043dc:	0a080000 	and	w0, w0, w8
ffffffffea8043e0:	4a100000 	eor	w0, w0, w16
	GICREG(0, GICD_ITARGETSR(reg)) = gicd_itargetsr[reg] = new_val;
ffffffffea8043e4:	b8277960 	str	w0, [x11, x7, lsl #2]
ffffffffea8043e8:	b82f4920 	str	w0, [x9, w15, uxtw]
			if (!smp || resume_gicd)
ffffffffea8043ec:	350001d7 	cbnz	w23, ffffffffea804424 <update_fiq_targets+0x124>
		while (mask) {
ffffffffea8043f0:	b5fffd06 	cbnz	x6, ffffffffea804390 <update_fiq_targets+0x90>
ffffffffea8043f4:	91000463 	add	x3, x3, #0x1
	for (i = 0; i < BITMAP_NUM_WORDS(MAX_INT); i++) {
ffffffffea8043f8:	f100347f 	cmp	x3, #0xd
ffffffffea8043fc:	54fffc21 	b.ne	ffffffffea804380 <update_fiq_targets+0x80>  // b.any
    arch_spin_unlock(lock);
ffffffffea804400:	91046300 	add	x0, x24, #0x118
ffffffffea804404:	97fff92d 	bl	ffffffffea8028b8 <arch_spin_unlock>
				gic_set_enable(fiq, enable);
		}
	}
	spin_unlock(&gicd_lock);
	return ret;
}
ffffffffea804408:	2a1303e0 	mov	w0, w19
ffffffffea80440c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea804410:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804414:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea804418:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80441c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea804420:	d65f03c0 	ret
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea804424:	12001080 	and	w0, w4, #0x1f
	int reg = vector / 32;
ffffffffea804428:	53057c84 	lsr	w4, w4, #5
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea80442c:	11110085 	add	w5, w4, #0x440
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea804430:	9ac02140 	lsl	x0, x10, x0
	if (enable)
ffffffffea804434:	340000b6 	cbz	w22, ffffffffea804448 <update_fiq_targets+0x148>
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804438:	531e74a5 	lsl	w5, w5, #2
ffffffffea80443c:	b825c920 	str	w0, [x9, w5, sxtw]
		while (mask) {
ffffffffea804440:	b5fffa86 	cbnz	x6, ffffffffea804390 <update_fiq_targets+0x90>
ffffffffea804444:	17ffffec 	b	ffffffffea8043f4 <update_fiq_targets+0xf4>
		GICREG(0, GICD_ICENABLER(reg)) = mask;
ffffffffea804448:	11118084 	add	w4, w4, #0x460
ffffffffea80444c:	531e7484 	lsl	w4, w4, #2
ffffffffea804450:	b824c920 	str	w0, [x9, w4, sxtw]
		while (mask) {
ffffffffea804454:	b5fff9e6 	cbnz	x6, ffffffffea804390 <update_fiq_targets+0x90>
ffffffffea804458:	17ffffe7 	b	ffffffffea8043f4 <update_fiq_targets+0xf4>
ffffffffea80445c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804460 <suspend_resume_fiq>:

#if !DISABLE_ARM_GIC_SUSPEND_RESUME
static void suspend_resume_fiq(bool resume_gicc, bool resume_gicd)
{
ffffffffea804460:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea804464:	910003fd 	mov	x29, sp
ffffffffea804468:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80446c:	12001c13 	and	w19, w0, #0xff
ffffffffea804470:	f90013f5 	str	x21, [sp, #32]
ffffffffea804474:	12001c34 	and	w20, w1, #0xff
ffffffffea804478:	aa1e03f5 	mov	x21, x30
	u_int cpu = arch_curr_cpu_num();
ffffffffea80447c:	97fff98b 	bl	ffffffffea802aa8 <arch_curr_cpu_num>

	ASSERT(cpu < 8);
ffffffffea804480:	71001c1f 	cmp	w0, #0x7
ffffffffea804484:	54000108 	b.hi	ffffffffea8044a4 <suspend_resume_fiq+0x44>  // b.pmore

	update_fiq_targets(cpu, resume_gicc, ~0, resume_gicd);
ffffffffea804488:	2a1403e3 	mov	w3, w20
ffffffffea80448c:	2a1303e1 	mov	w1, w19
}
ffffffffea804490:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_fiq_targets(cpu, resume_gicc, ~0, resume_gicd);
ffffffffea804494:	12800002 	mov	w2, #0xffffffff            	// #-1
}
ffffffffea804498:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80449c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	update_fiq_targets(cpu, resume_gicc, ~0, resume_gicd);
ffffffffea8044a0:	17ffff98 	b	ffffffffea804300 <update_fiq_targets>
	ASSERT(cpu < 8);
ffffffffea8044a4:	d0000084 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8044a8:	d0000082 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8044ac:	b0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8044b0:	910ea084 	add	x4, x4, #0x3a8
ffffffffea8044b4:	528046a3 	mov	w3, #0x235                 	// #565
ffffffffea8044b8:	910ec042 	add	x2, x2, #0x3b0
ffffffffea8044bc:	9135a021 	add	x1, x1, #0xd68
ffffffffea8044c0:	aa1503e0 	mov	x0, x21
ffffffffea8044c4:	940035f5 	bl	ffffffffea811c98 <_panic>

ffffffffea8044c8 <arm_gic_suspend_cpu>:
	suspend_resume_fiq(false, false);
ffffffffea8044c8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8044cc:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8044d0:	17ffffe4 	b	ffffffffea804460 <suspend_resume_fiq>
ffffffffea8044d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8044d8 <register_int_handler>:
{
ffffffffea8044d8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea8044dc:	910003fd 	mov	x29, sp
ffffffffea8044e0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8044e4:	2a0003f3 	mov	w19, w0
ffffffffea8044e8:	a903e7f8 	stp	x24, x25, [sp, #56]
ffffffffea8044ec:	aa1e03f4 	mov	x20, x30
ffffffffea8044f0:	aa0103f9 	mov	x25, x1
ffffffffea8044f4:	aa0203f8 	mov	x24, x2
	uint cpu = arch_curr_cpu_num();
ffffffffea8044f8:	97fff96c 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea8044fc:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea804500:	f9001bb7 	str	x23, [x29, #48]
	if (vector >= MAX_INT)
ffffffffea804504:	710c7e7f 	cmp	w19, #0x31f
ffffffffea804508:	54000688 	b.hi	ffffffffea8045d8 <register_int_handler+0x100>  // b.pmore
ffffffffea80450c:	2a0003f5 	mov	w21, w0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804510:	d53b4220 	mrs	x0, daif
};

static inline void
arch_interrupt_save(spin_lock_saved_state_t *statep, spin_lock_save_flags_t flags)
{
    spin_lock_saved_state_t state = 0;
ffffffffea804514:	52800017 	mov	w23, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804518:	363804a0 	tbz	w0, #7, ffffffffea8045ac <register_int_handler+0xd4>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80451c:	d53b4220 	mrs	x0, daif
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
        arch_disable_ints();
    }
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804520:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea804524:	37300080 	tbnz	w0, #6, ffffffffea804534 <register_int_handler+0x5c>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804528:	321f02f7 	orr	w23, w23, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea80452c:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804530:	52800056 	mov	w22, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804534:	900002b4 	adrp	x20, ffffffffea858000 <__bss_start>
ffffffffea804538:	91046280 	add	x0, x20, #0x118
ffffffffea80453c:	97fff8d7 	bl	ffffffffea802898 <arch_spin_lock>
	if (!arm_gic_non_secure_interrupts_frozen)
ffffffffea804540:	900002a0 	adrp	x0, ffffffffea858000 <__bss_start>
ffffffffea804544:	3942a000 	ldrb	w0, [x0, #168]
ffffffffea804548:	35000380 	cbnz	w0, ffffffffea8045b8 <register_int_handler+0xe0>
	if (vector < GIC_MAX_PER_CPU_INT)
ffffffffea80454c:	71007e7f 	cmp	w19, #0x1f
ffffffffea804550:	54000248 	b.hi	ffffffffea804598 <register_int_handler+0xc0>  // b.pmore
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804554:	8b334eb3 	add	x19, x21, w19, uxtw #3
ffffffffea804558:	900002a3 	adrp	x3, ffffffffea858000 <__bss_start>
ffffffffea80455c:	91048063 	add	x3, x3, #0x120
ffffffffea804560:	8b131073 	add	x19, x3, x19, lsl #4
		h->arg = arg;
ffffffffea804564:	a9006279 	stp	x25, x24, [x19]
    arch_spin_unlock(lock);
ffffffffea804568:	91046280 	add	x0, x20, #0x118
ffffffffea80456c:	97fff8d3 	bl	ffffffffea8028b8 <arch_spin_unlock>
}

static inline void
arch_interrupt_restore(spin_lock_saved_state_t old_state, spin_lock_save_flags_t flags)
{
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804570:	34000056 	cbz	w22, ffffffffea804578 <register_int_handler+0xa0>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804574:	d50341ff 	msr	daifclr, #0x1
        arch_enable_fiqs();
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804578:	36000057 	tbz	w23, #0, ffffffffea804580 <register_int_handler+0xa8>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80457c:	d50342ff 	msr	daifclr, #0x2
ffffffffea804580:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea804584:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804588:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea80458c:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea804590:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea804594:	d65f03c0 	ret
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804598:	51008273 	sub	w19, w19, #0x20
ffffffffea80459c:	b00002a3 	adrp	x3, ffffffffea859000 <int_handler_table_per_cpu+0xee0>
ffffffffea8045a0:	91048063 	add	x3, x3, #0x120
ffffffffea8045a4:	8b131073 	add	x19, x3, x19, lsl #4
ffffffffea8045a8:	17ffffef 	b	ffffffffea804564 <register_int_handler+0x8c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8045ac:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8045b0:	52800037 	mov	w23, #0x1                   	// #1
ffffffffea8045b4:	17ffffda 	b	ffffffffea80451c <register_int_handler+0x44>
	TRACEF("change to interrupt %d ignored after booting ns\n", irq);
ffffffffea8045b8:	d0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8045bc:	d0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8045c0:	2a1303e3 	mov	w3, w19
ffffffffea8045c4:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea8045c8:	91034021 	add	x1, x1, #0xd0
ffffffffea8045cc:	9109c000 	add	x0, x0, #0x270
ffffffffea8045d0:	94003b18 	bl	ffffffffea813230 <_printf>
ffffffffea8045d4:	17ffffe5 	b	ffffffffea804568 <register_int_handler+0x90>
		panic("register_int_handler: vector out of range %d\n", vector);
ffffffffea8045d8:	d0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8045dc:	2a1303e2 	mov	w2, w19
ffffffffea8045e0:	91090021 	add	x1, x1, #0x240
ffffffffea8045e4:	aa1403e0 	mov	x0, x20
ffffffffea8045e8:	940035ac 	bl	ffffffffea811c98 <_panic>
ffffffffea8045ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8045f0 <arm_gic_init>:
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea8045f0:	929fffe3 	mov	x3, #0xffffffffffff0000    	// #-65536
	for (i = 0; i < MAX_INT; i+= 32) {
ffffffffea8045f4:	52800001 	mov	w1, #0x0                   	// #0
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea8045f8:	f2be2803 	movk	x3, #0xf140, lsl #16
ffffffffea8045fc:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea804600:	13057c20 	asr	w0, w1, #5
	for (i = 0; i < MAX_INT; i+= 32) {
ffffffffea804604:	11008021 	add	w1, w1, #0x20
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea804608:	11118000 	add	w0, w0, #0x460
	for (i = 0; i < MAX_INT; i+= 32) {
ffffffffea80460c:	710c803f 	cmp	w1, #0x320
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea804610:	531e7400 	lsl	w0, w0, #2
		GICREG(0, GICD_ICPENDR(i / 32)) = ~0;
ffffffffea804614:	11040004 	add	w4, w0, #0x100
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea804618:	b820c862 	str	w2, [x3, w0, sxtw]
		GICREG(0, GICD_ICPENDR(i / 32)) = ~0;
ffffffffea80461c:	b824c862 	str	w2, [x3, w4, sxtw]
	for (i = 0; i < MAX_INT; i+= 32) {
ffffffffea804620:	54ffff01 	b.ne	ffffffffea804600 <arm_gic_init+0x10>  // b.any
	return (GICREG(0, GICD_TYPER) >> 5) & 0x7;
ffffffffea804624:	929dff60 	mov	x0, #0xffffffffffff1004    	// #-61436
ffffffffea804628:	f2be2800 	movk	x0, #0xf140, lsl #16
ffffffffea80462c:	b9400000 	ldr	w0, [x0]
	if (arm_gic_max_cpu() > 0) {
ffffffffea804630:	f27b081f 	tst	x0, #0xe0
ffffffffea804634:	540001e0 	b.eq	ffffffffea804670 <arm_gic_init+0x80>  // b.none
ffffffffea804638:	b00000a3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
			GICREG(0, GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
ffffffffea80463c:	929fffe4 	mov	x4, #0xffffffffffff0000    	// #-65536
ffffffffea804640:	9108e063 	add	x3, x3, #0x238
		for (i = 32; i < MAX_INT; i += 4) {
ffffffffea804644:	52800400 	mov	w0, #0x20                  	// #32
			GICREG(0, GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
ffffffffea804648:	f2be2804 	movk	x4, #0xf140, lsl #16
ffffffffea80464c:	d503201f 	nop
ffffffffea804650:	13027c02 	asr	w2, w0, #2
		for (i = 32; i < MAX_INT; i += 4) {
ffffffffea804654:	11001000 	add	w0, w0, #0x4
			GICREG(0, GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
ffffffffea804658:	11180041 	add	w1, w2, #0x600
		for (i = 32; i < MAX_INT; i += 4) {
ffffffffea80465c:	710c801f 	cmp	w0, #0x320
			GICREG(0, GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
ffffffffea804660:	531e7421 	lsl	w1, w1, #2
ffffffffea804664:	b862d862 	ldr	w2, [x3, w2, sxtw #2]
ffffffffea804668:	b821c882 	str	w2, [x4, w1, sxtw]
		for (i = 32; i < MAX_INT; i += 4) {
ffffffffea80466c:	54ffff21 	b.ne	ffffffffea804650 <arm_gic_init+0x60>  // b.any
	GICREG(0, GICD_CTLR) = 1; // enable GIC0
ffffffffea804670:	929dffe1 	mov	x1, #0xffffffffffff1000    	// #-61440
ffffffffea804674:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea804678:	f2be2801 	movk	x1, #0xf140, lsl #16
ffffffffea80467c:	b00000a3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
		GICREG(0, GICD_IGROUPR(reg)) = gicd_igroupr[reg];
ffffffffea804680:	929fffe4 	mov	x4, #0xffffffffffff0000    	// #-65536
ffffffffea804684:	91074063 	add	x3, x3, #0x1d0
	GICREG(0, GICD_CTLR) = 1; // enable GIC0
ffffffffea804688:	b9000020 	str	w0, [x1]
	GICREG(0, GICD_CTLR) = 3; // enable GIC0 ns interrupts
ffffffffea80468c:	52800062 	mov	w2, #0x3                   	// #3
		GICREG(0, GICD_IGROUPR(reg)) = gicd_igroupr[reg];
ffffffffea804690:	f2be2804 	movk	x4, #0xf140, lsl #16
	GICREG(0, GICD_CTLR) = 3; // enable GIC0 ns interrupts
ffffffffea804694:	b9000022 	str	w2, [x1]
	for (i = 32; i < MAX_INT; i += 32) {
ffffffffea804698:	52800400 	mov	w0, #0x20                  	// #32
ffffffffea80469c:	d503201f 	nop
		u_int reg = i / 32;
ffffffffea8046a0:	13057c02 	asr	w2, w0, #5
	for (i = 32; i < MAX_INT; i += 32) {
ffffffffea8046a4:	11008000 	add	w0, w0, #0x20
		GICREG(0, GICD_IGROUPR(reg)) = gicd_igroupr[reg];
ffffffffea8046a8:	11108041 	add	w1, w2, #0x420
	for (i = 32; i < MAX_INT; i += 32) {
ffffffffea8046ac:	710c801f 	cmp	w0, #0x320
		GICREG(0, GICD_IGROUPR(reg)) = gicd_igroupr[reg];
ffffffffea8046b0:	531e7421 	lsl	w1, w1, #2
ffffffffea8046b4:	b8625862 	ldr	w2, [x3, w2, uxtw #2]
ffffffffea8046b8:	b8214882 	str	w2, [x4, w1, uxtw]
	for (i = 32; i < MAX_INT; i += 32) {
ffffffffea8046bc:	54ffff21 	b.ne	ffffffffea8046a0 <arm_gic_init+0xb0>  // b.any
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8046c0:	929bffe2 	mov	x2, #0xffffffffffff2000    	// #-57344
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea8046c4:	929defe1 	mov	x1, #0xffffffffffff1080    	// #-61312
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8046c8:	f2be2802 	movk	x2, #0xf140, lsl #16
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea8046cc:	f2be2801 	movk	x1, #0xf140, lsl #16
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea8046d0:	929bff60 	mov	x0, #0xffffffffffff2004    	// #-57340
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8046d4:	52800163 	mov	w3, #0xb                   	// #11
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea8046d8:	f2be2800 	movk	x0, #0xf140, lsl #16
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8046dc:	b9000043 	str	w3, [x2]
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea8046e0:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea8046e4:	b9000022 	str	w2, [x1]
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea8046e8:	52801fe1 	mov	w1, #0xff                  	// #255
ffffffffea8046ec:	b9000001 	str	w1, [x0]
}
ffffffffea8046f0:	d65f03c0 	ret
ffffffffea8046f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8046f8 <arm_gic_resume_cpu>:
{
ffffffffea8046f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8046fc:	910003fd 	mov	x29, sp
ffffffffea804700:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804704:	a9025bf5 	stp	x21, x22, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804708:	d53b4220 	mrs	x0, daif
ffffffffea80470c:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804710:	37380060 	tbnz	w0, #7, ffffffffea80471c <arm_gic_resume_cpu+0x24>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804714:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804718:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80471c:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804720:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea804724:	37300080 	tbnz	w0, #6, ffffffffea804734 <arm_gic_resume_cpu+0x3c>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804728:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea80472c:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804730:	52800055 	mov	w21, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804734:	900002b3 	adrp	x19, ffffffffea858000 <__bss_start>
ffffffffea804738:	91046260 	add	x0, x19, #0x118
ffffffffea80473c:	97fff857 	bl	ffffffffea802898 <arch_spin_lock>
	if (!(GICREG(0, GICD_CTLR) & 1)) {
ffffffffea804740:	929dffe0 	mov	x0, #0xffffffffffff1000    	// #-61440
ffffffffea804744:	f2be2800 	movk	x0, #0xf140, lsl #16
ffffffffea804748:	b9400000 	ldr	w0, [x0]
ffffffffea80474c:	36000340 	tbz	w0, #0, ffffffffea8047b4 <arm_gic_resume_cpu+0xbc>
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804750:	929bffe2 	mov	x2, #0xffffffffffff2000    	// #-57344
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea804754:	929defe1 	mov	x1, #0xffffffffffff1080    	// #-61312
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804758:	f2be2802 	movk	x2, #0xf140, lsl #16
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea80475c:	f2be2801 	movk	x1, #0xf140, lsl #16
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea804760:	929bff60 	mov	x0, #0xffffffffffff2004    	// #-57340
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804764:	52800163 	mov	w3, #0xb                   	// #11
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea804768:	f2be2800 	movk	x0, #0xf140, lsl #16
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea80476c:	b9000043 	str	w3, [x2]
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea804770:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea804774:	b9000022 	str	w2, [x1]
	bool resume_gicd = false;
ffffffffea804778:	52800016 	mov	w22, #0x0                   	// #0
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea80477c:	52801fe1 	mov	w1, #0xff                  	// #255
ffffffffea804780:	b9000001 	str	w1, [x0]
    arch_spin_unlock(lock);
ffffffffea804784:	91046260 	add	x0, x19, #0x118
ffffffffea804788:	97fff84c 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea80478c:	34000055 	cbz	w21, ffffffffea804794 <arm_gic_resume_cpu+0x9c>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804790:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804794:	36000054 	tbz	w20, #0, ffffffffea80479c <arm_gic_resume_cpu+0xa4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804798:	d50342ff 	msr	daifclr, #0x2
	suspend_resume_fiq(true, resume_gicd);
ffffffffea80479c:	2a1603e1 	mov	w1, w22
ffffffffea8047a0:	52800020 	mov	w0, #0x1                   	// #1
}
ffffffffea8047a4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8047a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8047ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
	suspend_resume_fiq(true, resume_gicd);
ffffffffea8047b0:	17ffff2c 	b	ffffffffea804460 <suspend_resume_fiq>
		dprintf(SPEW, "%s: distibutor is off, calling arm_gic_init instead\n", __func__);
ffffffffea8047b4:	d0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8047b8:	91048021 	add	x1, x1, #0x120
ffffffffea8047bc:	d0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8047c0:	9105a000 	add	x0, x0, #0x168
ffffffffea8047c4:	940034b7 	bl	ffffffffea811aa0 <_dprintf>
		resume_gicd = true;
ffffffffea8047c8:	52800036 	mov	w22, #0x1                   	// #1
		arm_gic_init();
ffffffffea8047cc:	97ffff89 	bl	ffffffffea8045f0 <arm_gic_init>
ffffffffea8047d0:	17ffffed 	b	ffffffffea804784 <arm_gic_resume_cpu+0x8c>
ffffffffea8047d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8047d8 <arm_gic_sgi>:
		((flags & ARM_GIC_SGI_FLAG_NS) ? (1U << 15) : 0) |
ffffffffea8047d8:	53134823 	lsl	w3, w1, #13
		((cpu_mask & 0xff) << 16) |
ffffffffea8047dc:	53101c42 	ubfiz	w2, w2, #16, #8
		(irq & 0xf);
ffffffffea8047e0:	12000c04 	and	w4, w0, #0xf
		((flags & ARM_GIC_SGI_FLAG_TARGET_FILTER_MASK) << 24) |
ffffffffea8047e4:	53080421 	ubfiz	w1, w1, #24, #2
		((flags & ARM_GIC_SGI_FLAG_NS) ? (1U << 15) : 0) |
ffffffffea8047e8:	12110063 	and	w3, w3, #0x8000
	u_int val =
ffffffffea8047ec:	2a040042 	orr	w2, w2, w4
ffffffffea8047f0:	2a030021 	orr	w1, w1, w3
	if (irq >= 16)
ffffffffea8047f4:	71003c1f 	cmp	w0, #0xf
	u_int val =
ffffffffea8047f8:	2a020021 	orr	w1, w1, w2
	if (irq >= 16)
ffffffffea8047fc:	540000c8 	b.hi	ffffffffea804814 <arm_gic_sgi+0x3c>  // b.pmore
	GICREG(0, GICD_SGIR) = val;
ffffffffea804800:	929c1fe2 	mov	x2, #0xffffffffffff1f00    	// #-57600
	return NO_ERROR;
ffffffffea804804:	52800000 	mov	w0, #0x0                   	// #0
	GICREG(0, GICD_SGIR) = val;
ffffffffea804808:	f2be2802 	movk	x2, #0xf140, lsl #16
ffffffffea80480c:	b9000041 	str	w1, [x2]
}
ffffffffea804810:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea804814:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea804818:	d65f03c0 	ret
ffffffffea80481c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804820 <unmask_interrupt>:
	if (vector >= MAX_INT)
ffffffffea804820:	710c7c1f 	cmp	w0, #0x31f
ffffffffea804824:	54000368 	b.hi	ffffffffea804890 <unmask_interrupt+0x70>  // b.pmore
	if (!arm_gic_non_secure_interrupts_frozen)
ffffffffea804828:	900002a1 	adrp	x1, ffffffffea858000 <__bss_start>
ffffffffea80482c:	3942a021 	ldrb	w1, [x1, #168]
ffffffffea804830:	35000181 	cbnz	w1, ffffffffea804860 <unmask_interrupt+0x40>
	int reg = vector / 32;
ffffffffea804834:	53057c01 	lsr	w1, w0, #5
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804838:	929fffe4 	mov	x4, #0xffffffffffff0000    	// #-65536
ffffffffea80483c:	11110021 	add	w1, w1, #0x440
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea804840:	12001003 	and	w3, w0, #0x1f
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804844:	f2be2804 	movk	x4, #0xf140, lsl #16
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea804848:	d2800022 	mov	x2, #0x1                   	// #1
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea80484c:	531e7421 	lsl	w1, w1, #2
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea804850:	9ac32043 	lsl	x3, x2, x3
	return NO_ERROR;
ffffffffea804854:	52800000 	mov	w0, #0x0                   	// #0
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804858:	b821c883 	str	w3, [x4, w1, sxtw]
ffffffffea80485c:	d65f03c0 	ret
{
ffffffffea804860:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea804864:	2a0003e3 	mov	w3, w0
	TRACEF("change to interrupt %d ignored after booting ns\n", irq);
ffffffffea804868:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea80486c:	d0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
{
ffffffffea804870:	910003fd 	mov	x29, sp
	TRACEF("change to interrupt %d ignored after booting ns\n", irq);
ffffffffea804874:	91034021 	add	x1, x1, #0xd0
ffffffffea804878:	d0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80487c:	9109c000 	add	x0, x0, #0x270
ffffffffea804880:	94003a6c 	bl	ffffffffea813230 <_printf>
	return NO_ERROR;
ffffffffea804884:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea804888:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80488c:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea804890:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea804894:	d65f03c0 	ret

ffffffffea804898 <platform_irq>:
{
ffffffffea804898:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	uint32_t ahppir = GICREG(0, GICC_AHPPIR);
ffffffffea80489c:	929bfae0 	mov	x0, #0xffffffffffff2028    	// #-57304
ffffffffea8048a0:	f2be2800 	movk	x0, #0xf140, lsl #16
{
ffffffffea8048a4:	910003fd 	mov	x29, sp
ffffffffea8048a8:	a901d7f4 	stp	x20, x21, [sp, #24]
	uint32_t ahppir = GICREG(0, GICC_AHPPIR);
ffffffffea8048ac:	b9400015 	ldr	w21, [x0]
	uint cpu = arch_curr_cpu_num();
ffffffffea8048b0:	97fff87e 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
	uint32_t pending_irq = ahppir & 0x3ff;
ffffffffea8048b4:	120026b4 	and	w20, w21, #0x3ff
	if (pending_irq < MAX_INT && get_int_handler(pending_irq, cpu)->handler) {
ffffffffea8048b8:	710c7e9f 	cmp	w20, #0x31f
ffffffffea8048bc:	54000948 	b.hi	ffffffffea8049e4 <platform_irq+0x14c>  // b.pmore
ffffffffea8048c0:	f9000bb3 	str	x19, [x29, #16]
	if (vector < GIC_MAX_PER_CPU_INT)
ffffffffea8048c4:	71007e9f 	cmp	w20, #0x1f
ffffffffea8048c8:	54000949 	b.ls	ffffffffea8049f0 <platform_irq+0x158>  // b.plast
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea8048cc:	51008293 	sub	w19, w20, #0x20
ffffffffea8048d0:	b00002a0 	adrp	x0, ffffffffea859000 <int_handler_table_per_cpu+0xee0>
ffffffffea8048d4:	91048000 	add	x0, x0, #0x120
ffffffffea8048d8:	8b131013 	add	x19, x0, x19, lsl #4
	if (pending_irq < MAX_INT && get_int_handler(pending_irq, cpu)->handler) {
ffffffffea8048dc:	f9400260 	ldr	x0, [x19]
ffffffffea8048e0:	b4000800 	cbz	x0, ffffffffea8049e0 <platform_irq+0x148>
ffffffffea8048e4:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea8048e8:	f9001fb8 	str	x24, [x29, #56]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8048ec:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea8048f0:	52800018 	mov	w24, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8048f4:	37380060 	tbnz	w0, #7, ffffffffea804900 <platform_irq+0x68>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8048f8:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8048fc:	52800038 	mov	w24, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804900:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804904:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea804908:	37300080 	tbnz	w0, #6, ffffffffea804918 <platform_irq+0x80>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea80490c:	321f0318 	orr	w24, w24, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804910:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804914:	52800057 	mov	w23, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804918:	900002b6 	adrp	x22, ffffffffea858000 <__bss_start>
ffffffffea80491c:	910462d6 	add	x22, x22, #0x118
ffffffffea804920:	aa1603e0 	mov	x0, x22
ffffffffea804924:	97fff7dd 	bl	ffffffffea802898 <arch_spin_lock>
	return (GICREG(0, GICD_IPRIORITYR(reg)) >> shift) & 0xff;
ffffffffea804928:	121e1e82 	and	w2, w20, #0x3fc
ffffffffea80492c:	52828000 	mov	w0, #0x1400                	// #5120
ffffffffea804930:	929fffe6 	mov	x6, #0xffffffffffff0000    	// #-65536
ffffffffea804934:	0b000042 	add	w2, w2, w0
ffffffffea804938:	f2be2806 	movk	x6, #0xf140, lsl #16
	u_int shift = 8 * (irq % 4);
ffffffffea80493c:	531d06a1 	ubfiz	w1, w21, #3, #2
	u_int mask = 0xff << shift;
ffffffffea804940:	52801fe4 	mov	w4, #0xff                  	// #255
	return (GICREG(0, GICD_IPRIORITYR(reg)) >> shift) & 0xff;
ffffffffea804944:	b86248c5 	ldr	w5, [x6, w2, uxtw]
	u_int mask = 0xff << shift;
ffffffffea804948:	1ac12084 	lsl	w4, w4, w1
	regval = GICREG(0, GICD_IPRIORITYR(reg));
ffffffffea80494c:	b86248c0 	ldr	w0, [x6, w2, uxtw]
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea804950:	2a2403e4 	mvn	w4, w4
ffffffffea804954:	0a040000 	and	w0, w0, w4
	GICREG(0, GICD_IPRIORITYR(reg)) = regval;
ffffffffea804958:	b82248c0 	str	w0, [x6, w2, uxtw]
		DSB;
ffffffffea80495c:	d5033f9f 	dsb	sy
		irq = GICREG(0, GICC_AIAR) & 0x3ff;
ffffffffea804960:	929bfbe3 	mov	x3, #0xffffffffffff2020    	// #-57312
	return (GICREG(0, GICD_IPRIORITYR(reg)) >> shift) & 0xff;
ffffffffea804964:	1ac124a5 	lsr	w5, w5, w1
		irq = GICREG(0, GICC_AIAR) & 0x3ff;
ffffffffea804968:	f2be2803 	movk	x3, #0xf140, lsl #16
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea80496c:	12001ca5 	and	w5, w5, #0xff
    arch_spin_unlock(lock);
ffffffffea804970:	aa1603e0 	mov	x0, x22
		irq = GICREG(0, GICC_AIAR) & 0x3ff;
ffffffffea804974:	b9400075 	ldr	w21, [x3]
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea804978:	1ac120a1 	lsl	w1, w5, w1
	regval = GICREG(0, GICD_IPRIORITYR(reg));
ffffffffea80497c:	b86248c7 	ldr	w7, [x6, w2, uxtw]
		irq = GICREG(0, GICC_AIAR) & 0x3ff;
ffffffffea804980:	120026b5 	and	w21, w21, #0x3ff
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea804984:	0a0400e4 	and	w4, w7, w4
ffffffffea804988:	2a040021 	orr	w1, w1, w4
	GICREG(0, GICD_IPRIORITYR(reg)) = regval;
ffffffffea80498c:	b82248c1 	str	w1, [x6, w2, uxtw]
ffffffffea804990:	97fff7ca 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804994:	34000057 	cbz	w23, ffffffffea80499c <platform_irq+0x104>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804998:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea80499c:	36000058 	tbz	w24, #0, ffffffffea8049a4 <platform_irq+0x10c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8049a0:	d50342ff 	msr	daifclr, #0x2
		if (irq < MAX_INT && (h = get_int_handler(pending_irq, cpu))->handler)
ffffffffea8049a4:	710c7ebf 	cmp	w21, #0x31f
ffffffffea8049a8:	54000308 	b.hi	ffffffffea804a08 <platform_irq+0x170>  // b.pmore
ffffffffea8049ac:	f9400261 	ldr	x1, [x19]
ffffffffea8049b0:	b40002c1 	cbz	x1, ffffffffea804a08 <platform_irq+0x170>
			ret = h->handler(h->arg);
ffffffffea8049b4:	f9400660 	ldr	x0, [x19, #8]
ffffffffea8049b8:	d63f0020 	blr	x1
		GICREG(0, GICC_AEOIR) = irq;
ffffffffea8049bc:	929bfb61 	mov	x1, #0xffffffffffff2024    	// #-57308
}
ffffffffea8049c0:	f9400bb3 	ldr	x19, [x29, #16]
		GICREG(0, GICC_AEOIR) = irq;
ffffffffea8049c4:	f2be2801 	movk	x1, #0xf140, lsl #16
}
ffffffffea8049c8:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea8049cc:	a942dfb6 	ldp	x22, x23, [x29, #40]
		GICREG(0, GICC_AEOIR) = irq;
ffffffffea8049d0:	b9000035 	str	w21, [x1]
}
ffffffffea8049d4:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8049d8:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8049dc:	d65f03c0 	ret
ffffffffea8049e0:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8049e4:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8049e8:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return sm_handle_irq();
ffffffffea8049ec:	14000ebd 	b	ffffffffea8084e0 <sm_handle_irq>
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea8049f0:	2a0003f3 	mov	w19, w0
ffffffffea8049f4:	900002a0 	adrp	x0, ffffffffea858000 <__bss_start>
ffffffffea8049f8:	8b344e73 	add	x19, x19, w20, uxtw #3
ffffffffea8049fc:	91048000 	add	x0, x0, #0x120
ffffffffea804a00:	8b131013 	add	x19, x0, x19, lsl #4
ffffffffea804a04:	17ffffb6 	b	ffffffffea8048dc <platform_irq+0x44>
			TRACEF("unexpected irq %d != %d may get lost\n", irq, pending_irq);
ffffffffea804a08:	d0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804a0c:	d0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804a10:	2a1403e4 	mov	w4, w20
ffffffffea804a14:	2a1503e3 	mov	w3, w21
ffffffffea804a18:	52803722 	mov	w2, #0x1b9                 	// #441
ffffffffea804a1c:	9103e021 	add	x1, x1, #0xf8
ffffffffea804a20:	91084000 	add	x0, x0, #0x210
ffffffffea804a24:	94003a03 	bl	ffffffffea813230 <_printf>
		enum handler_return ret = 0;
ffffffffea804a28:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea804a2c:	17ffffe4 	b	ffffffffea8049bc <platform_irq+0x124>

ffffffffea804a30 <platform_fiq>:
	sm_handle_fiq();
ffffffffea804a30:	14000ec6 	b	ffffffffea808548 <sm_handle_fiq>
ffffffffea804a34:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804a38 <smc_intc_get_next_irq>:
{
ffffffffea804a38:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea804a3c:	910003fd 	mov	x29, sp
ffffffffea804a40:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804a44:	aa0003f3 	mov	x19, x0
ffffffffea804a48:	a9025bf5 	stp	x21, x22, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804a4c:	d53b4220 	mrs	x0, daif
ffffffffea804a50:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804a54:	37380060 	tbnz	w0, #7, ffffffffea804a60 <smc_intc_get_next_irq+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804a58:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804a5c:	52800035 	mov	w21, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804a60:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804a64:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea804a68:	37300080 	tbnz	w0, #6, ffffffffea804a78 <smc_intc_get_next_irq+0x40>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804a6c:	321f02b5 	orr	w21, w21, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804a70:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804a74:	52800056 	mov	w22, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804a78:	900002b4 	adrp	x20, ffffffffea858000 <__bss_start>
ffffffffea804a7c:	91046280 	add	x0, x20, #0x118
ffffffffea804a80:	97fff786 	bl	ffffffffea802898 <arch_spin_lock>
	arm_gic_non_secure_interrupts_frozen = true;
ffffffffea804a84:	900002a1 	adrp	x1, ffffffffea858000 <__bss_start>
	u_int max_irq = per_cpu ? GIC_MAX_PER_CPU_INT : MAX_INT;
ffffffffea804a88:	b9400a60 	ldr	w0, [x19, #8]
	arm_gic_non_secure_interrupts_frozen = true;
ffffffffea804a8c:	52800022 	mov	w2, #0x1                   	// #1
	ret = arm_gic_get_next_irq_locked(args->params[0], args->params[1]);
ffffffffea804a90:	b9400673 	ldr	w19, [x19, #4]
	arm_gic_non_secure_interrupts_frozen = true;
ffffffffea804a94:	3902a022 	strb	w2, [x1, #168]
	u_int max_irq = per_cpu ? GIC_MAX_PER_CPU_INT : MAX_INT;
ffffffffea804a98:	35000480 	cbnz	w0, ffffffffea804b28 <smc_intc_get_next_irq+0xf0>
	uint cpu = arch_curr_cpu_num();
ffffffffea804a9c:	97fff803 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
	u_int max_irq = per_cpu ? GIC_MAX_PER_CPU_INT : MAX_INT;
ffffffffea804aa0:	52806403 	mov	w3, #0x320                 	// #800
	if (!per_cpu && min_irq < GIC_MAX_PER_CPU_INT)
ffffffffea804aa4:	71007e7f 	cmp	w19, #0x1f
ffffffffea804aa8:	54000448 	b.hi	ffffffffea804b30 <smc_intc_get_next_irq+0xf8>  // b.pmore
		min_irq = GIC_MAX_PER_CPU_INT;
ffffffffea804aac:	52800413 	mov	w19, #0x20                  	// #32
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804ab0:	b00002a5 	adrp	x5, ffffffffea859000 <int_handler_table_per_cpu+0xee0>
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804ab4:	900002a4 	adrp	x4, ffffffffea858000 <__bss_start>
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804ab8:	910480a5 	add	x5, x5, #0x120
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804abc:	2a0003e0 	mov	w0, w0
ffffffffea804ac0:	91048084 	add	x4, x4, #0x120
ffffffffea804ac4:	14000007 	b	ffffffffea804ae0 <smc_intc_get_next_irq+0xa8>
ffffffffea804ac8:	8b021081 	add	x1, x4, x2, lsl #4
		if (get_int_handler(irq, cpu)->handler)
ffffffffea804acc:	f9400021 	ldr	x1, [x1]
ffffffffea804ad0:	b5000161 	cbnz	x1, ffffffffea804afc <smc_intc_get_next_irq+0xc4>
	for (irq = min_irq; irq < max_irq; irq++)
ffffffffea804ad4:	11000673 	add	w19, w19, #0x1
ffffffffea804ad8:	6b03027f 	cmp	w19, w3
ffffffffea804adc:	540002e2 	b.cs	ffffffffea804b38 <smc_intc_get_next_irq+0x100>  // b.hs, b.nlast
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804ae0:	51008261 	sub	w1, w19, #0x20
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804ae4:	8b334c02 	add	x2, x0, w19, uxtw #3
	if (vector < GIC_MAX_PER_CPU_INT)
ffffffffea804ae8:	71007e7f 	cmp	w19, #0x1f
ffffffffea804aec:	54fffee9 	b.ls	ffffffffea804ac8 <smc_intc_get_next_irq+0x90>  // b.plast
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804af0:	8b0110a1 	add	x1, x5, x1, lsl #4
		if (get_int_handler(irq, cpu)->handler)
ffffffffea804af4:	f9400021 	ldr	x1, [x1]
ffffffffea804af8:	b4fffee1 	cbz	x1, ffffffffea804ad4 <smc_intc_get_next_irq+0x9c>
ffffffffea804afc:	2a1303f3 	mov	w19, w19
    arch_spin_unlock(lock);
ffffffffea804b00:	91046280 	add	x0, x20, #0x118
ffffffffea804b04:	97fff76d 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804b08:	35000216 	cbnz	w22, ffffffffea804b48 <smc_intc_get_next_irq+0x110>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804b0c:	36000055 	tbz	w21, #0, ffffffffea804b14 <smc_intc_get_next_irq+0xdc>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804b10:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea804b14:	aa1303e0 	mov	x0, x19
ffffffffea804b18:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804b1c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea804b20:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea804b24:	d65f03c0 	ret
	uint cpu = arch_curr_cpu_num();
ffffffffea804b28:	97fff7e0 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
	u_int max_irq = per_cpu ? GIC_MAX_PER_CPU_INT : MAX_INT;
ffffffffea804b2c:	52800403 	mov	w3, #0x20                  	// #32
	for (irq = min_irq; irq < max_irq; irq++)
ffffffffea804b30:	6b03027f 	cmp	w19, w3
ffffffffea804b34:	54fffbe3 	b.cc	ffffffffea804ab0 <smc_intc_get_next_irq+0x78>  // b.lo, b.ul, b.last
		min_irq = GIC_MAX_PER_CPU_INT;
ffffffffea804b38:	92800133 	mov	x19, #0xfffffffffffffff6    	// #-10
ffffffffea804b3c:	91046280 	add	x0, x20, #0x118
ffffffffea804b40:	97fff75e 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804b44:	34fffe56 	cbz	w22, ffffffffea804b0c <smc_intc_get_next_irq+0xd4>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804b48:	d50341ff 	msr	daifclr, #0x1
ffffffffea804b4c:	17fffff0 	b	ffffffffea804b0c <smc_intc_get_next_irq+0xd4>

ffffffffea804b50 <smc_intc_request_fiq>:
{
ffffffffea804b50:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea804b54:	aa0003e2 	mov	x2, x0
	dprintf(SPEW, "%s: fiq %d, enable %d\n", __func__, fiq, enable);
ffffffffea804b58:	d0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804b5c:	910ca000 	add	x0, x0, #0x328
{
ffffffffea804b60:	910003fd 	mov	x29, sp
ffffffffea804b64:	a9025bf5 	stp	x21, x22, [sp, #32]
	bool enable = args->params[1];
ffffffffea804b68:	b9400856 	ldr	w22, [x2, #8]
{
ffffffffea804b6c:	f90023f9 	str	x25, [sp, #64]
	bool enable = args->params[1];
ffffffffea804b70:	710002df 	cmp	w22, #0x0
	u_int fiq = args->params[0];
ffffffffea804b74:	b9400459 	ldr	w25, [x2, #4]
	bool enable = args->params[1];
ffffffffea804b78:	1a9f07f5 	cset	w21, ne  // ne = any
{
ffffffffea804b7c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804b80:	a90363f7 	stp	x23, x24, [sp, #48]
	dprintf(SPEW, "%s: fiq %d, enable %d\n", __func__, fiq, enable);
ffffffffea804b84:	d0000094 	adrp	x20, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804b88:	2a1503e3 	mov	w3, w21
ffffffffea804b8c:	9104e281 	add	x1, x20, #0x138
ffffffffea804b90:	2a1903e2 	mov	w2, w25
ffffffffea804b94:	940033c3 	bl	ffffffffea811aa0 <_dprintf>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804b98:	d53b4220 	mrs	x0, daif
ffffffffea804b9c:	52800017 	mov	w23, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804ba0:	37380060 	tbnz	w0, #7, ffffffffea804bac <smc_intc_request_fiq+0x5c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804ba4:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804ba8:	52800037 	mov	w23, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804bac:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804bb0:	52800018 	mov	w24, #0x0                   	// #0
ffffffffea804bb4:	37300080 	tbnz	w0, #6, ffffffffea804bc4 <smc_intc_request_fiq+0x74>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804bb8:	321f02f7 	orr	w23, w23, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804bbc:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804bc0:	52800058 	mov	w24, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804bc4:	900002b3 	adrp	x19, ffffffffea858000 <__bss_start>
ffffffffea804bc8:	91046260 	add	x0, x19, #0x118
ffffffffea804bcc:	97fff733 	bl	ffffffffea802898 <arch_spin_lock>
	uint32_t mask = 1ULL << (irq % 32);
ffffffffea804bd0:	12001320 	and	w0, w25, #0x1f
ffffffffea804bd4:	d2800026 	mov	x6, #0x1                   	// #1
	int reg = irq / 32;
ffffffffea804bd8:	53057f22 	lsr	w2, w25, #5
	if (irq >= MAX_INT)
ffffffffea804bdc:	710c7f3f 	cmp	w25, #0x31f
	uint32_t mask = 1ULL << (irq % 32);
ffffffffea804be0:	9ac020c6 	lsl	x6, x6, x0
	if (irq >= MAX_INT)
ffffffffea804be4:	54000188 	b.hi	ffffffffea804c14 <smc_intc_request_fiq+0xc4>  // b.pmore
		GICREG(0, GICD_IGROUPR(reg)) = (gicd_igroupr[reg] &= ~mask);
ffffffffea804be8:	93407c44 	sxtw	x4, w2
ffffffffea804bec:	b00000a3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
ffffffffea804bf0:	11108040 	add	w0, w2, #0x420
ffffffffea804bf4:	91074063 	add	x3, x3, #0x1d0
ffffffffea804bf8:	929fffe5 	mov	x5, #0xffffffffffff0000    	// #-65536
ffffffffea804bfc:	531e7400 	lsl	w0, w0, #2
ffffffffea804c00:	f2be2805 	movk	x5, #0xf140, lsl #16
ffffffffea804c04:	b8647861 	ldr	w1, [x3, x4, lsl #2]
ffffffffea804c08:	0a260021 	bic	w1, w1, w6
ffffffffea804c0c:	b8247861 	str	w1, [x3, x4, lsl #2]
ffffffffea804c10:	b820c8a1 	str	w1, [x5, w0, sxtw]
	u_int reg = irq / 4;
ffffffffea804c14:	53027f21 	lsr	w1, w25, #2
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804c18:	b00000a8 	adrp	x8, ffffffffea819000 <_mem_phys_base>
ffffffffea804c1c:	9108e108 	add	x8, x8, #0x238
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804c20:	11180024 	add	w4, w1, #0x600
	u_int shift = 8 * (irq % 4);
ffffffffea804c24:	531d0725 	ubfiz	w5, w25, #3, #2
	enable_mask = (enable_mask << shift) & cpu_mask;
ffffffffea804c28:	12800000 	mov	w0, #0xffffffff            	// #-1
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804c2c:	531e7484 	lsl	w4, w4, #2
ffffffffea804c30:	929fffe7 	mov	x7, #0xffffffffffff0000    	// #-65536
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804c34:	b861790a 	ldr	w10, [x8, x1, lsl #2]
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804c38:	f2be2807 	movk	x7, #0xf140, lsl #16
	enable_mask = (enable_mask << shift) & cpu_mask;
ffffffffea804c3c:	1ac52000 	lsl	w0, w0, w5
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804c40:	52801fe3 	mov	w3, #0xff                  	// #255
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804c44:	4a0a0000 	eor	w0, w0, w10
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804c48:	1ac52063 	lsl	w3, w3, w5
	regval = GICREG(0, GICD_IPRIORITYR(reg));
ffffffffea804c4c:	51100089 	sub	w9, w4, #0x400
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804c50:	0a030000 	and	w0, w0, w3
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804c54:	b86448e5 	ldr	w5, [x7, w4, uxtw]
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804c58:	4a0a0000 	eor	w0, w0, w10
	GICREG(0, GICD_ITARGETSR(reg)) = gicd_itargetsr[reg] = new_val;
ffffffffea804c5c:	b82448e0 	str	w0, [x7, w4, uxtw]
ffffffffea804c60:	900002a5 	adrp	x5, ffffffffea858000 <__bss_start>
ffffffffea804c64:	9102c0a4 	add	x4, x5, #0xb0
	regval = GICREG(0, GICD_IPRIORITYR(reg));
ffffffffea804c68:	b86948ea 	ldr	w10, [x7, w9, uxtw]
ffffffffea804c6c:	53067f25 	lsr	w5, w25, #6
	GICREG(0, GICD_ITARGETSR(reg)) = gicd_itargetsr[reg] = new_val;
ffffffffea804c70:	b8217900 	str	w0, [x8, x1, lsl #2]
ffffffffea804c74:	d2800020 	mov	x0, #0x1                   	// #1
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea804c78:	0a230143 	bic	w3, w10, w3
	GICREG(0, GICD_IPRIORITYR(reg)) = regval;
ffffffffea804c7c:	b82948e3 	str	w3, [x7, w9, uxtw]
ffffffffea804c80:	f8657881 	ldr	x1, [x4, x5, lsl #3]
ffffffffea804c84:	9ad92000 	lsl	x0, x0, x25
	if (enable)
ffffffffea804c88:	34000336 	cbz	w22, ffffffffea804cec <smc_intc_request_fiq+0x19c>
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804c8c:	11110042 	add	w2, w2, #0x440
		*bitmap |= mask;
ffffffffea804c90:	aa010000 	orr	x0, x0, x1
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804c94:	531e7442 	lsl	w2, w2, #2
ffffffffea804c98:	b822c8e6 	str	w6, [x7, w2, sxtw]
		*bitmap |= mask;
ffffffffea804c9c:	f8257880 	str	x0, [x4, x5, lsl #3]
	dprintf(SPEW, "%s: fiq %d, enable %d done\n", __func__, fiq, enable);
ffffffffea804ca0:	2a1503e3 	mov	w3, w21
ffffffffea804ca4:	2a1903e2 	mov	w2, w25
ffffffffea804ca8:	9104e281 	add	x1, x20, #0x138
ffffffffea804cac:	d0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804cb0:	910d0000 	add	x0, x0, #0x340
ffffffffea804cb4:	9400337b 	bl	ffffffffea811aa0 <_dprintf>
    arch_spin_unlock(lock);
ffffffffea804cb8:	91046260 	add	x0, x19, #0x118
ffffffffea804cbc:	97fff6ff 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804cc0:	34000058 	cbz	w24, ffffffffea804cc8 <smc_intc_request_fiq+0x178>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804cc4:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804cc8:	36000057 	tbz	w23, #0, ffffffffea804cd0 <smc_intc_request_fiq+0x180>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804ccc:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea804cd0:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea804cd4:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea804cd8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804cdc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea804ce0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea804ce4:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea804ce8:	d65f03c0 	ret
		GICREG(0, GICD_ICENABLER(reg)) = mask;
ffffffffea804cec:	11118042 	add	w2, w2, #0x460
		*bitmap &= ~mask;
ffffffffea804cf0:	8a200020 	bic	x0, x1, x0
		GICREG(0, GICD_ICENABLER(reg)) = mask;
ffffffffea804cf4:	531e7442 	lsl	w2, w2, #2
ffffffffea804cf8:	b822c8e6 	str	w6, [x7, w2, sxtw]
		*bitmap &= ~mask;
ffffffffea804cfc:	f8257880 	str	x0, [x4, x5, lsl #3]
ffffffffea804d00:	17ffffe8 	b	ffffffffea804ca0 <smc_intc_request_fiq+0x150>
ffffffffea804d04:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804d08 <sm_intc_fiq_enter>:
#endif

status_t sm_intc_fiq_enter(void)
{
ffffffffea804d08:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea804d0c:	910003fd 	mov	x29, sp
ffffffffea804d10:	f9000bf3 	str	x19, [sp, #16]
ffffffffea804d14:	f90013f5 	str	x21, [sp, #32]
ffffffffea804d18:	aa1e03f5 	mov	x21, x30
	u_int cpu = arch_curr_cpu_num();
ffffffffea804d1c:	97fff763 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
	u_int irq = GICREG(0, GICC_IAR) & 0x3ff;
	bool fiq_enabled;

	ASSERT(cpu < 8);
ffffffffea804d20:	71001c1f 	cmp	w0, #0x7
	u_int irq = GICREG(0, GICC_IAR) & 0x3ff;
ffffffffea804d24:	929bfe61 	mov	x1, #0xffffffffffff200c    	// #-57332
ffffffffea804d28:	f2be2801 	movk	x1, #0xf140, lsl #16
ffffffffea804d2c:	b9400033 	ldr	w19, [x1]
	ASSERT(cpu < 8);
ffffffffea804d30:	54000388 	b.hi	ffffffffea804da0 <sm_intc_fiq_enter+0x98>  // b.pmore
ffffffffea804d34:	12002673 	and	w19, w19, #0x3ff

	LTRACEF("cpu %d, irq %i\n", cpu, irq);

	if (irq >= 1020) {
ffffffffea804d38:	710fee7f 	cmp	w19, #0x3fb
ffffffffea804d3c:	54000468 	b.hi	ffffffffea804dc8 <sm_intc_fiq_enter+0xc0>  // b.pmore
		LTRACEF("spurious fiq: cpu %d, old %d, new %d\n", cpu, current_fiq[cpu], irq);
		return ERR_NO_MSG;
	}

	fiq_enabled = update_fiq_targets(cpu, false, irq, false);
ffffffffea804d40:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea804d44:	2a1303e2 	mov	w2, w19
ffffffffea804d48:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea804d4c:	f9000fb4 	str	x20, [x29, #24]
ffffffffea804d50:	2a0003f4 	mov	w20, w0
ffffffffea804d54:	97fffd6b 	bl	ffffffffea804300 <update_fiq_targets>
	GICREG(0, GICC_EOIR) = irq;
ffffffffea804d58:	929bfde2 	mov	x2, #0xffffffffffff2010    	// #-57328

	if (current_fiq[cpu] != 0x3ff) {
ffffffffea804d5c:	b00000a1 	adrp	x1, ffffffffea819000 <_mem_phys_base>
	GICREG(0, GICC_EOIR) = irq;
ffffffffea804d60:	f2be2802 	movk	x2, #0xf140, lsl #16
	if (current_fiq[cpu] != 0x3ff) {
ffffffffea804d64:	2a1403e3 	mov	w3, w20
ffffffffea804d68:	9106c021 	add	x1, x1, #0x1b0
	fiq_enabled = update_fiq_targets(cpu, false, irq, false);
ffffffffea804d6c:	12001c00 	and	w0, w0, #0xff
	GICREG(0, GICC_EOIR) = irq;
ffffffffea804d70:	b9000053 	str	w19, [x2]
	if (current_fiq[cpu] != 0x3ff) {
ffffffffea804d74:	b8637822 	ldr	w2, [x1, x3, lsl #2]
ffffffffea804d78:	710ffc5f 	cmp	w2, #0x3ff
ffffffffea804d7c:	540002a1 	b.ne	ffffffffea804dd0 <sm_intc_fiq_enter+0xc8>  // b.any
		dprintf(INFO, "more than one fiq active: cpu %d, old %d, new %d\n", cpu, current_fiq[cpu], irq);
		return ERR_ALREADY_STARTED;
	}

	if (!fiq_enabled) {
ffffffffea804d80:	34000380 	cbz	w0, ffffffffea804df0 <sm_intc_fiq_enter+0xe8>
		return ERR_NOT_READY;
	}

	current_fiq[cpu] = irq;

	return 0;
ffffffffea804d84:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea804d88:	52800000 	mov	w0, #0x0                   	// #0
	current_fiq[cpu] = irq;
ffffffffea804d8c:	b8237833 	str	w19, [x1, x3, lsl #2]
}
ffffffffea804d90:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea804d94:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea804d98:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea804d9c:	d65f03c0 	ret
	ASSERT(cpu < 8);
ffffffffea804da0:	d0000084 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804da4:	d0000082 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804da8:	b0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804dac:	910ea084 	add	x4, x4, #0x3a8
ffffffffea804db0:	52804823 	mov	w3, #0x241                 	// #577
ffffffffea804db4:	910ec042 	add	x2, x2, #0x3b0
ffffffffea804db8:	9135a021 	add	x1, x1, #0xd68
ffffffffea804dbc:	aa1503e0 	mov	x0, x21
ffffffffea804dc0:	f9000fb4 	str	x20, [x29, #24]
ffffffffea804dc4:	940033b5 	bl	ffffffffea811c98 <_panic>
		return ERR_NO_MSG;
ffffffffea804dc8:	12800060 	mov	w0, #0xfffffffc            	// #-4
ffffffffea804dcc:	17fffff1 	b	ffffffffea804d90 <sm_intc_fiq_enter+0x88>
		dprintf(INFO, "more than one fiq active: cpu %d, old %d, new %d\n", cpu, current_fiq[cpu], irq);
ffffffffea804dd0:	2a1403e1 	mov	w1, w20
ffffffffea804dd4:	d0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804dd8:	2a1303e3 	mov	w3, w19
ffffffffea804ddc:	910aa000 	add	x0, x0, #0x2a8
ffffffffea804de0:	94003330 	bl	ffffffffea811aa0 <_dprintf>
		return ERR_ALREADY_STARTED;
ffffffffea804de4:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea804de8:	128000a0 	mov	w0, #0xfffffffa            	// #-6
ffffffffea804dec:	17ffffe9 	b	ffffffffea804d90 <sm_intc_fiq_enter+0x88>
		dprintf(INFO, "got disabled fiq: cpu %d, new %d\n", cpu, irq);
ffffffffea804df0:	2a1403e1 	mov	w1, w20
ffffffffea804df4:	d0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804df8:	2a1303e2 	mov	w2, w19
ffffffffea804dfc:	910b8000 	add	x0, x0, #0x2e0
ffffffffea804e00:	94003328 	bl	ffffffffea811aa0 <_dprintf>
		return ERR_NOT_READY;
ffffffffea804e04:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea804e08:	12800040 	mov	w0, #0xfffffffd            	// #-3
ffffffffea804e0c:	17ffffe1 	b	ffffffffea804d90 <sm_intc_fiq_enter+0x88>

ffffffffea804e10 <sm_intc_fiq_exit>:

void sm_intc_fiq_exit(void)
{
ffffffffea804e10:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea804e14:	910003fd 	mov	x29, sp
ffffffffea804e18:	f9000bf3 	str	x19, [sp, #16]
ffffffffea804e1c:	aa1e03f3 	mov	x19, x30
	u_int cpu = arch_curr_cpu_num();
ffffffffea804e20:	97fff722 	bl	ffffffffea802aa8 <arch_curr_cpu_num>

	ASSERT(cpu < 8);
ffffffffea804e24:	71001c1f 	cmp	w0, #0x7
ffffffffea804e28:	f9000fb4 	str	x20, [x29, #24]
ffffffffea804e2c:	54000348 	b.hi	ffffffffea804e94 <sm_intc_fiq_exit+0x84>  // b.pmore

	LTRACEF("cpu %d, irq %i\n", cpu, current_fiq[cpu]);
	if (current_fiq[cpu] == 0x3ff) {
ffffffffea804e30:	b00000b3 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea804e34:	2a0003f4 	mov	w20, w0
ffffffffea804e38:	9106c273 	add	x19, x19, #0x1b0
ffffffffea804e3c:	2a0003e3 	mov	w3, w0
ffffffffea804e40:	b8747a62 	ldr	w2, [x19, x20, lsl #2]
ffffffffea804e44:	710ffc5f 	cmp	w2, #0x3ff
ffffffffea804e48:	54000140 	b.eq	ffffffffea804e70 <sm_intc_fiq_exit+0x60>  // b.none
		dprintf(INFO, "%s: no fiq active, cpu %d\n", __func__, cpu);
		return;
	}
	update_fiq_targets(cpu, true, current_fiq[cpu], false);
ffffffffea804e4c:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea804e50:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea804e54:	97fffd2b 	bl	ffffffffea804300 <update_fiq_targets>
	current_fiq[cpu] = 0x3ff;
ffffffffea804e58:	52807fe0 	mov	w0, #0x3ff                 	// #1023
ffffffffea804e5c:	b8347a60 	str	w0, [x19, x20, lsl #2]
ffffffffea804e60:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea804e64:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea804e68:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea804e6c:	d65f03c0 	ret
		dprintf(INFO, "%s: no fiq active, cpu %d\n", __func__, cpu);
ffffffffea804e70:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea804e74:	d0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
}
ffffffffea804e78:	f9400bf3 	ldr	x19, [sp, #16]
		dprintf(INFO, "%s: no fiq active, cpu %d\n", __func__, cpu);
ffffffffea804e7c:	d0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
}
ffffffffea804e80:	a8c27bfd 	ldp	x29, x30, [sp], #32
		dprintf(INFO, "%s: no fiq active, cpu %d\n", __func__, cpu);
ffffffffea804e84:	2a0303e2 	mov	w2, w3
ffffffffea804e88:	91054021 	add	x1, x1, #0x150
ffffffffea804e8c:	910c2000 	add	x0, x0, #0x308
ffffffffea804e90:	14003304 	b	ffffffffea811aa0 <_dprintf>
	ASSERT(cpu < 8);
ffffffffea804e94:	d0000084 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804e98:	d0000082 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea804e9c:	b0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804ea0:	910ea084 	add	x4, x4, #0x3a8
ffffffffea804ea4:	52804c03 	mov	w3, #0x260                 	// #608
ffffffffea804ea8:	910ec042 	add	x2, x2, #0x3b0
ffffffffea804eac:	9135a021 	add	x1, x1, #0xd68
ffffffffea804eb0:	aa1303e0 	mov	x0, x19
ffffffffea804eb4:	94003379 	bl	ffffffffea811c98 <_panic>

ffffffffea804eb8 <arm_gic_sim_irq_handler>:
 *        expired.
 *        The body of this function is a mimic of irq_exception routine in
 *        arch/arm64/exceptions.S
 */
status_t arm_gic_sim_irq_handler(u_int irq)
{
ffffffffea804eb8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea804ebc:	910003fd 	mov	x29, sp
ffffffffea804ec0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804ec4:	2a0003f4 	mov	w20, w0
	status_t ret = NO_ERROR;
#if WITH_LIB_SM
	uint cpu = arch_curr_cpu_num();
ffffffffea804ec8:	97fff6f8 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
	struct int_handler_struct *h;
	spin_lock_saved_state_t state;

	LTRACEF("irq: %u cpu: %u\n", irq, cpu);

	if (irq >= MAX_INT) {
ffffffffea804ecc:	710c7e9f 	cmp	w20, #0x31f
ffffffffea804ed0:	54000c28 	b.hi	ffffffffea805054 <arm_gic_sim_irq_handler+0x19c>  // b.pmore
ffffffffea804ed4:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea804ed8:	2a0003f3 	mov	w19, w0
ffffffffea804edc:	f9001bb7 	str	x23, [x29, #48]
			irq, MAX_INT);
		return ERR_INVALID_ARGS;
	}

	/* Barrier against speculatively loading int_handler_struct addresses */
	platform_arch_speculation_barrier();
ffffffffea804ee0:	97fff4d4 	bl	ffffffffea802230 <platform_arch_speculation_barrier>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804ee4:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea804ee8:	52800016 	mov	w22, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804eec:	36380520 	tbz	w0, #7, ffffffffea804f90 <arm_gic_sim_irq_handler+0xd8>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804ef0:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804ef4:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea804ef8:	37300080 	tbnz	w0, #6, ffffffffea804f08 <arm_gic_sim_irq_handler+0x50>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804efc:	321f02d6 	orr	w22, w22, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804f00:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804f04:	52800057 	mov	w23, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804f08:	900002b5 	adrp	x21, ffffffffea858000 <__bss_start>
ffffffffea804f0c:	910462a0 	add	x0, x21, #0x118
ffffffffea804f10:	97fff662 	bl	ffffffffea802898 <arch_spin_lock>
	if (vector < GIC_MAX_PER_CPU_INT)
ffffffffea804f14:	71007e9f 	cmp	w20, #0x1f
ffffffffea804f18:	54000309 	b.ls	ffffffffea804f78 <arm_gic_sim_irq_handler+0xc0>  // b.plast
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804f1c:	51008281 	sub	w1, w20, #0x20
ffffffffea804f20:	b00002a0 	adrp	x0, ffffffffea859000 <int_handler_table_per_cpu+0xee0>
ffffffffea804f24:	91048000 	add	x0, x0, #0x120
ffffffffea804f28:	8b011001 	add	x1, x0, x1, lsl #4

	spin_lock_save(&gicd_lock, &state, GICD_LOCK_FLAGS);
	if ((h = get_int_handler(irq, cpu))->handler != NULL) {
ffffffffea804f2c:	f9400022 	ldr	x2, [x1]
ffffffffea804f30:	b4000802 	cbz	x2, ffffffffea805030 <arm_gic_sim_irq_handler+0x178>
		if (h->handler(h->arg) == INT_RESCHEDULE) {
ffffffffea804f34:	f9400420 	ldr	x0, [x1, #8]
	status_t ret = NO_ERROR;
ffffffffea804f38:	52800013 	mov	w19, #0x0                   	// #0
		if (h->handler(h->arg) == INT_RESCHEDULE) {
ffffffffea804f3c:	d63f0040 	blr	x2
ffffffffea804f40:	7100041f 	cmp	w0, #0x1
ffffffffea804f44:	54000380 	b.eq	ffffffffea804fb4 <arm_gic_sim_irq_handler+0xfc>  // b.none
    arch_spin_unlock(lock);
ffffffffea804f48:	910462a0 	add	x0, x21, #0x118
ffffffffea804f4c:	97fff65b 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804f50:	34000057 	cbz	w23, ffffffffea804f58 <arm_gic_sim_irq_handler+0xa0>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804f54:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804f58:	36000236 	tbz	w22, #0, ffffffffea804f9c <arm_gic_sim_irq_handler+0xe4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804f5c:	d50342ff 	msr	daifclr, #0x2
ffffffffea804f60:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea804f64:	f9401bb7 	ldr	x23, [x29, #48]
	spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);
#else
	ret = ERR_NOT_SUPPORTED;
#endif
	return ret;
}
ffffffffea804f68:	2a1303e0 	mov	w0, w19
ffffffffea804f6c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804f70:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea804f74:	d65f03c0 	ret
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804f78:	2a1303e1 	mov	w1, w19
ffffffffea804f7c:	900002a0 	adrp	x0, ffffffffea858000 <__bss_start>
ffffffffea804f80:	8b344c21 	add	x1, x1, w20, uxtw #3
ffffffffea804f84:	91048000 	add	x0, x0, #0x120
ffffffffea804f88:	8b011001 	add	x1, x0, x1, lsl #4
ffffffffea804f8c:	17ffffe8 	b	ffffffffea804f2c <arm_gic_sim_irq_handler+0x74>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804f90:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804f94:	52800036 	mov	w22, #0x1                   	// #1
ffffffffea804f98:	17ffffd6 	b	ffffffffea804ef0 <arm_gic_sim_irq_handler+0x38>
}
ffffffffea804f9c:	2a1303e0 	mov	w0, w19
ffffffffea804fa0:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea804fa4:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea804fa8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804fac:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea804fb0:	d65f03c0 	ret
ffffffffea804fb4:	910462a0 	add	x0, x21, #0x118
ffffffffea804fb8:	97fff640 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804fbc:	34000057 	cbz	w23, ffffffffea804fc4 <arm_gic_sim_irq_handler+0x10c>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804fc0:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804fc4:	36000056 	tbz	w22, #0, ffffffffea804fcc <arm_gic_sim_irq_handler+0x114>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804fc8:	d50342ff 	msr	daifclr, #0x2
			    thread_preempt();
ffffffffea804fcc:	94000527 	bl	ffffffffea806468 <thread_preempt>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804fd0:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea804fd4:	52800016 	mov	w22, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804fd8:	37380060 	tbnz	w0, #7, ffffffffea804fe4 <arm_gic_sim_irq_handler+0x12c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804fdc:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804fe0:	52800036 	mov	w22, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804fe4:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804fe8:	37300160 	tbnz	w0, #6, ffffffffea805014 <arm_gic_sim_irq_handler+0x15c>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804fec:	321f02d6 	orr	w22, w22, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804ff0:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea804ff4:	910462b5 	add	x21, x21, #0x118
	status_t ret = NO_ERROR;
ffffffffea804ff8:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea804ffc:	aa1503e0 	mov	x0, x21
ffffffffea805000:	97fff626 	bl	ffffffffea802898 <arch_spin_lock>
    arch_spin_unlock(lock);
ffffffffea805004:	aa1503e0 	mov	x0, x21
ffffffffea805008:	97fff62c 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea80500c:	d50341ff 	msr	daifclr, #0x1
ffffffffea805010:	17ffffd2 	b	ffffffffea804f58 <arm_gic_sim_irq_handler+0xa0>
    arch_spin_lock(lock);
ffffffffea805014:	910462b5 	add	x21, x21, #0x118
ffffffffea805018:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea80501c:	aa1503e0 	mov	x0, x21
ffffffffea805020:	97fff61e 	bl	ffffffffea802898 <arch_spin_lock>
    arch_spin_unlock(lock);
ffffffffea805024:	aa1503e0 	mov	x0, x21
ffffffffea805028:	97fff624 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea80502c:	17ffffcb 	b	ffffffffea804f58 <arm_gic_sim_irq_handler+0xa0>
		ret = ERR_NOT_FOUND;
ffffffffea805030:	12800033 	mov	w19, #0xfffffffe            	// #-2
		TRACEF("interrupt handler not found. irq: %u\n", irq);
ffffffffea805034:	b0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea805038:	b0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80503c:	2a1403e3 	mov	w3, w20
ffffffffea805040:	52805242 	mov	w2, #0x292                 	// #658
ffffffffea805044:	91042021 	add	x1, x1, #0x108
ffffffffea805048:	91078000 	add	x0, x0, #0x1e0
ffffffffea80504c:	94003879 	bl	ffffffffea813230 <_printf>
ffffffffea805050:	17ffffbe 	b	ffffffffea804f48 <arm_gic_sim_irq_handler+0x90>
		TRACEF("Interrupt out of range: vector = %u, MAX_INT = %u\n",
ffffffffea805054:	b0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea805058:	b0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80505c:	52806404 	mov	w4, #0x320                 	// #800
ffffffffea805060:	2a1403e3 	mov	w3, w20
ffffffffea805064:	52805062 	mov	w2, #0x283                 	// #643
ffffffffea805068:	91042021 	add	x1, x1, #0x108
		return ERR_INVALID_ARGS;
ffffffffea80506c:	128000f3 	mov	w19, #0xfffffff8            	// #-8
		TRACEF("Interrupt out of range: vector = %u, MAX_INT = %u\n",
ffffffffea805070:	91068000 	add	x0, x0, #0x1a0
ffffffffea805074:	9400386f 	bl	ffffffffea813230 <_printf>
		return ERR_INVALID_ARGS;
ffffffffea805078:	17ffffbc 	b	ffffffffea804f68 <arm_gic_sim_irq_handler+0xb0>
ffffffffea80507c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805080 <cntpct_to_lk_time>:
}

static inline uint64_t
mul_u32_u32(uint32_t a, uint32_t b, int a_shift, int b_shift)
{
    uint64_t ret = (uint64_t)a * b;
ffffffffea805080:	b00002c1 	adrp	x1, ffffffffea85e000 <rb_data+0x18>
ffffffffea805084:	9101c024 	add	x4, x1, #0x70
ffffffffea805088:	92407c02 	and	x2, x0, #0xffffffff
}

static inline uint32_t
u32_mul_u64_fp32_64(uint64_t a, struct fp_32_64 b)
{
    uint32_t a_r32 = a >> 32;
ffffffffea80508c:	d360fc00 	lsr	x0, x0, #32
    uint64_t ret = (uint64_t)a * b;
ffffffffea805090:	b9407023 	ldr	w3, [x1, #112]
ffffffffea805094:	b9400881 	ldr	w1, [x4, #8]
ffffffffea805098:	b9400484 	ldr	w4, [x4, #4]
ffffffffea80509c:	9b027c63 	mul	x3, x3, x2
ffffffffea8050a0:	9b017c05 	mul	x5, x0, x1
ffffffffea8050a4:	9b017c41 	mul	x1, x2, x1
    uint64_t res_l32;
    uint32_t ret;

    /* mul_u32_u32(a_r32, b.l0, 32, 0) does not affect result */
    res_l32 = mul_u32_u32(a_0, b.l0, 0, 0) << 32;
    res_l32 += mul_u32_u32(a_r32, b.l32, 32, -32) << 32;
ffffffffea8050a8:	9b040c00 	madd	x0, x0, x4, x3
ffffffffea8050ac:	9b041442 	madd	x2, x2, x4, x5
ffffffffea8050b0:	8b008040 	add	x0, x2, x0, lsl #32
    res_l32 += mul_u32_u32(a_0, b.l32, 0, -32);
    res_l32 += mul_u32_u32(a_r32, b.l64, 32, -64);
    res_l32 += mul_u32_u32(a_0, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea8050b4:	8b418000 	add	x0, x0, x1, lsr #32
    ret = (res_l32 >> 32) + ((uint32_t)res_l32 >> 31); /* Round to nearest integer */
ffffffffea8050b8:	d360fc01 	lsr	x1, x0, #32
}

static lk_time_t cntpct_to_lk_time(uint64_t cntpct)
{
	return u32_mul_u64_fp32_64(cntpct, ms_per_cntpct);
}
ffffffffea8050bc:	0b407c20 	add	w0, w1, w0, lsr #31
ffffffffea8050c0:	d65f03c0 	ret
ffffffffea8050c4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8050c8 <platform_tick>:
}

static void write_cntp_ctl(uint32_t cntp_ctl)
{
	LTRACEF_LEVEL(3, "cntp_ctl: 0x%x %x\n", cntp_ctl, read_cntp_ctl());
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea8050c8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8050cc:	d51fe221 	msr	cntps_ctl_el1, x1
ffffffffea8050d0:	d5033fdf 	isb
}

static enum handler_return platform_tick(void *arg)
{
	write_cntp_ctl(0);
	if (t_callback) {
ffffffffea8050d4:	f00002a1 	adrp	x1, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
ffffffffea8050d8:	f9409027 	ldr	x7, [x1, #288]
ffffffffea8050dc:	b4000147 	cbz	x7, ffffffffea805104 <platform_tick+0x3c>
{
ffffffffea8050e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea8050e4:	aa0003e6 	mov	x6, x0
ffffffffea8050e8:	910003fd 	mov	x29, sp
	cntpct = READ_TIMER_REG64(TIMER_REG_CT);
ffffffffea8050ec:	d53be020 	mrs	x0, cntpct_el0
	return cntpct_to_lk_bigtime(read_cntpct());
}

lk_time_t current_time(void)
{
	return cntpct_to_lk_time(read_cntpct());
ffffffffea8050f0:	97ffffe4 	bl	ffffffffea805080 <cntpct_to_lk_time>
		return t_callback(arg, current_time());
ffffffffea8050f4:	2a0003e1 	mov	w1, w0
}
ffffffffea8050f8:	a8c17bfd 	ldp	x29, x30, [sp], #16
		return t_callback(arg, current_time());
ffffffffea8050fc:	aa0603e0 	mov	x0, x6
ffffffffea805100:	d61f00e0 	br	x7
}
ffffffffea805104:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805108:	d65f03c0 	ret
ffffffffea80510c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805110 <arm_generic_timer_resume_cpu>:
	WRITE_TIMER_REG32(TIMER_REG_TVAL, cntp_tval);
ffffffffea805110:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805114:	d51fe200 	msr	cntps_tval_el1, x0
ffffffffea805118:	d5033fdf 	isb
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea80511c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea805120:	d51fe220 	msr	cntps_ctl_el1, x0
ffffffffea805124:	d5033fdf 	isb
static void arm_generic_timer_resume_cpu(uint level)
{
	/* Always trigger a timer interrupt on each cpu for now */
	write_cntp_tval(0);
	write_cntp_ctl(1);
}
ffffffffea805128:	d65f03c0 	ret
ffffffffea80512c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805130 <arm_generic_timer_init_secondary_cpu>:
{
ffffffffea805130:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	register_int_handler(timer_irq, &platform_tick, NULL);
ffffffffea805134:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea805138:	90000001 	adrp	x1, ffffffffea805000 <arm_gic_sim_irq_handler+0x148>
ffffffffea80513c:	91032021 	add	x1, x1, #0xc8
{
ffffffffea805140:	910003fd 	mov	x29, sp
ffffffffea805144:	f9000bf3 	str	x19, [sp, #16]
	register_int_handler(timer_irq, &platform_tick, NULL);
ffffffffea805148:	f00002b3 	adrp	x19, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
ffffffffea80514c:	b9412a60 	ldr	w0, [x19, #296]
ffffffffea805150:	97fffce2 	bl	ffffffffea8044d8 <register_int_handler>
	unmask_interrupt(timer_irq);
ffffffffea805154:	b9412a60 	ldr	w0, [x19, #296]
}
ffffffffea805158:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80515c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	unmask_interrupt(timer_irq);
ffffffffea805160:	17fffdb0 	b	ffffffffea804820 <unmask_interrupt>
ffffffffea805164:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805168 <test_cntpct_to_lk_time>:
{
ffffffffea805168:	2a0003e5 	mov	w5, w0
ffffffffea80516c:	2a0103e8 	mov	w8, w1
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea805170:	d29ef9e1 	mov	x1, #0xf7cf                	// #63439
{
ffffffffea805174:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea805178:	f2bc6a61 	movk	x1, #0xe353, lsl #16
	if ((uint64_t)cntfrq * wrap_count > UINT_MAX)
ffffffffea80517c:	b2407fe3 	mov	x3, #0xffffffff            	// #4294967295
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea805180:	9ba87ca0 	umull	x0, w5, w8
ffffffffea805184:	f2d374a1 	movk	x1, #0x9ba5, lsl #32
ffffffffea805188:	f2e41881 	movk	x1, #0x20c4, lsl #48
	if ((uint64_t)cntfrq * wrap_count > UINT_MAX)
ffffffffea80518c:	9ba27ca4 	umull	x4, w5, w2
{
ffffffffea805190:	910003fd 	mov	x29, sp
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea805194:	d343fc00 	lsr	x0, x0, #3
{
ffffffffea805198:	aa0503e6 	mov	x6, x5
ffffffffea80519c:	aa0803e7 	mov	x7, x8
	if ((uint64_t)cntfrq * wrap_count > UINT_MAX)
ffffffffea8051a0:	eb03009f 	cmp	x4, x3
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea8051a4:	9bc17c00 	umulh	x0, x0, x1
ffffffffea8051a8:	d344fc00 	lsr	x0, x0, #4
	if ((uint64_t)cntfrq * wrap_count > UINT_MAX)
ffffffffea8051ac:	54000229 	b.ls	ffffffffea8051f0 <test_cntpct_to_lk_time+0x88>  // b.plast
		cntpct += (((uint64_t)cntfrq << 32) / 1000) * wrap_count;
ffffffffea8051b0:	d36388a4 	lsl	x4, x5, #29
ffffffffea8051b4:	2a0203e2 	mov	w2, w2
ffffffffea8051b8:	9bc17c84 	umulh	x4, x4, x1
ffffffffea8051bc:	d344fc84 	lsr	x4, x4, #4
ffffffffea8051c0:	9b020080 	madd	x0, x4, x2, x0
	lk_time = cntpct_to_lk_time(cntpct);
ffffffffea8051c4:	97ffffaf 	bl	ffffffffea805080 <cntpct_to_lk_time>
	if (a != b) {
ffffffffea8051c8:	eb20411f 	cmp	x8, w0, uxtw
ffffffffea8051cc:	540000e0 	b.eq	ffffffffea8051e8 <test_cntpct_to_lk_time+0x80>  // b.none
	test_time_conversion_check_result(lk_time, expected_lk_time, (1000 + cntfrq - 1) / cntfrq, true);
ffffffffea8051d0:	110f9cc1 	add	w1, w6, #0x3e7
	return (a > 0) ? a : -a;
ffffffffea8051d4:	6b070000 	subs	w0, w0, w7
ffffffffea8051d8:	5a805400 	cneg	w0, w0, mi  // mi = first
	test_time_conversion_check_result(lk_time, expected_lk_time, (1000 + cntfrq - 1) / cntfrq, true);
ffffffffea8051dc:	1ac60826 	udiv	w6, w1, w6
		if (diff <= limit)
ffffffffea8051e0:	6b0000df 	cmp	w6, w0
ffffffffea8051e4:	540000e3 	b.cc	ffffffffea805200 <test_cntpct_to_lk_time+0x98>  // b.lo, b.ul, b.last
}
ffffffffea8051e8:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8051ec:	d65f03c0 	ret
		cntpct += (((uint64_t)(cntfrq * wrap_count) << 32) / 1000);
ffffffffea8051f0:	d3637c84 	ubfiz	x4, x4, #29, #32
ffffffffea8051f4:	9bc17c84 	umulh	x4, x4, x1
ffffffffea8051f8:	8b441000 	add	x0, x0, x4, lsr #4
ffffffffea8051fc:	17fffff2 	b	ffffffffea8051c4 <test_cntpct_to_lk_time+0x5c>
}
ffffffffea805200:	a8c17bfd 	ldp	x29, x30, [sp], #16
			TRACEF("FAIL, off by %llu\n", diff);
ffffffffea805204:	b0000084 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea805208:	93407c03 	sxtw	x3, w0
ffffffffea80520c:	b0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea805210:	52801f42 	mov	w2, #0xfa                  	// #250
ffffffffea805214:	910f8021 	add	x1, x1, #0x3e0
ffffffffea805218:	9113a080 	add	x0, x4, #0x4e8
ffffffffea80521c:	14003805 	b	ffffffffea813230 <_printf>

ffffffffea805220 <test_cntpct_to_lk_bigtime>:
	uint64_t cntpct = (uint64_t)cntfrq * expected_s;
ffffffffea805220:	2a0003e4 	mov	w4, w0
    uint64_t ret = (uint64_t)a * b;
ffffffffea805224:	b00002c5 	adrp	x5, ffffffffea85e000 <rb_data+0x18>
ffffffffea805228:	910180a2 	add	x2, x5, #0x60
	lk_bigtime_t expected_lk_bigtime = expected_s * 1000 * 1000;
ffffffffea80522c:	d2884803 	mov	x3, #0x4240                	// #16960
ffffffffea805230:	b94060a6 	ldr	w6, [x5, #96]
ffffffffea805234:	f2a001e3 	movk	x3, #0xf, lsl #16
	uint64_t cntpct = (uint64_t)cntfrq * expected_s;
ffffffffea805238:	9b017c84 	mul	x4, x4, x1
ffffffffea80523c:	29409449 	ldp	w9, w5, [x2, #4]
ffffffffea805240:	92407c88 	and	x8, x4, #0xffffffff
}

static inline uint64_t
u64_mul_u64_fp32_64(uint64_t a, struct fp_32_64 b)
{
    uint32_t a_r32 = a >> 32;
ffffffffea805244:	d360fc84 	lsr	x4, x4, #32
	lk_bigtime_t expected_lk_bigtime = expected_s * 1000 * 1000;
ffffffffea805248:	9b037c21 	mul	x1, x1, x3
    uint64_t ret = (uint64_t)a * b;
ffffffffea80524c:	9b097d07 	mul	x7, x8, x9
ffffffffea805250:	9b057d02 	mul	x2, x8, x5
ffffffffea805254:	9b057c85 	mul	x5, x4, x5
ffffffffea805258:	9b067c83 	mul	x3, x4, x6
    tmp = mul_u32_u32(a_0, b.l32, 0, -32);
    res_0 += tmp >> 32;
    res_l32 = (uint32_t)tmp;
    tmp = mul_u32_u32(a_r32, b.l64, 32, -64);
    res_0 += tmp >> 32;
    res_l32 += (uint32_t)tmp;
ffffffffea80525c:	92407caa 	and	x10, x5, #0xffffffff
    uint64_t ret = (uint64_t)a * b;
ffffffffea805260:	9b097c84 	mul	x4, x4, x9
    res_0 += tmp >> 32;
ffffffffea805264:	d360fce9 	lsr	x9, x7, #32
    res_l32 += (uint32_t)tmp;
ffffffffea805268:	8b274147 	add	x7, x10, w7, uxtw
    tmp = mul_u32_u32(a_0, b.l64, 0, -64); /* Improve rounding accuracy */
    res_l32 += tmp >> 32;
    res_0 += res_l32 >> 32;
    res_l32_32 = res_l32;
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea80526c:	9b0810c4 	madd	x4, x6, x8, x4
    res_l32 += tmp >> 32;
ffffffffea805270:	8b4280e2 	add	x2, x7, x2, lsr #32
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805274:	8b038123 	add	x3, x9, x3, lsl #32
ffffffffea805278:	8b040063 	add	x3, x3, x4
    res_0 += res_l32 >> 32;
ffffffffea80527c:	d360fc44 	lsr	x4, x2, #32
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805280:	8b458085 	add	x5, x4, x5, lsr #32
ffffffffea805284:	531f7c42 	lsr	w2, w2, #31
ffffffffea805288:	8b050063 	add	x3, x3, x5
ffffffffea80528c:	8b030043 	add	x3, x2, x3
	if (a != b) {
ffffffffea805290:	eb03003f 	cmp	x1, x3
ffffffffea805294:	54000100 	b.eq	ffffffffea8052b4 <test_cntpct_to_lk_bigtime+0x94>  // b.none
	test_time_conversion_check_result(lk_bigtime, expected_lk_bigtime, (1000 * 1000 + cntfrq - 1) / cntfrq, false);
ffffffffea805298:	1143d002 	add	w2, w0, #0xf4, lsl #12
	return (a > 0) ? a : -a;
ffffffffea80529c:	eb010063 	subs	x3, x3, x1
	test_time_conversion_check_result(lk_bigtime, expected_lk_bigtime, (1000 * 1000 + cntfrq - 1) / cntfrq, false);
ffffffffea8052a0:	1108fc42 	add	w2, w2, #0x23f
	return (a > 0) ? a : -a;
ffffffffea8052a4:	da835463 	cneg	x3, x3, mi  // mi = first
	test_time_conversion_check_result(lk_bigtime, expected_lk_bigtime, (1000 * 1000 + cntfrq - 1) / cntfrq, false);
ffffffffea8052a8:	1ac00840 	udiv	w0, w2, w0
		if (diff <= limit)
ffffffffea8052ac:	eb03001f 	cmp	x0, x3
ffffffffea8052b0:	54000043 	b.cc	ffffffffea8052b8 <test_cntpct_to_lk_bigtime+0x98>  // b.lo, b.ul, b.last
}
ffffffffea8052b4:	d65f03c0 	ret
			TRACEF("FAIL, off by %llu\n", diff);
ffffffffea8052b8:	b0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8052bc:	b0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8052c0:	52801f42 	mov	w2, #0xfa                  	// #250
ffffffffea8052c4:	910f8021 	add	x1, x1, #0x3e0
ffffffffea8052c8:	9113a000 	add	x0, x0, #0x4e8
ffffffffea8052cc:	140037d9 	b	ffffffffea813230 <_printf>

ffffffffea8052d0 <test_lk_time_to_cntpct>:
    uint64_t ret = (uint64_t)a * b;
ffffffffea8052d0:	b00002c3 	adrp	x3, ffffffffea85e000 <rb_data+0x18>
ffffffffea8052d4:	91020064 	add	x4, x3, #0x80
	uint64_t expected_cntpct = ((uint64_t)cntfrq * lk_time + 500) / 1000;
ffffffffea8052d8:	d2803e82 	mov	x2, #0x1f4                 	// #500
ffffffffea8052dc:	d29ef9e7 	mov	x7, #0xf7cf                	// #63439
    ret = res_0 + (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea8052e0:	b9408066 	ldr	w6, [x3, #128]
ffffffffea8052e4:	f2bc6a67 	movk	x7, #0xe353, lsl #16
    uint64_t ret = (uint64_t)a * b;
ffffffffea8052e8:	29409085 	ldp	w5, w4, [x4, #4]
ffffffffea8052ec:	d503201f 	nop
ffffffffea8052f0:	9ba10803 	umaddl	x3, w0, w1, x2
ffffffffea8052f4:	f2d374a7 	movk	x7, #0x9ba5, lsl #32
ffffffffea8052f8:	f2e41887 	movk	x7, #0x20c4, lsl #48
ffffffffea8052fc:	9ba57c25 	umull	x5, w1, w5
ffffffffea805300:	d343fc63 	lsr	x3, x3, #3
ffffffffea805304:	9ba47c20 	umull	x0, w1, w4
    res_l32 += mul_u32_u32(a, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea805308:	92407ca2 	and	x2, x5, #0xffffffff
    res_0 += tmp >> 32;
ffffffffea80530c:	d360fca5 	lsr	x5, x5, #32
ffffffffea805310:	9bc77c63 	umulh	x3, x3, x7
    res_l32 += mul_u32_u32(a, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea805314:	8b408040 	add	x0, x2, x0, lsr #32
    ret = res_0 + (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805318:	9ba61421 	umaddl	x1, w1, w6, x5
ffffffffea80531c:	531f7c02 	lsr	w2, w0, #31
ffffffffea805320:	8b408040 	add	x0, x2, x0, lsr #32
ffffffffea805324:	d344fc63 	lsr	x3, x3, #4
ffffffffea805328:	8b000021 	add	x1, x1, x0
	if (a != b) {
ffffffffea80532c:	eb01007f 	cmp	x3, x1
ffffffffea805330:	540000a0 	b.eq	ffffffffea805344 <test_lk_time_to_cntpct+0x74>  // b.none
	return (a > 0) ? a : -a;
ffffffffea805334:	eb030021 	subs	x1, x1, x3
ffffffffea805338:	da815423 	cneg	x3, x1, mi  // mi = first
		if (diff <= limit)
ffffffffea80533c:	f100047f 	cmp	x3, #0x1
ffffffffea805340:	54000041 	b.ne	ffffffffea805348 <test_lk_time_to_cntpct+0x78>  // b.any
}
ffffffffea805344:	d65f03c0 	ret
			TRACEF("FAIL, off by %llu\n", diff);
ffffffffea805348:	b0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80534c:	b0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea805350:	52801f42 	mov	w2, #0xfa                  	// #250
ffffffffea805354:	910f8021 	add	x1, x1, #0x3e0
ffffffffea805358:	9113a000 	add	x0, x0, #0x4e8
ffffffffea80535c:	140037b5 	b	ffffffffea813230 <_printf>

ffffffffea805360 <platform_set_oneshot_timer>:
    uint64_t ret = (uint64_t)a * b;
ffffffffea805360:	b00002c4 	adrp	x4, ffffffffea85e000 <rb_data+0x18>
ffffffffea805364:	91020083 	add	x3, x4, #0x80
    ret = res_0 + (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805368:	b9408086 	ldr	w6, [x4, #128]
    uint64_t ret = (uint64_t)a * b;
ffffffffea80536c:	29408c64 	ldp	w4, w3, [x3, #4]
ffffffffea805370:	9ba47c44 	umull	x4, w2, w4
ffffffffea805374:	9ba37c43 	umull	x3, w2, w3
    res_l32 += mul_u32_u32(a, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea805378:	92407c85 	and	x5, x4, #0xffffffff
    res_0 += tmp >> 32;
ffffffffea80537c:	d360fc84 	lsr	x4, x4, #32
    res_l32 += mul_u32_u32(a, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea805380:	8b4380a3 	add	x3, x5, x3, lsr #32
    ret = res_0 + (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805384:	9ba61042 	umaddl	x2, w2, w6, x4
ffffffffea805388:	531f7c65 	lsr	w5, w3, #31
ffffffffea80538c:	8b4380a3 	add	x3, x5, x3, lsr #32
ffffffffea805390:	8b030042 	add	x2, x2, x3
	ASSERT(arg == NULL);
ffffffffea805394:	b50002c1 	cbnz	x1, ffffffffea8053ec <platform_set_oneshot_timer+0x8c>
	t_callback = callback;
ffffffffea805398:	f00002a1 	adrp	x1, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
	if (cntpct_interval <= INT_MAX)
ffffffffea80539c:	b2407be3 	mov	x3, #0x7fffffff            	// #2147483647
ffffffffea8053a0:	eb03005f 	cmp	x2, x3
	t_callback = callback;
ffffffffea8053a4:	f9009020 	str	x0, [x1, #288]
	if (cntpct_interval <= INT_MAX)
ffffffffea8053a8:	54000149 	b.ls	ffffffffea8053d0 <platform_set_oneshot_timer+0x70>  // b.plast
	cntpct = READ_TIMER_REG64(TIMER_REG_CT);
ffffffffea8053ac:	d53be020 	mrs	x0, cntpct_el0
		write_cntp_cval(read_cntpct() + cntpct_interval);
ffffffffea8053b0:	8b000042 	add	x2, x2, x0
	WRITE_TIMER_REG64(TIMER_REG_CVAL, cntp_cval);
ffffffffea8053b4:	d51fe242 	msr	cntps_cval_el1, x2
ffffffffea8053b8:	d5033fdf 	isb
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea8053bc:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea8053c0:	d51fe220 	msr	cntps_ctl_el1, x0
ffffffffea8053c4:	d5033fdf 	isb
}
ffffffffea8053c8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8053cc:	d65f03c0 	ret
	WRITE_TIMER_REG32(TIMER_REG_TVAL, cntp_tval);
ffffffffea8053d0:	d51fe202 	msr	cntps_tval_el1, x2
ffffffffea8053d4:	d5033fdf 	isb
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea8053d8:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea8053dc:	d51fe220 	msr	cntps_ctl_el1, x0
ffffffffea8053e0:	d5033fdf 	isb
}
ffffffffea8053e4:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8053e8:	d65f03c0 	ret
{
ffffffffea8053ec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(arg == NULL);
ffffffffea8053f0:	b0000084 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8053f4:	b0000082 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8053f8:	90000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
{
ffffffffea8053fc:	910003fd 	mov	x29, sp
ffffffffea805400:	aa1e03e0 	mov	x0, x30
	ASSERT(arg == NULL);
ffffffffea805404:	91116084 	add	x4, x4, #0x458
ffffffffea805408:	528019c3 	mov	w3, #0xce                  	// #206
ffffffffea80540c:	9111a042 	add	x2, x2, #0x468
ffffffffea805410:	9135a021 	add	x1, x1, #0xd68
ffffffffea805414:	94003221 	bl	ffffffffea811c98 <_panic>

ffffffffea805418 <platform_stop_timer>:
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea805418:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80541c:	d51fe220 	msr	cntps_ctl_el1, x0
ffffffffea805420:	d5033fdf 	isb
}
ffffffffea805424:	d65f03c0 	ret

ffffffffea805428 <current_time_hires>:
	cntpct = READ_TIMER_REG64(TIMER_REG_CT);
ffffffffea805428:	d53be023 	mrs	x3, cntpct_el0
    uint64_t ret = (uint64_t)a * b;
ffffffffea80542c:	b00002c1 	adrp	x1, ffffffffea85e000 <rb_data+0x18>
ffffffffea805430:	91018020 	add	x0, x1, #0x60
    uint32_t a_r32 = a >> 32;
ffffffffea805434:	d360fc64 	lsr	x4, x3, #32
ffffffffea805438:	92407c63 	and	x3, x3, #0xffffffff
    uint64_t ret = (uint64_t)a * b;
ffffffffea80543c:	b9406026 	ldr	w6, [x1, #96]
ffffffffea805440:	29408007 	ldp	w7, w0, [x0, #4]
ffffffffea805444:	9b067c82 	mul	x2, x4, x6
ffffffffea805448:	9b007c85 	mul	x5, x4, x0
ffffffffea80544c:	9b077c61 	mul	x1, x3, x7
ffffffffea805450:	9b007c60 	mul	x0, x3, x0
ffffffffea805454:	9b077c84 	mul	x4, x4, x7
    res_l32 += (uint32_t)tmp;
ffffffffea805458:	92407ca7 	and	x7, x5, #0xffffffff
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea80545c:	9b0310c4 	madd	x4, x6, x3, x4
    res_l32 += (uint32_t)tmp;
ffffffffea805460:	8b2140e3 	add	x3, x7, w1, uxtw
    res_l32 += tmp >> 32;
ffffffffea805464:	8b408060 	add	x0, x3, x0, lsr #32
    res_0 += tmp >> 32;
ffffffffea805468:	d360fc21 	lsr	x1, x1, #32
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea80546c:	8b028021 	add	x1, x1, x2, lsl #32
    res_0 += res_l32 >> 32;
ffffffffea805470:	d360fc02 	lsr	x2, x0, #32
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805474:	8b040021 	add	x1, x1, x4
ffffffffea805478:	8b458045 	add	x5, x2, x5, lsr #32
ffffffffea80547c:	531f7c00 	lsr	w0, w0, #31
ffffffffea805480:	8b050021 	add	x1, x1, x5
}
ffffffffea805484:	8b010000 	add	x0, x0, x1
ffffffffea805488:	d65f03c0 	ret
ffffffffea80548c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805490 <current_time>:
	cntpct = READ_TIMER_REG64(TIMER_REG_CT);
ffffffffea805490:	d53be020 	mrs	x0, cntpct_el0
	return cntpct_to_lk_time(read_cntpct());
ffffffffea805494:	17fffefb 	b	ffffffffea805080 <cntpct_to_lk_time>

ffffffffea805498 <arm_generic_timer_init>:
{
ffffffffea805498:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80549c:	910003fd 	mov	x29, sp
ffffffffea8054a0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8054a4:	2a0003f4 	mov	w20, w0
	if (freq_override == 0) {
ffffffffea8054a8:	35001001 	cbnz	w1, ffffffffea8056a8 <arm_generic_timer_init+0x210>
	cntfrq = READ_TIMER_REG32(TIMER_REG_CNTFRQ);
ffffffffea8054ac:	d53be000 	mrs	x0, cntfrq_el0
ffffffffea8054b0:	2a0003f3 	mov	w19, w0
		if (!cntfrq) {
ffffffffea8054b4:	34000fe0 	cbz	w0, ffffffffea8056b0 <arm_generic_timer_init+0x218>
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea8054b8:	2a1303e5 	mov	w5, w19
ffffffffea8054bc:	d29ef9eb 	mov	x11, #0xf7cf                	// #63439
ffffffffea8054c0:	f2bc6a6b 	movk	x11, #0xe353, lsl #16
    result->l0 = tmp >> 32;
ffffffffea8054c4:	b00002c2 	adrp	x2, ffffffffea85e000 <rb_data+0x18>
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea8054c8:	d3607cae 	lsl	x14, x5, #32
ffffffffea8054cc:	f2d374ab 	movk	x11, #0x9ba5, lsl #32
ffffffffea8054d0:	f2e4188b 	movk	x11, #0x20c4, lsl #48
    result->l0 = tmp >> 32;
ffffffffea8054d4:	9102004a 	add	x10, x2, #0x80
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea8054d8:	d343fdc6 	lsr	x6, x14, #3
ffffffffea8054dc:	d2c84800 	mov	x0, #0x424000000000        	// #72842645340160
ffffffffea8054e0:	d2c07d01 	mov	x1, #0x3e800000000         	// #4294967296000
ffffffffea8054e4:	f2e001e0 	movk	x0, #0xf, lsl #48
    result->l0 = tmp >> 32;
ffffffffea8054e8:	b00002d0 	adrp	x16, ffffffffea85e000 <rb_data+0x18>
ffffffffea8054ec:	b00002cf 	adrp	x15, ffffffffea85e000 <rb_data+0x18>
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea8054f0:	9bcb7cc6 	umulh	x6, x6, x11
    result->l0 = tmp >> 32;
ffffffffea8054f4:	9101c20d 	add	x13, x16, #0x70
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea8054f8:	9ac50829 	udiv	x9, x1, x5
    result->l0 = tmp >> 32;
ffffffffea8054fc:	910181ec 	add	x12, x15, #0x60
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea805500:	9ac50808 	udiv	x8, x0, x5
ffffffffea805504:	d344fcc7 	lsr	x7, x6, #4
    result->l0 = tmp >> 32;
ffffffffea805508:	d364fcc6 	lsr	x6, x6, #36
ffffffffea80550c:	b9008046 	str	w6, [x2, #128]
    rem = ((uint64_t)dividend << 32) % divisor;
ffffffffea805510:	d37be8e2 	lsl	x2, x7, #5
ffffffffea805514:	9b058524 	msub	x4, x9, x5, x1
ffffffffea805518:	cb070042 	sub	x2, x2, x7
	test_lk_time_to_cntpct(cntfrq, 0);
ffffffffea80551c:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805520:	9b058103 	msub	x3, x8, x5, x0
    result->l0 = tmp >> 32;
ffffffffea805524:	d360fd11 	lsr	x17, x8, #32
    rem = ((uint64_t)dividend << 32) % divisor;
ffffffffea805528:	8b0208e2 	add	x2, x7, x2, lsl #2
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea80552c:	d3607c84 	lsl	x4, x4, #32
    result->l0 = tmp >> 32;
ffffffffea805530:	d360fd20 	lsr	x0, x9, #32
ffffffffea805534:	b90061f1 	str	w17, [x15, #96]
    rem = ((uint64_t)dividend << 32) % divisor;
ffffffffea805538:	cb020dc2 	sub	x2, x14, x2, lsl #3
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea80553c:	d3607c63 	lsl	x3, x3, #32
ffffffffea805540:	9ac50884 	udiv	x4, x4, x5
    result->l0 = tmp >> 32;
ffffffffea805544:	b9007200 	str	w0, [x16, #112]
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea805548:	d3607c42 	lsl	x2, x2, #32
ffffffffea80554c:	2a1303e0 	mov	w0, w19
ffffffffea805550:	9ac50863 	udiv	x3, x3, x5
ffffffffea805554:	d343fc42 	lsr	x2, x2, #3
    result->l64 = tmp;
ffffffffea805558:	290091a9 	stp	w9, w4, [x13, #4]
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea80555c:	9bcb7c42 	umulh	x2, x2, x11
    result->l64 = tmp;
ffffffffea805560:	29008d88 	stp	w8, w3, [x12, #4]
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea805564:	d344fc42 	lsr	x2, x2, #4
    result->l64 = tmp;
ffffffffea805568:	29008947 	stp	w7, w2, [x10, #4]
ffffffffea80556c:	97ffff59 	bl	ffffffffea8052d0 <test_lk_time_to_cntpct>
	test_lk_time_to_cntpct(cntfrq, 1);
ffffffffea805570:	2a1303e0 	mov	w0, w19
ffffffffea805574:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea805578:	97ffff56 	bl	ffffffffea8052d0 <test_lk_time_to_cntpct>
	test_lk_time_to_cntpct(cntfrq, INT_MAX);
ffffffffea80557c:	2a1303e0 	mov	w0, w19
ffffffffea805580:	12b00001 	mov	w1, #0x7fffffff            	// #2147483647
ffffffffea805584:	97ffff53 	bl	ffffffffea8052d0 <test_lk_time_to_cntpct>
	test_lk_time_to_cntpct(cntfrq, INT_MAX + 1U);
ffffffffea805588:	2a1303e0 	mov	w0, w19
ffffffffea80558c:	52b00001 	mov	w1, #0x80000000            	// #-2147483648
ffffffffea805590:	97ffff50 	bl	ffffffffea8052d0 <test_lk_time_to_cntpct>
	test_lk_time_to_cntpct(cntfrq, ~0);
ffffffffea805594:	2a1303e0 	mov	w0, w19
ffffffffea805598:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80559c:	97ffff4d 	bl	ffffffffea8052d0 <test_lk_time_to_cntpct>
	test_cntpct_to_lk_time(cntfrq, 0, 0);
ffffffffea8055a0:	2a1303e0 	mov	w0, w19
ffffffffea8055a4:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8055a8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8055ac:	97fffeef 	bl	ffffffffea805168 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, INT_MAX, 0);
ffffffffea8055b0:	2a1303e0 	mov	w0, w19
ffffffffea8055b4:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8055b8:	12b00001 	mov	w1, #0x7fffffff            	// #2147483647
ffffffffea8055bc:	97fffeeb 	bl	ffffffffea805168 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, INT_MAX + 1U, 0);
ffffffffea8055c0:	2a1303e0 	mov	w0, w19
ffffffffea8055c4:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8055c8:	52b00001 	mov	w1, #0x80000000            	// #-2147483648
ffffffffea8055cc:	97fffee7 	bl	ffffffffea805168 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, ~0, 0);
ffffffffea8055d0:	2a1303e0 	mov	w0, w19
ffffffffea8055d4:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8055d8:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8055dc:	97fffee3 	bl	ffffffffea805168 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, 0, 1);
ffffffffea8055e0:	2a1303e0 	mov	w0, w19
ffffffffea8055e4:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea8055e8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8055ec:	97fffedf 	bl	ffffffffea805168 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, 0, 7);
ffffffffea8055f0:	2a1303e0 	mov	w0, w19
ffffffffea8055f4:	528000e2 	mov	w2, #0x7                   	// #7
ffffffffea8055f8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8055fc:	97fffedb 	bl	ffffffffea805168 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, 0, 70);
ffffffffea805600:	2a1303e0 	mov	w0, w19
ffffffffea805604:	528008c2 	mov	w2, #0x46                  	// #70
ffffffffea805608:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80560c:	97fffed7 	bl	ffffffffea805168 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, 0, 700);
ffffffffea805610:	52805782 	mov	w2, #0x2bc                 	// #700
ffffffffea805614:	2a1303e0 	mov	w0, w19
ffffffffea805618:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80561c:	97fffed3 	bl	ffffffffea805168 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_bigtime(cntfrq, 0);
ffffffffea805620:	2a1303e0 	mov	w0, w19
ffffffffea805624:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea805628:	97fffefe 	bl	ffffffffea805220 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 1);
ffffffffea80562c:	2a1303e0 	mov	w0, w19
ffffffffea805630:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea805634:	97fffefb 	bl	ffffffffea805220 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 60 * 60 * 24);
ffffffffea805638:	d28a3001 	mov	x1, #0x5180                	// #20864
ffffffffea80563c:	2a1303e0 	mov	w0, w19
ffffffffea805640:	f2a00021 	movk	x1, #0x1, lsl #16
ffffffffea805644:	97fffef7 	bl	ffffffffea805220 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 60 * 60 * 24 * 365);
ffffffffea805648:	d2867001 	mov	x1, #0x3380                	// #13184
ffffffffea80564c:	2a1303e0 	mov	w0, w19
ffffffffea805650:	f2a03c21 	movk	x1, #0x1e1, lsl #16
ffffffffea805654:	97fffef3 	bl	ffffffffea805220 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 60 * 60 * 24 * (365 * 10 + 2));
ffffffffea805658:	d294c001 	mov	x1, #0xa600                	// #42496
ffffffffea80565c:	2a1303e0 	mov	w0, w19
ffffffffea805660:	f2a259c1 	movk	x1, #0x12ce, lsl #16
ffffffffea805664:	97fffeef 	bl	ffffffffea805220 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 60ULL * 60 * 24 * (365 * 100 + 2));
ffffffffea805668:	d2982001 	mov	x1, #0xc100                	// #49408
ffffffffea80566c:	2a1303e0 	mov	w0, w19
ffffffffea805670:	f2b77f41 	movk	x1, #0xbbfa, lsl #16
ffffffffea805674:	97fffeeb 	bl	ffffffffea805220 <test_cntpct_to_lk_bigtime>
	register_int_handler(irq, &platform_tick, NULL);
ffffffffea805678:	90000001 	adrp	x1, ffffffffea805000 <arm_gic_sim_irq_handler+0x148>
ffffffffea80567c:	91032021 	add	x1, x1, #0xc8
ffffffffea805680:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea805684:	2a1403e0 	mov	w0, w20
ffffffffea805688:	97fffb94 	bl	ffffffffea8044d8 <register_int_handler>
	unmask_interrupt(irq);
ffffffffea80568c:	2a1403e0 	mov	w0, w20
ffffffffea805690:	97fffc64 	bl	ffffffffea804820 <unmask_interrupt>
	timer_irq = irq;
ffffffffea805694:	f00002a0 	adrp	x0, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
ffffffffea805698:	b9012814 	str	w20, [x0, #296]
}
ffffffffea80569c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8056a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8056a4:	d65f03c0 	ret
ffffffffea8056a8:	2a0103f3 	mov	w19, w1
ffffffffea8056ac:	17ffff83 	b	ffffffffea8054b8 <arm_generic_timer_init+0x20>
ffffffffea8056b0:	a94153f3 	ldp	x19, x20, [sp, #16]
			TRACEF("Failed to initialize timer, frequency is 0\n");
ffffffffea8056b4:	b0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
}
ffffffffea8056b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
			TRACEF("Failed to initialize timer, frequency is 0\n");
ffffffffea8056bc:	b0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8056c0:	52802942 	mov	w2, #0x14a                 	// #330
ffffffffea8056c4:	91102021 	add	x1, x1, #0x408
ffffffffea8056c8:	91108000 	add	x0, x0, #0x420
ffffffffea8056cc:	140036d9 	b	ffffffffea813230 <_printf>

ffffffffea8056d0 <event_init>:
 * @param initial  Initial value for "signaled" state
 * @param flags    0 or EVENT_FLAG_AUTOUNSIGNAL
 */
void event_init(event_t *e, bool initial, uint flags)
{
	*e = (event_t)EVENT_INITIAL_VALUE(*e, initial, flags);
ffffffffea8056d0:	528dce85 	mov	w5, #0x6e74                	// #28276
ffffffffea8056d4:	528d2e84 	mov	w4, #0x6974                	// #26996
ffffffffea8056d8:	72acaec5 	movk	w5, #0x6576, lsl #16
ffffffffea8056dc:	91006003 	add	x3, x0, #0x18
ffffffffea8056e0:	72aeec24 	movk	w4, #0x7761, lsl #16
ffffffffea8056e4:	b9000005 	str	w5, [x0]
ffffffffea8056e8:	39001001 	strb	w1, [x0, #4]
ffffffffea8056ec:	b9000802 	str	w2, [x0, #8]
ffffffffea8056f0:	b9001004 	str	w4, [x0, #16]
ffffffffea8056f4:	a9018c03 	stp	x3, x3, [x0, #24]
ffffffffea8056f8:	b900281f 	str	wzr, [x0, #40]
}
ffffffffea8056fc:	d65f03c0 	ret

ffffffffea805700 <event_destroy>:
 * still waiting on the event will be resumed.
 *
 * @param e        Event object to initialize
 */
void event_destroy(event_t *e)
{
ffffffffea805700:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805704:	910003fd 	mov	x29, sp
ffffffffea805708:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80570c:	aa0003f3 	mov	x19, x0
ffffffffea805710:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805714:	d53b4220 	mrs	x0, daif
ffffffffea805718:	91004275 	add	x21, x19, #0x10
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80571c:	37380260 	tbnz	w0, #7, ffffffffea805768 <event_destroy+0x68>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805720:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea805724:	900002d4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea805728:	912ea294 	add	x20, x20, #0xba8
ffffffffea80572c:	aa1403e0 	mov	x0, x20
ffffffffea805730:	97fff45a 	bl	ffffffffea802898 <arch_spin_lock>
	DEBUG_ASSERT(e->magic == EVENT_MAGIC);

	THREAD_LOCK(state);

	e->magic = 0;
ffffffffea805734:	b900027f 	str	wzr, [x19]
	e->signalled = false;
	e->flags = 0;
	wait_queue_destroy(&e->wait, true);
ffffffffea805738:	52800021 	mov	w1, #0x1                   	// #1
	e->signalled = false;
ffffffffea80573c:	3900127f 	strb	wzr, [x19, #4]
	wait_queue_destroy(&e->wait, true);
ffffffffea805740:	aa1503e0 	mov	x0, x21
	e->flags = 0;
ffffffffea805744:	b9000a7f 	str	wzr, [x19, #8]
	wait_queue_destroy(&e->wait, true);
ffffffffea805748:	94000644 	bl	ffffffffea807058 <wait_queue_destroy>
    arch_spin_unlock(lock);
ffffffffea80574c:	aa1403e0 	mov	x0, x20
ffffffffea805750:	97fff45a 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea805754:	d50342ff 	msr	daifclr, #0x2

	THREAD_UNLOCK(state);
}
ffffffffea805758:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80575c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805760:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805764:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea805768:	900002d4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80576c:	912ea294 	add	x20, x20, #0xba8
ffffffffea805770:	aa1403e0 	mov	x0, x20
ffffffffea805774:	97fff449 	bl	ffffffffea802898 <arch_spin_lock>
	e->magic = 0;
ffffffffea805778:	b900027f 	str	wzr, [x19]
	wait_queue_destroy(&e->wait, true);
ffffffffea80577c:	aa1503e0 	mov	x0, x21
	e->signalled = false;
ffffffffea805780:	3900127f 	strb	wzr, [x19, #4]
	wait_queue_destroy(&e->wait, true);
ffffffffea805784:	52800021 	mov	w1, #0x1                   	// #1
	e->flags = 0;
ffffffffea805788:	b9000a7f 	str	wzr, [x19, #8]
	wait_queue_destroy(&e->wait, true);
ffffffffea80578c:	94000633 	bl	ffffffffea807058 <wait_queue_destroy>
}
ffffffffea805790:	f94013f5 	ldr	x21, [sp, #32]
    arch_spin_unlock(lock);
ffffffffea805794:	aa1403e0 	mov	x0, x20
ffffffffea805798:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80579c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8057a0:	17fff446 	b	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea8057a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8057a8 <event_wait_timeout>:
 *
 * @return  0 on success, ERR_TIMED_OUT on timeout,
 *         other values on other errors.
 */
status_t event_wait_timeout(event_t *e, lk_time_t timeout)
{
ffffffffea8057a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8057ac:	910003fd 	mov	x29, sp
ffffffffea8057b0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8057b4:	aa0003f3 	mov	x19, x0
ffffffffea8057b8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8057bc:	2a0103f6 	mov	w22, w1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8057c0:	d53b4220 	mrs	x0, daif
ffffffffea8057c4:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea8057c8:	37380060 	tbnz	w0, #7, ffffffffea8057d4 <event_wait_timeout+0x2c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8057cc:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8057d0:	52800035 	mov	w21, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea8057d4:	900002d4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8057d8:	912ea280 	add	x0, x20, #0xba8
ffffffffea8057dc:	97fff42f 	bl	ffffffffea802898 <arch_spin_lock>

	DEBUG_ASSERT(e->magic == EVENT_MAGIC);

	THREAD_LOCK(state);

	if (e->signalled) {
ffffffffea8057e0:	39401260 	ldrb	w0, [x19, #4]
ffffffffea8057e4:	340001e0 	cbz	w0, ffffffffea805820 <event_wait_timeout+0x78>
		/* signalled, we're going to fall through */
		if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
ffffffffea8057e8:	b9400a60 	ldr	w0, [x19, #8]
	status_t ret = NO_ERROR;
ffffffffea8057ec:	52800016 	mov	w22, #0x0                   	// #0
		if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
ffffffffea8057f0:	37000140 	tbnz	w0, #0, ffffffffea805818 <event_wait_timeout+0x70>
    arch_spin_unlock(lock);
ffffffffea8057f4:	912ea280 	add	x0, x20, #0xba8
ffffffffea8057f8:	97fff430 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8057fc:	34000055 	cbz	w21, ffffffffea805804 <event_wait_timeout+0x5c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea805800:	d50342ff 	msr	daifclr, #0x2
	}

	THREAD_UNLOCK(state);

	return ret;
}
ffffffffea805804:	2a1603e0 	mov	w0, w22
ffffffffea805808:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80580c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea805810:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805814:	d65f03c0 	ret
			e->signalled = false;
ffffffffea805818:	3900127f 	strb	wzr, [x19, #4]
ffffffffea80581c:	17fffff6 	b	ffffffffea8057f4 <event_wait_timeout+0x4c>
		ret = wait_queue_block(&e->wait, timeout);
ffffffffea805820:	2a1603e1 	mov	w1, w22
ffffffffea805824:	91004260 	add	x0, x19, #0x10
ffffffffea805828:	9400044c 	bl	ffffffffea806958 <wait_queue_block>
ffffffffea80582c:	2a0003f6 	mov	w22, w0
ffffffffea805830:	17fffff1 	b	ffffffffea8057f4 <event_wait_timeout+0x4c>
ffffffffea805834:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805838 <event_signal>:
 *                    queue.
 *
 * @return  Returns NO_ERROR on success.
 */
status_t event_signal(event_t *e, bool reschedule)
{
ffffffffea805838:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80583c:	910003fd 	mov	x29, sp
ffffffffea805840:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805844:	aa0003f3 	mov	x19, x0
ffffffffea805848:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80584c:	12001c35 	and	w21, w1, #0xff
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805850:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea805854:	37380340 	tbnz	w0, #7, ffffffffea8058bc <event_signal+0x84>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805858:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80585c:	900002d4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea805860:	912ea296 	add	x22, x20, #0xba8
ffffffffea805864:	aa1603e0 	mov	x0, x22
ffffffffea805868:	97fff40c 	bl	ffffffffea802898 <arch_spin_lock>
	DEBUG_ASSERT(e->magic == EVENT_MAGIC);

	THREAD_LOCK(state);

	if (!e->signalled) {
ffffffffea80586c:	39401260 	ldrb	w0, [x19, #4]
ffffffffea805870:	350005c0 	cbnz	w0, ffffffffea805928 <event_signal+0xf0>
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea805874:	52800036 	mov	w22, #0x1                   	// #1
		if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
ffffffffea805878:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea80587c:	91004260 	add	x0, x19, #0x10
ffffffffea805880:	36000381 	tbz	w1, #0, ffffffffea8058f0 <event_signal+0xb8>
			/* try to release one thread and leave unsignalled if successful */
			if (wait_queue_wake_one(&e->wait, reschedule, NO_ERROR) <= 0) {
ffffffffea805884:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea805888:	2a1503e1 	mov	w1, w21
ffffffffea80588c:	940004af 	bl	ffffffffea806b48 <wait_queue_wake_one>
ffffffffea805890:	7100001f 	cmp	w0, #0x0
ffffffffea805894:	5400040d 	b.le	ffffffffea805914 <event_signal+0xdc>
    arch_spin_unlock(lock);
ffffffffea805898:	912ea280 	add	x0, x20, #0xba8
ffffffffea80589c:	97fff407 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8058a0:	340001f6 	cbz	w22, ffffffffea8058dc <event_signal+0xa4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8058a4:	d50342ff 	msr	daifclr, #0x2
	}

	THREAD_UNLOCK(state);

	return NO_ERROR;
}
ffffffffea8058a8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8058ac:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8058b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8058b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8058b8:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8058bc:	900002d4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8058c0:	912ea296 	add	x22, x20, #0xba8
ffffffffea8058c4:	aa1603e0 	mov	x0, x22
ffffffffea8058c8:	97fff3f4 	bl	ffffffffea802898 <arch_spin_lock>
	if (!e->signalled) {
ffffffffea8058cc:	39401260 	ldrb	w0, [x19, #4]
ffffffffea8058d0:	34000280 	cbz	w0, ffffffffea805920 <event_signal+0xe8>
    arch_spin_unlock(lock);
ffffffffea8058d4:	aa1603e0 	mov	x0, x22
ffffffffea8058d8:	97fff3f8 	bl	ffffffffea8028b8 <arch_spin_unlock>
}
ffffffffea8058dc:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8058e0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8058e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8058e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8058ec:	d65f03c0 	ret
			e->signalled = true;
ffffffffea8058f0:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8058f4:	39001261 	strb	w1, [x19, #4]
			wait_queue_wake_all(&e->wait, reschedule, NO_ERROR);
ffffffffea8058f8:	2a1503e1 	mov	w1, w21
ffffffffea8058fc:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea805900:	940004dc 	bl	ffffffffea806c70 <wait_queue_wake_all>
ffffffffea805904:	912ea280 	add	x0, x20, #0xba8
ffffffffea805908:	97fff3ec 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea80590c:	35fffcd6 	cbnz	w22, ffffffffea8058a4 <event_signal+0x6c>
ffffffffea805910:	17fffff3 	b	ffffffffea8058dc <event_signal+0xa4>
				e->signalled = true;
ffffffffea805914:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea805918:	39001260 	strb	w0, [x19, #4]
ffffffffea80591c:	17ffffdf 	b	ffffffffea805898 <event_signal+0x60>
    spin_lock_saved_state_t state = 0;
ffffffffea805920:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea805924:	17ffffd5 	b	ffffffffea805878 <event_signal+0x40>
ffffffffea805928:	aa1603e0 	mov	x0, x22
ffffffffea80592c:	97fff3e3 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea805930:	d50342ff 	msr	daifclr, #0x2
ffffffffea805934:	17ffffdd 	b	ffffffffea8058a8 <event_signal+0x70>

ffffffffea805938 <event_unsignal>:
 */
status_t event_unsignal(event_t *e)
{
	DEBUG_ASSERT(e->magic == EVENT_MAGIC);

	e->signalled = false;
ffffffffea805938:	3900101f 	strb	wzr, [x0, #4]

	return NO_ERROR;
}
ffffffffea80593c:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805940:	d65f03c0 	ret
ffffffffea805944:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805948 <kernel_init>:
#include <kernel/thread.h>
#include <kernel/timer.h>
#include <kernel/mp.h>

void kernel_init(void)
{
ffffffffea805948:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	// if enabled, configure the kernel's event log
	kernel_evlog_init();

	// initialize the threading system
	dprintf(SPEW, "initializing mp\n");
ffffffffea80594c:	b0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea805950:	91142000 	add	x0, x0, #0x508
{
ffffffffea805954:	910003fd 	mov	x29, sp
	dprintf(SPEW, "initializing mp\n");
ffffffffea805958:	94003052 	bl	ffffffffea811aa0 <_dprintf>
	mp_init();
ffffffffea80595c:	94000721 	bl	ffffffffea8075e0 <mp_init>

	// initialize the threading system
	dprintf(SPEW, "initializing threads\n");
ffffffffea805960:	b0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea805964:	91148000 	add	x0, x0, #0x520
ffffffffea805968:	9400304e 	bl	ffffffffea811aa0 <_dprintf>
	thread_init();
ffffffffea80596c:	94000369 	bl	ffffffffea806710 <thread_init>

	// initialize kernel timers
	dprintf(SPEW, "initializing timers\n");
ffffffffea805970:	b0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea805974:	9114e000 	add	x0, x0, #0x538
ffffffffea805978:	9400304a 	bl	ffffffffea811aa0 <_dprintf>
	timer_init();
}
ffffffffea80597c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	timer_init();
ffffffffea805980:	1400070c 	b	ffffffffea8075b0 <timer_init>
ffffffffea805984:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805988 <mutex_init>:
/**
 * @brief  Initialize a mutex_t
 */
void mutex_init(mutex_t *m)
{
	*m = (mutex_t)MUTEX_INITIAL_VALUE(*m);
ffffffffea805988:	528e8f03 	mov	w3, #0x7478                	// #29816
ffffffffea80598c:	528d2e82 	mov	w2, #0x6974                	// #26996
ffffffffea805990:	72adaea3 	movk	w3, #0x6d75, lsl #16
ffffffffea805994:	91008001 	add	x1, x0, #0x20
ffffffffea805998:	72aeec22 	movk	w2, #0x7761, lsl #16
ffffffffea80599c:	b9000003 	str	w3, [x0]
ffffffffea8059a0:	f900041f 	str	xzr, [x0, #8]
ffffffffea8059a4:	b900101f 	str	wzr, [x0, #16]
ffffffffea8059a8:	b9001802 	str	w2, [x0, #24]
ffffffffea8059ac:	a9020401 	stp	x1, x1, [x0, #32]
ffffffffea8059b0:	b900301f 	str	wzr, [x0, #48]
}
ffffffffea8059b4:	d65f03c0 	ret

ffffffffea8059b8 <mutex_acquire_timeout>:
 *
 * @return  NO_ERROR on success, ERR_TIMED_OUT on timeout,
 * other values on error
 */
status_t mutex_acquire_timeout(mutex_t *m, lk_time_t timeout)
{
ffffffffea8059b8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea8059bc:	910003fd 	mov	x29, sp
ffffffffea8059c0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8059c4:	aa0003f3 	mov	x19, x0
ffffffffea8059c8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8059cc:	f9001bf7 	str	x23, [sp, #48]
ffffffffea8059d0:	2a0103f7 	mov	w23, w1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8059d4:	d53b4220 	mrs	x0, daif
ffffffffea8059d8:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8059dc:	37380060 	tbnz	w0, #7, ffffffffea8059e8 <mutex_acquire_timeout+0x30>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8059e0:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8059e4:	52800035 	mov	w21, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea8059e8:	900002d4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8059ec:	912ea280 	add	x0, x20, #0xba8
ffffffffea8059f0:	97fff3aa 	bl	ffffffffea802898 <arch_spin_lock>
		      get_current_thread(), get_current_thread()->name, m);
#endif

	THREAD_LOCK(state);

	status_t ret = NO_ERROR;
ffffffffea8059f4:	52800016 	mov	w22, #0x0                   	// #0
	if (unlikely(++m->count > 1)) {
ffffffffea8059f8:	b9401260 	ldr	w0, [x19, #16]
ffffffffea8059fc:	11000400 	add	w0, w0, #0x1
ffffffffea805a00:	b9001260 	str	w0, [x19, #16]
ffffffffea805a04:	7100041f 	cmp	w0, #0x1
ffffffffea805a08:	540001ac 	b.gt	ffffffffea805a3c <mutex_acquire_timeout+0x84>
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea805a0c:	d538d080 	mrs	x0, tpidr_el1
			 */
			goto err;
		}
	}

	m->holder = get_current_thread();
ffffffffea805a10:	f9000660 	str	x0, [x19, #8]
    arch_spin_unlock(lock);
ffffffffea805a14:	912ea280 	add	x0, x20, #0xba8
ffffffffea805a18:	97fff3a8 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea805a1c:	34000055 	cbz	w21, ffffffffea805a24 <mutex_acquire_timeout+0x6c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea805a20:	d50342ff 	msr	daifclr, #0x2

err:
	THREAD_UNLOCK(state);
	return ret;
}
ffffffffea805a24:	2a1603e0 	mov	w0, w22
ffffffffea805a28:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea805a2c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805a30:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea805a34:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea805a38:	d65f03c0 	ret
		ret = wait_queue_block(&m->wait, timeout);
ffffffffea805a3c:	2a1703e1 	mov	w1, w23
ffffffffea805a40:	91006260 	add	x0, x19, #0x18
ffffffffea805a44:	940003c5 	bl	ffffffffea806958 <wait_queue_block>
ffffffffea805a48:	2a0003f6 	mov	w22, w0
		if (unlikely(ret < NO_ERROR)) {
ffffffffea805a4c:	36fffe00 	tbz	w0, #31, ffffffffea805a0c <mutex_acquire_timeout+0x54>
			if (likely(ret == ERR_TIMED_OUT)) {
ffffffffea805a50:	3100341f 	cmn	w0, #0xd
ffffffffea805a54:	54fffe01 	b.ne	ffffffffea805a14 <mutex_acquire_timeout+0x5c>  // b.any
				m->count--;
ffffffffea805a58:	b9401260 	ldr	w0, [x19, #16]
ffffffffea805a5c:	51000400 	sub	w0, w0, #0x1
ffffffffea805a60:	b9001260 	str	w0, [x19, #16]
ffffffffea805a64:	17ffffec 	b	ffffffffea805a14 <mutex_acquire_timeout+0x5c>

ffffffffea805a68 <mutex_release>:

/**
 * @brief  Release mutex
 */
status_t mutex_release(mutex_t *m)
{
ffffffffea805a68:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea805a6c:	910003fd 	mov	x29, sp
ffffffffea805a70:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805a74:	aa0003f3 	mov	x19, x0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805a78:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea805a7c:	37380260 	tbnz	w0, #7, ffffffffea805ac8 <mutex_release+0x60>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805a80:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea805a84:	900002d4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea805a88:	912ea294 	add	x20, x20, #0xba8
ffffffffea805a8c:	aa1403e0 	mov	x0, x20
ffffffffea805a90:	97fff382 	bl	ffffffffea802898 <arch_spin_lock>

	THREAD_LOCK(state);

	m->holder = 0;

	if (unlikely(--m->count >= 1)) {
ffffffffea805a94:	b9401260 	ldr	w0, [x19, #16]
	m->holder = 0;
ffffffffea805a98:	f900067f 	str	xzr, [x19, #8]
	if (unlikely(--m->count >= 1)) {
ffffffffea805a9c:	51000400 	sub	w0, w0, #0x1
ffffffffea805aa0:	b9001260 	str	w0, [x19, #16]
ffffffffea805aa4:	7100001f 	cmp	w0, #0x0
ffffffffea805aa8:	540003ac 	b.gt	ffffffffea805b1c <mutex_release+0xb4>
    arch_spin_unlock(lock);
ffffffffea805aac:	aa1403e0 	mov	x0, x20
ffffffffea805ab0:	97fff382 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea805ab4:	d50342ff 	msr	daifclr, #0x2
		wait_queue_wake_one(&m->wait, true, NO_ERROR);
	}

	THREAD_UNLOCK(state);
	return NO_ERROR;
}
ffffffffea805ab8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805abc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805ac0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea805ac4:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea805ac8:	900002d4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea805acc:	912ea294 	add	x20, x20, #0xba8
ffffffffea805ad0:	aa1403e0 	mov	x0, x20
ffffffffea805ad4:	97fff371 	bl	ffffffffea802898 <arch_spin_lock>
	if (unlikely(--m->count >= 1)) {
ffffffffea805ad8:	b9401260 	ldr	w0, [x19, #16]
	m->holder = 0;
ffffffffea805adc:	f900067f 	str	xzr, [x19, #8]
	if (unlikely(--m->count >= 1)) {
ffffffffea805ae0:	51000400 	sub	w0, w0, #0x1
ffffffffea805ae4:	b9001260 	str	w0, [x19, #16]
ffffffffea805ae8:	7100001f 	cmp	w0, #0x0
ffffffffea805aec:	540000ec 	b.gt	ffffffffea805b08 <mutex_release+0xa0>
    arch_spin_unlock(lock);
ffffffffea805af0:	aa1403e0 	mov	x0, x20
ffffffffea805af4:	97fff371 	bl	ffffffffea8028b8 <arch_spin_unlock>
}
ffffffffea805af8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805afc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805b00:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea805b04:	d65f03c0 	ret
		wait_queue_wake_one(&m->wait, true, NO_ERROR);
ffffffffea805b08:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea805b0c:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea805b10:	91006260 	add	x0, x19, #0x18
ffffffffea805b14:	9400040d 	bl	ffffffffea806b48 <wait_queue_wake_one>
ffffffffea805b18:	17fffff6 	b	ffffffffea805af0 <mutex_release+0x88>
ffffffffea805b1c:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea805b20:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea805b24:	91006260 	add	x0, x19, #0x18
ffffffffea805b28:	94000408 	bl	ffffffffea806b48 <wait_queue_wake_one>
ffffffffea805b2c:	17ffffe0 	b	ffffffffea805aac <mutex_release+0x44>

ffffffffea805b30 <init_thread_struct>:
	list_add_tail(&run_queue[t->priority], &t->queue_node);
	run_queue_bitmap |= (1<<t->priority);
}

static void init_thread_struct(thread_t *t, const char *name)
{
ffffffffea805b30:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	memset(t, 0, sizeof(thread_t));
ffffffffea805b34:	d2805b02 	mov	x2, #0x2d8                 	// #728
{
ffffffffea805b38:	910003fd 	mov	x29, sp
ffffffffea805b3c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805b40:	aa0003f3 	mov	x19, x0
ffffffffea805b44:	aa0103f4 	mov	x20, x1
	memset(t, 0, sizeof(thread_t));
ffffffffea805b48:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805b4c:	940036b5 	bl	ffffffffea813620 <memset>
	t->magic = THREAD_MAGIC;
ffffffffea805b50:	528e4c81 	mov	w1, #0x7264                	// #29284
	t->pinned_cpu = -1;
ffffffffea805b54:	12800000 	mov	w0, #0xffffffff            	// #-1
	t->magic = THREAD_MAGIC;
ffffffffea805b58:	72ae8d01 	movk	w1, #0x7468, lsl #16
ffffffffea805b5c:	b9000261 	str	w1, [x19]
	t->pinned_cpu = -1;
ffffffffea805b60:	b9003e60 	str	w0, [x19, #60]
	strlcpy(t->name, name, sizeof(t->name));
ffffffffea805b64:	aa1403e1 	mov	x1, x20
ffffffffea805b68:	910ae260 	add	x0, x19, #0x2b8
ffffffffea805b6c:	d2800402 	mov	x2, #0x20                  	// #32
}
ffffffffea805b70:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805b74:	a8c27bfd 	ldp	x29, x30, [sp], #32
	strlcpy(t->name, name, sizeof(t->name));
ffffffffea805b78:	140036ec 	b	ffffffffea813728 <strlcpy>
ffffffffea805b7c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805b80 <get_top_thread>:
}

static thread_t *get_top_thread(int cpu, bool unlink)
{
	thread_t *newthread;
	uint32_t local_run_queue_bitmap = run_queue_bitmap;
ffffffffea805b80:	900002cc 	adrp	x12, ffffffffea85d000 <idle_threads+0xeb0>
{
ffffffffea805b84:	2a0003e4 	mov	w4, w0
ffffffffea805b88:	12001c21 	and	w1, w1, #0xff
	uint32_t local_run_queue_bitmap = run_queue_bitmap;
ffffffffea805b8c:	b94b918a 	ldr	w10, [x12, #2960]
	uint next_queue;

	while (local_run_queue_bitmap) {
ffffffffea805b90:	3400056a 	cbz	w10, ffffffffea805c3c <get_top_thread+0xbc>
ffffffffea805b94:	900002c9 	adrp	x9, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea805b98:	2a0a03e7 	mov	w7, w10
		/* find the first (remaining) queue with a thread in it */
		next_queue = HIGHEST_PRIORITY - __builtin_clz(local_run_queue_bitmap)
			- (sizeof(run_queue_bitmap) * 8 - NUM_PRIORITIES);

		list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
ffffffffea805b9c:	91264128 	add	x8, x9, #0x990
		next_queue = HIGHEST_PRIORITY - __builtin_clz(local_run_queue_bitmap)
ffffffffea805ba0:	528003eb 	mov	w11, #0x1f                  	// #31

				return newthread;
			}
		}

		local_run_queue_bitmap &= ~(1<<next_queue);
ffffffffea805ba4:	5280002d 	mov	w13, #0x1                   	// #1
		next_queue = HIGHEST_PRIORITY - __builtin_clz(local_run_queue_bitmap)
ffffffffea805ba8:	5ac010e5 	clz	w5, w7
ffffffffea805bac:	4b050166 	sub	w6, w11, w5
ffffffffea805bb0:	aa0603e5 	mov	x5, x6
		list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
ffffffffea805bb4:	8b061100 	add	x0, x8, x6, lsl #4
ffffffffea805bb8:	8b26d103 	add	x3, x8, w6, sxtw #4
ffffffffea805bbc:	f9400402 	ldr	x2, [x0, #8]
ffffffffea805bc0:	d1006040 	sub	x0, x2, #0x18
ffffffffea805bc4:	eb02007f 	cmp	x3, x2
ffffffffea805bc8:	54000340 	b.eq	ffffffffea805c30 <get_top_thread+0xb0>  // b.none
			if (newthread->pinned_cpu < 0 || newthread->pinned_cpu == cpu) {
ffffffffea805bcc:	b9403c02 	ldr	w2, [x0, #60]
ffffffffea805bd0:	7100005f 	cmp	w2, #0x0
ffffffffea805bd4:	7a42a084 	ccmp	w4, w2, #0x4, ge  // ge = tcont
ffffffffea805bd8:	54000140 	b.eq	ffffffffea805c00 <get_top_thread+0x80>  // b.none
ffffffffea805bdc:	d503201f 	nop
		list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
ffffffffea805be0:	f9401002 	ldr	x2, [x0, #32]
ffffffffea805be4:	d1006040 	sub	x0, x2, #0x18
ffffffffea805be8:	eb02007f 	cmp	x3, x2
ffffffffea805bec:	54000220 	b.eq	ffffffffea805c30 <get_top_thread+0xb0>  // b.none
			if (newthread->pinned_cpu < 0 || newthread->pinned_cpu == cpu) {
ffffffffea805bf0:	b9403c02 	ldr	w2, [x0, #60]
ffffffffea805bf4:	7100005f 	cmp	w2, #0x0
ffffffffea805bf8:	7a44a044 	ccmp	w2, w4, #0x4, ge  // ge = tcont
ffffffffea805bfc:	54ffff21 	b.ne	ffffffffea805be0 <get_top_thread+0x60>  // b.any
				if (unlink) {
ffffffffea805c00:	34000161 	cbz	w1, ffffffffea805c2c <get_top_thread+0xac>
	item->next->prev = item->prev;
ffffffffea805c04:	a9418402 	ldp	x2, x1, [x0, #24]
        &(entry)->member != (list);\
        entry = temp_entry, temp_entry = containerof((temp_entry)->member.next, type, member))

static inline bool list_is_empty(struct list_node *list)
{
	return (list->next == list) ? true : false;
ffffffffea805c08:	91264129 	add	x9, x9, #0x990
ffffffffea805c0c:	8b061126 	add	x6, x9, x6, lsl #4
	item->next->prev = item->prev;
ffffffffea805c10:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea805c14:	f9400c02 	ldr	x2, [x0, #24]
ffffffffea805c18:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea805c1c:	a901fc1f 	stp	xzr, xzr, [x0, #24]
					if (list_is_empty(&run_queue[next_queue]))
ffffffffea805c20:	f94004c1 	ldr	x1, [x6, #8]
ffffffffea805c24:	eb03003f 	cmp	x1, x3
ffffffffea805c28:	54000140 	b.eq	ffffffffea805c50 <get_top_thread+0xd0>  // b.none
	}
	/* no threads to run, select the idle thread for this cpu */
	return &idle_threads[cpu];
}
ffffffffea805c2c:	d65f03c0 	ret
		local_run_queue_bitmap &= ~(1<<next_queue);
ffffffffea805c30:	1ac521a5 	lsl	w5, w13, w5
	while (local_run_queue_bitmap) {
ffffffffea805c34:	6a2500e7 	bics	w7, w7, w5
ffffffffea805c38:	54fffb81 	b.ne	ffffffffea805ba8 <get_top_thread+0x28>  // b.any
	return &idle_threads[cpu];
ffffffffea805c3c:	f00002a0 	adrp	x0, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
ffffffffea805c40:	91054000 	add	x0, x0, #0x150
ffffffffea805c44:	52805b01 	mov	w1, #0x2d8                 	// #728
ffffffffea805c48:	9b210080 	smaddl	x0, w4, w1, x0
}
ffffffffea805c4c:	d65f03c0 	ret
						run_queue_bitmap &= ~(1<<next_queue);
ffffffffea805c50:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea805c54:	1ac52025 	lsl	w5, w1, w5
ffffffffea805c58:	0a25014a 	bic	w10, w10, w5
ffffffffea805c5c:	b90b918a 	str	w10, [x12, #2960]
}
ffffffffea805c60:	d65f03c0 	ret
ffffffffea805c64:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805c68 <thread_get_mp_reschedule_target.isra.5>:
static mp_cpu_mask_t thread_get_mp_reschedule_target(thread_t *current_thread, thread_t *t)
ffffffffea805c68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805c6c:	910003fd 	mov	x29, sp
ffffffffea805c70:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805c74:	aa0203f3 	mov	x19, x2
ffffffffea805c78:	f90013f5 	str	x21, [sp, #32]
ffffffffea805c7c:	aa0003f4 	mov	x20, x0
ffffffffea805c80:	aa0103f5 	mov	x21, x1
	uint cpu = arch_curr_cpu_num();
ffffffffea805c84:	97fff389 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
	if (t->pinned_cpu != -1 && current_thread->pinned_cpu == t->pinned_cpu)
ffffffffea805c88:	b9400261 	ldr	w1, [x19]
ffffffffea805c8c:	3100043f 	cmn	w1, #0x1
ffffffffea805c90:	54000280 	b.eq	ffffffffea805ce0 <thread_get_mp_reschedule_target.isra.5+0x78>  // b.none
ffffffffea805c94:	b9400283 	ldr	w3, [x20]
ffffffffea805c98:	2a0003e2 	mov	w2, w0
		return 0;
ffffffffea805c9c:	52800000 	mov	w0, #0x0                   	// #0
	if (t->pinned_cpu != -1 && current_thread->pinned_cpu == t->pinned_cpu)
ffffffffea805ca0:	6b03003f 	cmp	w1, w3
ffffffffea805ca4:	54000160 	b.eq	ffffffffea805cd0 <thread_get_mp_reschedule_target.isra.5+0x68>  // b.none
	if (t->pinned_cpu == -1 || (uint)t->pinned_cpu == cpu)
ffffffffea805ca8:	6b01005f 	cmp	w2, w1
ffffffffea805cac:	54000120 	b.eq	ffffffffea805cd0 <thread_get_mp_reschedule_target.isra.5+0x68>  // b.none
	if (t->priority < cpu_priority[target_cpu])
ffffffffea805cb0:	f00002a2 	adrp	x2, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
ffffffffea805cb4:	9104c042 	add	x2, x2, #0x130
	return 1UL << target_cpu;
ffffffffea805cb8:	d2800020 	mov	x0, #0x1                   	// #1
	if (t->priority < cpu_priority[target_cpu])
ffffffffea805cbc:	b94002a3 	ldr	w3, [x21]
	return 1UL << target_cpu;
ffffffffea805cc0:	9ac12000 	lsl	x0, x0, x1
	if (t->priority < cpu_priority[target_cpu])
ffffffffea805cc4:	b8615841 	ldr	w1, [x2, w1, uxtw #2]
	return 1UL << target_cpu;
ffffffffea805cc8:	6b01007f 	cmp	w3, w1
ffffffffea805ccc:	1a80b3e0 	csel	w0, wzr, w0, lt  // lt = tstop
}
ffffffffea805cd0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805cd4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805cd8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805cdc:	d65f03c0 	ret
		return 0;
ffffffffea805ce0:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea805ce4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805ce8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805cec:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805cf0:	d65f03c0 	ret
ffffffffea805cf4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805cf8 <thread_mp_reschedule>:
{
ffffffffea805cf8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea805cfc:	aa0103e2 	mov	x2, x1
	mp_reschedule(thread_get_mp_reschedule_target(current_thread, t), 0);
ffffffffea805d00:	9100f042 	add	x2, x2, #0x3c
ffffffffea805d04:	9100a021 	add	x1, x1, #0x28
{
ffffffffea805d08:	910003fd 	mov	x29, sp
	mp_reschedule(thread_get_mp_reschedule_target(current_thread, t), 0);
ffffffffea805d0c:	9100f000 	add	x0, x0, #0x3c
ffffffffea805d10:	97ffffd6 	bl	ffffffffea805c68 <thread_get_mp_reschedule_target.isra.5>
}
ffffffffea805d14:	a8c17bfd 	ldp	x29, x30, [sp], #16
	mp_reschedule(thread_get_mp_reschedule_target(current_thread, t), 0);
ffffffffea805d18:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805d1c:	14000633 	b	ffffffffea8075e8 <mp_reschedule>

ffffffffea805d20 <thread_cond_mp_reschedule.isra.6>:

static void thread_cond_mp_reschedule(thread_t *current_thread, const char *caller)
ffffffffea805d20:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
{
	int i;
	uint best_cpu = ~0U;
	int best_cpu_priority = INT_MAX;
	thread_t *t = get_top_thread(-1, false);
ffffffffea805d24:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805d28:	12800000 	mov	w0, #0xffffffff            	// #-1
static void thread_cond_mp_reschedule(thread_t *current_thread, const char *caller)
ffffffffea805d2c:	910003fd 	mov	x29, sp
	thread_t *t = get_top_thread(-1, false);
ffffffffea805d30:	97ffff94 	bl	ffffffffea805b80 <get_top_thread>
ffffffffea805d34:	b00002c6 	adrp	x6, ffffffffea85e000 <rb_data+0x18>

	for (i = 0; i < SMP_MAX_CPUS; i++) {
		if (!(mp.active_cpus & (1 << i)))
			continue;

		if (cpu_priority[i] < best_cpu_priority) {
ffffffffea805d38:	f00002a8 	adrp	x8, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
		if (!(mp.active_cpus & (1 << i)))
ffffffffea805d3c:	910300c6 	add	x6, x6, #0xc0
		if (cpu_priority[i] < best_cpu_priority) {
ffffffffea805d40:	9104c108 	add	x8, x8, #0x130
	thread_t *t = get_top_thread(-1, false);
ffffffffea805d44:	d2800001 	mov	x1, #0x0                   	// #0
	uint best_cpu = ~0U;
ffffffffea805d48:	12800003 	mov	w3, #0xffffffff            	// #-1
	int best_cpu_priority = INT_MAX;
ffffffffea805d4c:	12b00002 	mov	w2, #0x7fffffff            	// #2147483647
		if (!(mp.active_cpus & (1 << i)))
ffffffffea805d50:	52800027 	mov	w7, #0x1                   	// #1
ffffffffea805d54:	d503201f 	nop
ffffffffea805d58:	b94000c4 	ldr	w4, [x6]
ffffffffea805d5c:	1ac120e5 	lsl	w5, w7, w1
ffffffffea805d60:	6a0400bf 	tst	w5, w4
ffffffffea805d64:	540000a0 	b.eq	ffffffffea805d78 <thread_cond_mp_reschedule.isra.6+0x58>  // b.none
		if (cpu_priority[i] < best_cpu_priority) {
ffffffffea805d68:	b8617904 	ldr	w4, [x8, x1, lsl #2]
			best_cpu = i;
ffffffffea805d6c:	6b02009f 	cmp	w4, w2
ffffffffea805d70:	1a81a063 	csel	w3, w3, w1, ge  // ge = tcont
ffffffffea805d74:	1a84a042 	csel	w2, w2, w4, ge  // ge = tcont
ffffffffea805d78:	91000421 	add	x1, x1, #0x1
	for (i = 0; i < SMP_MAX_CPUS; i++) {
ffffffffea805d7c:	f100203f 	cmp	x1, #0x8
ffffffffea805d80:	54fffec1 	b.ne	ffffffffea805d58 <thread_cond_mp_reschedule.isra.6+0x38>  // b.any
			best_cpu_priority = cpu_priority[i];
		}
	}

	if (t->priority <= best_cpu_priority)
ffffffffea805d84:	b9402804 	ldr	w4, [x0, #40]
ffffffffea805d88:	6b02009f 	cmp	w4, w2
ffffffffea805d8c:	5400006c 	b.gt	ffffffffea805d98 <thread_cond_mp_reschedule.isra.6+0x78>
		t->priority, t->name,
		current_thread->priority, current_thread->name);
#endif
	cpu_priority[best_cpu] = t->priority;
	mp_reschedule(1UL << best_cpu, 0);
}
ffffffffea805d90:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea805d94:	d65f03c0 	ret
	cpu_priority[best_cpu] = t->priority;
ffffffffea805d98:	f00002a2 	adrp	x2, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
ffffffffea805d9c:	9104c042 	add	x2, x2, #0x130
	mp_reschedule(1UL << best_cpu, 0);
ffffffffea805da0:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea805da4:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805da8:	9ac32000 	lsl	x0, x0, x3
	cpu_priority[best_cpu] = t->priority;
ffffffffea805dac:	b8235844 	str	w4, [x2, w3, uxtw #2]
}
ffffffffea805db0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	mp_reschedule(1UL << best_cpu, 0);
ffffffffea805db4:	1400060d 	b	ffffffffea8075e8 <mp_reschedule>

ffffffffea805db8 <thread_resched>:
 *
 * This is probably not the function you're looking for. See
 * thread_yield() instead.
 */
void thread_resched(void)
{
ffffffffea805db8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805dbc:	910003fd 	mov	x29, sp
ffffffffea805dc0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805dc4:	f90013f5 	str	x21, [sp, #32]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea805dc8:	d538d094 	mrs	x20, tpidr_el1
	thread_t *oldthread;
	thread_t *newthread;

	thread_t *current_thread = get_current_thread();
	uint cpu = arch_curr_cpu_num();
ffffffffea805dcc:	97fff337 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea805dd0:	2a0003f5 	mov	w21, w0
	ASSERT(current_thread->state != THREAD_RUNNING);
#endif

	THREAD_STATS_INC(reschedules);

	newthread = get_top_thread(cpu, true);
ffffffffea805dd4:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea805dd8:	97ffff6a 	bl	ffffffffea805b80 <get_top_thread>
ffffffffea805ddc:	aa0003f3 	mov	x19, x0

#if THREAD_CHECKS
	ASSERT(newthread);
#endif

	newthread->state = THREAD_RUNNING;
ffffffffea805de0:	52800040 	mov	w0, #0x2                   	// #2

	oldthread = current_thread;

	if (newthread == oldthread)
ffffffffea805de4:	eb14027f 	cmp	x19, x20
	newthread->state = THREAD_RUNNING;
ffffffffea805de8:	b9002e60 	str	w0, [x19, #44]
	if (newthread == oldthread)
ffffffffea805dec:	540006a0 	b.eq	ffffffffea805ec0 <thread_resched+0x108>  // b.none
		return;

	/* set up quantum for the new thread if it was consumed */
	if (newthread->remaining_quantum <= 0) {
ffffffffea805df0:	b9403260 	ldr	w0, [x19, #48]
ffffffffea805df4:	7100001f 	cmp	w0, #0x0
ffffffffea805df8:	5400052d 	b.le	ffffffffea805e9c <thread_resched+0xe4>
ffffffffea805dfc:	b00002c1 	adrp	x1, ffffffffea85e000 <rb_data+0x18>
ffffffffea805e00:	91030021 	add	x1, x1, #0xc0
		newthread->remaining_quantum = 5; // XXX make this smarter
	}

	/* mark the cpu ownership of the threads */
	oldthread->curr_cpu = -1;
ffffffffea805e04:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea805e08:	b9003a80 	str	w0, [x20, #56]
ffffffffea805e0c:	d2800020 	mov	x0, #0x1                   	// #1
	newthread->curr_cpu = cpu;
ffffffffea805e10:	b9003a75 	str	w21, [x19, #56]
ffffffffea805e14:	29409823 	ldp	w3, w6, [x1, #4]
ffffffffea805e18:	9ad52000 	lsl	x0, x0, x21

	if (thread_is_idle(newthread)) {
ffffffffea805e1c:	b9403664 	ldr	w4, [x19, #52]
extern struct mp_state mp;

/* must be called with the thread lock held */
static inline void mp_set_cpu_idle(uint cpu)
{
    mp.idle_cpus |= 1UL << cpu;
ffffffffea805e20:	2a2003e2 	mvn	w2, w0
ffffffffea805e24:	0a030047 	and	w7, w2, w3
		mp_set_cpu_idle(cpu);
	} else {
		mp_set_cpu_busy(cpu);
	}

	if (thread_is_realtime(newthread)) {
ffffffffea805e28:	b9402a65 	ldr	w5, [x19, #40]
ffffffffea805e2c:	2a000063 	orr	w3, w3, w0
    mp.realtime_cpus |= 1UL << cpu;
}

static inline void mp_set_cpu_non_realtime(uint cpu)
{
    mp.realtime_cpus &= ~(1UL << cpu);
ffffffffea805e30:	0a060042 	and	w2, w2, w6
    mp.idle_cpus |= 1UL << cpu;
ffffffffea805e34:	f27c009f 	tst	x4, #0x10
    mp.realtime_cpus &= ~(1UL << cpu);
ffffffffea805e38:	2a0000c0 	orr	w0, w6, w0
    mp.idle_cpus |= 1UL << cpu;
ffffffffea805e3c:	1a871063 	csel	w3, w3, w7, ne  // ne = any
	return (t->flags & THREAD_FLAG_REAL_TIME) && t->priority > DEFAULT_PRIORITY;
ffffffffea805e40:	f27d009f 	tst	x4, #0x8
    mp.realtime_cpus &= ~(1UL << cpu);
ffffffffea805e44:	7a5018a4 	ccmp	w5, #0x10, #0x4, ne  // ne = any
ffffffffea805e48:	1a80d040 	csel	w0, w2, w0, le
ffffffffea805e4c:	29008023 	stp	w3, w0, [x1, #4]
#endif

	KEVLOG_THREAD_SWITCH(oldthread, newthread);

#if PLATFORM_HAS_DYNAMIC_TIMER
	if (thread_is_real_time_or_idle(newthread)) {
ffffffffea805e50:	721d049f 	tst	w4, #0x18
ffffffffea805e54:	540002a1 	b.ne	ffffffffea805ea8 <thread_resched+0xf0>  // b.any
	return !!(t->flags & (THREAD_FLAG_REAL_TIME | THREAD_FLAG_IDLE));
ffffffffea805e58:	b9403680 	ldr	w0, [x20, #52]
			dprintf(ALWAYS, "arch_context_switch: stop preempt, cpu %d, old %p (%s), new %p (%s)\n",
				cpu, oldthread, oldthread->name, newthread, newthread->name);
#endif
			timer_cancel(&preempt_timer[cpu]);
		}
	} else if (thread_is_real_time_or_idle(oldthread)) {
ffffffffea805e5c:	721d041f 	tst	w0, #0x18
ffffffffea805e60:	54000461 	b.ne	ffffffffea805eec <thread_resched+0x134>  // b.any

	/* set some optional target debug leds */
	target_set_debug_led(0, !thread_is_idle(&idle_threads[cpu]));

	/* do the switch */
	cpu_priority[cpu] = newthread->priority;
ffffffffea805e64:	f00002a0 	adrp	x0, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
ffffffffea805e68:	9104c000 	add	x0, x0, #0x130
ffffffffea805e6c:	b8355805 	str	w5, [x0, w21, uxtw #2]
}

static inline void set_current_thread(struct thread *t)
{
    ARM64_WRITE_SYSREG(tpidr_el1, (uint64_t)t);
ffffffffea805e70:	d518d093 	msr	tpidr_el1, x19
ffffffffea805e74:	d5033fdf 	isb
		oldthread->flags, newthread, newthread->name,
		newthread->priority, newthread->flags);
#endif

#ifdef WITH_LIB_UTHREAD
	uthread_context_switch(oldthread, newthread);
ffffffffea805e78:	aa1303e1 	mov	x1, x19
ffffffffea805e7c:	aa1403e0 	mov	x0, x20
ffffffffea805e80:	940037ea 	bl	ffffffffea813e28 <uthread_context_switch>
#endif
	arch_context_switch(oldthread, newthread);
}
ffffffffea805e84:	f94013f5 	ldr	x21, [sp, #32]
	arch_context_switch(oldthread, newthread);
ffffffffea805e88:	aa1303e1 	mov	x1, x19
ffffffffea805e8c:	aa1403e0 	mov	x0, x20
}
ffffffffea805e90:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805e94:	a8c37bfd 	ldp	x29, x30, [sp], #48
	arch_context_switch(oldthread, newthread);
ffffffffea805e98:	17fff462 	b	ffffffffea803020 <arch_context_switch>
		newthread->remaining_quantum = 5; // XXX make this smarter
ffffffffea805e9c:	528000a0 	mov	w0, #0x5                   	// #5
ffffffffea805ea0:	b9003260 	str	w0, [x19, #48]
ffffffffea805ea4:	17ffffd6 	b	ffffffffea805dfc <thread_resched+0x44>
		thread_cond_mp_reschedule(newthread, __func__);
ffffffffea805ea8:	97ffff9e 	bl	ffffffffea805d20 <thread_cond_mp_reschedule.isra.6>
	return !!(t->flags & (THREAD_FLAG_REAL_TIME | THREAD_FLAG_IDLE));
ffffffffea805eac:	b9403680 	ldr	w0, [x20, #52]
		if (!thread_is_real_time_or_idle(oldthread)) {
ffffffffea805eb0:	721d041f 	tst	w0, #0x18
ffffffffea805eb4:	540000e0 	b.eq	ffffffffea805ed0 <thread_resched+0x118>  // b.none
ffffffffea805eb8:	b9402a65 	ldr	w5, [x19, #40]
ffffffffea805ebc:	17ffffea 	b	ffffffffea805e64 <thread_resched+0xac>
}
ffffffffea805ec0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805ec4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805ec8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805ecc:	d65f03c0 	ret
			timer_cancel(&preempt_timer[cpu]);
ffffffffea805ed0:	900002c0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea805ed4:	91204000 	add	x0, x0, #0x810
ffffffffea805ed8:	52800601 	mov	w1, #0x30                  	// #48
ffffffffea805edc:	9ba102a0 	umaddl	x0, w21, w1, x0
ffffffffea805ee0:	94000576 	bl	ffffffffea8074b8 <timer_cancel>
ffffffffea805ee4:	b9402a65 	ldr	w5, [x19, #40]
ffffffffea805ee8:	17ffffdf 	b	ffffffffea805e64 <thread_resched+0xac>
		timer_set_periodic(&preempt_timer[cpu], 10, (timer_callback)thread_timer_tick, NULL);
ffffffffea805eec:	900002c0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea805ef0:	91204000 	add	x0, x0, #0x810
ffffffffea805ef4:	52800601 	mov	w1, #0x30                  	// #48
ffffffffea805ef8:	90000002 	adrp	x2, ffffffffea805000 <arm_gic_sim_irq_handler+0x148>
ffffffffea805efc:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea805f00:	913ee042 	add	x2, x2, #0xfb8
ffffffffea805f04:	9ba102a0 	umaddl	x0, w21, w1, x0
ffffffffea805f08:	52800141 	mov	w1, #0xa                   	// #10
ffffffffea805f0c:	94000565 	bl	ffffffffea8074a0 <timer_set_periodic>
ffffffffea805f10:	b9402a65 	ldr	w5, [x19, #40]
ffffffffea805f14:	17ffffd4 	b	ffffffffea805e64 <thread_resched+0xac>

ffffffffea805f18 <thread_sleep_handler>:
	}
}

/* timer callback to wake up a sleeping thread */
static enum handler_return thread_sleep_handler(timer_t *timer, lk_time_t now, void *arg)
{
ffffffffea805f18:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805f1c:	910003fd 	mov	x29, sp
ffffffffea805f20:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805f24:	aa0203f3 	mov	x19, x2
ffffffffea805f28:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805f2c:	d53b4220 	mrs	x0, daif
ffffffffea805f30:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea805f34:	37380060 	tbnz	w0, #7, ffffffffea805f40 <thread_sleep_handler+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805f38:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea805f3c:	52800035 	mov	w21, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea805f40:	900002d4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea805f44:	912ea294 	add	x20, x20, #0xba8
ffffffffea805f48:	aa1403e0 	mov	x0, x20
ffffffffea805f4c:	97fff253 	bl	ffffffffea802898 <arch_spin_lock>
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea805f50:	b9402a62 	ldr	w2, [x19, #40]
	item->next = list->next;
ffffffffea805f54:	900002c1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea805f58:	91264021 	add	x1, x1, #0x990
	run_queue_bitmap |= (1<<t->priority);
ffffffffea805f5c:	900002c5 	adrp	x5, ffffffffea85d000 <idle_threads+0xeb0>
	ASSERT(t->state == THREAD_SLEEPING);
#endif

	THREAD_LOCK(state);

	t->state = THREAD_READY;
ffffffffea805f60:	52800020 	mov	w0, #0x1                   	// #1
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea805f64:	91006264 	add	x4, x19, #0x18
ffffffffea805f68:	8b22d021 	add	x1, x1, w2, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea805f6c:	1ac22003 	lsl	w3, w0, w2
ffffffffea805f70:	b94b90a6 	ldr	w6, [x5, #2960]
ffffffffea805f74:	f9400422 	ldr	x2, [x1, #8]
ffffffffea805f78:	a9018a61 	stp	x1, x2, [x19, #24]
ffffffffea805f7c:	2a060062 	orr	w2, w3, w6
ffffffffea805f80:	b90b90a2 	str	w2, [x5, #2960]
	list->next->prev = item;
ffffffffea805f84:	f9400422 	ldr	x2, [x1, #8]
	t->state = THREAD_READY;
ffffffffea805f88:	b9002e60 	str	w0, [x19, #44]
    arch_spin_unlock(lock);
ffffffffea805f8c:	aa1403e0 	mov	x0, x20
ffffffffea805f90:	f9000044 	str	x4, [x2]
	list->next = item;
ffffffffea805f94:	f9000424 	str	x4, [x1, #8]
ffffffffea805f98:	97fff248 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea805f9c:	34000055 	cbz	w21, ffffffffea805fa4 <thread_sleep_handler+0x8c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea805fa0:	d50342ff 	msr	daifclr, #0x2
	insert_in_run_queue_head(t);

	THREAD_UNLOCK(state);

	return INT_RESCHEDULE;
}
ffffffffea805fa4:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea805fa8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805fac:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805fb0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805fb4:	d65f03c0 	ret

ffffffffea805fb8 <thread_timer_tick>:
{
ffffffffea805fb8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea805fbc:	910003fd 	mov	x29, sp
ffffffffea805fc0:	f9000bf3 	str	x19, [sp, #16]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea805fc4:	d538d093 	mrs	x19, tpidr_el1
	return !!(t->flags & THREAD_FLAG_IDLE);
ffffffffea805fc8:	b9403660 	ldr	w0, [x19, #52]
	if (thread_is_idle(current_thread))
ffffffffea805fcc:	362000a0 	tbz	w0, #4, ffffffffea805fe0 <thread_timer_tick+0x28>
		return INT_NO_RESCHEDULE;
ffffffffea805fd0:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea805fd4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea805fd8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea805fdc:	d65f03c0 	ret
ffffffffea805fe0:	f9000fb4 	str	x20, [x29, #24]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805fe4:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea805fe8:	36380280 	tbz	w0, #7, ffffffffea806038 <thread_timer_tick+0x80>
    arch_spin_lock(lock);
ffffffffea805fec:	900002d4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea805ff0:	912ea294 	add	x20, x20, #0xba8
ffffffffea805ff4:	aa1403e0 	mov	x0, x20
ffffffffea805ff8:	97fff228 	bl	ffffffffea802898 <arch_spin_lock>
	thread_cond_mp_reschedule(current_thread, __func__);
ffffffffea805ffc:	97ffff49 	bl	ffffffffea805d20 <thread_cond_mp_reschedule.isra.6>
    arch_spin_unlock(lock);
ffffffffea806000:	aa1403e0 	mov	x0, x20
ffffffffea806004:	97fff22d 	bl	ffffffffea8028b8 <arch_spin_unlock>
	return !!(t->flags & (THREAD_FLAG_REAL_TIME | THREAD_FLAG_IDLE));
ffffffffea806008:	b9403660 	ldr	w0, [x19, #52]
	if (thread_is_real_time_or_idle(current_thread))
ffffffffea80600c:	721d041f 	tst	w0, #0x18
ffffffffea806010:	540002c1 	b.ne	ffffffffea806068 <thread_timer_tick+0xb0>  // b.any
	current_thread->remaining_quantum--;
ffffffffea806014:	b9403260 	ldr	w0, [x19, #48]
	if (current_thread->remaining_quantum <= 0) {
ffffffffea806018:	f9400fb4 	ldr	x20, [x29, #24]
	current_thread->remaining_quantum--;
ffffffffea80601c:	51000400 	sub	w0, w0, #0x1
ffffffffea806020:	b9003260 	str	w0, [x19, #48]
	if (current_thread->remaining_quantum <= 0) {
ffffffffea806024:	7100001f 	cmp	w0, #0x0
}
ffffffffea806028:	f9400bf3 	ldr	x19, [sp, #16]
	if (current_thread->remaining_quantum <= 0) {
ffffffffea80602c:	1a9fc7e0 	cset	w0, le
}
ffffffffea806030:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806034:	d65f03c0 	ret
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806038:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80603c:	f00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806040:	912ea294 	add	x20, x20, #0xba8
ffffffffea806044:	aa1403e0 	mov	x0, x20
ffffffffea806048:	97fff214 	bl	ffffffffea802898 <arch_spin_lock>
	thread_cond_mp_reschedule(current_thread, __func__);
ffffffffea80604c:	97ffff35 	bl	ffffffffea805d20 <thread_cond_mp_reschedule.isra.6>
    arch_spin_unlock(lock);
ffffffffea806050:	aa1403e0 	mov	x0, x20
ffffffffea806054:	97fff219 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806058:	d50342ff 	msr	daifclr, #0x2
	return !!(t->flags & (THREAD_FLAG_REAL_TIME | THREAD_FLAG_IDLE));
ffffffffea80605c:	b9403660 	ldr	w0, [x19, #52]
	if (thread_is_real_time_or_idle(current_thread))
ffffffffea806060:	721d041f 	tst	w0, #0x18
ffffffffea806064:	54fffd80 	b.eq	ffffffffea806014 <thread_timer_tick+0x5c>  // b.none
ffffffffea806068:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80606c:	17ffffd9 	b	ffffffffea805fd0 <thread_timer_tick+0x18>

ffffffffea806070 <thread_create_etc>:
{
ffffffffea806070:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea806074:	910003fd 	mov	x29, sp
ffffffffea806078:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80607c:	aa0003f3 	mov	x19, x0
ffffffffea806080:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea806084:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea806088:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80608c:	aa0503f6 	mov	x22, x5
ffffffffea806090:	f90023f9 	str	x25, [sp, #64]
ffffffffea806094:	aa0203f8 	mov	x24, x2
ffffffffea806098:	aa0303f7 	mov	x23, x3
ffffffffea80609c:	aa0603f5 	mov	x21, x6
ffffffffea8060a0:	2a0403f9 	mov	w25, w4
	if (!t) {
ffffffffea8060a4:	b4000840 	cbz	x0, ffffffffea8061ac <thread_create_etc+0x13c>
	init_thread_struct(t, name);
ffffffffea8060a8:	aa1303e0 	mov	x0, x19
ffffffffea8060ac:	97fffea1 	bl	ffffffffea805b30 <init_thread_struct>
 * @defgroup  wait  Wait Queue
 * @{
 */
void wait_queue_init(wait_queue_t *wait)
{
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8060b0:	528d2e81 	mov	w1, #0x6974                	// #26996
	t->curr_cpu = -1;
ffffffffea8060b4:	12800002 	mov	w2, #0xffffffff            	// #-1
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8060b8:	72aeec21 	movk	w1, #0x7761, lsl #16
	t->state = THREAD_SUSPENDED;
ffffffffea8060bc:	29057e79 	stp	w25, wzr, [x19, #40]
	t->curr_cpu = -1;
ffffffffea8060c0:	b9003a62 	str	w2, [x19, #56]
	t->blocking_wait_queue = NULL;
ffffffffea8060c4:	f900227f 	str	xzr, [x19, #64]
	t->wait_queue_block_ret = NO_ERROR;
ffffffffea8060c8:	b9004a7f 	str	wzr, [x19, #72]
	t->entry = entry;
ffffffffea8060cc:	f9013e78 	str	x24, [x19, #632]
	t->arg = arg;
ffffffffea8060d0:	f9014277 	str	x23, [x19, #640]
	t->retcode = 0;
ffffffffea8060d4:	b9028a7f 	str	wzr, [x19, #648]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8060d8:	b9029261 	str	w1, [x19, #656]
ffffffffea8060dc:	910a6261 	add	x1, x19, #0x298
ffffffffea8060e0:	f9014e61 	str	x1, [x19, #664]
ffffffffea8060e4:	f9015261 	str	x1, [x19, #672]
ffffffffea8060e8:	b902aa7f 	str	wzr, [x19, #680]
	if (!stack) {
ffffffffea8060ec:	b5000236 	cbnz	x22, ffffffffea806130 <thread_create_etc+0xc0>
		t->stack = malloc(stack_size);
ffffffffea8060f0:	aa1503e0 	mov	x0, x21
ffffffffea8060f4:	94003477 	bl	ffffffffea8132d0 <malloc>
ffffffffea8060f8:	f9013660 	str	x0, [x19, #616]
		if (!t->stack) {
ffffffffea8060fc:	b5000180 	cbnz	x0, ffffffffea80612c <thread_create_etc+0xbc>
			if (flags & THREAD_FLAG_FREE_STRUCT)
ffffffffea806100:	35000114 	cbnz	w20, ffffffffea806120 <thread_create_etc+0xb0>
}
ffffffffea806104:	a94153f3 	ldp	x19, x20, [sp, #16]
			return NULL;
ffffffffea806108:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80610c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806110:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806114:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea806118:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80611c:	d65f03c0 	ret
				free(t);
ffffffffea806120:	aa1303e0 	mov	x0, x19
ffffffffea806124:	94003481 	bl	ffffffffea813328 <free>
ffffffffea806128:	17fffff7 	b	ffffffffea806104 <thread_create_etc+0x94>
		flags |= THREAD_FLAG_FREE_STACK;
ffffffffea80612c:	321f0294 	orr	w20, w20, #0x2
	t->flags = flags;
ffffffffea806130:	b9003674 	str	w20, [x19, #52]
	t->stack_size = stack_size;
ffffffffea806134:	f9013a75 	str	x21, [x19, #624]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806138:	d538d080 	mrs	x0, tpidr_el1
		t->tls[i] = current_thread->tls[i];
ffffffffea80613c:	f9415801 	ldr	x1, [x0, #688]
	arch_thread_initialize(t);
ffffffffea806140:	aa1303e0 	mov	x0, x19
		t->tls[i] = current_thread->tls[i];
ffffffffea806144:	f9015a61 	str	x1, [x19, #688]
	arch_thread_initialize(t);
ffffffffea806148:	97fff39e 	bl	ffffffffea802fc0 <arch_thread_initialize>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80614c:	d53b4220 	mrs	x0, daif
ffffffffea806150:	91002274 	add	x20, x19, #0x8
ffffffffea806154:	373803c0 	tbnz	w0, #7, ffffffffea8061cc <thread_create_etc+0x15c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806158:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80615c:	f00002b5 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806160:	912ea2b5 	add	x21, x21, #0xba8
ffffffffea806164:	aa1503e0 	mov	x0, x21
ffffffffea806168:	97fff1cc 	bl	ffffffffea802898 <arch_spin_lock>
	item->next = list->next;
ffffffffea80616c:	f00002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806170:	912e6021 	add	x1, x1, #0xb98
    arch_spin_unlock(lock);
ffffffffea806174:	aa1503e0 	mov	x0, x21
ffffffffea806178:	f9400422 	ldr	x2, [x1, #8]
ffffffffea80617c:	a9008a61 	stp	x1, x2, [x19, #8]
	list->next->prev = item;
ffffffffea806180:	f9000054 	str	x20, [x2]
	list->next = item;
ffffffffea806184:	f9000434 	str	x20, [x1, #8]
ffffffffea806188:	97fff1cc 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80618c:	d50342ff 	msr	daifclr, #0x2
ffffffffea806190:	aa1303e0 	mov	x0, x19
}
ffffffffea806194:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea806198:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80619c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8061a0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8061a4:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8061a8:	d65f03c0 	ret
ffffffffea8061ac:	f9002fa1 	str	x1, [x29, #88]
		t = malloc(sizeof(thread_t));
ffffffffea8061b0:	d2805b00 	mov	x0, #0x2d8                 	// #728
ffffffffea8061b4:	94003447 	bl	ffffffffea8132d0 <malloc>
		flags |= THREAD_FLAG_FREE_STRUCT;
ffffffffea8061b8:	52800094 	mov	w20, #0x4                   	// #4
		t = malloc(sizeof(thread_t));
ffffffffea8061bc:	aa0003f3 	mov	x19, x0
		if (!t)
ffffffffea8061c0:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea8061c4:	b5fff720 	cbnz	x0, ffffffffea8060a8 <thread_create_etc+0x38>
ffffffffea8061c8:	17ffffcf 	b	ffffffffea806104 <thread_create_etc+0x94>
    arch_spin_lock(lock);
ffffffffea8061cc:	f00002b5 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8061d0:	912ea2b5 	add	x21, x21, #0xba8
ffffffffea8061d4:	aa1503e0 	mov	x0, x21
ffffffffea8061d8:	97fff1b0 	bl	ffffffffea802898 <arch_spin_lock>
	item->next = list->next;
ffffffffea8061dc:	f00002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8061e0:	912e6021 	add	x1, x1, #0xb98
    arch_spin_unlock(lock);
ffffffffea8061e4:	aa1503e0 	mov	x0, x21
ffffffffea8061e8:	f9400422 	ldr	x2, [x1, #8]
ffffffffea8061ec:	a9008a61 	stp	x1, x2, [x19, #8]
	list->next->prev = item;
ffffffffea8061f0:	f9000054 	str	x20, [x2]
	list->next = item;
ffffffffea8061f4:	f9000434 	str	x20, [x1, #8]
ffffffffea8061f8:	97fff1b0 	bl	ffffffffea8028b8 <arch_spin_unlock>
}
ffffffffea8061fc:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea806200:	aa1303e0 	mov	x0, x19
ffffffffea806204:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806208:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80620c:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806210:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806214:	d65f03c0 	ret

ffffffffea806218 <thread_create>:
	return thread_create_etc(NULL, name, entry, arg, priority, NULL, stack_size);
ffffffffea806218:	aa0403e6 	mov	x6, x4
ffffffffea80621c:	d2800005 	mov	x5, #0x0                   	// #0
ffffffffea806220:	2a0303e4 	mov	w4, w3
ffffffffea806224:	aa0203e3 	mov	x3, x2
ffffffffea806228:	aa0103e2 	mov	x2, x1
ffffffffea80622c:	aa0003e1 	mov	x1, x0
ffffffffea806230:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea806234:	17ffff8f 	b	ffffffffea806070 <thread_create_etc>

ffffffffea806238 <thread_set_real_time>:
	if (!t)
ffffffffea806238:	b4000560 	cbz	x0, ffffffffea8062e4 <thread_set_real_time+0xac>
{
ffffffffea80623c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea806240:	910003fd 	mov	x29, sp
ffffffffea806244:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806248:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80624c:	d53b4221 	mrs	x1, daif
    spin_lock_saved_state_t state = 0;
ffffffffea806250:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea806254:	36380281 	tbz	w1, #7, ffffffffea8062a4 <thread_set_real_time+0x6c>
ffffffffea806258:	aa0003f3 	mov	x19, x0
    arch_spin_lock(lock);
ffffffffea80625c:	f00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806260:	912ea280 	add	x0, x20, #0xba8
ffffffffea806264:	97fff18d 	bl	ffffffffea802898 <arch_spin_lock>
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806268:	d538d080 	mrs	x0, tpidr_el1
	if (t == get_current_thread()) {
ffffffffea80626c:	eb00027f 	cmp	x19, x0
ffffffffea806270:	540002c0 	b.eq	ffffffffea8062c8 <thread_set_real_time+0x90>  // b.none
	t->flags |= THREAD_FLAG_REAL_TIME;
ffffffffea806274:	b9403661 	ldr	w1, [x19, #52]
    arch_spin_unlock(lock);
ffffffffea806278:	912ea280 	add	x0, x20, #0xba8
ffffffffea80627c:	321d0021 	orr	w1, w1, #0x8
ffffffffea806280:	b9003661 	str	w1, [x19, #52]
ffffffffea806284:	97fff18d 	bl	ffffffffea8028b8 <arch_spin_unlock>
	return NO_ERROR;
ffffffffea806288:	52800000 	mov	w0, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea80628c:	34000055 	cbz	w21, ffffffffea806294 <thread_set_real_time+0x5c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806290:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea806294:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806298:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80629c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8062a0:	d65f03c0 	ret
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8062a4:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea8062a8:	f00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8062ac:	aa0003f3 	mov	x19, x0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8062b0:	52800035 	mov	w21, #0x1                   	// #1
ffffffffea8062b4:	912ea280 	add	x0, x20, #0xba8
ffffffffea8062b8:	97fff178 	bl	ffffffffea802898 <arch_spin_lock>
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea8062bc:	d538d080 	mrs	x0, tpidr_el1
	if (t == get_current_thread()) {
ffffffffea8062c0:	eb00027f 	cmp	x19, x0
ffffffffea8062c4:	54fffd81 	b.ne	ffffffffea806274 <thread_set_real_time+0x3c>  // b.any
		timer_cancel(&preempt_timer[arch_curr_cpu_num()]);
ffffffffea8062c8:	97fff1f8 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea8062cc:	f00002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8062d0:	91204021 	add	x1, x1, #0x810
ffffffffea8062d4:	52800602 	mov	w2, #0x30                  	// #48
ffffffffea8062d8:	9ba20400 	umaddl	x0, w0, w2, x1
ffffffffea8062dc:	94000477 	bl	ffffffffea8074b8 <timer_cancel>
ffffffffea8062e0:	17ffffe5 	b	ffffffffea806274 <thread_set_real_time+0x3c>
		return ERR_INVALID_ARGS;
ffffffffea8062e4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea8062e8:	d65f03c0 	ret
ffffffffea8062ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8062f0 <thread_yield>:
{
ffffffffea8062f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8062f4:	910003fd 	mov	x29, sp
ffffffffea8062f8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8062fc:	f90013f5 	str	x21, [sp, #32]
ffffffffea806300:	d538d093 	mrs	x19, tpidr_el1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806304:	d53b4220 	mrs	x0, daif
ffffffffea806308:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80630c:	37380060 	tbnz	w0, #7, ffffffffea806318 <thread_yield+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806310:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea806314:	52800035 	mov	w21, #0x1                   	// #1
ffffffffea806318:	f00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80631c:	912ea280 	add	x0, x20, #0xba8
ffffffffea806320:	97fff15e 	bl	ffffffffea802898 <arch_spin_lock>
	return !!(t->flags & THREAD_FLAG_IDLE);
ffffffffea806324:	b9403661 	ldr	w1, [x19, #52]
	current_thread->state = THREAD_READY;
ffffffffea806328:	52800020 	mov	w0, #0x1                   	// #1
	current_thread->remaining_quantum = 0;
ffffffffea80632c:	2905fe60 	stp	w0, wzr, [x19, #44]
	if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
ffffffffea806330:	37200221 	tbnz	w1, #4, ffffffffea806374 <thread_yield+0x84>
	list_add_tail(&run_queue[t->priority], &t->queue_node);
ffffffffea806334:	b9402a65 	ldr	w5, [x19, #40]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806338:	f00002a4 	adrp	x4, ffffffffea85d000 <idle_threads+0xeb0>
	item->prev = list->prev;
ffffffffea80633c:	f00002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806340:	91264021 	add	x1, x1, #0x990
ffffffffea806344:	b94b9087 	ldr	w7, [x4, #2960]
	list_add_tail(&run_queue[t->priority], &t->queue_node);
ffffffffea806348:	91006263 	add	x3, x19, #0x18
ffffffffea80634c:	937c7ca2 	sbfiz	x2, x5, #4, #32
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806350:	1ac52000 	lsl	w0, w0, w5
ffffffffea806354:	2a070000 	orr	w0, w0, w7
ffffffffea806358:	b90b9080 	str	w0, [x4, #2960]
ffffffffea80635c:	8b020026 	add	x6, x1, x2
ffffffffea806360:	f8626820 	ldr	x0, [x1, x2]
	item->next = list;
ffffffffea806364:	a9019a60 	stp	x0, x6, [x19, #24]
	list->prev->next = item;
ffffffffea806368:	f8626820 	ldr	x0, [x1, x2]
ffffffffea80636c:	f9000403 	str	x3, [x0, #8]
	list->prev = item;
ffffffffea806370:	f8226823 	str	x3, [x1, x2]
	thread_resched();
ffffffffea806374:	97fffe91 	bl	ffffffffea805db8 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea806378:	912ea280 	add	x0, x20, #0xba8
ffffffffea80637c:	97fff14f 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806380:	34000055 	cbz	w21, ffffffffea806388 <thread_yield+0x98>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806384:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea806388:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80638c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806390:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806394:	d65f03c0 	ret

ffffffffea806398 <thread_resume>:
{
ffffffffea806398:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80639c:	910003fd 	mov	x29, sp
ffffffffea8063a0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8063a4:	aa0003f3 	mov	x19, x0
ffffffffea8063a8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8063ac:	f9001bf7 	str	x23, [sp, #48]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8063b0:	d53b4237 	mrs	x23, daif
ffffffffea8063b4:	d53b4220 	mrs	x0, daif
ffffffffea8063b8:	52800016 	mov	w22, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8063bc:	37380060 	tbnz	w0, #7, ffffffffea8063c8 <thread_resume+0x30>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8063c0:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8063c4:	52800036 	mov	w22, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea8063c8:	f00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8063cc:	912ea280 	add	x0, x20, #0xba8
ffffffffea8063d0:	97fff132 	bl	ffffffffea802898 <arch_spin_lock>
	bool resched = false;
ffffffffea8063d4:	52800015 	mov	w21, #0x0                   	// #0
	if (t->state == THREAD_SUSPENDED) {
ffffffffea8063d8:	b9402e60 	ldr	w0, [x19, #44]
ffffffffea8063dc:	35000280 	cbnz	w0, ffffffffea80642c <thread_resume+0x94>
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea8063e0:	b9402a64 	ldr	w4, [x19, #40]
	item->next = list->next;
ffffffffea8063e4:	f00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8063e8:	91264000 	add	x0, x0, #0x990
	run_queue_bitmap |= (1<<t->priority);
ffffffffea8063ec:	f00002a3 	adrp	x3, ffffffffea85d000 <idle_threads+0xeb0>
		t->state = THREAD_READY;
ffffffffea8063f0:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8063f4:	b9002e61 	str	w1, [x19, #44]
ffffffffea8063f8:	8b24d000 	add	x0, x0, w4, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea8063fc:	1ac42021 	lsl	w1, w1, w4
ffffffffea806400:	b94b9065 	ldr	w5, [x3, #2960]
		if (!ints_disabled) /* HACK, don't resced into bootstrap thread before idle thread is set up */
ffffffffea806404:	d27902f5 	eor	x21, x23, #0x80
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806408:	91006262 	add	x2, x19, #0x18
ffffffffea80640c:	f9400404 	ldr	x4, [x0, #8]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806410:	2a050021 	orr	w1, w1, w5
ffffffffea806414:	a9019260 	stp	x0, x4, [x19, #24]
		if (!ints_disabled) /* HACK, don't resced into bootstrap thread before idle thread is set up */
ffffffffea806418:	53071eb5 	ubfx	w21, w21, #7, #1
	run_queue_bitmap |= (1<<t->priority);
ffffffffea80641c:	b90b9061 	str	w1, [x3, #2960]
	list->next->prev = item;
ffffffffea806420:	f9400403 	ldr	x3, [x0, #8]
ffffffffea806424:	f9000062 	str	x2, [x3]
	list->next = item;
ffffffffea806428:	f9000402 	str	x2, [x0, #8]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80642c:	d538d080 	mrs	x0, tpidr_el1
	thread_mp_reschedule(get_current_thread(), t);
ffffffffea806430:	aa1303e1 	mov	x1, x19
ffffffffea806434:	97fffe31 	bl	ffffffffea805cf8 <thread_mp_reschedule>
    arch_spin_unlock(lock);
ffffffffea806438:	912ea280 	add	x0, x20, #0xba8
ffffffffea80643c:	97fff11f 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806440:	34000056 	cbz	w22, ffffffffea806448 <thread_resume+0xb0>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806444:	d50342ff 	msr	daifclr, #0x2
	if (resched)
ffffffffea806448:	34000055 	cbz	w21, ffffffffea806450 <thread_resume+0xb8>
		thread_yield();
ffffffffea80644c:	97ffffa9 	bl	ffffffffea8062f0 <thread_yield>
}
ffffffffea806450:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea806454:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea806458:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80645c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806460:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea806464:	d65f03c0 	ret

ffffffffea806468 <thread_preempt>:
{
ffffffffea806468:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80646c:	910003fd 	mov	x29, sp
ffffffffea806470:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806474:	a9025bf5 	stp	x21, x22, [sp, #32]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806478:	d538d093 	mrs	x19, tpidr_el1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80647c:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea806480:	373804e0 	tbnz	w0, #7, ffffffffea80651c <thread_preempt+0xb4>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806484:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea806488:	f00002b5 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80648c:	912ea2b6 	add	x22, x21, #0xba8
ffffffffea806490:	aa1603e0 	mov	x0, x22
ffffffffea806494:	97fff101 	bl	ffffffffea802898 <arch_spin_lock>
	return !!(t->flags & THREAD_FLAG_IDLE);
ffffffffea806498:	b9403660 	ldr	w0, [x19, #52]
	current_thread->state = THREAD_READY;
ffffffffea80649c:	52800034 	mov	w20, #0x1                   	// #1
ffffffffea8064a0:	b9002e74 	str	w20, [x19, #44]
	if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
ffffffffea8064a4:	37200680 	tbnz	w0, #4, ffffffffea806574 <thread_preempt+0x10c>
ffffffffea8064a8:	b9402a62 	ldr	w2, [x19, #40]
ffffffffea8064ac:	f00002a4 	adrp	x4, ffffffffea85d000 <idle_threads+0xeb0>
		if (current_thread->remaining_quantum > 0)
ffffffffea8064b0:	b9403266 	ldr	w6, [x19, #48]
ffffffffea8064b4:	f00002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8064b8:	b94b9087 	ldr	w7, [x4, #2960]
ffffffffea8064bc:	91264021 	add	x1, x1, #0x990
ffffffffea8064c0:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea8064c4:	937c7c43 	sbfiz	x3, x2, #4, #32
ffffffffea8064c8:	1ac22000 	lsl	w0, w0, w2
ffffffffea8064cc:	91006265 	add	x5, x19, #0x18
ffffffffea8064d0:	8b030022 	add	x2, x1, x3
ffffffffea8064d4:	2a070000 	orr	w0, w0, w7
ffffffffea8064d8:	710000df 	cmp	w6, #0x0
ffffffffea8064dc:	540003ed 	b.le	ffffffffea806558 <thread_preempt+0xf0>
	item->next = list->next;
ffffffffea8064e0:	f9400441 	ldr	x1, [x2, #8]
ffffffffea8064e4:	a9018662 	stp	x2, x1, [x19, #24]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea8064e8:	b90b9080 	str	w0, [x4, #2960]
	list->next->prev = item;
ffffffffea8064ec:	f9400440 	ldr	x0, [x2, #8]
ffffffffea8064f0:	f9000005 	str	x5, [x0]
	list->next = item;
ffffffffea8064f4:	f9000445 	str	x5, [x2, #8]
	thread_resched();
ffffffffea8064f8:	97fffe30 	bl	ffffffffea805db8 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea8064fc:	912ea2a0 	add	x0, x21, #0xba8
ffffffffea806500:	97fff0ee 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806504:	34000054 	cbz	w20, ffffffffea80650c <thread_preempt+0xa4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806508:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea80650c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806510:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806514:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806518:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea80651c:	f00002b5 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806520:	912ea2b6 	add	x22, x21, #0xba8
ffffffffea806524:	aa1603e0 	mov	x0, x22
ffffffffea806528:	97fff0dc 	bl	ffffffffea802898 <arch_spin_lock>
	return !!(t->flags & THREAD_FLAG_IDLE);
ffffffffea80652c:	b9403660 	ldr	w0, [x19, #52]
	current_thread->state = THREAD_READY;
ffffffffea806530:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea806534:	b9002e61 	str	w1, [x19, #44]
    spin_lock_saved_state_t state = 0;
ffffffffea806538:	52800014 	mov	w20, #0x0                   	// #0
	if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
ffffffffea80653c:	3627fb60 	tbz	w0, #4, ffffffffea8064a8 <thread_preempt+0x40>
	thread_resched();
ffffffffea806540:	97fffe1e 	bl	ffffffffea805db8 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea806544:	aa1603e0 	mov	x0, x22
}
ffffffffea806548:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80654c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806550:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806554:	17fff0d9 	b	ffffffffea8028b8 <arch_spin_unlock>
	item->prev = list->prev;
ffffffffea806558:	f8636826 	ldr	x6, [x1, x3]
	item->next = list;
ffffffffea80655c:	a9018a66 	stp	x6, x2, [x19, #24]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806560:	b90b9080 	str	w0, [x4, #2960]
	list->prev->next = item;
ffffffffea806564:	f8636820 	ldr	x0, [x1, x3]
ffffffffea806568:	f9000405 	str	x5, [x0, #8]
	list->prev = item;
ffffffffea80656c:	f8236825 	str	x5, [x1, x3]
ffffffffea806570:	17ffffe2 	b	ffffffffea8064f8 <thread_preempt+0x90>
	thread_resched();
ffffffffea806574:	97fffe11 	bl	ffffffffea805db8 <thread_resched>
ffffffffea806578:	aa1603e0 	mov	x0, x22
ffffffffea80657c:	97fff0cf 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea806580:	17ffffe2 	b	ffffffffea806508 <thread_preempt+0xa0>
ffffffffea806584:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806588 <thread_sleep>:
{
ffffffffea806588:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80658c:	910003fd 	mov	x29, sp
ffffffffea806590:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806594:	f90013f5 	str	x21, [sp, #32]
ffffffffea806598:	2a0003f5 	mov	w21, w0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80659c:	d538d093 	mrs	x19, tpidr_el1
	timer_initialize(&timer);
ffffffffea8065a0:	9100c3a0 	add	x0, x29, #0x30
ffffffffea8065a4:	940003b1 	bl	ffffffffea807468 <timer_initialize>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8065a8:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8065ac:	373802c0 	tbnz	w0, #7, ffffffffea806604 <thread_sleep+0x7c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8065b0:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea8065b4:	f00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8065b8:	912ea294 	add	x20, x20, #0xba8
ffffffffea8065bc:	aa1403e0 	mov	x0, x20
ffffffffea8065c0:	97fff0b6 	bl	ffffffffea802898 <arch_spin_lock>
	timer_set_oneshot(&timer, delay, thread_sleep_handler, (void *)current_thread);
ffffffffea8065c4:	aa1303e3 	mov	x3, x19
ffffffffea8065c8:	2a1503e1 	mov	w1, w21
ffffffffea8065cc:	9100c3a0 	add	x0, x29, #0x30
ffffffffea8065d0:	f0ffffe2 	adrp	x2, ffffffffea805000 <arm_gic_sim_irq_handler+0x148>
ffffffffea8065d4:	913c6042 	add	x2, x2, #0xf18
ffffffffea8065d8:	940003ac 	bl	ffffffffea807488 <timer_set_oneshot>
	current_thread->state = THREAD_SLEEPING;
ffffffffea8065dc:	52800080 	mov	w0, #0x4                   	// #4
ffffffffea8065e0:	b9002e60 	str	w0, [x19, #44]
	thread_resched();
ffffffffea8065e4:	97fffdf5 	bl	ffffffffea805db8 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea8065e8:	aa1403e0 	mov	x0, x20
ffffffffea8065ec:	97fff0b3 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8065f0:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8065f4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8065f8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8065fc:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806600:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea806604:	f00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806608:	912ea294 	add	x20, x20, #0xba8
ffffffffea80660c:	aa1403e0 	mov	x0, x20
ffffffffea806610:	97fff0a2 	bl	ffffffffea802898 <arch_spin_lock>
	timer_set_oneshot(&timer, delay, thread_sleep_handler, (void *)current_thread);
ffffffffea806614:	aa1303e3 	mov	x3, x19
ffffffffea806618:	2a1503e1 	mov	w1, w21
ffffffffea80661c:	9100c3a0 	add	x0, x29, #0x30
ffffffffea806620:	f0ffffe2 	adrp	x2, ffffffffea805000 <arm_gic_sim_irq_handler+0x148>
ffffffffea806624:	913c6042 	add	x2, x2, #0xf18
ffffffffea806628:	94000398 	bl	ffffffffea807488 <timer_set_oneshot>
	current_thread->state = THREAD_SLEEPING;
ffffffffea80662c:	52800080 	mov	w0, #0x4                   	// #4
ffffffffea806630:	b9002e60 	str	w0, [x19, #44]
	thread_resched();
ffffffffea806634:	97fffde1 	bl	ffffffffea805db8 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea806638:	aa1403e0 	mov	x0, x20
ffffffffea80663c:	97fff09f 	bl	ffffffffea8028b8 <arch_spin_unlock>
}
ffffffffea806640:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806644:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806648:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80664c:	d65f03c0 	ret

ffffffffea806650 <thread_init_early>:
{
ffffffffea806650:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea806654:	f00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806658:	91264000 	add	x0, x0, #0x990
ffffffffea80665c:	910003fd 	mov	x29, sp
ffffffffea806660:	91080001 	add	x1, x0, #0x200
ffffffffea806664:	a90153f3 	stp	x19, x20, [sp, #16]
	list->prev = list->next = list;
ffffffffea806668:	a9000000 	stp	x0, x0, [x0]
ffffffffea80666c:	91004000 	add	x0, x0, #0x10
	for (i=0; i < NUM_PRIORITIES; i++)
ffffffffea806670:	eb01001f 	cmp	x0, x1
ffffffffea806674:	54ffffa1 	b.ne	ffffffffea806668 <thread_init_early+0x18>  // b.any
ffffffffea806678:	f00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80667c:	912e6014 	add	x20, x0, #0xb98
	init_thread_struct(t, "bootstrap");
ffffffffea806680:	d00002b3 	adrp	x19, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
ffffffffea806684:	91054273 	add	x19, x19, #0x150
ffffffffea806688:	f905cc14 	str	x20, [x0, #2968]
ffffffffea80668c:	90000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea806690:	aa1303e0 	mov	x0, x19
ffffffffea806694:	91160021 	add	x1, x1, #0x580
ffffffffea806698:	f9000694 	str	x20, [x20, #8]
ffffffffea80669c:	97fffd25 	bl	ffffffffea805b30 <init_thread_struct>
	item->next = list->next;
ffffffffea8066a0:	f9400682 	ldr	x2, [x20, #8]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8066a4:	528d2e83 	mov	w3, #0x6974                	// #26996
ffffffffea8066a8:	72aeec23 	movk	w3, #0x7761, lsl #16
	t->priority = HIGHEST_PRIORITY;
ffffffffea8066ac:	528003e1 	mov	w1, #0x1f                  	// #31
	t->state = THREAD_RUNNING;
ffffffffea8066b0:	52800045 	mov	w5, #0x2                   	// #2
	t->flags = THREAD_FLAG_DETACHED;
ffffffffea8066b4:	d2800024 	mov	x4, #0x1                   	// #1
ffffffffea8066b8:	a9008a74 	stp	x20, x2, [x19, #8]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8066bc:	d00002a0 	adrp	x0, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
	t->state = THREAD_RUNNING;
ffffffffea8066c0:	29051661 	stp	w1, w5, [x19, #40]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8066c4:	910fa000 	add	x0, x0, #0x3e8
	t->flags = THREAD_FLAG_DETACHED;
ffffffffea8066c8:	f8034264 	stur	x4, [x19, #52]
	t->curr_cpu = 0;
ffffffffea8066cc:	b9003e7f 	str	wzr, [x19, #60]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8066d0:	b9029263 	str	w3, [x19, #656]
	cpu_priority[0] = t->priority;
ffffffffea8066d4:	d00002a3 	adrp	x3, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8066d8:	f9014e60 	str	x0, [x19, #664]
ffffffffea8066dc:	f9015260 	str	x0, [x19, #672]
	list->next->prev = item;
ffffffffea8066e0:	d00002a0 	adrp	x0, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
ffffffffea8066e4:	b902aa7f 	str	wzr, [x19, #680]
ffffffffea8066e8:	91056000 	add	x0, x0, #0x158
ffffffffea8066ec:	f9000040 	str	x0, [x2]
	cpu_priority[0] = t->priority;
ffffffffea8066f0:	b9013061 	str	w1, [x3, #304]
	list->next = item;
ffffffffea8066f4:	f9000680 	str	x0, [x20, #8]
    ARM64_WRITE_SYSREG(tpidr_el1, (uint64_t)t);
ffffffffea8066f8:	d518d093 	msr	tpidr_el1, x19
ffffffffea8066fc:	d5033fdf 	isb
}
ffffffffea806700:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806704:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806708:	d65f03c0 	ret
ffffffffea80670c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806710 <thread_init>:
{
ffffffffea806710:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea806714:	910003fd 	mov	x29, sp
ffffffffea806718:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80671c:	f00002b3 	adrp	x19, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806720:	91204273 	add	x19, x19, #0x810
ffffffffea806724:	91060274 	add	x20, x19, #0x180
		timer_initialize(&preempt_timer[i]);
ffffffffea806728:	aa1303e0 	mov	x0, x19
ffffffffea80672c:	9100c273 	add	x19, x19, #0x30
ffffffffea806730:	9400034e 	bl	ffffffffea807468 <timer_initialize>
	for (uint i = 0; i < SMP_MAX_CPUS; i++) {
ffffffffea806734:	eb14027f 	cmp	x19, x20
ffffffffea806738:	54ffff81 	b.ne	ffffffffea806728 <thread_init+0x18>  // b.any
}
ffffffffea80673c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806740:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806744:	d65f03c0 	ret

ffffffffea806748 <thread_become_idle>:
{
ffffffffea806748:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80674c:	910003fd 	mov	x29, sp
ffffffffea806750:	f9000bf3 	str	x19, [sp, #16]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806754:	d538d093 	mrs	x19, tpidr_el1
	snprintf(name, sizeof(name), "idle %d", arch_curr_cpu_num());
ffffffffea806758:	97fff0d4 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea80675c:	2a0003e3 	mov	w3, w0
ffffffffea806760:	d2800201 	mov	x1, #0x10                  	// #16
ffffffffea806764:	910083a0 	add	x0, x29, #0x20
ffffffffea806768:	90000082 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80676c:	91154042 	add	x2, x2, #0x550
ffffffffea806770:	94003292 	bl	ffffffffea8131b8 <snprintf>
ffffffffea806774:	d538d080 	mrs	x0, tpidr_el1
	strlcpy(current_thread->name, name, sizeof(current_thread->name));
ffffffffea806778:	d2800402 	mov	x2, #0x20                  	// #32
ffffffffea80677c:	910ae000 	add	x0, x0, #0x2b8
ffffffffea806780:	8b0203a1 	add	x1, x29, x2
ffffffffea806784:	940033e9 	bl	ffffffffea813728 <strlcpy>
	t->flags |= THREAD_FLAG_IDLE;
ffffffffea806788:	b9403660 	ldr	w0, [x19, #52]
	t->priority = IDLE_PRIORITY;
ffffffffea80678c:	b9002a7f 	str	wzr, [x19, #40]
	t->flags |= THREAD_FLAG_IDLE;
ffffffffea806790:	321c0000 	orr	w0, w0, #0x10
ffffffffea806794:	b9003660 	str	w0, [x19, #52]
	t->pinned_cpu = arch_curr_cpu_num();
ffffffffea806798:	97fff0c4 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea80679c:	b9003e60 	str	w0, [x19, #60]
	mp_set_curr_cpu_active(true);
ffffffffea8067a0:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea8067a4:	940003a5 	bl	ffffffffea807638 <mp_set_curr_cpu_active>
	mp_set_cpu_idle(arch_curr_cpu_num());
ffffffffea8067a8:	97fff0c0 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
    mp.idle_cpus |= 1UL << cpu;
ffffffffea8067ac:	900002c1 	adrp	x1, ffffffffea85e000 <rb_data+0x18>
ffffffffea8067b0:	91030021 	add	x1, x1, #0xc0
ffffffffea8067b4:	d2800022 	mov	x2, #0x1                   	// #1
ffffffffea8067b8:	9ac02042 	lsl	x2, x2, x0
ffffffffea8067bc:	b9400420 	ldr	w0, [x1, #4]
ffffffffea8067c0:	2a020000 	orr	w0, w0, w2
ffffffffea8067c4:	b9000420 	str	w0, [x1, #4]
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8067c8:	d50342ff 	msr	daifclr, #0x2
	thread_yield();
ffffffffea8067cc:	97fffec9 	bl	ffffffffea8062f0 <thread_yield>
		arch_idle();
ffffffffea8067d0:	97fff0da 	bl	ffffffffea802b38 <arch_idle>
ffffffffea8067d4:	97fff0d9 	bl	ffffffffea802b38 <arch_idle>
ffffffffea8067d8:	17fffffe 	b	ffffffffea8067d0 <thread_become_idle+0x88>
ffffffffea8067dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8067e0 <thread_secondary_cpu_init_early>:
{
ffffffffea8067e0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea8067e4:	910003fd 	mov	x29, sp
ffffffffea8067e8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8067ec:	52805b13 	mov	w19, #0x2d8                 	// #728
ffffffffea8067f0:	a9025bf5 	stp	x21, x22, [sp, #32]
	thread_t *t = &idle_threads[cpu];
ffffffffea8067f4:	d00002b5 	adrp	x21, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
{
ffffffffea8067f8:	a90363f7 	stp	x23, x24, [sp, #48]
	uint cpu = arch_curr_cpu_num();
ffffffffea8067fc:	97fff0ab 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea806800:	2a0003f7 	mov	w23, w0
	snprintf(name, sizeof(name), "idle %d", cpu);
ffffffffea806804:	90000082 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea806808:	2a1703e3 	mov	w3, w23
ffffffffea80680c:	91154042 	add	x2, x2, #0x550
	thread_t *t = &idle_threads[cpu];
ffffffffea806810:	910542b8 	add	x24, x21, #0x150
	snprintf(name, sizeof(name), "idle %d", cpu);
ffffffffea806814:	910103a0 	add	x0, x29, #0x40
ffffffffea806818:	9bb37ef3 	umull	x19, w23, w19
ffffffffea80681c:	d2800201 	mov	x1, #0x10                  	// #16
ffffffffea806820:	94003266 	bl	ffffffffea8131b8 <snprintf>
	thread_t *t = &idle_threads[cpu];
ffffffffea806824:	8b180274 	add	x20, x19, x24
	init_thread_struct(t, name);
ffffffffea806828:	910103a1 	add	x1, x29, #0x40
ffffffffea80682c:	aa1403e0 	mov	x0, x20
ffffffffea806830:	97fffcc0 	bl	ffffffffea805b30 <init_thread_struct>
	t->pinned_cpu = cpu;
ffffffffea806834:	d2805b00 	mov	x0, #0x2d8                 	// #728
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea806838:	910a6261 	add	x1, x19, #0x298
ffffffffea80683c:	528d2e82 	mov	w2, #0x6974                	// #26996
ffffffffea806840:	8b180021 	add	x1, x1, x24
	t->pinned_cpu = cpu;
ffffffffea806844:	9b0062e0 	madd	x0, x23, x0, x24
	t->priority = HIGHEST_PRIORITY;
ffffffffea806848:	528003e5 	mov	w5, #0x1f                  	// #31
	t->state = THREAD_RUNNING;
ffffffffea80684c:	52800044 	mov	w4, #0x2                   	// #2
	t->flags = THREAD_FLAG_DETACHED | THREAD_FLAG_IDLE;
ffffffffea806850:	52800223 	mov	w3, #0x11                  	// #17
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea806854:	72aeec22 	movk	w2, #0x7761, lsl #16
	t->state = THREAD_RUNNING;
ffffffffea806858:	29051005 	stp	w5, w4, [x0, #40]
	t->curr_cpu = cpu;
ffffffffea80685c:	2906dc03 	stp	w3, w23, [x0, #52]
	t->pinned_cpu = cpu;
ffffffffea806860:	b9003c17 	str	w23, [x0, #60]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea806864:	b9029002 	str	w2, [x0, #656]
ffffffffea806868:	f9014c01 	str	x1, [x0, #664]
ffffffffea80686c:	f9015001 	str	x1, [x0, #672]
ffffffffea806870:	b902a81f 	str	wzr, [x0, #680]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806874:	d53b4220 	mrs	x0, daif
ffffffffea806878:	52800018 	mov	w24, #0x0                   	// #0
ffffffffea80687c:	37380060 	tbnz	w0, #7, ffffffffea806888 <thread_secondary_cpu_init_early+0xa8>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806880:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea806884:	52800038 	mov	w24, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea806888:	f00002b6 	adrp	x22, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80688c:	912ea2d6 	add	x22, x22, #0xba8
ffffffffea806890:	aa1603e0 	mov	x0, x22
	list_add_head(&thread_list, &t->thread_list_node);
ffffffffea806894:	910542b5 	add	x21, x21, #0x150
ffffffffea806898:	97fff000 	bl	ffffffffea802898 <arch_spin_lock>
ffffffffea80689c:	91002273 	add	x19, x19, #0x8
	item->next = list->next;
ffffffffea8068a0:	d2805b00 	mov	x0, #0x2d8                 	// #728
ffffffffea8068a4:	f00002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8068a8:	912e6021 	add	x1, x1, #0xb98
ffffffffea8068ac:	8b150273 	add	x19, x19, x21
ffffffffea8068b0:	9b0056e0 	madd	x0, x23, x0, x21
	cpu_priority[cpu] = t->priority;
ffffffffea8068b4:	d00002a2 	adrp	x2, ffffffffea85c000 <int_handler_table_shared+0x2ee0>
ffffffffea8068b8:	9104c042 	add	x2, x2, #0x130
ffffffffea8068bc:	f9400423 	ldr	x3, [x1, #8]
ffffffffea8068c0:	a9008c01 	stp	x1, x3, [x0, #8]
	list->next->prev = item;
ffffffffea8068c4:	f9000073 	str	x19, [x3]
	list->next = item;
ffffffffea8068c8:	f9000433 	str	x19, [x1, #8]
ffffffffea8068cc:	b9402800 	ldr	w0, [x0, #40]
ffffffffea8068d0:	b8377840 	str	w0, [x2, x23, lsl #2]
    ARM64_WRITE_SYSREG(tpidr_el1, (uint64_t)t);
ffffffffea8068d4:	d518d094 	msr	tpidr_el1, x20
ffffffffea8068d8:	d5033fdf 	isb
    arch_spin_unlock(lock);
ffffffffea8068dc:	aa1603e0 	mov	x0, x22
ffffffffea8068e0:	97ffeff6 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8068e4:	34000058 	cbz	w24, ffffffffea8068ec <thread_secondary_cpu_init_early+0x10c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8068e8:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8068ec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8068f0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8068f4:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8068f8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8068fc:	d65f03c0 	ret

ffffffffea806900 <thread_secondary_cpu_entry>:
{
ffffffffea806900:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea806904:	910003fd 	mov	x29, sp
ffffffffea806908:	f9000bf3 	str	x19, [sp, #16]
	uint cpu = arch_curr_cpu_num();
ffffffffea80690c:	97fff067 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea806910:	2a0003f3 	mov	w19, w0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806914:	d538d080 	mrs	x0, tpidr_el1
	t->priority = IDLE_PRIORITY;
ffffffffea806918:	b900281f 	str	wzr, [x0, #40]
	mp_set_curr_cpu_active(true);
ffffffffea80691c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea806920:	94000346 	bl	ffffffffea807638 <mp_set_curr_cpu_active>
ffffffffea806924:	900002c0 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
ffffffffea806928:	91030000 	add	x0, x0, #0xc0
ffffffffea80692c:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea806930:	9ad32022 	lsl	x2, x1, x19
ffffffffea806934:	b9400401 	ldr	w1, [x0, #4]
ffffffffea806938:	2a020021 	orr	w1, w1, w2
ffffffffea80693c:	b9000401 	str	w1, [x0, #4]
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806940:	d50342ff 	msr	daifclr, #0x2
	thread_yield();
ffffffffea806944:	97fffe6b 	bl	ffffffffea8062f0 <thread_yield>
		arch_idle();
ffffffffea806948:	97fff07c 	bl	ffffffffea802b38 <arch_idle>
ffffffffea80694c:	97fff07b 	bl	ffffffffea802b38 <arch_idle>
ffffffffea806950:	17fffffe 	b	ffffffffea806948 <thread_secondary_cpu_entry+0x48>
ffffffffea806954:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806958 <wait_queue_block>:
 *
 * @return ERR_TIMED_OUT on timeout, else returns the return
 * value specified when the queue was woken by wait_queue_wake_one().
 */
status_t wait_queue_block(wait_queue_t *wait, lk_time_t timeout)
{
ffffffffea806958:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80695c:	910003fd 	mov	x29, sp
ffffffffea806960:	f9000bf3 	str	x19, [sp, #16]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806964:	d538d093 	mrs	x19, tpidr_el1
	ASSERT(current_thread->state == THREAD_RUNNING);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif

	if (timeout == 0)
ffffffffea806968:	340004a1 	cbz	w1, ffffffffea8069fc <wait_queue_block+0xa4>
	item->prev = list->prev;
ffffffffea80696c:	aa0003e3 	mov	x3, x0
		return ERR_TIMED_OUT;

	list_add_tail(&wait->list, &current_thread->queue_node);
	wait->count++;
ffffffffea806970:	b9401802 	ldr	w2, [x0, #24]
	current_thread->state = THREAD_BLOCKED;
ffffffffea806974:	52800064 	mov	w4, #0x3                   	// #3
	wait->count++;
ffffffffea806978:	11000442 	add	w2, w2, #0x1
ffffffffea80697c:	f8408c65 	ldr	x5, [x3, #8]!
ffffffffea806980:	f9000fb4 	str	x20, [x29, #24]
ffffffffea806984:	2a0103f4 	mov	w20, w1
	item->next = list;
ffffffffea806988:	a9018e65 	stp	x5, x3, [x19, #24]
	list_add_tail(&wait->list, &current_thread->queue_node);
ffffffffea80698c:	91006261 	add	x1, x19, #0x18
	current_thread->blocking_wait_queue = wait;
	current_thread->wait_queue_block_ret = NO_ERROR;

	/* if the timeout is nonzero or noninfinite, set a callback to yank us out of the queue */
	if (timeout != INFINITE_TIME) {
ffffffffea806990:	3100069f 	cmn	w20, #0x1
	list->prev->next = item;
ffffffffea806994:	f9400403 	ldr	x3, [x0, #8]
ffffffffea806998:	f9000461 	str	x1, [x3, #8]
	list->prev = item;
ffffffffea80699c:	f9000401 	str	x1, [x0, #8]
	wait->count++;
ffffffffea8069a0:	b9001802 	str	w2, [x0, #24]
	current_thread->state = THREAD_BLOCKED;
ffffffffea8069a4:	b9002e64 	str	w4, [x19, #44]
	current_thread->blocking_wait_queue = wait;
ffffffffea8069a8:	f9002260 	str	x0, [x19, #64]
	current_thread->wait_queue_block_ret = NO_ERROR;
ffffffffea8069ac:	b9004a7f 	str	wzr, [x19, #72]
	if (timeout != INFINITE_TIME) {
ffffffffea8069b0:	540000e1 	b.ne	ffffffffea8069cc <wait_queue_block+0x74>  // b.any
		timer_initialize(&timer);
		timer_set_oneshot(&timer, timeout, wait_queue_timeout_handler, (void *)current_thread);
	}

	thread_resched();
ffffffffea8069b4:	97fffd01 	bl	ffffffffea805db8 <thread_resched>
	/* we don't really know if the timer fired or not, so it's better safe to try to cancel it */
	if (timeout != INFINITE_TIME) {
		timer_cancel(&timer);
	}

	return current_thread->wait_queue_block_ret;
ffffffffea8069b8:	b9404a60 	ldr	w0, [x19, #72]
ffffffffea8069bc:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea8069c0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8069c4:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8069c8:	d65f03c0 	ret
		timer_initialize(&timer);
ffffffffea8069cc:	910083a0 	add	x0, x29, #0x20
ffffffffea8069d0:	940002a6 	bl	ffffffffea807468 <timer_initialize>
		timer_set_oneshot(&timer, timeout, wait_queue_timeout_handler, (void *)current_thread);
ffffffffea8069d4:	910083a0 	add	x0, x29, #0x20
ffffffffea8069d8:	aa1303e3 	mov	x3, x19
ffffffffea8069dc:	2a1403e1 	mov	w1, w20
ffffffffea8069e0:	b0000002 	adrp	x2, ffffffffea807000 <thread_exit+0x58>
ffffffffea8069e4:	9104a042 	add	x2, x2, #0x128
ffffffffea8069e8:	940002a8 	bl	ffffffffea807488 <timer_set_oneshot>
	thread_resched();
ffffffffea8069ec:	97fffcf3 	bl	ffffffffea805db8 <thread_resched>
		timer_cancel(&timer);
ffffffffea8069f0:	910083a0 	add	x0, x29, #0x20
ffffffffea8069f4:	940002b1 	bl	ffffffffea8074b8 <timer_cancel>
ffffffffea8069f8:	17fffff0 	b	ffffffffea8069b8 <wait_queue_block+0x60>
		return ERR_TIMED_OUT;
ffffffffea8069fc:	12800180 	mov	w0, #0xfffffff3            	// #-13
ffffffffea806a00:	17fffff0 	b	ffffffffea8069c0 <wait_queue_block+0x68>
ffffffffea806a04:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806a08 <thread_join>:
{
ffffffffea806a08:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea806a0c:	910003fd 	mov	x29, sp
ffffffffea806a10:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806a14:	aa0003f3 	mov	x19, x0
ffffffffea806a18:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea806a1c:	2a0203f4 	mov	w20, w2
ffffffffea806a20:	aa0103f5 	mov	x21, x1
ffffffffea806a24:	f9001bf7 	str	x23, [sp, #48]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806a28:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea806a2c:	37380540 	tbnz	w0, #7, ffffffffea806ad4 <thread_join+0xcc>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806a30:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea806a34:	f00002b6 	adrp	x22, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806a38:	912ea2d7 	add	x23, x22, #0xba8
ffffffffea806a3c:	aa1703e0 	mov	x0, x23
ffffffffea806a40:	97ffef96 	bl	ffffffffea802898 <arch_spin_lock>
	if (t->flags & THREAD_FLAG_DETACHED) {
ffffffffea806a44:	b9403660 	ldr	w0, [x19, #52]
ffffffffea806a48:	370006e0 	tbnz	w0, #0, ffffffffea806b24 <thread_join+0x11c>
	if (t->state != THREAD_DEATH) {
ffffffffea806a4c:	b9402e60 	ldr	w0, [x19, #44]
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea806a50:	52800037 	mov	w23, #0x1                   	// #1
ffffffffea806a54:	7100141f 	cmp	w0, #0x5
ffffffffea806a58:	54000521 	b.ne	ffffffffea806afc <thread_join+0xf4>  // b.any
ffffffffea806a5c:	d503201f 	nop
	if (retcode)
ffffffffea806a60:	b4000075 	cbz	x21, ffffffffea806a6c <thread_join+0x64>
		*retcode = t->retcode;
ffffffffea806a64:	b9428a60 	ldr	w0, [x19, #648]
ffffffffea806a68:	b90002a0 	str	w0, [x21]
	item->next->prev = item->prev;
ffffffffea806a6c:	a9408662 	ldp	x2, x1, [x19, #8]
    arch_spin_unlock(lock);
ffffffffea806a70:	912ea2c0 	add	x0, x22, #0xba8
ffffffffea806a74:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea806a78:	f9400662 	ldr	x2, [x19, #8]
ffffffffea806a7c:	f9000441 	str	x1, [x2, #8]
	t->magic = 0;
ffffffffea806a80:	b900027f 	str	wzr, [x19]
	item->prev = item->next = 0;
ffffffffea806a84:	a900fe7f 	stp	xzr, xzr, [x19, #8]
ffffffffea806a88:	97ffef8c 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806a8c:	34000057 	cbz	w23, ffffffffea806a94 <thread_join+0x8c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806a90:	d50342ff 	msr	daifclr, #0x2
	if (t->flags & THREAD_FLAG_FREE_STACK && t->stack)
ffffffffea806a94:	b9403661 	ldr	w1, [x19, #52]
ffffffffea806a98:	360800a1 	tbz	w1, #1, ffffffffea806aac <thread_join+0xa4>
ffffffffea806a9c:	f9413660 	ldr	x0, [x19, #616]
ffffffffea806aa0:	b4000060 	cbz	x0, ffffffffea806aac <thread_join+0xa4>
		free(t->stack);
ffffffffea806aa4:	94003221 	bl	ffffffffea813328 <free>
ffffffffea806aa8:	b9403661 	ldr	w1, [x19, #52]
	return NO_ERROR;
ffffffffea806aac:	52800014 	mov	w20, #0x0                   	// #0
	if (t->flags & THREAD_FLAG_FREE_STRUCT)
ffffffffea806ab0:	36100061 	tbz	w1, #2, ffffffffea806abc <thread_join+0xb4>
		free(t);
ffffffffea806ab4:	aa1303e0 	mov	x0, x19
ffffffffea806ab8:	9400321c 	bl	ffffffffea813328 <free>
}
ffffffffea806abc:	2a1403e0 	mov	w0, w20
ffffffffea806ac0:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea806ac4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806ac8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806acc:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea806ad0:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea806ad4:	f00002b6 	adrp	x22, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806ad8:	912ea2d7 	add	x23, x22, #0xba8
ffffffffea806adc:	aa1703e0 	mov	x0, x23
ffffffffea806ae0:	97ffef6e 	bl	ffffffffea802898 <arch_spin_lock>
	if (t->flags & THREAD_FLAG_DETACHED) {
ffffffffea806ae4:	b9403660 	ldr	w0, [x19, #52]
ffffffffea806ae8:	37000280 	tbnz	w0, #0, ffffffffea806b38 <thread_join+0x130>
	if (t->state != THREAD_DEATH) {
ffffffffea806aec:	b9402e60 	ldr	w0, [x19, #44]
    spin_lock_saved_state_t state = 0;
ffffffffea806af0:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea806af4:	7100141f 	cmp	w0, #0x5
ffffffffea806af8:	54fffb40 	b.eq	ffffffffea806a60 <thread_join+0x58>  // b.none
		status_t err = wait_queue_block(&t->retcode_wait_queue, timeout);
ffffffffea806afc:	2a1403e1 	mov	w1, w20
ffffffffea806b00:	910a4260 	add	x0, x19, #0x290
ffffffffea806b04:	97ffff95 	bl	ffffffffea806958 <wait_queue_block>
ffffffffea806b08:	2a0003f4 	mov	w20, w0
		if (err < 0) {
ffffffffea806b0c:	36fffaa0 	tbz	w0, #31, ffffffffea806a60 <thread_join+0x58>
    arch_spin_unlock(lock);
ffffffffea806b10:	912ea2c0 	add	x0, x22, #0xba8
ffffffffea806b14:	97ffef69 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806b18:	34fffd37 	cbz	w23, ffffffffea806abc <thread_join+0xb4>
ffffffffea806b1c:	d50342ff 	msr	daifclr, #0x2
ffffffffea806b20:	17ffffe7 	b	ffffffffea806abc <thread_join+0xb4>
ffffffffea806b24:	aa1703e0 	mov	x0, x23
ffffffffea806b28:	97ffef64 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea806b2c:	d50342ff 	msr	daifclr, #0x2
		return ERR_THREAD_DETACHED;
ffffffffea806b30:	12800434 	mov	w20, #0xffffffde            	// #-34
ffffffffea806b34:	17ffffe2 	b	ffffffffea806abc <thread_join+0xb4>
ffffffffea806b38:	aa1703e0 	mov	x0, x23
ffffffffea806b3c:	12800434 	mov	w20, #0xffffffde            	// #-34
ffffffffea806b40:	97ffef5e 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea806b44:	17ffffde 	b	ffffffffea806abc <thread_join+0xb4>

ffffffffea806b48 <wait_queue_wake_one>:
 * from wait_queue_block().
 *
 * @return  The number of threads woken (zero or one)
 */
int wait_queue_wake_one(wait_queue_t *wait, bool reschedule, status_t wait_queue_error)
{
ffffffffea806b48:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea806b4c:	910003fd 	mov	x29, sp
ffffffffea806b50:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806b54:	12001c34 	and	w20, w1, #0xff
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806b58:	d538d086 	mrs	x6, tpidr_el1
	if (list->next != list) {
ffffffffea806b5c:	f9400801 	ldr	x1, [x0, #16]
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif

	t = list_remove_head_type(&wait->list, thread_t, queue_node);
ffffffffea806b60:	91002003 	add	x3, x0, #0x8
ffffffffea806b64:	eb03003f 	cmp	x1, x3
ffffffffea806b68:	54000780 	b.eq	ffffffffea806c58 <wait_queue_wake_one+0x110>  // b.none
	item->next->prev = item->prev;
ffffffffea806b6c:	a9401025 	ldp	x5, x4, [x1]
	item->prev = item->next = 0;
ffffffffea806b70:	aa0103e3 	mov	x3, x1
	if (t) {
ffffffffea806b74:	f100603f 	cmp	x1, #0x18
	item->next->prev = item->prev;
ffffffffea806b78:	f9000085 	str	x5, [x4]
	item->prev->next = item->next;
ffffffffea806b7c:	f9400025 	ldr	x5, [x1]
ffffffffea806b80:	f90004a4 	str	x4, [x5, #8]
	item->prev = item->next = 0;
ffffffffea806b84:	f900043f 	str	xzr, [x1, #8]
ffffffffea806b88:	f81e847f 	str	xzr, [x3], #-24
ffffffffea806b8c:	54000660 	b.eq	ffffffffea806c58 <wait_queue_wake_one+0x110>  // b.none
		wait->count--;
ffffffffea806b90:	b9401804 	ldr	w4, [x0, #24]
#if THREAD_CHECKS
		ASSERT(t->state == THREAD_BLOCKED);
#endif
		t->state = THREAD_READY;
ffffffffea806b94:	52800025 	mov	w5, #0x1                   	// #1
ffffffffea806b98:	f00002a8 	adrp	x8, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806b9c:	f00002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
		wait->count--;
ffffffffea806ba0:	51000484 	sub	w4, w4, #0x1
ffffffffea806ba4:	b9001804 	str	w4, [x0, #24]
		t->state = THREAD_READY;
ffffffffea806ba8:	b9002c65 	str	w5, [x3, #44]
		t->wait_queue_block_ret = wait_queue_error;
		t->blocking_wait_queue = NULL;
ffffffffea806bac:	f900207f 	str	xzr, [x3, #64]
		t->wait_queue_block_ret = wait_queue_error;
ffffffffea806bb0:	b9004862 	str	w2, [x3, #72]
ffffffffea806bb4:	b94b9109 	ldr	w9, [x8, #2960]

		/* if we're instructed to reschedule, stick the current thread on the head
		 * of the run queue first, so that the newly awakened thread gets a chance to run
		 * before the current one, but the current one doesn't get unnecessarilly punished.
		 */
		if (reschedule) {
ffffffffea806bb8:	340001b4 	cbz	w20, ffffffffea806bec <wait_queue_wake_one+0xa4>
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806bbc:	b94028c4 	ldr	w4, [x6, #40]
	item->next = list->next;
ffffffffea806bc0:	91264020 	add	x0, x1, #0x990
			current_thread->state = THREAD_READY;
ffffffffea806bc4:	b9002cc5 	str	w5, [x6, #44]
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806bc8:	910060c2 	add	x2, x6, #0x18
ffffffffea806bcc:	8b24d000 	add	x0, x0, w4, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806bd0:	1ac420a5 	lsl	w5, w5, w4
ffffffffea806bd4:	2a050129 	orr	w9, w9, w5
ffffffffea806bd8:	f9400404 	ldr	x4, [x0, #8]
ffffffffea806bdc:	a90190c0 	stp	x0, x4, [x6, #24]
	list->next->prev = item;
ffffffffea806be0:	f9400404 	ldr	x4, [x0, #8]
ffffffffea806be4:	f9000082 	str	x2, [x4]
	list->next = item;
ffffffffea806be8:	f9000402 	str	x2, [x0, #8]
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806bec:	b9402864 	ldr	w4, [x3, #40]
	item->next = list->next;
ffffffffea806bf0:	91264022 	add	x2, x1, #0x990
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806bf4:	52800025 	mov	w5, #0x1                   	// #1
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806bf8:	91006067 	add	x7, x3, #0x18
			insert_in_run_queue_head(current_thread);
		}
		insert_in_run_queue_head(t);
		thread_mp_reschedule(current_thread, t);
ffffffffea806bfc:	aa0303e1 	mov	x1, x3
ffffffffea806c00:	aa0603e0 	mov	x0, x6
ffffffffea806c04:	8b24d042 	add	x2, x2, w4, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806c08:	1ac420a4 	lsl	w4, w5, w4
ffffffffea806c0c:	2a090084 	orr	w4, w4, w9
ffffffffea806c10:	b90b9104 	str	w4, [x8, #2960]
		if (reschedule) {
			thread_resched();
		}
		ret = 1;
ffffffffea806c14:	2a0503f3 	mov	w19, w5
ffffffffea806c18:	f9400444 	ldr	x4, [x2, #8]
ffffffffea806c1c:	a9019062 	stp	x2, x4, [x3, #24]
	list->next->prev = item;
ffffffffea806c20:	f9400443 	ldr	x3, [x2, #8]
ffffffffea806c24:	f9000067 	str	x7, [x3]
	list->next = item;
ffffffffea806c28:	f9000447 	str	x7, [x2, #8]
		thread_mp_reschedule(current_thread, t);
ffffffffea806c2c:	97fffc33 	bl	ffffffffea805cf8 <thread_mp_reschedule>
		if (reschedule) {
ffffffffea806c30:	350000b4 	cbnz	w20, ffffffffea806c44 <wait_queue_wake_one+0xfc>

	}

	return ret;
}
ffffffffea806c34:	2a1303e0 	mov	w0, w19
ffffffffea806c38:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806c3c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806c40:	d65f03c0 	ret
			thread_resched();
ffffffffea806c44:	97fffc5d 	bl	ffffffffea805db8 <thread_resched>
}
ffffffffea806c48:	2a1303e0 	mov	w0, w19
ffffffffea806c4c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806c50:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806c54:	d65f03c0 	ret
	int ret = 0;
ffffffffea806c58:	52800013 	mov	w19, #0x0                   	// #0
}
ffffffffea806c5c:	2a1303e0 	mov	w0, w19
ffffffffea806c60:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806c64:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806c68:	d65f03c0 	ret
ffffffffea806c6c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806c70 <wait_queue_wake_all>:
 * from wait_queue_block().
 *
 * @return  The number of threads woken (zero or one)
 */
int wait_queue_wake_all(wait_queue_t *wait, bool reschedule, status_t wait_queue_error)
{
ffffffffea806c70:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea806c74:	910003fd 	mov	x29, sp
ffffffffea806c78:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806c7c:	f90013f5 	str	x21, [sp, #32]
ffffffffea806c80:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea806c84:	12001c38 	and	w24, w1, #0xff
ffffffffea806c88:	f90027fa 	str	x26, [sp, #72]
ffffffffea806c8c:	d538d095 	mrs	x21, tpidr_el1
ffffffffea806c90:	91002017 	add	x23, x0, #0x8
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif

	if (reschedule && wait->count > 0) {
ffffffffea806c94:	340002b8 	cbz	w24, ffffffffea806ce8 <wait_queue_wake_all+0x78>
ffffffffea806c98:	b9401801 	ldr	w1, [x0, #24]
ffffffffea806c9c:	7100003f 	cmp	w1, #0x0
ffffffffea806ca0:	54000bcd 	b.le	ffffffffea806e18 <wait_queue_wake_all+0x1a8>
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806ca4:	b9402aa4 	ldr	w4, [x21, #40]
	item->next = list->next;
ffffffffea806ca8:	f00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806cac:	91264294 	add	x20, x20, #0x990
		/* if we're instructed to reschedule, stick the current thread on the head
		 * of the run queue first, so that the newly awakened threads get a chance to run
		 * before the current one, but the current one doesn't get unnecessarilly punished.
		 */
		current_thread->state = THREAD_READY;
ffffffffea806cb0:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea806cb4:	b9002ea1 	str	w1, [x21, #44]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806cb8:	f00002ba 	adrp	x26, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806cbc:	8b24d294 	add	x20, x20, w4, sxtw #4
ffffffffea806cc0:	1ac42021 	lsl	w1, w1, w4
ffffffffea806cc4:	b94b9345 	ldr	w5, [x26, #2960]
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806cc8:	910062a3 	add	x3, x21, #0x18
ffffffffea806ccc:	f9400684 	ldr	x4, [x20, #8]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806cd0:	2a050021 	orr	w1, w1, w5
ffffffffea806cd4:	a90192b4 	stp	x20, x4, [x21, #24]
ffffffffea806cd8:	b90b9341 	str	w1, [x26, #2960]
	list->next->prev = item;
ffffffffea806cdc:	f9400684 	ldr	x4, [x20, #8]
ffffffffea806ce0:	f9000083 	str	x3, [x4]
	list->next = item;
ffffffffea806ce4:	f9000683 	str	x3, [x20, #8]
	if (list->next != list) {
ffffffffea806ce8:	f9400803 	ldr	x3, [x0, #16]
ffffffffea806cec:	eb0302ff 	cmp	x23, x3
ffffffffea806cf0:	540009a0 	b.eq	ffffffffea806e24 <wait_queue_wake_all+0x1b4>  // b.none
	item->next->prev = item->prev;
ffffffffea806cf4:	a9401065 	ldp	x5, x4, [x3]
	item->prev = item->next = 0;
ffffffffea806cf8:	aa0303e1 	mov	x1, x3
		insert_in_run_queue_head(current_thread);
	}

	/* pop all the threads off the wait queue into the run queue */
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
ffffffffea806cfc:	f100607f 	cmp	x3, #0x18
	item->next->prev = item->prev;
ffffffffea806d00:	f9000085 	str	x5, [x4]
	item->prev->next = item->next;
ffffffffea806d04:	f9400065 	ldr	x5, [x3]
ffffffffea806d08:	f90004a4 	str	x4, [x5, #8]
	item->prev = item->next = 0;
ffffffffea806d0c:	f900047f 	str	xzr, [x3, #8]
ffffffffea806d10:	f81e843f 	str	xzr, [x1], #-24
ffffffffea806d14:	54000880 	b.eq	ffffffffea806e24 <wait_queue_wake_all+0x1b4>  // b.none
ffffffffea806d18:	f00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806d1c:	f00002ba 	adrp	x26, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806d20:	f90017b6 	str	x22, [x29, #40]
ffffffffea806d24:	9100f2b5 	add	x21, x21, #0x3c
ffffffffea806d28:	f90023b9 	str	x25, [x29, #64]
	item->next = list->next;
ffffffffea806d2c:	91264294 	add	x20, x20, #0x990
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806d30:	912e435a 	add	x26, x26, #0xb90
ffffffffea806d34:	2a0203f6 	mov	w22, w2
ffffffffea806d38:	aa0003f9 	mov	x25, x0
ffffffffea806d3c:	a90573bb 	stp	x27, x28, [x29, #80]
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
ffffffffea806d40:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea806d44:	5280001b 	mov	w27, #0x0                   	// #0
		wait->count--;
#if THREAD_CHECKS
		ASSERT(t->state == THREAD_BLOCKED);
#endif
		t->state = THREAD_READY;
ffffffffea806d48:	5280003c 	mov	w28, #0x1                   	// #1
ffffffffea806d4c:	d503201f 	nop
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806d50:	b9402823 	ldr	w3, [x1, #40]
ffffffffea806d54:	91006025 	add	x5, x1, #0x18
		wait->count--;
ffffffffea806d58:	b9401b22 	ldr	w2, [x25, #24]
		t->wait_queue_block_ret = wait_queue_error;
		t->blocking_wait_queue = NULL;

		insert_in_run_queue_head(t);
		mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
		ret++;
ffffffffea806d5c:	11000673 	add	w19, w19, #0x1
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806d60:	b9400340 	ldr	w0, [x26]
ffffffffea806d64:	8b23d284 	add	x4, x20, w3, sxtw #4
		wait->count--;
ffffffffea806d68:	51000442 	sub	w2, w2, #0x1
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806d6c:	1ac32383 	lsl	w3, w28, w3
ffffffffea806d70:	2a000063 	orr	w3, w3, w0
ffffffffea806d74:	b9000343 	str	w3, [x26]
		mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
ffffffffea806d78:	aa1503e0 	mov	x0, x21
ffffffffea806d7c:	f9400486 	ldr	x6, [x4, #8]
		wait->count--;
ffffffffea806d80:	b9001b22 	str	w2, [x25, #24]
		mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
ffffffffea806d84:	9100f022 	add	x2, x1, #0x3c
ffffffffea806d88:	a9019824 	stp	x4, x6, [x1, #24]
ffffffffea806d8c:	9100a021 	add	x1, x1, #0x28
		t->state = THREAD_READY;
ffffffffea806d90:	b900043c 	str	w28, [x1, #4]
	list->next->prev = item;
ffffffffea806d94:	f9400483 	ldr	x3, [x4, #8]
		t->blocking_wait_queue = NULL;
ffffffffea806d98:	f9000c3f 	str	xzr, [x1, #24]
		t->wait_queue_block_ret = wait_queue_error;
ffffffffea806d9c:	b9002036 	str	w22, [x1, #32]
ffffffffea806da0:	f9000065 	str	x5, [x3]
	list->next = item;
ffffffffea806da4:	f9000485 	str	x5, [x4, #8]
		mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
ffffffffea806da8:	97fffbb0 	bl	ffffffffea805c68 <thread_get_mp_reschedule_target.isra.5>
ffffffffea806dac:	2a00037b 	orr	w27, w27, w0
	if (list->next != list) {
ffffffffea806db0:	f9400b23 	ldr	x3, [x25, #16]
	item->prev = item->next = 0;
ffffffffea806db4:	aa0303e1 	mov	x1, x3
	if (list->next != list) {
ffffffffea806db8:	eb17007f 	cmp	x3, x23
ffffffffea806dbc:	54000120 	b.eq	ffffffffea806de0 <wait_queue_wake_all+0x170>  // b.none
	item->next->prev = item->prev;
ffffffffea806dc0:	a9400062 	ldp	x2, x0, [x3]
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
ffffffffea806dc4:	f100607f 	cmp	x3, #0x18
ffffffffea806dc8:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea806dcc:	f9400062 	ldr	x2, [x3]
ffffffffea806dd0:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea806dd4:	f900047f 	str	xzr, [x3, #8]
ffffffffea806dd8:	f81e843f 	str	xzr, [x1], #-24
ffffffffea806ddc:	54fffba1 	b.ne	ffffffffea806d50 <wait_queue_wake_all+0xe0>  // b.any
#if THREAD_CHECKS
	ASSERT(wait->count == 0);
#endif

	if (ret > 0) {
		mp_reschedule(mp_reschedule_target, 0);
ffffffffea806de0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea806de4:	2a1b03e0 	mov	w0, w27
ffffffffea806de8:	94000200 	bl	ffffffffea8075e8 <mp_reschedule>
		if (reschedule) {
ffffffffea806dec:	350002d8 	cbnz	w24, ffffffffea806e44 <wait_queue_wake_all+0x1d4>
			thread_resched();
		}
	}

	return ret;
}
ffffffffea806df0:	2a1303e0 	mov	w0, w19
ffffffffea806df4:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea806df8:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea806dfc:	a94573bb 	ldp	x27, x28, [x29, #80]
ffffffffea806e00:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806e04:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806e08:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806e0c:	f94027fa 	ldr	x26, [sp, #72]
ffffffffea806e10:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806e14:	d65f03c0 	ret
	if (list->next != list) {
ffffffffea806e18:	f9400803 	ldr	x3, [x0, #16]
ffffffffea806e1c:	eb17007f 	cmp	x3, x23
ffffffffea806e20:	54fff6a1 	b.ne	ffffffffea806cf4 <wait_queue_wake_all+0x84>  // b.any
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
ffffffffea806e24:	52800013 	mov	w19, #0x0                   	// #0
}
ffffffffea806e28:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806e2c:	2a1303e0 	mov	w0, w19
ffffffffea806e30:	f94027fa 	ldr	x26, [sp, #72]
ffffffffea806e34:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806e38:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806e3c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806e40:	d65f03c0 	ret
			thread_resched();
ffffffffea806e44:	97fffbdd 	bl	ffffffffea805db8 <thread_resched>
	return ret;
ffffffffea806e48:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea806e4c:	2a1303e0 	mov	w0, w19
	return ret;
ffffffffea806e50:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea806e54:	a94573bb 	ldp	x27, x28, [x29, #80]
}
ffffffffea806e58:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806e5c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806e60:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806e64:	f94027fa 	ldr	x26, [sp, #72]
ffffffffea806e68:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806e6c:	d65f03c0 	ret

ffffffffea806e70 <thread_detach>:
{
ffffffffea806e70:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea806e74:	910003fd 	mov	x29, sp
ffffffffea806e78:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806e7c:	aa0003f3 	mov	x19, x0
ffffffffea806e80:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806e84:	d53b4220 	mrs	x0, daif
ffffffffea806e88:	910a4275 	add	x21, x19, #0x290
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea806e8c:	37380340 	tbnz	w0, #7, ffffffffea806ef4 <thread_detach+0x84>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806e90:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea806e94:	f00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806e98:	912ea294 	add	x20, x20, #0xba8
ffffffffea806e9c:	aa1403e0 	mov	x0, x20
ffffffffea806ea0:	97ffee7e 	bl	ffffffffea802898 <arch_spin_lock>
	wait_queue_wake_all(&t->retcode_wait_queue, false, ERR_THREAD_DETACHED);
ffffffffea806ea4:	12800422 	mov	w2, #0xffffffde            	// #-34
ffffffffea806ea8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea806eac:	aa1503e0 	mov	x0, x21
ffffffffea806eb0:	97ffff70 	bl	ffffffffea806c70 <wait_queue_wake_all>
	if (t->state == THREAD_DEATH) {
ffffffffea806eb4:	b9402e60 	ldr	w0, [x19, #44]
ffffffffea806eb8:	7100141f 	cmp	w0, #0x5
ffffffffea806ebc:	54000461 	b.ne	ffffffffea806f48 <thread_detach+0xd8>  // b.any
		t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
ffffffffea806ec0:	b9403661 	ldr	w1, [x19, #52]
    arch_spin_unlock(lock);
ffffffffea806ec4:	aa1403e0 	mov	x0, x20
ffffffffea806ec8:	121f7821 	and	w1, w1, #0xfffffffe
ffffffffea806ecc:	b9003661 	str	w1, [x19, #52]
ffffffffea806ed0:	97ffee7a 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806ed4:	d50342ff 	msr	daifclr, #0x2
		return thread_join(t, NULL, 0);
ffffffffea806ed8:	aa1303e0 	mov	x0, x19
}
ffffffffea806edc:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806ee0:	a94153f3 	ldp	x19, x20, [sp, #16]
		return thread_join(t, NULL, 0);
ffffffffea806ee4:	52800002 	mov	w2, #0x0                   	// #0
}
ffffffffea806ee8:	a8c37bfd 	ldp	x29, x30, [sp], #48
		return thread_join(t, NULL, 0);
ffffffffea806eec:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea806ef0:	17fffec6 	b	ffffffffea806a08 <thread_join>
    arch_spin_lock(lock);
ffffffffea806ef4:	f00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806ef8:	912ea294 	add	x20, x20, #0xba8
ffffffffea806efc:	aa1403e0 	mov	x0, x20
ffffffffea806f00:	97ffee66 	bl	ffffffffea802898 <arch_spin_lock>
	wait_queue_wake_all(&t->retcode_wait_queue, false, ERR_THREAD_DETACHED);
ffffffffea806f04:	12800422 	mov	w2, #0xffffffde            	// #-34
ffffffffea806f08:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea806f0c:	aa1503e0 	mov	x0, x21
ffffffffea806f10:	97ffff58 	bl	ffffffffea806c70 <wait_queue_wake_all>
	if (t->state == THREAD_DEATH) {
ffffffffea806f14:	b9402e60 	ldr	w0, [x19, #44]
ffffffffea806f18:	7100141f 	cmp	w0, #0x5
ffffffffea806f1c:	540002c0 	b.eq	ffffffffea806f74 <thread_detach+0x104>  // b.none
		t->flags |= THREAD_FLAG_DETACHED;
ffffffffea806f20:	b9403661 	ldr	w1, [x19, #52]
    arch_spin_unlock(lock);
ffffffffea806f24:	aa1403e0 	mov	x0, x20
ffffffffea806f28:	32000021 	orr	w1, w1, #0x1
ffffffffea806f2c:	b9003661 	str	w1, [x19, #52]
ffffffffea806f30:	97ffee62 	bl	ffffffffea8028b8 <arch_spin_unlock>
}
ffffffffea806f34:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806f38:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea806f3c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806f40:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806f44:	d65f03c0 	ret
		t->flags |= THREAD_FLAG_DETACHED;
ffffffffea806f48:	b9403661 	ldr	w1, [x19, #52]
ffffffffea806f4c:	aa1403e0 	mov	x0, x20
ffffffffea806f50:	32000021 	orr	w1, w1, #0x1
ffffffffea806f54:	b9003661 	str	w1, [x19, #52]
ffffffffea806f58:	97ffee58 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea806f5c:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea806f60:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea806f64:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806f68:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806f6c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806f70:	d65f03c0 	ret
		t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
ffffffffea806f74:	b9403661 	ldr	w1, [x19, #52]
ffffffffea806f78:	aa1403e0 	mov	x0, x20
ffffffffea806f7c:	121f7821 	and	w1, w1, #0xfffffffe
ffffffffea806f80:	b9003661 	str	w1, [x19, #52]
ffffffffea806f84:	97ffee4d 	bl	ffffffffea8028b8 <arch_spin_unlock>
}
ffffffffea806f88:	f94013f5 	ldr	x21, [sp, #32]
		return thread_join(t, NULL, 0);
ffffffffea806f8c:	aa1303e0 	mov	x0, x19
ffffffffea806f90:	52800002 	mov	w2, #0x0                   	// #0
}
ffffffffea806f94:	a94153f3 	ldp	x19, x20, [sp, #16]
		return thread_join(t, NULL, 0);
ffffffffea806f98:	d2800001 	mov	x1, #0x0                   	// #0
}
ffffffffea806f9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
		return thread_join(t, NULL, 0);
ffffffffea806fa0:	17fffe9a 	b	ffffffffea806a08 <thread_join>
ffffffffea806fa4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806fa8 <thread_exit>:
{
ffffffffea806fa8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea806fac:	910003fd 	mov	x29, sp
ffffffffea806fb0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806fb4:	aa1e03f4 	mov	x20, x30
ffffffffea806fb8:	f90013f5 	str	x21, [sp, #32]
ffffffffea806fbc:	2a0003f5 	mov	w21, w0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806fc0:	d538d093 	mrs	x19, tpidr_el1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806fc4:	d53b4220 	mrs	x0, daif
ffffffffea806fc8:	37380040 	tbnz	w0, #7, ffffffffea806fd0 <thread_exit+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806fcc:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea806fd0:	f00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea806fd4:	912ea000 	add	x0, x0, #0xba8
ffffffffea806fd8:	97ffee30 	bl	ffffffffea802898 <arch_spin_lock>
	current_thread->retcode = retcode;
ffffffffea806fdc:	b9028a75 	str	w21, [x19, #648]
	if (current_thread->flags & THREAD_FLAG_DETACHED) {
ffffffffea806fe0:	b9403661 	ldr	w1, [x19, #52]
	current_thread->state = THREAD_DEATH;
ffffffffea806fe4:	528000a0 	mov	w0, #0x5                   	// #5
ffffffffea806fe8:	b9002e60 	str	w0, [x19, #44]
	if (current_thread->flags & THREAD_FLAG_DETACHED) {
ffffffffea806fec:	360002a1 	tbz	w1, #0, ffffffffea807040 <thread_exit+0x98>
	item->next->prev = item->prev;
ffffffffea806ff0:	a9408262 	ldp	x2, x0, [x19, #8]
ffffffffea806ff4:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea806ff8:	f9400662 	ldr	x2, [x19, #8]
ffffffffea806ffc:	f9000440 	str	x0, [x2, #8]
		current_thread->magic = 0;
ffffffffea807000:	b900027f 	str	wzr, [x19]
	item->prev = item->next = 0;
ffffffffea807004:	a900fe7f 	stp	xzr, xzr, [x19, #8]
		if (current_thread->flags & THREAD_FLAG_FREE_STACK && current_thread->stack)
ffffffffea807008:	360800a1 	tbz	w1, #1, ffffffffea80701c <thread_exit+0x74>
ffffffffea80700c:	f9413660 	ldr	x0, [x19, #616]
ffffffffea807010:	b4000060 	cbz	x0, ffffffffea80701c <thread_exit+0x74>
			heap_delayed_free(current_thread->stack);
ffffffffea807014:	94002cb7 	bl	ffffffffea8122f0 <heap_delayed_free>
ffffffffea807018:	b9403661 	ldr	w1, [x19, #52]
		if (current_thread->flags & THREAD_FLAG_FREE_STRUCT)
ffffffffea80701c:	371000c1 	tbnz	w1, #2, ffffffffea807034 <thread_exit+0x8c>
	thread_resched();
ffffffffea807020:	97fffb66 	bl	ffffffffea805db8 <thread_resched>
	panic("somehow fell through thread_exit()\n");
ffffffffea807024:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807028:	aa1403e0 	mov	x0, x20
ffffffffea80702c:	91156021 	add	x1, x1, #0x558
ffffffffea807030:	94002b1a 	bl	ffffffffea811c98 <_panic>
			heap_delayed_free(current_thread);
ffffffffea807034:	aa1303e0 	mov	x0, x19
ffffffffea807038:	94002cae 	bl	ffffffffea8122f0 <heap_delayed_free>
ffffffffea80703c:	17fffff9 	b	ffffffffea807020 <thread_exit+0x78>
		wait_queue_wake_all(&current_thread->retcode_wait_queue, false, 0);
ffffffffea807040:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea807044:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea807048:	910a4260 	add	x0, x19, #0x290
ffffffffea80704c:	97ffff09 	bl	ffffffffea806c70 <wait_queue_wake_all>
ffffffffea807050:	17fffff4 	b	ffffffffea807020 <thread_exit+0x78>
ffffffffea807054:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807058 <wait_queue_destroy>:
 * @brief  Free all resources allocated in wait_queue_init()
 *
 * If any threads were waiting on this queue, they are all woken.
 */
void wait_queue_destroy(wait_queue_t *wait, bool reschedule)
{
ffffffffea807058:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
#if THREAD_CHECKS
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif
	wait_queue_wake_all(wait, reschedule, ERR_OBJECT_DESTROYED);
ffffffffea80705c:	12800142 	mov	w2, #0xfffffff5            	// #-11
{
ffffffffea807060:	910003fd 	mov	x29, sp
ffffffffea807064:	f9000bf3 	str	x19, [sp, #16]
ffffffffea807068:	aa0003f3 	mov	x19, x0
	wait_queue_wake_all(wait, reschedule, ERR_OBJECT_DESTROYED);
ffffffffea80706c:	97ffff01 	bl	ffffffffea806c70 <wait_queue_wake_all>
	wait->magic = 0;
ffffffffea807070:	b900027f 	str	wzr, [x19]
}
ffffffffea807074:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea807078:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80707c:	d65f03c0 	ret

ffffffffea807080 <thread_unblock_from_wait_queue>:
	ASSERT(t->magic == THREAD_MAGIC);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif

	if (t->state != THREAD_BLOCKED)
ffffffffea807080:	b9402c02 	ldr	w2, [x0, #44]
ffffffffea807084:	71000c5f 	cmp	w2, #0x3
ffffffffea807088:	540004c1 	b.ne	ffffffffea807120 <thread_unblock_from_wait_queue+0xa0>  // b.any
ffffffffea80708c:	2a0103e3 	mov	w3, w1
ffffffffea807090:	aa0003e1 	mov	x1, x0
{
ffffffffea807094:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	run_queue_bitmap |= (1<<t->priority);
ffffffffea807098:	d00002a8 	adrp	x8, ffffffffea85d000 <idle_threads+0xeb0>
	item->next = list->next;
ffffffffea80709c:	d00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8070a0:	91264000 	add	x0, x0, #0x990
{
ffffffffea8070a4:	910003fd 	mov	x29, sp
	item->next->prev = item->prev;
ffffffffea8070a8:	a941a424 	ldp	x4, x9, [x1, #24]
#endif

	list_delete(&t->queue_node);
	t->blocking_wait_queue->count--;
	t->blocking_wait_queue = NULL;
	t->state = THREAD_READY;
ffffffffea8070ac:	52800026 	mov	w6, #0x1                   	// #1
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea8070b0:	b9402822 	ldr	w2, [x1, #40]
	list_delete(&t->queue_node);
ffffffffea8070b4:	91006025 	add	x5, x1, #0x18
	t->blocking_wait_queue->count--;
ffffffffea8070b8:	f9402027 	ldr	x7, [x1, #64]
ffffffffea8070bc:	f9000124 	str	x4, [x9]
	item->next = list->next;
ffffffffea8070c0:	8b22d000 	add	x0, x0, w2, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea8070c4:	b94b910a 	ldr	w10, [x8, #2960]
	item->prev->next = item->next;
ffffffffea8070c8:	f9400c2b 	ldr	x11, [x1, #24]
ffffffffea8070cc:	1ac220c2 	lsl	w2, w6, w2
	t->blocking_wait_queue->count--;
ffffffffea8070d0:	b94018e4 	ldr	w4, [x7, #24]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea8070d4:	2a0a0042 	orr	w2, w2, w10
ffffffffea8070d8:	b90b9102 	str	w2, [x8, #2960]
ffffffffea8070dc:	f9000569 	str	x9, [x11, #8]
	t->blocking_wait_queue->count--;
ffffffffea8070e0:	51000484 	sub	w4, w4, #0x1
	item->prev = item->next = 0;
ffffffffea8070e4:	f900103f 	str	xzr, [x1, #32]
	item->next = list->next;
ffffffffea8070e8:	f9400402 	ldr	x2, [x0, #8]
ffffffffea8070ec:	b90018e4 	str	w4, [x7, #24]
ffffffffea8070f0:	a9018820 	stp	x0, x2, [x1, #24]
	t->state = THREAD_READY;
ffffffffea8070f4:	b9002c26 	str	w6, [x1, #44]
	list->next->prev = item;
ffffffffea8070f8:	f9400402 	ldr	x2, [x0, #8]
	t->blocking_wait_queue = NULL;
ffffffffea8070fc:	f900203f 	str	xzr, [x1, #64]
	t->wait_queue_block_ret = wait_queue_error;
ffffffffea807100:	b9004823 	str	w3, [x1, #72]
ffffffffea807104:	f9000045 	str	x5, [x2]
	list->next = item;
ffffffffea807108:	f9000405 	str	x5, [x0, #8]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80710c:	d538d080 	mrs	x0, tpidr_el1
	insert_in_run_queue_head(t);
	thread_mp_reschedule(get_current_thread(), t);
ffffffffea807110:	97fffafa 	bl	ffffffffea805cf8 <thread_mp_reschedule>

	return NO_ERROR;
ffffffffea807114:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea807118:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80711c:	d65f03c0 	ret
		return ERR_NOT_BLOCKED;
ffffffffea807120:	12800160 	mov	w0, #0xfffffff4            	// #-12
}
ffffffffea807124:	d65f03c0 	ret

ffffffffea807128 <wait_queue_timeout_handler>:
{
ffffffffea807128:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80712c:	910003fd 	mov	x29, sp
ffffffffea807130:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea807134:	d00002b3 	adrp	x19, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea807138:	912ea273 	add	x19, x19, #0xba8
ffffffffea80713c:	aa0203f4 	mov	x20, x2
ffffffffea807140:	aa1303e0 	mov	x0, x19
ffffffffea807144:	97ffedd5 	bl	ffffffffea802898 <arch_spin_lock>
	if (thread_unblock_from_wait_queue(thread, ERR_TIMED_OUT) >= NO_ERROR) {
ffffffffea807148:	12800181 	mov	w1, #0xfffffff3            	// #-13
ffffffffea80714c:	aa1403e0 	mov	x0, x20
ffffffffea807150:	97ffffcc 	bl	ffffffffea807080 <thread_unblock_from_wait_queue>
ffffffffea807154:	2a0003f4 	mov	w20, w0
    arch_spin_unlock(lock);
ffffffffea807158:	aa1303e0 	mov	x0, x19
ffffffffea80715c:	97ffedd7 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea807160:	2a3403e0 	mvn	w0, w20
}
ffffffffea807164:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807168:	531f7c00 	lsr	w0, w0, #31
ffffffffea80716c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea807170:	d65f03c0 	ret
ffffffffea807174:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807178 <insert_timer_in_queue>:

	DEBUG_ASSERT(arch_ints_disabled());

	LTRACEF("timer %p, cpu %u, scheduled %u, periodic %u\n", timer, cpu, timer->scheduled_time, timer->periodic_time);

	list_for_every_entry(&timers[cpu].timer_queue, entry, timer_t, node) {
ffffffffea807178:	2a0003e0 	mov	w0, w0
ffffffffea80717c:	d00002a7 	adrp	x7, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea807180:	912f00e5 	add	x5, x7, #0xbc0
ffffffffea807184:	8b0014a5 	add	x5, x5, x0, lsl #5
ffffffffea807188:	f94004a2 	ldr	x2, [x5, #8]
ffffffffea80718c:	aa0203e4 	mov	x4, x2
ffffffffea807190:	d1002042 	sub	x2, x2, #0x8
ffffffffea807194:	eb0400bf 	cmp	x5, x4
ffffffffea807198:	54000200 	b.eq	ffffffffea8071d8 <insert_timer_in_queue+0x60>  // b.none
		if (TIME_GT(entry->scheduled_time, timer->scheduled_time)) {
ffffffffea80719c:	b9401826 	ldr	w6, [x1, #24]
ffffffffea8071a0:	b9401843 	ldr	w3, [x2, #24]
ffffffffea8071a4:	4b060063 	sub	w3, w3, w6
ffffffffea8071a8:	7100007f 	cmp	w3, #0x0
ffffffffea8071ac:	540000cd 	b.le	ffffffffea8071c4 <insert_timer_in_queue+0x4c>
ffffffffea8071b0:	14000013 	b	ffffffffea8071fc <insert_timer_in_queue+0x84>
ffffffffea8071b4:	b9401843 	ldr	w3, [x2, #24]
ffffffffea8071b8:	4b060063 	sub	w3, w3, w6
ffffffffea8071bc:	7100007f 	cmp	w3, #0x0
ffffffffea8071c0:	540001ec 	b.gt	ffffffffea8071fc <insert_timer_in_queue+0x84>
	list_for_every_entry(&timers[cpu].timer_queue, entry, timer_t, node) {
ffffffffea8071c4:	f9400842 	ldr	x2, [x2, #16]
ffffffffea8071c8:	aa0203e4 	mov	x4, x2
ffffffffea8071cc:	d1002042 	sub	x2, x2, #0x8
ffffffffea8071d0:	eb05009f 	cmp	x4, x5
ffffffffea8071d4:	54ffff01 	b.ne	ffffffffea8071b4 <insert_timer_in_queue+0x3c>  // b.any
	item->prev = list->prev;
ffffffffea8071d8:	912f00e7 	add	x7, x7, #0xbc0
ffffffffea8071dc:	d37be800 	lsl	x0, x0, #5
			return;
		}
	}

	/* walked off the end of the list */
	list_add_tail(&timers[cpu].timer_queue, &timer->node);
ffffffffea8071e0:	91002022 	add	x2, x1, #0x8
ffffffffea8071e4:	f86068e3 	ldr	x3, [x7, x0]
	item->next = list;
ffffffffea8071e8:	a9009423 	stp	x3, x5, [x1, #8]
	list->prev->next = item;
ffffffffea8071ec:	f86068e1 	ldr	x1, [x7, x0]
ffffffffea8071f0:	f9000422 	str	x2, [x1, #8]
	list->prev = item;
ffffffffea8071f4:	f82068e2 	str	x2, [x7, x0]
}
ffffffffea8071f8:	d65f03c0 	ret
	item->prev = list->prev;
ffffffffea8071fc:	f9400440 	ldr	x0, [x2, #8]
	item->next = list;
ffffffffea807200:	a9009020 	stp	x0, x4, [x1, #8]
			list_add_before(&entry->node, &timer->node);
ffffffffea807204:	91002021 	add	x1, x1, #0x8
	list->prev->next = item;
ffffffffea807208:	f9400440 	ldr	x0, [x2, #8]
ffffffffea80720c:	f9000401 	str	x1, [x0, #8]
	list->prev = item;
ffffffffea807210:	f9000441 	str	x1, [x2, #8]
}
ffffffffea807214:	d65f03c0 	ret

ffffffffea807218 <timer_tick>:
	spin_unlock_irqrestore(&timer_lock, state);
}

/* called at interrupt time to process any pending timers */
static enum handler_return timer_tick(void *arg, lk_time_t now)
{
ffffffffea807218:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80721c:	910003fd 	mov	x29, sp
ffffffffea807220:	a90153f3 	stp	x19, x20, [sp, #16]

	spin_lock(&timer_lock);

	for (;;) {
		/* see if there's an event to process */
		timer = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea807224:	d00002b3 	adrp	x19, ffffffffea85d000 <idle_threads+0xeb0>
{
ffffffffea807228:	a9025bf5 	stp	x21, x22, [sp, #32]
    arch_spin_lock(lock);
ffffffffea80722c:	f00002b5 	adrp	x21, ffffffffea85e000 <rb_data+0x18>
ffffffffea807230:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea807234:	910282b4 	add	x20, x21, #0xa0
ffffffffea807238:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea80723c:	2a0103f8 	mov	w24, w1
	uint cpu = arch_curr_cpu_num();
ffffffffea807240:	97ffee1a 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea807244:	2a0003f7 	mov	w23, w0
ffffffffea807248:	aa1403e0 	mov	x0, x20
ffffffffea80724c:	97ffed93 	bl	ffffffffea802898 <arch_spin_lock>
		timer = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea807250:	d37b7ee0 	ubfiz	x0, x23, #5, #32
ffffffffea807254:	912f0273 	add	x19, x19, #0xbc0
ffffffffea807258:	8b000273 	add	x19, x19, x0
	enum handler_return ret = INT_NO_RESCHEDULE;
ffffffffea80725c:	52800016 	mov	w22, #0x0                   	// #0
	if (list->next != list) {
ffffffffea807260:	aa1303f9 	mov	x25, x19
		bool periodic = timer->periodic_time > 0;

		LTRACEF("timer %p firing callback %p, arg %p\n", timer, timer->callback, timer->arg);
		KEVLOG_TIMER_CALL(timer->callback, timer->arg);
		if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
			ret = INT_RESCHEDULE;
ffffffffea807264:	5280003a 	mov	w26, #0x1                   	// #1
ffffffffea807268:	f9400721 	ldr	x1, [x25, #8]
ffffffffea80726c:	eb01027f 	cmp	x19, x1
ffffffffea807270:	540000e0 	b.eq	ffffffffea80728c <timer_tick+0x74>  // b.none
ffffffffea807274:	f9002bbb 	str	x27, [x29, #80]
		if (likely(timer == 0))
ffffffffea807278:	f100203f 	cmp	x1, #0x8
		timer = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea80727c:	d100203b 	sub	x27, x1, #0x8
ffffffffea807280:	b4000041 	cbz	x1, ffffffffea807288 <timer_tick+0x70>
		if (likely(timer == 0))
ffffffffea807284:	54000161 	b.ne	ffffffffea8072b0 <timer_tick+0x98>  // b.any
ffffffffea807288:	f9402bbb 	ldr	x27, [x29, #80]
    arch_spin_unlock(lock);
ffffffffea80728c:	910282a0 	add	x0, x21, #0xa0
ffffffffea807290:	97ffed8a 	bl	ffffffffea8028b8 <arch_spin_unlock>
	if (thread_timer_tick() == INT_RESCHEDULE)
		ret = INT_RESCHEDULE;
#endif

	return ret;
}
ffffffffea807294:	2a1603e0 	mov	w0, w22
ffffffffea807298:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80729c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8072a0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8072a4:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea8072a8:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8072ac:	d65f03c0 	ret
		if (likely(TIME_LT(now, timer->scheduled_time)))
ffffffffea8072b0:	b9401b62 	ldr	w2, [x27, #24]
ffffffffea8072b4:	4b020300 	sub	w0, w24, w2
ffffffffea8072b8:	36f80100 	tbz	w0, #31, ffffffffea8072d8 <timer_tick+0xc0>
		platform_set_oneshot_timer(timer_tick, NULL, delay);
ffffffffea8072bc:	90000000 	adrp	x0, ffffffffea807000 <thread_exit+0x58>
ffffffffea8072c0:	4b180042 	sub	w2, w2, w24
ffffffffea8072c4:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8072c8:	91086000 	add	x0, x0, #0x218
ffffffffea8072cc:	97fff825 	bl	ffffffffea805360 <platform_set_oneshot_timer>
ffffffffea8072d0:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea8072d4:	17ffffee 	b	ffffffffea80728c <timer_tick+0x74>
	item->next->prev = item->prev;
ffffffffea8072d8:	a9408762 	ldp	x2, x1, [x27, #8]
ffffffffea8072dc:	f9002fbc 	str	x28, [x29, #88]
ffffffffea8072e0:	aa1403e0 	mov	x0, x20
ffffffffea8072e4:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea8072e8:	f9400762 	ldr	x2, [x27, #8]
ffffffffea8072ec:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea8072f0:	a900ff7f 	stp	xzr, xzr, [x27, #8]
ffffffffea8072f4:	97ffed71 	bl	ffffffffea8028b8 <arch_spin_unlock>
		bool periodic = timer->periodic_time > 0;
ffffffffea8072f8:	b9401f7c 	ldr	w28, [x27, #28]
		if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
ffffffffea8072fc:	a9420b63 	ldp	x3, x2, [x27, #32]
ffffffffea807300:	2a1803e1 	mov	w1, w24
ffffffffea807304:	aa1b03e0 	mov	x0, x27
ffffffffea807308:	d63f0060 	blr	x3
			ret = INT_RESCHEDULE;
ffffffffea80730c:	7100041f 	cmp	w0, #0x1
ffffffffea807310:	1a9a12d6 	csel	w22, w22, w26, ne  // ne = any
    arch_spin_lock(lock);
ffffffffea807314:	aa1403e0 	mov	x0, x20
ffffffffea807318:	97ffed60 	bl	ffffffffea802898 <arch_spin_lock>
		if (periodic && !list_in_list(&timer->node) && timer->periodic_time > 0) {
ffffffffea80731c:	3400007c 	cbz	w28, ffffffffea807328 <timer_tick+0x110>
	if (item->prev == 0 && item->next == 0)
ffffffffea807320:	f9400760 	ldr	x0, [x27, #8]
ffffffffea807324:	b4000060 	cbz	x0, ffffffffea807330 <timer_tick+0x118>
ffffffffea807328:	a94573bb 	ldp	x27, x28, [x29, #80]
ffffffffea80732c:	17ffffcf 	b	ffffffffea807268 <timer_tick+0x50>
ffffffffea807330:	f9400b60 	ldr	x0, [x27, #16]
ffffffffea807334:	b5ffffa0 	cbnz	x0, ffffffffea807328 <timer_tick+0x110>
ffffffffea807338:	b9401f60 	ldr	w0, [x27, #28]
ffffffffea80733c:	34ffff60 	cbz	w0, ffffffffea807328 <timer_tick+0x110>
			timer->scheduled_time = now + timer->periodic_time;
ffffffffea807340:	0b180000 	add	w0, w0, w24
ffffffffea807344:	b9001b60 	str	w0, [x27, #24]
			insert_timer_in_queue(cpu, timer);
ffffffffea807348:	aa1b03e1 	mov	x1, x27
ffffffffea80734c:	2a1703e0 	mov	w0, w23
ffffffffea807350:	97ffff8a 	bl	ffffffffea807178 <insert_timer_in_queue>
ffffffffea807354:	a94573bb 	ldp	x27, x28, [x29, #80]
ffffffffea807358:	17ffffc4 	b	ffffffffea807268 <timer_tick+0x50>
ffffffffea80735c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807360 <timer_set>:
{
ffffffffea807360:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea807364:	910003fd 	mov	x29, sp
ffffffffea807368:	f90013f5 	str	x21, [sp, #32]
ffffffffea80736c:	2a0103f5 	mov	w21, w1
ffffffffea807370:	f9400401 	ldr	x1, [x0, #8]
ffffffffea807374:	f9000bf3 	str	x19, [sp, #16]
ffffffffea807378:	aa0003f3 	mov	x19, x0
ffffffffea80737c:	b5000681 	cbnz	x1, ffffffffea80744c <timer_set+0xec>
ffffffffea807380:	f9400801 	ldr	x1, [x0, #16]
ffffffffea807384:	b5000641 	cbnz	x1, ffffffffea80744c <timer_set+0xec>
ffffffffea807388:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80738c:	aa0403f4 	mov	x20, x4
ffffffffea807390:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea807394:	2a0203f7 	mov	w23, w2
ffffffffea807398:	aa0303f6 	mov	x22, x3
	now = current_time();
ffffffffea80739c:	97fff83d 	bl	ffffffffea805490 <current_time>
	timer->arg = arg;
ffffffffea8073a0:	a9025276 	stp	x22, x20, [x19, #32]
	timer->scheduled_time = now + delay;
ffffffffea8073a4:	0b150000 	add	w0, w0, w21
	timer->periodic_time = period;
ffffffffea8073a8:	29035e60 	stp	w0, w23, [x19, #24]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8073ac:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea8073b0:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8073b4:	36380340 	tbz	w0, #7, ffffffffea80741c <timer_set+0xbc>
ffffffffea8073b8:	f00002b6 	adrp	x22, ffffffffea85e000 <rb_data+0x18>
ffffffffea8073bc:	910282c0 	add	x0, x22, #0xa0
ffffffffea8073c0:	97ffed36 	bl	ffffffffea802898 <arch_spin_lock>
	uint cpu = arch_curr_cpu_num();
ffffffffea8073c4:	97ffedb9 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea8073c8:	2a0003e8 	mov	w8, w0
	insert_timer_in_queue(cpu, timer);
ffffffffea8073cc:	aa1303e1 	mov	x1, x19
ffffffffea8073d0:	97ffff6a 	bl	ffffffffea807178 <insert_timer_in_queue>
	if (list->next != list) {
ffffffffea8073d4:	d37b7d08 	ubfiz	x8, x8, #5, #32
ffffffffea8073d8:	d00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8073dc:	912f0000 	add	x0, x0, #0xbc0
ffffffffea8073e0:	8b080000 	add	x0, x0, x8
ffffffffea8073e4:	f9400401 	ldr	x1, [x0, #8]
	if (list_peek_head_type(&timers[cpu].timer_queue, timer_t, node) == timer) {
ffffffffea8073e8:	f100003f 	cmp	x1, #0x0
ffffffffea8073ec:	fa411004 	ccmp	x0, x1, #0x4, ne  // ne = any
ffffffffea8073f0:	540001c1 	b.ne	ffffffffea807428 <timer_set+0xc8>  // b.any
    arch_spin_unlock(lock);
ffffffffea8073f4:	910282c0 	add	x0, x22, #0xa0
ffffffffea8073f8:	97ffed30 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8073fc:	34000054 	cbz	w20, ffffffffea807404 <timer_set+0xa4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea807400:	d50342ff 	msr	daifclr, #0x2
ffffffffea807404:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea807408:	a942dfb6 	ldp	x22, x23, [x29, #40]
}
ffffffffea80740c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea807410:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea807414:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea807418:	d65f03c0 	ret
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80741c:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea807420:	52800034 	mov	w20, #0x1                   	// #1
ffffffffea807424:	17ffffe5 	b	ffffffffea8073b8 <timer_set+0x58>
	if (list_peek_head_type(&timers[cpu].timer_queue, timer_t, node) == timer) {
ffffffffea807428:	d1002021 	sub	x1, x1, #0x8
ffffffffea80742c:	eb01027f 	cmp	x19, x1
ffffffffea807430:	54fffe21 	b.ne	ffffffffea8073f4 <timer_set+0x94>  // b.any
		platform_set_oneshot_timer(timer_tick, NULL, delay);
ffffffffea807434:	90000000 	adrp	x0, ffffffffea807000 <thread_exit+0x58>
ffffffffea807438:	2a1503e2 	mov	w2, w21
ffffffffea80743c:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea807440:	91086000 	add	x0, x0, #0x218
ffffffffea807444:	97fff7c7 	bl	ffffffffea805360 <platform_set_oneshot_timer>
ffffffffea807448:	17ffffeb 	b	ffffffffea8073f4 <timer_set+0x94>
		panic("timer %p already in list\n", timer);
ffffffffea80744c:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807450:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea807454:	aa1303e2 	mov	x2, x19
ffffffffea807458:	91164021 	add	x1, x1, #0x590
ffffffffea80745c:	aa1e03e0 	mov	x0, x30
ffffffffea807460:	f9000fb4 	str	x20, [x29, #24]
ffffffffea807464:	94002a0d 	bl	ffffffffea811c98 <_panic>

ffffffffea807468 <timer_initialize>:
	*timer = (timer_t)TIMER_INITIAL_VALUE(*timer);
ffffffffea807468:	528dae41 	mov	w1, #0x6d72                	// #28018
ffffffffea80746c:	a900fc1f 	stp	xzr, xzr, [x0, #8]
ffffffffea807470:	72ae8d21 	movk	w1, #0x7469, lsl #16
ffffffffea807474:	b9000001 	str	w1, [x0]
ffffffffea807478:	a901fc1f 	stp	xzr, xzr, [x0, #24]
ffffffffea80747c:	f900141f 	str	xzr, [x0, #40]
}
ffffffffea807480:	d65f03c0 	ret
ffffffffea807484:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807488 <timer_set_oneshot>:
		delay = 1;
ffffffffea807488:	7100003f 	cmp	w1, #0x0
	timer_set(timer, delay, 0, callback, arg);
ffffffffea80748c:	aa0303e4 	mov	x4, x3
ffffffffea807490:	1a9f1421 	csinc	w1, w1, wzr, ne  // ne = any
ffffffffea807494:	aa0203e3 	mov	x3, x2
ffffffffea807498:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea80749c:	17ffffb1 	b	ffffffffea807360 <timer_set>

ffffffffea8074a0 <timer_set_periodic>:
		period = 1;
ffffffffea8074a0:	7100003f 	cmp	w1, #0x0
	timer_set(timer, period, period, callback, arg);
ffffffffea8074a4:	aa0303e4 	mov	x4, x3
		period = 1;
ffffffffea8074a8:	1a9f1421 	csinc	w1, w1, wzr, ne  // ne = any
	timer_set(timer, period, period, callback, arg);
ffffffffea8074ac:	aa0203e3 	mov	x3, x2
ffffffffea8074b0:	2a0103e2 	mov	w2, w1
ffffffffea8074b4:	17ffffab 	b	ffffffffea807360 <timer_set>

ffffffffea8074b8 <timer_cancel>:
{
ffffffffea8074b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8074bc:	910003fd 	mov	x29, sp
ffffffffea8074c0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8074c4:	aa0003f3 	mov	x19, x0
ffffffffea8074c8:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8074cc:	d53b4220 	mrs	x0, daif
ffffffffea8074d0:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8074d4:	37380060 	tbnz	w0, #7, ffffffffea8074e0 <timer_cancel+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8074d8:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8074dc:	52800035 	mov	w21, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea8074e0:	f00002b4 	adrp	x20, ffffffffea85e000 <rb_data+0x18>
ffffffffea8074e4:	91028280 	add	x0, x20, #0xa0
ffffffffea8074e8:	97ffecec 	bl	ffffffffea802898 <arch_spin_lock>
	uint cpu = arch_curr_cpu_num();
ffffffffea8074ec:	97ffed6f 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
	timer_t *oldhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea8074f0:	2a0003e0 	mov	w0, w0
ffffffffea8074f4:	d00002a2 	adrp	x2, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8074f8:	912f0041 	add	x1, x2, #0xbc0
ffffffffea8074fc:	8b001421 	add	x1, x1, x0, lsl #5
ffffffffea807500:	a9409666 	ldp	x6, x5, [x19, #8]
ffffffffea807504:	f9400423 	ldr	x3, [x1, #8]
ffffffffea807508:	f100007f 	cmp	x3, #0x0
ffffffffea80750c:	d1002064 	sub	x4, x3, #0x8
ffffffffea807510:	fa431024 	ccmp	x1, x3, #0x4, ne  // ne = any
ffffffffea807514:	9a9f1084 	csel	x4, x4, xzr, ne  // ne = any
	if (item->prev == 0 && item->next == 0)
ffffffffea807518:	b4000486 	cbz	x6, ffffffffea8075a8 <timer_cancel+0xf0>
	item->next->prev = item->prev;
ffffffffea80751c:	f90000a6 	str	x6, [x5]
	item->prev->next = item->next;
ffffffffea807520:	f9400663 	ldr	x3, [x19, #8]
ffffffffea807524:	f9000465 	str	x5, [x3, #8]
	item->prev = item->next = 0;
ffffffffea807528:	a900fe7f 	stp	xzr, xzr, [x19, #8]
	if (list->next != list) {
ffffffffea80752c:	912f0042 	add	x2, x2, #0xbc0
ffffffffea807530:	8b001440 	add	x0, x2, x0, lsl #5
ffffffffea807534:	f9400400 	ldr	x0, [x0, #8]
	timer->periodic_time = 0;
ffffffffea807538:	b9001e7f 	str	wzr, [x19, #28]
	timer->arg = NULL;
ffffffffea80753c:	a9027e7f 	stp	xzr, xzr, [x19, #32]
	timer_t *newhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea807540:	f100001f 	cmp	x0, #0x0
ffffffffea807544:	fa401024 	ccmp	x1, x0, #0x4, ne  // ne = any
ffffffffea807548:	540001e0 	b.eq	ffffffffea807584 <timer_cancel+0xcc>  // b.none
	if (newhead == NULL) {
ffffffffea80754c:	f100201f 	cmp	x0, #0x8
ffffffffea807550:	540001a0 	b.eq	ffffffffea807584 <timer_cancel+0xcc>  // b.none
	timer_t *newhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea807554:	d1002013 	sub	x19, x0, #0x8
	} else if (newhead != oldhead) {
ffffffffea807558:	eb13009f 	cmp	x4, x19
ffffffffea80755c:	54000160 	b.eq	ffffffffea807588 <timer_cancel+0xd0>  // b.none
		lk_time_t now = current_time();
ffffffffea807560:	97fff7cc 	bl	ffffffffea805490 <current_time>
		if (TIME_LT(newhead->scheduled_time, now))
ffffffffea807564:	b9401a62 	ldr	w2, [x19, #24]
		platform_set_oneshot_timer(timer_tick, NULL, delay);
ffffffffea807568:	90000003 	adrp	x3, ffffffffea807000 <thread_exit+0x58>
ffffffffea80756c:	d2800001 	mov	x1, #0x0                   	// #0
			delay = 0;
ffffffffea807570:	6b000042 	subs	w2, w2, w0
		platform_set_oneshot_timer(timer_tick, NULL, delay);
ffffffffea807574:	91086060 	add	x0, x3, #0x218
ffffffffea807578:	1a9f5042 	csel	w2, w2, wzr, pl  // pl = nfrst
ffffffffea80757c:	97fff779 	bl	ffffffffea805360 <platform_set_oneshot_timer>
ffffffffea807580:	14000002 	b	ffffffffea807588 <timer_cancel+0xd0>
		platform_stop_timer();
ffffffffea807584:	97fff7a5 	bl	ffffffffea805418 <platform_stop_timer>
    arch_spin_unlock(lock);
ffffffffea807588:	91028280 	add	x0, x20, #0xa0
ffffffffea80758c:	97ffeccb 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea807590:	34000055 	cbz	w21, ffffffffea807598 <timer_cancel+0xe0>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea807594:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea807598:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80759c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8075a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8075a4:	d65f03c0 	ret
	if (item->prev == 0 && item->next == 0)
ffffffffea8075a8:	b5fffba5 	cbnz	x5, ffffffffea80751c <timer_cancel+0x64>
ffffffffea8075ac:	17ffffe0 	b	ffffffffea80752c <timer_cancel+0x74>

ffffffffea8075b0 <timer_init>:

void timer_init(void)
{
	timer_lock = SPIN_LOCK_INITIAL_VALUE;
ffffffffea8075b0:	f00002a2 	adrp	x2, ffffffffea85e000 <rb_data+0x18>
ffffffffea8075b4:	d00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8075b8:	912f0000 	add	x0, x0, #0xbc0
ffffffffea8075bc:	91040001 	add	x1, x0, #0x100
ffffffffea8075c0:	f900505f 	str	xzr, [x2, #160]
ffffffffea8075c4:	d503201f 	nop
	list->prev = list->next = list;
ffffffffea8075c8:	a9000000 	stp	x0, x0, [x0]
ffffffffea8075cc:	91008000 	add	x0, x0, #0x20
	for (uint i = 0; i < SMP_MAX_CPUS; i++) {
ffffffffea8075d0:	eb01001f 	cmp	x0, x1
ffffffffea8075d4:	54ffffa1 	b.ne	ffffffffea8075c8 <timer_init+0x18>  // b.any
	}
#if !PLATFORM_HAS_DYNAMIC_TIMER
	/* register for a periodic timer tick */
	platform_set_periodic_timer(timer_tick, NULL, 10); /* 10ms */
#endif
}
ffffffffea8075d8:	d65f03c0 	ret
ffffffffea8075dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8075e0 <mp_init>:
/* a global state structure, aligned on cpu cache line to minimize aliasing */
struct mp_state mp __CPU_ALIGN;

void mp_init(void)
{
}
ffffffffea8075e0:	d65f03c0 	ret
ffffffffea8075e4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8075e8 <mp_reschedule>:

void mp_reschedule(mp_cpu_mask_t target, uint flags)
{
ffffffffea8075e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea8075ec:	910003fd 	mov	x29, sp
ffffffffea8075f0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8075f4:	2a0003f4 	mov	w20, w0
ffffffffea8075f8:	2a0103f3 	mov	w19, w1
#if WITH_SMP
	uint local_cpu = arch_curr_cpu_num();
ffffffffea8075fc:	97ffed2b 	bl	ffffffffea802aa8 <arch_curr_cpu_num>

	LTRACEF("local %d, target 0x%x\n", local_cpu, target);

	/* mask out cpus that are not active and the local cpu */
	target &= mp.active_cpus;
ffffffffea807600:	f00002a4 	adrp	x4, ffffffffea85e000 <rb_data+0x18>
ffffffffea807604:	b940c082 	ldr	w2, [x4, #192]
ffffffffea807608:	0a140042 	and	w2, w2, w20

	/* mask out cpus that are currently running realtime code */
	if ((flags & MP_RESCHEDULE_FLAG_REALTIME) == 0) {
ffffffffea80760c:	37000093 	tbnz	w19, #0, ffffffffea80761c <mp_reschedule+0x34>
ffffffffea807610:	91030081 	add	x1, x4, #0xc0
		target &= ~mp.realtime_cpus;
ffffffffea807614:	b9400821 	ldr	w1, [x1, #8]
ffffffffea807618:	0a210042 	bic	w2, w2, w1

	LTRACEF("local %d, post mask target now 0x%x\n", local_cpu, target);

	arch_mp_send_ipi(target, MP_IPI_RESCHEDULE);
#endif
}
ffffffffea80761c:	a94153f3 	ldp	x19, x20, [sp, #16]
	target &= ~(1U << local_cpu);
ffffffffea807620:	52800023 	mov	w3, #0x1                   	// #1
}
ffffffffea807624:	a8c27bfd 	ldp	x29, x30, [sp], #32
	target &= ~(1U << local_cpu);
ffffffffea807628:	1ac02060 	lsl	w0, w3, w0
	arch_mp_send_ipi(target, MP_IPI_RESCHEDULE);
ffffffffea80762c:	2a0303e1 	mov	w1, w3
ffffffffea807630:	0a200040 	bic	w0, w2, w0
ffffffffea807634:	17ffef0d 	b	ffffffffea803268 <arch_mp_send_ipi>

ffffffffea807638 <mp_set_curr_cpu_active>:

void mp_set_curr_cpu_active(bool active)
{
ffffffffea807638:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80763c:	910003fd 	mov	x29, sp
	atomic_or((volatile int *)&mp.active_cpus, 1U << arch_curr_cpu_num());
ffffffffea807640:	97ffed1a 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea807644:	52800022 	mov	w2, #0x1                   	// #1
    return __atomic_fetch_or(ptr, val, __ATOMIC_RELAXED);
ffffffffea807648:	f00002a1 	adrp	x1, ffffffffea85e000 <rb_data+0x18>
ffffffffea80764c:	91030021 	add	x1, x1, #0xc0
ffffffffea807650:	1ac02040 	lsl	w0, w2, w0
ffffffffea807654:	885f7c22 	ldxr	w2, [x1]
ffffffffea807658:	2a000042 	orr	w2, w2, w0
ffffffffea80765c:	88037c22 	stxr	w3, w2, [x1]
ffffffffea807660:	35ffffa3 	cbnz	w3, ffffffffea807654 <mp_set_curr_cpu_active+0x1c>
}
ffffffffea807664:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea807668:	d65f03c0 	ret
ffffffffea80766c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807670 <mp_mbx_reschedule_irq>:

#if WITH_SMP
enum handler_return mp_mbx_reschedule_irq(void)
{
ffffffffea807670:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea807674:	910003fd 	mov	x29, sp
	uint cpu = arch_curr_cpu_num();
ffffffffea807678:	97ffed0c 	bl	ffffffffea802aa8 <arch_curr_cpu_num>

	LTRACEF("cpu %u\n", cpu);

	THREAD_STATS_INC(reschedule_ipis);

	return (mp.active_cpus & (1U << cpu)) ? INT_RESCHEDULE : INT_NO_RESCHEDULE;
ffffffffea80767c:	f00002a1 	adrp	x1, ffffffffea85e000 <rb_data+0x18>
}
ffffffffea807680:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return (mp.active_cpus & (1U << cpu)) ? INT_RESCHEDULE : INT_NO_RESCHEDULE;
ffffffffea807684:	b940c021 	ldr	w1, [x1, #192]
ffffffffea807688:	1ac02420 	lsr	w0, w1, w0
}
ffffffffea80768c:	12000000 	and	w0, w0, #0x1
ffffffffea807690:	d65f03c0 	ret
ffffffffea807694:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807698 <tegra_boot_profiler_init>:
 * If the profiler is not enabled then we just turn all of the profiler
 * functions into no-ops.
 * The '(void)' statements are to silence compiler
 * warnings */

long tegra_boot_profiler_init(paddr_t boot_arg){ return 0L; }
ffffffffea807698:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80769c:	d65f03c0 	ret

ffffffffea8076a0 <tegra_boot_profiler_deinit>:

void tegra_boot_profiler_deinit(void){ ; }
ffffffffea8076a0:	d65f03c0 	ret
ffffffffea8076a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8076a8 <tegra_boot_profiler_get_timestamp>:

uint32_t tegra_boot_profiler_get_timestamp(void) { return 0U; }
ffffffffea8076a8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8076ac:	d65f03c0 	ret

ffffffffea8076b0 <tegra_boot_profiler_record>:

/* If TOS boot profiler is NOT enabled no records will be added */
void tegra_boot_profiler_record(const char *str) {
	(void)str;
}
ffffffffea8076b0:	d65f03c0 	ret
ffffffffea8076b4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8076b8 <tegra_boot_profiler_prerecorded>:

void tegra_boot_profiler_prerecorded(const char *str, uint32_t tstamp) {
	(void)str;
	(void)tstamp;
}
ffffffffea8076b8:	d65f03c0 	ret
ffffffffea8076bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8076c0 <memlog_init>:
static smc32_entity_t log_sm_entity = {
	.stdcall_handler = memlog_stdcall,
};

static void memlog_init(uint level)
{
ffffffffea8076c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	int err;

	err = sm_register_entity(SMC_ENTITY_LOGGING, &log_sm_entity);
ffffffffea8076c4:	d0000081 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea8076c8:	52800660 	mov	w0, #0x33                  	// #51
ffffffffea8076cc:	9115a021 	add	x1, x1, #0x568
{
ffffffffea8076d0:	910003fd 	mov	x29, sp
	err = sm_register_entity(SMC_ENTITY_LOGGING, &log_sm_entity);
ffffffffea8076d4:	940004f3 	bl	ffffffffea808aa0 <sm_register_entity>
	if (err) {
ffffffffea8076d8:	35000060 	cbnz	w0, ffffffffea8076e4 <memlog_init+0x24>
		printf("trusty error register entity: %d\n", err);
	}
}
ffffffffea8076dc:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8076e0:	d65f03c0 	ret
ffffffffea8076e4:	a8c17bfd 	ldp	x29, x30, [sp], #16
		printf("trusty error register entity: %d\n", err);
ffffffffea8076e8:	f0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8076ec:	2a0003e1 	mov	w1, w0
ffffffffea8076f0:	9117c040 	add	x0, x2, #0x5f0
ffffffffea8076f4:	14002ecf 	b	ffffffffea813230 <_printf>

ffffffffea8076f8 <memlog_print_callback>:
{
ffffffffea8076f8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea8076fc:	910003fd 	mov	x29, sp
ffffffffea807700:	a90153f3 	stp	x19, x20, [sp, #16]
	struct memlog *log = containerof(cb, struct memlog, cb);
ffffffffea807704:	d1008014 	sub	x20, x0, #0x20
{
ffffffffea807708:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80770c:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea807710:	aa0003f7 	mov	x23, x0
ffffffffea807714:	f90023f9 	str	x25, [sp, #64]
ffffffffea807718:	aa0103f8 	mov	x24, x1
ffffffffea80771c:	aa0203f9 	mov	x25, x2
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea807720:	d53b4220 	mrs	x0, daif
ffffffffea807724:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea807728:	37380060 	tbnz	w0, #7, ffffffffea807734 <memlog_print_callback+0x3c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80772c:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea807730:	52800035 	mov	w21, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea807734:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea807738:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea80773c:	37300080 	tbnz	w0, #6, ffffffffea80774c <memlog_print_callback+0x54>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea807740:	321f02b5 	orr	w21, w21, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea807744:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea807748:	52800053 	mov	w19, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea80774c:	d00002b6 	adrp	x22, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea807750:	913302c0 	add	x0, x22, #0xcc0
ffffffffea807754:	97ffec51 	bl	ffffffffea802898 <arch_spin_lock>
	for (i = 0; i < len / chunk_size; i++) {
ffffffffea807758:	d347ff2a 	lsr	x10, x25, #7
ffffffffea80775c:	b40003ea 	cbz	x10, ffffffffea8077d8 <memlog_print_callback+0xe0>
ffffffffea807760:	d379e14a 	lsl	x10, x10, #7
ffffffffea807764:	aa1803e7 	mov	x7, x24
ffffffffea807768:	8b180149 	add	x9, x10, x24
ffffffffea80776c:	d503201f 	nop
		__memlog_write(log, &str[i * chunk_size], chunk_size);
ffffffffea807770:	f9400286 	ldr	x6, [x20]
	log_offset = rb->alloc;
ffffffffea807774:	b94000c8 	ldr	w8, [x6]
	rb->alloc += len;
ffffffffea807778:	b94000c0 	ldr	w0, [x6]
ffffffffea80777c:	11020000 	add	w0, w0, #0x80
ffffffffea807780:	b90000c0 	str	w0, [x6]
	wmb();
ffffffffea807784:	d5033e9f 	dsb	st
	for (i = 0; i < len; i++) {
ffffffffea807788:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea80778c:	d503201f 	nop
		uint32_t offset = (log_offset + i) & (log->rb_sz - 1);
ffffffffea807790:	f9400680 	ldr	x0, [x20, #8]
ffffffffea807794:	0b030105 	add	w5, w8, w3
		*ptr = str[i];
ffffffffea807798:	386368e4 	ldrb	w4, [x7, x3]
	for (i = 0; i < len; i++) {
ffffffffea80779c:	91000463 	add	x3, x3, #0x1
		uint32_t offset = (log_offset + i) & (log->rb_sz - 1);
ffffffffea8077a0:	51000400 	sub	w0, w0, #0x1
	for (i = 0; i < len; i++) {
ffffffffea8077a4:	f102007f 	cmp	x3, #0x80
		*ptr = str[i];
ffffffffea8077a8:	0a050000 	and	w0, w0, w5
ffffffffea8077ac:	8b0000c0 	add	x0, x6, x0
ffffffffea8077b0:	39003004 	strb	w4, [x0, #12]
	for (i = 0; i < len; i++) {
ffffffffea8077b4:	54fffee1 	b.ne	ffffffffea807790 <memlog_print_callback+0x98>  // b.any
	wmb();
ffffffffea8077b8:	d5033e9f 	dsb	st
	rb->put += len;
ffffffffea8077bc:	b94004c0 	ldr	w0, [x6, #4]
ffffffffea8077c0:	910200e7 	add	x7, x7, #0x80
	for (i = 0; i < len / chunk_size; i++) {
ffffffffea8077c4:	eb07013f 	cmp	x9, x7
	rb->put += len;
ffffffffea8077c8:	11020000 	add	w0, w0, #0x80
ffffffffea8077cc:	b90004c0 	str	w0, [x6, #4]
	for (i = 0; i < len / chunk_size; i++) {
ffffffffea8077d0:	54fffd01 	b.ne	ffffffffea807770 <memlog_print_callback+0x78>  // b.any
ffffffffea8077d4:	cb0a0339 	sub	x25, x25, x10
	if (rem) {
ffffffffea8077d8:	b4000319 	cbz	x25, ffffffffea807838 <memlog_print_callback+0x140>
		__memlog_write(log, &str[i * chunk_size], rem);
ffffffffea8077dc:	f85e02e3 	ldur	x3, [x23, #-32]
	rb->alloc += len;
ffffffffea8077e0:	2a1903e7 	mov	w7, w25
	log_offset = rb->alloc;
ffffffffea8077e4:	b9400066 	ldr	w6, [x3]
	rb->alloc += len;
ffffffffea8077e8:	b9400060 	ldr	w0, [x3]
ffffffffea8077ec:	0b190000 	add	w0, w0, w25
ffffffffea8077f0:	b9000060 	str	w0, [x3]
	wmb();
ffffffffea8077f4:	d5033e9f 	dsb	st
ffffffffea8077f8:	8b180149 	add	x9, x10, x24
	for (i = 0; i < len; i++) {
ffffffffea8077fc:	d2800001 	mov	x1, #0x0                   	// #0
		uint32_t offset = (log_offset + i) & (log->rb_sz - 1);
ffffffffea807800:	f9400680 	ldr	x0, [x20, #8]
ffffffffea807804:	0b0100c5 	add	w5, w6, w1
		*ptr = str[i];
ffffffffea807808:	38616924 	ldrb	w4, [x9, x1]
	for (i = 0; i < len; i++) {
ffffffffea80780c:	91000421 	add	x1, x1, #0x1
		uint32_t offset = (log_offset + i) & (log->rb_sz - 1);
ffffffffea807810:	51000400 	sub	w0, w0, #0x1
	for (i = 0; i < len; i++) {
ffffffffea807814:	eb19003f 	cmp	x1, x25
		*ptr = str[i];
ffffffffea807818:	0a050000 	and	w0, w0, w5
ffffffffea80781c:	8b000060 	add	x0, x3, x0
ffffffffea807820:	39003004 	strb	w4, [x0, #12]
	for (i = 0; i < len; i++) {
ffffffffea807824:	54fffee1 	b.ne	ffffffffea807800 <memlog_print_callback+0x108>  // b.any
	wmb();
ffffffffea807828:	d5033e9f 	dsb	st
	rb->put += len;
ffffffffea80782c:	b9400460 	ldr	w0, [x3, #4]
ffffffffea807830:	0b0000e0 	add	w0, w7, w0
ffffffffea807834:	b9000460 	str	w0, [x3, #4]
    arch_spin_unlock(lock);
ffffffffea807838:	913302c0 	add	x0, x22, #0xcc0
ffffffffea80783c:	97ffec1f 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea807840:	34000053 	cbz	w19, ffffffffea807848 <memlog_print_callback+0x150>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea807844:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea807848:	36000055 	tbz	w21, #0, ffffffffea807850 <memlog_print_callback+0x158>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80784c:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea807850:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807854:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea807858:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80785c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea807860:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea807864:	d65f03c0 	ret

ffffffffea807868 <memlog_add>:
{
ffffffffea807868:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80786c:	910003fd 	mov	x29, sp
ffffffffea807870:	f90013f5 	str	x21, [sp, #32]
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea807874:	d0000095 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea807878:	911562a3 	add	x3, x21, #0x558
ffffffffea80787c:	f9400465 	ldr	x5, [x3, #8]
ffffffffea807880:	eb05007f 	cmp	x3, x5
ffffffffea807884:	54000260 	b.eq	ffffffffea8078d0 <memlog_add+0x68>  // b.none
ffffffffea807888:	d100e0a4 	sub	x4, x5, #0x38
ffffffffea80788c:	8b010006 	add	x6, x0, x1
ffffffffea807890:	aa0303e5 	mov	x5, x3
		if (pa + sz <= log->buf_pa) {
ffffffffea807894:	f9400883 	ldr	x3, [x4, #16]
ffffffffea807898:	eb06007f 	cmp	x3, x6
ffffffffea80789c:	54000122 	b.cs	ffffffffea8078c0 <memlog_add+0x58>  // b.hs, b.nlast
		if (pa >= log->buf_pa + log->buf_sz){
ffffffffea8078a0:	f9400c87 	ldr	x7, [x4, #24]
ffffffffea8078a4:	8b070063 	add	x3, x3, x7
ffffffffea8078a8:	eb03001f 	cmp	x0, x3
ffffffffea8078ac:	540000a2 	b.cs	ffffffffea8078c0 <memlog_add+0x58>  // b.hs, b.nlast
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea8078b0:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
}
ffffffffea8078b4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8078b8:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8078bc:	d65f03c0 	ret
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea8078c0:	f9402083 	ldr	x3, [x4, #64]
ffffffffea8078c4:	d100e064 	sub	x4, x3, #0x38
ffffffffea8078c8:	eb0300bf 	cmp	x5, x3
ffffffffea8078cc:	54fffe41 	b.ne	ffffffffea807894 <memlog_add+0x2c>  // b.any
ffffffffea8078d0:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea8078d4:	aa0003f4 	mov	x20, x0
ffffffffea8078d8:	a90363b7 	stp	x23, x24, [x29, #48]
	log = malloc(sizeof(*log));
ffffffffea8078dc:	d2800900 	mov	x0, #0x48                  	// #72
ffffffffea8078e0:	2a0203f8 	mov	w24, w2
ffffffffea8078e4:	aa0103f7 	mov	x23, x1
ffffffffea8078e8:	94002e7a 	bl	ffffffffea8132d0 <malloc>
ffffffffea8078ec:	aa0003f3 	mov	x19, x0
	if (!log) {
ffffffffea8078f0:	b40009a0 	cbz	x0, ffffffffea807a24 <memlog_add+0x1bc>
ffffffffea8078f4:	f90017b6 	str	x22, [x29, #40]
	sz = ROUNDUP((sz + offset), mb);
ffffffffea8078f8:	b2404fe1 	mov	x1, #0xfffff               	// #1048575
ffffffffea8078fc:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea807900:	8b0102f6 	add	x22, x23, x1
	offset = pa & (mb - 1);
ffffffffea807904:	92404e99 	and	x25, x20, #0xfffff
	pa = ROUNDDOWN(pa, mb);
ffffffffea807908:	926cae9a 	and	x26, x20, #0xfffffffffff00000
	sz = ROUNDUP((sz + offset), mb);
ffffffffea80790c:	8b1902d6 	add	x22, x22, x25
	err = trusty_hyp_check_guest_pa_valid(pa, sz, guest);
ffffffffea807910:	2a1803e2 	mov	w2, w24
	sz = ROUNDUP((sz + offset), mb);
ffffffffea807914:	926caed6 	and	x22, x22, #0xfffffffffff00000
	err = trusty_hyp_check_guest_pa_valid(pa, sz, guest);
ffffffffea807918:	aa1a03e0 	mov	x0, x26
	log->buf_sz = sz;
ffffffffea80791c:	a9015e74 	stp	x20, x23, [x19, #16]
	err = trusty_hyp_check_guest_pa_valid(pa, sz, guest);
ffffffffea807920:	aa1603e1 	mov	x1, x22
ffffffffea807924:	97ffebad 	bl	ffffffffea8027d8 <trusty_hyp_check_guest_pa_valid>
	if (err != NO_ERROR) {
ffffffffea807928:	350005e0 	cbnz	w0, ffffffffea8079e4 <memlog_add+0x17c>
	err = vmm_alloc_physical(vmm_get_kernel_aspace(),
ffffffffea80792c:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807930:	f00002a0 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
ffffffffea807934:	52800607 	mov	w7, #0x30                  	// #48
ffffffffea807938:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80793c:	aa1a03e5 	mov	x5, x26
ffffffffea807940:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea807944:	910163a3 	add	x3, x29, #0x58
ffffffffea807948:	aa1603e2 	mov	x2, x22
ffffffffea80794c:	9117a021 	add	x1, x1, #0x5e8
ffffffffea807950:	91034000 	add	x0, x0, #0xd0
ffffffffea807954:	94002691 	bl	ffffffffea811398 <vmm_alloc_physical>
	if (err) {
ffffffffea807958:	35000520 	cbnz	w0, ffffffffea8079fc <memlog_add+0x194>
	log->rb_sz = lower_pow2(log->buf_sz - offsetof(struct log_rb, data));
ffffffffea80795c:	f9400e60 	ldr	x0, [x19, #24]
	item->next = list->next;
ffffffffea807960:	911562b5 	add	x21, x21, #0x558
	*va += offset;
ffffffffea807964:	f9402fa5 	ldr	x5, [x29, #88]
	return 1u << (31 - __builtin_clz(v));
ffffffffea807968:	528003e3 	mov	w3, #0x1f                  	// #31
	log->rb_sz = lower_pow2(log->buf_sz - offsetof(struct log_rb, data));
ffffffffea80796c:	51003000 	sub	w0, w0, #0xc
	return 1u << (31 - __builtin_clz(v));
ffffffffea807970:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea807974:	5ac01000 	clz	w0, w0
	*va += offset;
ffffffffea807978:	8b050321 	add	x1, x25, x5
	return 1u << (31 - __builtin_clz(v));
ffffffffea80797c:	4b000060 	sub	w0, w3, w0
ffffffffea807980:	f94006a4 	ldr	x4, [x21, #8]
	*va += offset;
ffffffffea807984:	f9002fa1 	str	x1, [x29, #88]
	list_add_head(&log_list, &log->entry);
ffffffffea807988:	9100e263 	add	x3, x19, #0x38
	return 1u << (31 - __builtin_clz(v));
ffffffffea80798c:	1ac02042 	lsl	w2, w2, w0
	log->rb_sz = lower_pow2(log->buf_sz - offsetof(struct log_rb, data));
ffffffffea807990:	a9000a61 	stp	x1, x2, [x19]
	return 1u << (31 - __builtin_clz(v));
ffffffffea807994:	aa0203e0 	mov	x0, x2
	rb->sz = log->rb_sz;
ffffffffea807998:	b9000820 	str	w0, [x1, #8]
	rb->alloc = 0;
ffffffffea80799c:	b8256b3f 	str	wzr, [x25, x5]
	log->cb.print = memlog_print_callback;
ffffffffea8079a0:	90000002 	adrp	x2, ffffffffea807000 <thread_exit+0x58>
	rb->put = 0;
ffffffffea8079a4:	b900043f 	str	wzr, [x1, #4]
	log->cb.print = memlog_print_callback;
ffffffffea8079a8:	911be042 	add	x2, x2, #0x6f8
ffffffffea8079ac:	a9039275 	stp	x21, x4, [x19, #56]
	register_print_callback(&log->cb);
ffffffffea8079b0:	91008260 	add	x0, x19, #0x20
	list->next->prev = item;
ffffffffea8079b4:	f9000083 	str	x3, [x4]
	log->cb.print = memlog_print_callback;
ffffffffea8079b8:	f9001a62 	str	x2, [x19, #48]
	list->next = item;
ffffffffea8079bc:	f90006a3 	str	x3, [x21, #8]
	register_print_callback(&log->cb);
ffffffffea8079c0:	94002750 	bl	ffffffffea811700 <register_print_callback>
	return 0;
ffffffffea8079c4:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea8079c8:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea8079cc:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea8079d0:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea8079d4:	a943e7b8 	ldp	x24, x25, [x29, #56]
}
ffffffffea8079d8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8079dc:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8079e0:	d65f03c0 	ret
		dprintf(ALWAYS, "%s: check_guest_pa_valid failed, error = %d",
ffffffffea8079e4:	f0000063 	adrp	x3, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8079e8:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8079ec:	2a0003e2 	mov	w2, w0
ffffffffea8079f0:	9116c021 	add	x1, x1, #0x5b0
ffffffffea8079f4:	9116e060 	add	x0, x3, #0x5b8
ffffffffea8079f8:	9400282a 	bl	ffffffffea811aa0 <_dprintf>
	free(log);
ffffffffea8079fc:	aa1303e0 	mov	x0, x19
ffffffffea807a00:	94002e4a 	bl	ffffffffea813328 <free>
	return status;
ffffffffea807a04:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea807a08:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea807a0c:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea807a10:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea807a14:	a943e7b8 	ldp	x24, x25, [x29, #56]
}
ffffffffea807a18:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea807a1c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea807a20:	d65f03c0 	ret
		return SM_ERR_INTERNAL_FAILURE;
ffffffffea807a24:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea807a28:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea807a2c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea807a30:	17ffffa1 	b	ffffffffea8078b4 <memlog_add+0x4c>
ffffffffea807a34:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807a38 <memlog_rm>:
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea807a38:	d0000082 	adrp	x2, ffffffffea819000 <_mem_phys_base>
ffffffffea807a3c:	91156042 	add	x2, x2, #0x558
ffffffffea807a40:	f9400441 	ldr	x1, [x2, #8]
ffffffffea807a44:	eb01005f 	cmp	x2, x1
ffffffffea807a48:	54000500 	b.eq	ffffffffea807ae8 <memlog_rm+0xb0>  // b.none
{
ffffffffea807a4c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea807a50:	910003fd 	mov	x29, sp
ffffffffea807a54:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea807a58:	d100e033 	sub	x19, x1, #0x38
		if (log->buf_pa == pa) {
ffffffffea807a5c:	f85d8021 	ldur	x1, [x1, #-40]
ffffffffea807a60:	eb01001f 	cmp	x0, x1
ffffffffea807a64:	540000a1 	b.ne	ffffffffea807a78 <memlog_rm+0x40>  // b.any
ffffffffea807a68:	1400000c 	b	ffffffffea807a98 <memlog_rm+0x60>
ffffffffea807a6c:	f85d8021 	ldur	x1, [x1, #-40]
ffffffffea807a70:	eb01001f 	cmp	x0, x1
ffffffffea807a74:	54000120 	b.eq	ffffffffea807a98 <memlog_rm+0x60>  // b.none
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea807a78:	f9402261 	ldr	x1, [x19, #64]
ffffffffea807a7c:	eb01005f 	cmp	x2, x1
ffffffffea807a80:	d100e033 	sub	x19, x1, #0x38
ffffffffea807a84:	54ffff41 	b.ne	ffffffffea807a6c <memlog_rm+0x34>  // b.any
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea807a88:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
}
ffffffffea807a8c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807a90:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea807a94:	d65f03c0 	ret
	unregister_print_callback(&log->cb);
ffffffffea807a98:	91008260 	add	x0, x19, #0x20
ffffffffea807a9c:	94002749 	bl	ffffffffea8117c0 <unregister_print_callback>
	item->next->prev = item->prev;
ffffffffea807aa0:	a9438a63 	ldp	x3, x2, [x19, #56]
	result = vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)log->rb);
ffffffffea807aa4:	f00002a0 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
ffffffffea807aa8:	f9400261 	ldr	x1, [x19]
ffffffffea807aac:	91034000 	add	x0, x0, #0xd0
ffffffffea807ab0:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea807ab4:	f9401e63 	ldr	x3, [x19, #56]
ffffffffea807ab8:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea807abc:	a903fe7f 	stp	xzr, xzr, [x19, #56]
ffffffffea807ac0:	94002698 	bl	ffffffffea811520 <vmm_free_region>
ffffffffea807ac4:	2a0003f4 	mov	w20, w0
	free(log);
ffffffffea807ac8:	aa1303e0 	mov	x0, x19
ffffffffea807acc:	94002e17 	bl	ffffffffea813328 <free>
	return 0;
ffffffffea807ad0:	7100029f 	cmp	w20, #0x0
ffffffffea807ad4:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
}
ffffffffea807ad8:	a94153f3 	ldp	x19, x20, [sp, #16]
	return 0;
ffffffffea807adc:	9a9f1000 	csel	x0, x0, xzr, ne  // ne = any
}
ffffffffea807ae0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea807ae4:	d65f03c0 	ret
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea807ae8:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
}
ffffffffea807aec:	d65f03c0 	ret

ffffffffea807af0 <memlog_stdcall>:
	switch (args->smc_nr) {
ffffffffea807af0:	b9400001 	ldr	w1, [x0]
ffffffffea807af4:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea807af8:	72a66002 	movk	w2, #0x3300, lsl #16
ffffffffea807afc:	6b02003f 	cmp	w1, w2
ffffffffea807b00:	54000120 	b.eq	ffffffffea807b24 <memlog_stdcall+0x34>  // b.none
ffffffffea807b04:	11000442 	add	w2, w2, #0x1
ffffffffea807b08:	6b02003f 	cmp	w1, w2
ffffffffea807b0c:	54000140 	b.eq	ffffffffea807b34 <memlog_stdcall+0x44>  // b.none
ffffffffea807b10:	52a66000 	mov	w0, #0x33000000            	// #855638016
		return SM_ERR_UNDEFINED_SMC;
ffffffffea807b14:	6b00003f 	cmp	w1, w0
ffffffffea807b18:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
ffffffffea807b1c:	9a9f1400 	csinc	x0, x0, xzr, ne  // ne = any
}
ffffffffea807b20:	d65f03c0 	ret
		return memlog_add(args_get_pa(args), args_get_sz(args), args_get_guest(args));
ffffffffea807b24:	b9400c01 	ldr	w1, [x0, #12]
ffffffffea807b28:	b9401c02 	ldr	w2, [x0, #28]
ffffffffea807b2c:	f8404000 	ldur	x0, [x0, #4]
ffffffffea807b30:	17ffff4e 	b	ffffffffea807868 <memlog_add>
		return memlog_rm(args_get_pa(args));
ffffffffea807b34:	f8404000 	ldur	x0, [x0, #4]
ffffffffea807b38:	17ffffc0 	b	ffffffffea807a38 <memlog_rm>
ffffffffea807b3c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807b40 <sm_sched_nonsecure>:
#include <lib/sm/sm_err.h>

#include <kernel/vm.h>

FUNCTION(sm_sched_nonsecure)
	push	x1, x30
ffffffffea807b40:	a9bf7be1 	stp	x1, x30, [sp, #-16]!
.Lfastcall_complete:
	mov	x1, x0
ffffffffea807b44:	aa0003e1 	mov	x1, x0
.Lreturn_sm_err:
	ldr	x0, =SMC_SC_NS_RETURN
ffffffffea807b48:	58000500 	ldr	x0, ffffffffea807be8 <smc_fastcall_secure_monitor+0x30>
	mov	x2, xzr
ffffffffea807b4c:	aa1f03e2 	mov	x2, xzr
	mov	x3, xzr
ffffffffea807b50:	aa1f03e3 	mov	x3, xzr
	smc	#0
ffffffffea807b54:	d4000003 	smc	#0x0

	tbnz	x0, #30, .Lsm_err_not_supported /* Check calling convention */
ffffffffea807b58:	37f00280 	tbnz	w0, #30, ffffffffea807ba8 <sm_sched_nonsecure+0x68>
	tbz	x0, #31, .Lnot_fast_call
ffffffffea807b5c:	36f801a0 	tbz	w0, #31, ffffffffea807b90 <sm_sched_nonsecure+0x50>

	/* fastcall */
	sub	sp, sp, #(4 * SMC_NUM_ARGS) /* allocate smc32_args_t on stack */
ffffffffea807b60:	d10083ff 	sub	sp, sp, #0x20
	stp	w0, w1, [sp]
ffffffffea807b64:	290007e0 	stp	w0, w1, [sp]
	stp	w2, w3, [sp, #4 * 2]
ffffffffea807b68:	29010fe2 	stp	w2, w3, [sp, #8]
	stp	w4, w5, [sp, #4 * 4]
ffffffffea807b6c:	290217e4 	stp	w4, w5, [sp, #16]
	stp	w6, w7, [sp, #4 * 6]
ffffffffea807b70:	29031fe6 	stp	w6, w7, [sp, #24]

	ubfx	x0, x0, #24, #6		/* x0 = entity */
ffffffffea807b74:	d3587400 	ubfx	x0, x0, #24, #6
	ldr	x9, =sm_fastcall_table
ffffffffea807b78:	580003c9 	ldr	x9, ffffffffea807bf0 <smc_fastcall_secure_monitor+0x38>
	ldr	x9, [x9, x0, lsl #3]
ffffffffea807b7c:	f8607929 	ldr	x9, [x9, x0, lsl #3]

	mov	x0, sp			/* x0 = smc_args_t* args */
ffffffffea807b80:	910003e0 	mov	x0, sp
	blr	x9
ffffffffea807b84:	d63f0120 	blr	x9
	add	sp, sp, #(4 * SMC_NUM_ARGS)
ffffffffea807b88:	910083ff 	add	sp, sp, #0x20
	b	.Lfastcall_complete
ffffffffea807b8c:	17ffffee 	b	ffffffffea807b44 <sm_sched_nonsecure+0x4>

.Lnot_fast_call:
	pop	x9, x30
ffffffffea807b90:	a8c17be9 	ldp	x9, x30, [sp], #16
	stp	w0, w1, [x9], #8
ffffffffea807b94:	28810520 	stp	w0, w1, [x9], #8
	stp	w2, w3, [x9], #8
ffffffffea807b98:	28810d22 	stp	w2, w3, [x9], #8
	stp	w4, w5, [x9], #8
ffffffffea807b9c:	28811524 	stp	w4, w5, [x9], #8
	stp	w6, w7, [x9], #8
ffffffffea807ba0:	28811d26 	stp	w6, w7, [x9], #8
	ret
ffffffffea807ba4:	d65f03c0 	ret

.Lsm_err_not_supported:
	mov	x1, #SM_ERR_NOT_SUPPORTED
ffffffffea807ba8:	928000e1 	mov	x1, #0xfffffffffffffff8    	// #-8
	b	.Lreturn_sm_err
ffffffffea807bac:	17ffffe7 	b	ffffffffea807b48 <sm_sched_nonsecure+0x8>

.Lsm_err_busy:
	mov	x1, #SM_ERR_BUSY
ffffffffea807bb0:	92800081 	mov	x1, #0xfffffffffffffffb    	// #-5
	b	.Lreturn_sm_err
ffffffffea807bb4:	17ffffe5 	b	ffffffffea807b48 <sm_sched_nonsecure+0x8>

ffffffffea807bb8 <smc_fastcall_secure_monitor>:

FUNCTION(smc_fastcall_secure_monitor)
	ldrh	w1, [x0]	/* r1 = function# */
ffffffffea807bb8:	79400001 	ldrh	w1, [x0]
	ldr	x2, =sm_nr_fastcall_functions
ffffffffea807bbc:	580001e2 	ldr	x2, ffffffffea807bf8 <smc_fastcall_secure_monitor+0x40>
	ldr	w2, [x2]
ffffffffea807bc0:	b9400042 	ldr	w2, [x2]
	cmp	w1, w2
ffffffffea807bc4:	6b02003f 	cmp	w1, w2
	bhs	.Lfastcall_smc_undefined
ffffffffea807bc8:	540000a2 	b.cs	ffffffffea807bdc <smc_fastcall_secure_monitor+0x24>  // b.hs, b.nlast
	ldr	x2, =sm_fastcall_function_table
ffffffffea807bcc:	580001a2 	ldr	x2, ffffffffea807c00 <smc_fastcall_secure_monitor+0x48>
	ldr	x2, [x2, x1, lsl#3]
ffffffffea807bd0:	f8617842 	ldr	x2, [x2, x1, lsl #3]
	cbz	x2, .Lfastcall_smc_undefined
ffffffffea807bd4:	b4000042 	cbz	x2, ffffffffea807bdc <smc_fastcall_secure_monitor+0x24>
	br	x2
ffffffffea807bd8:	d61f0040 	br	x2
.Lfastcall_smc_undefined:
	ldr	x2, =smc_undefined
ffffffffea807bdc:	58000162 	ldr	x2, ffffffffea807c08 <smc_fastcall_secure_monitor+0x50>
	br	x2
ffffffffea807be0:	d61f0040 	br	x2
ffffffffea807be4:	00000000 	.inst	0x00000000 ; undefined
ffffffffea807be8:	3c000000 	.word	0x3c000000
ffffffffea807bec:	00000000 	.word	0x00000000
ffffffffea807bf0:	ea8196a0 	.word	0xea8196a0
ffffffffea807bf4:	ffffffff 	.word	0xffffffff
ffffffffea807bf8:	ea819aa0 	.word	0xea819aa0
ffffffffea807bfc:	ffffffff 	.word	0xffffffff
ffffffffea807c00:	ea819630 	.word	0xea819630
ffffffffea807c04:	ffffffff 	.word	0xffffffff
ffffffffea807c08:	ea808788 	.word	0xea808788
ffffffffea807c0c:	ffffffff 	.word	0xffffffff

ffffffffea807c10 <platform_halt>:
#include <lib/sm/sm_err.h>
#include <platform.h>

void platform_halt(platform_halt_action suggested_action,
                   platform_halt_reason reason)
{
ffffffffea807c10:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);

    dprintf(ALWAYS, "HALT: (reason = %d)\n", reason);
ffffffffea807c14:	f0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807c18:	91188000 	add	x0, x0, #0x620
{
ffffffffea807c1c:	910003fd 	mov	x29, sp
    smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);
ffffffffea807c20:	a9017fbf 	stp	xzr, xzr, [x29, #16]
ffffffffea807c24:	a9027fbf 	stp	xzr, xzr, [x29, #32]
    dprintf(ALWAYS, "HALT: (reason = %d)\n", reason);
ffffffffea807c28:	9400279e 	bl	ffffffffea811aa0 <_dprintf>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea807c2c:	d50342df 	msr	daifset, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea807c30:	d50341df 	msr	daifset, #0x1
ffffffffea807c34:	d503201f 	nop
    arch_disable_ints();
    arch_disable_fiqs();
    while(true) {
        sm_sched_nonsecure(SM_ERR_PANIC, &args);
ffffffffea807c38:	910043a1 	add	x1, x29, #0x10
ffffffffea807c3c:	92800140 	mov	x0, #0xfffffffffffffff5    	// #-11
ffffffffea807c40:	97ffffc0 	bl	ffffffffea807b40 <sm_sched_nonsecure>
ffffffffea807c44:	17fffffd 	b	ffffffffea807c38 <platform_halt+0x28>

ffffffffea807c48 <sm_secondary_init>:
LK_INIT_HOOK_FLAGS(libsm_mon_perrcpu, sm_mon_percpu_init,
		   LK_INIT_LEVEL_PLATFORM - 3, LK_INIT_FLAG_ALL_CPUS);
#endif

static void sm_secondary_init(uint level)
{
ffffffffea807c48:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea807c4c:	910003fd 	mov	x29, sp
ffffffffea807c50:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea807c54:	f90013f5 	str	x21, [sp, #32]
	int cpu = arch_curr_cpu_num();

	event_init(&nsirqevent[cpu], false, EVENT_FLAG_AUTOUNSIGNAL);

	snprintf(name, sizeof(name), "irq-ns-switch-%d", cpu);
	nsirqthreads[cpu] = thread_create(name, sm_irq_loop, (void *)(uintptr_t)cpu,
ffffffffea807c58:	d00002b5 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
{
ffffffffea807c5c:	f9001bf7 	str	x23, [sp, #48]
ffffffffea807c60:	aa1e03f7 	mov	x23, x30
	int cpu = arch_curr_cpu_num();
ffffffffea807c64:	97ffeb91 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea807c68:	93407c14 	sxtw	x20, w0
	event_init(&nsirqevent[cpu], false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea807c6c:	d00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea807c70:	9134a000 	add	x0, x0, #0xd28
ffffffffea807c74:	52800603 	mov	w3, #0x30                  	// #48
	nsirqthreads[cpu] = thread_create(name, sm_irq_loop, (void *)(uintptr_t)cpu,
ffffffffea807c78:	913aa2b5 	add	x21, x21, #0xea8
	event_init(&nsirqevent[cpu], false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea807c7c:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea807c80:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea807c84:	9b230280 	smaddl	x0, w20, w3, x0
ffffffffea807c88:	97fff692 	bl	ffffffffea8056d0 <event_init>
	snprintf(name, sizeof(name), "irq-ns-switch-%d", cpu);
ffffffffea807c8c:	2a1403e3 	mov	w3, w20
ffffffffea807c90:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea807c94:	f0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807c98:	910103a0 	add	x0, x29, #0x40
ffffffffea807c9c:	91250042 	add	x2, x2, #0x940
ffffffffea807ca0:	94002d46 	bl	ffffffffea8131b8 <snprintf>
	nsirqthreads[cpu] = thread_create(name, sm_irq_loop, (void *)(uintptr_t)cpu,
ffffffffea807ca4:	b0000001 	adrp	x1, ffffffffea808000 <sm_get_api_version+0x88>
ffffffffea807ca8:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea807cac:	528003e3 	mov	w3, #0x1f                  	// #31
ffffffffea807cb0:	aa1403e2 	mov	x2, x20
ffffffffea807cb4:	910d0021 	add	x1, x1, #0x340
ffffffffea807cb8:	910103a0 	add	x0, x29, #0x40
ffffffffea807cbc:	97fff957 	bl	ffffffffea806218 <thread_create>
ffffffffea807cc0:	f90017b6 	str	x22, [x29, #40]
ffffffffea807cc4:	f8347aa0 	str	x0, [x21, x20, lsl #3]
					  HIGHEST_PRIORITY, DEFAULT_STACK_SIZE);
	if (!nsirqthreads[cpu]) {
ffffffffea807cc8:	b4000540 	cbz	x0, ffffffffea807d70 <sm_secondary_init+0x128>
ffffffffea807ccc:	aa0003e1 	mov	x1, x0
	}
	nsirqthreads[cpu]->pinned_cpu = cpu;
	thread_set_real_time(nsirqthreads[cpu]);

	snprintf(name, sizeof(name), "idle-ns-switch-%d", cpu);
	nsidlethreads[cpu] = thread_create(name,
ffffffffea807cd0:	d00002b6 	adrp	x22, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea807cd4:	9133a2d6 	add	x22, x22, #0xce8
	nsirqthreads[cpu]->pinned_cpu = cpu;
ffffffffea807cd8:	b9003c34 	str	w20, [x1, #60]
	thread_set_real_time(nsirqthreads[cpu]);
ffffffffea807cdc:	97fff957 	bl	ffffffffea806238 <thread_set_real_time>
	snprintf(name, sizeof(name), "idle-ns-switch-%d", cpu);
ffffffffea807ce0:	2a1403e3 	mov	w3, w20
ffffffffea807ce4:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea807ce8:	f0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807cec:	910103a0 	add	x0, x29, #0x40
ffffffffea807cf0:	91264042 	add	x2, x2, #0x990
ffffffffea807cf4:	94002d31 	bl	ffffffffea8131b8 <snprintf>
	nsidlethreads[cpu] = thread_create(name,
ffffffffea807cf8:	b0000001 	adrp	x1, ffffffffea808000 <sm_get_api_version+0x88>
ffffffffea807cfc:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea807d00:	9107e021 	add	x1, x1, #0x1f8
ffffffffea807d04:	52800023 	mov	w3, #0x1                   	// #1
ffffffffea807d08:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea807d0c:	910103a0 	add	x0, x29, #0x40
ffffffffea807d10:	97fff942 	bl	ffffffffea806218 <thread_create>
ffffffffea807d14:	f8347ac0 	str	x0, [x22, x20, lsl #3]
ffffffffea807d18:	aa0003e1 	mov	x1, x0
			(thread_start_routine)sm_wait_for_smcall,
			NULL, LOWEST_PRIORITY + 1, DEFAULT_STACK_SIZE);
	if (!nsidlethreads[cpu]) {
ffffffffea807d1c:	b4000200 	cbz	x0, ffffffffea807d5c <sm_secondary_init+0x114>
		panic("failed to create idle NS switcher thread for cpu %d!\n", cpu);
	}
	nsidlethreads[cpu]->pinned_cpu = cpu;
ffffffffea807d20:	b9003c34 	str	w20, [x1, #60]
	thread_set_real_time(nsidlethreads[cpu]);
ffffffffea807d24:	97fff945 	bl	ffffffffea806238 <thread_set_real_time>

	if (ns_threads_started) {
ffffffffea807d28:	d00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea807d2c:	39738000 	ldrb	w0, [x0, #3296]
ffffffffea807d30:	340000a0 	cbz	w0, ffffffffea807d44 <sm_secondary_init+0xfc>
		thread_resume(nsirqthreads[cpu]);
ffffffffea807d34:	f8747aa0 	ldr	x0, [x21, x20, lsl #3]
ffffffffea807d38:	97fff998 	bl	ffffffffea806398 <thread_resume>
		thread_resume(nsidlethreads[cpu]);
ffffffffea807d3c:	f8747ac0 	ldr	x0, [x22, x20, lsl #3]
ffffffffea807d40:	97fff996 	bl	ffffffffea806398 <thread_resume>
	}
}
ffffffffea807d44:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807d48:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea807d4c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea807d50:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea807d54:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea807d58:	d65f03c0 	ret
		panic("failed to create idle NS switcher thread for cpu %d!\n", cpu);
ffffffffea807d5c:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807d60:	2a1403e2 	mov	w2, w20
ffffffffea807d64:	9126a021 	add	x1, x1, #0x9a8
ffffffffea807d68:	aa1703e0 	mov	x0, x23
ffffffffea807d6c:	940027cb 	bl	ffffffffea811c98 <_panic>
		panic("failed to create irq NS switcher thread for cpu %d!\n", cpu);
ffffffffea807d70:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807d74:	2a1403e2 	mov	w2, w20
ffffffffea807d78:	91256021 	add	x1, x1, #0x958
ffffffffea807d7c:	aa1703e0 	mov	x0, x23
ffffffffea807d80:	940027c6 	bl	ffffffffea811c98 <_panic>
ffffffffea807d84:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807d88 <resume_nsthreads>:
	mutex_release(&boot_args_lock);
	return err;
}

static void resume_nsthreads(void)
{
ffffffffea807d88:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	int i;

	ns_threads_started = true;
ffffffffea807d8c:	d00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea807d90:	52800021 	mov	w1, #0x1                   	// #1
{
ffffffffea807d94:	910003fd 	mov	x29, sp
ffffffffea807d98:	a90153f3 	stp	x19, x20, [sp, #16]
	ns_threads_started = true;
ffffffffea807d9c:	39338001 	strb	w1, [x0, #3296]
{
ffffffffea807da0:	f90013f5 	str	x21, [sp, #32]
	smp_wmb();
ffffffffea807da4:	d5033abf 	dmb	ishst
ffffffffea807da8:	d00002b5 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea807dac:	d00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
	for (i = 0; i < SMP_MAX_CPUS; i++) {
		if (nsirqthreads[i]) {
ffffffffea807db0:	913aa2b5 	add	x21, x21, #0xea8
			thread_resume(nsirqthreads[i]);
		}
		if (nsidlethreads[i]) {
ffffffffea807db4:	9133a294 	add	x20, x20, #0xce8
	smp_wmb();
ffffffffea807db8:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea807dbc:	d503201f 	nop
		if (nsirqthreads[i]) {
ffffffffea807dc0:	f8756a61 	ldr	x1, [x19, x21]
			thread_resume(nsirqthreads[i]);
ffffffffea807dc4:	aa0103e0 	mov	x0, x1
		if (nsirqthreads[i]) {
ffffffffea807dc8:	b4000041 	cbz	x1, ffffffffea807dd0 <resume_nsthreads+0x48>
			thread_resume(nsirqthreads[i]);
ffffffffea807dcc:	97fff973 	bl	ffffffffea806398 <thread_resume>
		if (nsidlethreads[i]) {
ffffffffea807dd0:	f8746a61 	ldr	x1, [x19, x20]
ffffffffea807dd4:	91002273 	add	x19, x19, #0x8
			thread_resume(nsidlethreads[i]);
ffffffffea807dd8:	aa0103e0 	mov	x0, x1
		if (nsidlethreads[i]) {
ffffffffea807ddc:	b4000041 	cbz	x1, ffffffffea807de4 <resume_nsthreads+0x5c>
			thread_resume(nsidlethreads[i]);
ffffffffea807de0:	97fff96e 	bl	ffffffffea806398 <thread_resume>
	for (i = 0; i < SMP_MAX_CPUS; i++) {
ffffffffea807de4:	f101027f 	cmp	x19, #0x40
ffffffffea807de8:	54fffec1 	b.ne	ffffffffea807dc0 <resume_nsthreads+0x38>  // b.any
		}
	}
}
ffffffffea807dec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807df0:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea807df4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea807df8:	d65f03c0 	ret
ffffffffea807dfc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807e00 <sm_init>:
{
ffffffffea807e00:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
void mutex_destroy(mutex_t *);
status_t mutex_acquire_timeout(mutex_t *, lk_time_t); /* try to acquire the mutex with a timeout value */
status_t mutex_release(mutex_t *);

static inline status_t mutex_acquire(mutex_t *m) {
	return mutex_acquire_timeout(m, INFINITE_TIME);
ffffffffea807e04:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea807e08:	910003fd 	mov	x29, sp
ffffffffea807e0c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea807e10:	d0000094 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea807e14:	f90013f5 	str	x21, [sp, #32]
ffffffffea807e18:	91160280 	add	x0, x20, #0x580
ffffffffea807e1c:	aa1e03f5 	mov	x21, x30
ffffffffea807e20:	97fff6e6 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	if (lk_boot_args[1] && lk_boot_args[2]) {
ffffffffea807e24:	f00002b3 	adrp	x19, ffffffffea85e000 <rb_data+0x18>
ffffffffea807e28:	91010260 	add	x0, x19, #0x40
ffffffffea807e2c:	f9400405 	ldr	x5, [x0, #8]
ffffffffea807e30:	b4000065 	cbz	x5, ffffffffea807e3c <sm_init+0x3c>
ffffffffea807e34:	f9400802 	ldr	x2, [x0, #16]
ffffffffea807e38:	b50004c2 	cbnz	x2, ffffffffea807ed0 <sm_init+0xd0>
	if ((void *)lk_boot_args[3] != NULL){
ffffffffea807e3c:	91010273 	add	x19, x19, #0x40
ffffffffea807e40:	f9400e61 	ldr	x1, [x19, #24]
ffffffffea807e44:	b50002a1 	cbnz	x1, ffffffffea807e98 <sm_init+0x98>
	stdcallthread = thread_create("sm-stdcall", sm_stdcall_loop, NULL,
ffffffffea807e48:	d00002b3 	adrp	x19, ffffffffea85d000 <idle_threads+0xeb0>
	mutex_release(&boot_args_lock);
ffffffffea807e4c:	91160280 	add	x0, x20, #0x580
ffffffffea807e50:	97fff706 	bl	ffffffffea805a68 <mutex_release>
	stdcallthread = thread_create("sm-stdcall", sm_stdcall_loop, NULL,
ffffffffea807e54:	b0000001 	adrp	x1, ffffffffea808000 <sm_get_api_version+0x88>
ffffffffea807e58:	f0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807e5c:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea807e60:	52800043 	mov	w3, #0x2                   	// #2
ffffffffea807e64:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea807e68:	910e4021 	add	x1, x1, #0x390
ffffffffea807e6c:	91206000 	add	x0, x0, #0x818
ffffffffea807e70:	97fff8ea 	bl	ffffffffea806218 <thread_create>
ffffffffea807e74:	f9078260 	str	x0, [x19, #3840]
	if (!stdcallthread) {
ffffffffea807e78:	b4000760 	cbz	x0, ffffffffea807f64 <sm_init+0x164>
	thread_set_real_time(stdcallthread);
ffffffffea807e7c:	97fff8ef 	bl	ffffffffea806238 <thread_set_real_time>
	thread_resume(stdcallthread);
ffffffffea807e80:	f9478260 	ldr	x0, [x19, #3840]
ffffffffea807e84:	97fff945 	bl	ffffffffea806398 <thread_resume>
}
ffffffffea807e88:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea807e8c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807e90:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea807e94:	d65f03c0 	ret
		dprintf(SPEW,"Profiler Carveout base paddr: %p \n",(void*)lk_boot_args[3]);
ffffffffea807e98:	f0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807e9c:	911ee000 	add	x0, x0, #0x7b8
ffffffffea807ea0:	94002700 	bl	ffffffffea811aa0 <_dprintf>
		ret = tegra_boot_profiler_init(lk_boot_args[3]);
ffffffffea807ea4:	f9400e60 	ldr	x0, [x19, #24]
ffffffffea807ea8:	97fffdfc 	bl	ffffffffea807698 <tegra_boot_profiler_init>
		if(ret) {
ffffffffea807eac:	34fffce0 	cbz	w0, ffffffffea807e48 <sm_init+0x48>
			TRACEF("Error mapping Profiler boot parameter block: %d\n", ret);
ffffffffea807eb0:	f0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807eb4:	2a0003e3 	mov	w3, w0
ffffffffea807eb8:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807ebc:	528035c2 	mov	w2, #0x1ae                 	// #430
ffffffffea807ec0:	9119a021 	add	x1, x1, #0x668
ffffffffea807ec4:	911f8080 	add	x0, x4, #0x7e0
ffffffffea807ec8:	94002cda 	bl	ffffffffea813230 <_printf>
ffffffffea807ecc:	17ffffdf 	b	ffffffffea807e48 <sm_init+0x48>
ffffffffea807ed0:	f90017b6 	str	x22, [x29, #40]
		size_t size   = ROUNDUP(lk_boot_args[2] + offset, PAGE_SIZE);
ffffffffea807ed4:	913ffc42 	add	x2, x2, #0xfff
		ulong offset = lk_boot_args[1] & (PAGE_SIZE - 1);
ffffffffea807ed8:	92402cb6 	and	x22, x5, #0xfff
		err = vmm_alloc_physical(vmm_get_kernel_aspace(), "sm",
ffffffffea807edc:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
		size_t size   = ROUNDUP(lk_boot_args[2] + offset, PAGE_SIZE);
ffffffffea807ee0:	8b160042 	add	x2, x2, x22
		err = vmm_alloc_physical(vmm_get_kernel_aspace(), "sm",
ffffffffea807ee4:	f00002a0 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
ffffffffea807ee8:	52800607 	mov	w7, #0x30                  	// #48
ffffffffea807eec:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea807ef0:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea807ef4:	9100e3a3 	add	x3, x29, #0x38
ffffffffea807ef8:	911de021 	add	x1, x1, #0x778
ffffffffea807efc:	91034000 	add	x0, x0, #0xd0
ffffffffea807f00:	9274cca5 	and	x5, x5, #0xfffffffffffff000
ffffffffea807f04:	9274cc42 	and	x2, x2, #0xfffffffffffff000
ffffffffea807f08:	94002524 	bl	ffffffffea811398 <vmm_alloc_physical>
		if (!err) {
ffffffffea807f0c:	35000160 	cbnz	w0, ffffffffea807f38 <sm_init+0x138>
			boot_args_refcnt++;
ffffffffea807f10:	d00002a2 	adrp	x2, ffffffffea85d000 <idle_threads+0xeb0>
			boot_args = (uint8_t *)vptr + offset;
ffffffffea807f14:	d00002a3 	adrp	x3, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea807f18:	f9401fa1 	ldr	x1, [x29, #56]
			boot_args_refcnt++;
ffffffffea807f1c:	b94cd040 	ldr	w0, [x2, #3280]
			boot_args = (uint8_t *)vptr + offset;
ffffffffea807f20:	8b160021 	add	x1, x1, x22
ffffffffea807f24:	f94017b6 	ldr	x22, [x29, #40]
			boot_args_refcnt++;
ffffffffea807f28:	11000400 	add	w0, w0, #0x1
			boot_args = (uint8_t *)vptr + offset;
ffffffffea807f2c:	f9066461 	str	x1, [x3, #3272]
			boot_args_refcnt++;
ffffffffea807f30:	b90cd040 	str	w0, [x2, #3280]
ffffffffea807f34:	17ffffc2 	b	ffffffffea807e3c <sm_init+0x3c>
			boot_args = NULL;
ffffffffea807f38:	d00002a2 	adrp	x2, ffffffffea85d000 <idle_threads+0xeb0>
			TRACEF("Error mapping initial boot parameter block: %d\n", err);
ffffffffea807f3c:	f0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807f40:	2a0003e3 	mov	w3, w0
ffffffffea807f44:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
			boot_args = NULL;
ffffffffea807f48:	f906645f 	str	xzr, [x2, #3272]
			TRACEF("Error mapping initial boot parameter block: %d\n", err);
ffffffffea807f4c:	9119a021 	add	x1, x1, #0x668
ffffffffea807f50:	52803422 	mov	w2, #0x1a1                 	// #417
ffffffffea807f54:	911e0080 	add	x0, x4, #0x780
ffffffffea807f58:	94002cb6 	bl	ffffffffea813230 <_printf>
ffffffffea807f5c:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea807f60:	17ffffb7 	b	ffffffffea807e3c <sm_init+0x3c>
		panic("failed to create sm-stdcall thread!\n");
ffffffffea807f64:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807f68:	aa1503e0 	mov	x0, x21
ffffffffea807f6c:	9120a021 	add	x1, x1, #0x828
ffffffffea807f70:	f90017b6 	str	x22, [x29, #40]
ffffffffea807f74:	94002749 	bl	ffffffffea811c98 <_panic>

ffffffffea807f78 <sm_get_api_version>:
{
ffffffffea807f78:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea807f7c:	910003fd 	mov	x29, sp
ffffffffea807f80:	a90153f3 	stp	x19, x20, [sp, #16]
	if (!sm_api_version_locked) {
ffffffffea807f84:	d00002b3 	adrp	x19, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea807f88:	d00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea807f8c:	397be260 	ldrb	w0, [x19, #3832]
ffffffffea807f90:	340000a0 	cbz	w0, ffffffffea807fa4 <sm_get_api_version+0x2c>
	return sm_api_version;
ffffffffea807f94:	b94eea80 	ldr	w0, [x20, #3816]
}
ffffffffea807f98:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807f9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea807fa0:	d65f03c0 	ret
ffffffffea807fa4:	a9025bb5 	stp	x21, x22, [x29, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea807fa8:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea807fac:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea807fb0:	37380060 	tbnz	w0, #7, ffffffffea807fbc <sm_get_api_version+0x44>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea807fb4:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea807fb8:	52800035 	mov	w21, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea807fbc:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea807fc0:	37300360 	tbnz	w0, #6, ffffffffea80802c <sm_get_api_version+0xb4>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea807fc4:	321f02b5 	orr	w21, w21, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea807fc8:	d50341df 	msr	daifset, #0x1
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea807fcc:	d00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
    arch_spin_lock(lock);
ffffffffea807fd0:	d00002b6 	adrp	x22, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea807fd4:	913bc2d6 	add	x22, x22, #0xef0
ffffffffea807fd8:	aa1603e0 	mov	x0, x22
ffffffffea807fdc:	97ffea2f 	bl	ffffffffea802898 <arch_spin_lock>
ffffffffea807fe0:	b94eea83 	ldr	w3, [x20, #3816]
		sm_api_version_locked = true;
ffffffffea807fe4:	52800024 	mov	w4, #0x1                   	// #1
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea807fe8:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807fec:	91194021 	add	x1, x1, #0x650
ffffffffea807ff0:	52800e42 	mov	w2, #0x72                  	// #114
		sm_api_version_locked = true;
ffffffffea807ff4:	393be264 	strb	w4, [x19, #3832]
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea807ff8:	f0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea807ffc:	911bc000 	add	x0, x0, #0x6f0
ffffffffea808000:	94002c8c 	bl	ffffffffea813230 <_printf>
    arch_spin_unlock(lock);
ffffffffea808004:	aa1603e0 	mov	x0, x22
ffffffffea808008:	97ffea2c 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea80800c:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea808010:	36000315 	tbz	w21, #0, ffffffffea808070 <sm_get_api_version+0xf8>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea808014:	d50342ff 	msr	daifclr, #0x2
	return sm_api_version;
ffffffffea808018:	b94eea80 	ldr	w0, [x20, #3816]
ffffffffea80801c:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea808020:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808024:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808028:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea80802c:	b00002b6 	adrp	x22, ffffffffea85d000 <idle_threads+0xeb0>
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea808030:	b00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea808034:	913bc2d6 	add	x22, x22, #0xef0
ffffffffea808038:	aa1603e0 	mov	x0, x22
ffffffffea80803c:	97ffea17 	bl	ffffffffea802898 <arch_spin_lock>
ffffffffea808040:	b94eea83 	ldr	w3, [x20, #3816]
		sm_api_version_locked = true;
ffffffffea808044:	52800024 	mov	w4, #0x1                   	// #1
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea808048:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80804c:	91194021 	add	x1, x1, #0x650
ffffffffea808050:	52800e42 	mov	w2, #0x72                  	// #114
ffffffffea808054:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
		sm_api_version_locked = true;
ffffffffea808058:	393be264 	strb	w4, [x19, #3832]
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea80805c:	911bc000 	add	x0, x0, #0x6f0
ffffffffea808060:	94002c74 	bl	ffffffffea813230 <_printf>
    arch_spin_unlock(lock);
ffffffffea808064:	aa1603e0 	mov	x0, x22
ffffffffea808068:	97ffea14 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea80806c:	3707fd55 	tbnz	w21, #0, ffffffffea808014 <sm_get_api_version+0x9c>
	return sm_api_version;
ffffffffea808070:	b94eea80 	ldr	w0, [x20, #3816]
ffffffffea808074:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea808078:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80807c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808080:	d65f03c0 	ret
ffffffffea808084:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808088 <sm_return_and_wait_for_next_stdcall.isra.1>:
static void sm_return_and_wait_for_next_stdcall(long ret, int cpu)
ffffffffea808088:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80808c:	910003fd 	mov	x29, sp
ffffffffea808090:	a90153f3 	stp	x19, x20, [sp, #16]
		if (args.smc_nr == SMC_SC_NOP) {
ffffffffea808094:	52800073 	mov	w19, #0x3                   	// #3
static void sm_return_and_wait_for_next_stdcall(long ret, int cpu)
ffffffffea808098:	a9025bf5 	stp	x21, x22, [sp, #32]
		if (args.smc_nr == SMC_SC_NOP) {
ffffffffea80809c:	72a78013 	movk	w19, #0x3c00, lsl #16
    arch_spin_lock(lock);
ffffffffea8080a0:	b0000095 	adrp	x21, ffffffffea819000 <_mem_phys_base>
		dprintf(CRITICAL, "%s: cpu %d, std call busy\n", __func__, cpu);
ffffffffea8080a4:	d0000076 	adrp	x22, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8080a8:	9116e2b4 	add	x20, x21, #0x5b8
ffffffffea8080ac:	911b02d6 	add	x22, x22, #0x6c0
	smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);
ffffffffea8080b0:	a9047fbf 	stp	xzr, xzr, [x29, #64]
ffffffffea8080b4:	a9057fbf 	stp	xzr, xzr, [x29, #80]
static void sm_return_and_wait_for_next_stdcall(long ret, int cpu)
ffffffffea8080b8:	f9001bf7 	str	x23, [sp, #48]
ffffffffea8080bc:	14000006 	b	ffffffffea8080d4 <sm_return_and_wait_for_next_stdcall.isra.1+0x4c>
			ret = sm_nopcall_table[SMC_ENTITY(args.params[0])](&args);
ffffffffea8080c0:	39411fa2 	ldrb	w2, [x29, #71]
ffffffffea8080c4:	92401442 	and	x2, x2, #0x3f
ffffffffea8080c8:	f8627821 	ldr	x1, [x1, x2, lsl #3]
ffffffffea8080cc:	d63f0020 	blr	x1
	} while (ret);
ffffffffea8080d0:	b40003e0 	cbz	x0, ffffffffea80814c <sm_return_and_wait_for_next_stdcall.isra.1+0xc4>
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8080d4:	d50341df 	msr	daifset, #0x1
		sm_sched_nonsecure(ret, &args);
ffffffffea8080d8:	910103a1 	add	x1, x29, #0x40
ffffffffea8080dc:	97fffe99 	bl	ffffffffea807b40 <sm_sched_nonsecure>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea8080e0:	d50341ff 	msr	daifclr, #0x1
		if (args.smc_nr == SMC_SC_NOP) {
ffffffffea8080e4:	b94043a2 	ldr	w2, [x29, #64]
			ret = sm_nopcall_table[SMC_ENTITY(args.params[0])](&args);
ffffffffea8080e8:	b0000081 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea8080ec:	910103a0 	add	x0, x29, #0x40
ffffffffea8080f0:	91228021 	add	x1, x1, #0x8a0
		if (args.smc_nr == SMC_SC_NOP) {
ffffffffea8080f4:	6b13005f 	cmp	w2, w19
ffffffffea8080f8:	54fffe40 	b.eq	ffffffffea8080c0 <sm_return_and_wait_for_next_stdcall.isra.1+0x38>  // b.none
	uint cpu = arch_curr_cpu_num();
ffffffffea8080fc:	97ffea6b 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea808100:	2a0003f7 	mov	w23, w0
ffffffffea808104:	aa1403e0 	mov	x0, x20
ffffffffea808108:	97ffe9e4 	bl	ffffffffea802898 <arch_spin_lock>
	if (stdcallstate.event.signalled || stdcallstate.done) {
ffffffffea80810c:	39403280 	ldrb	w0, [x20, #12]
ffffffffea808110:	34000280 	cbz	w0, ffffffffea808160 <sm_return_and_wait_for_next_stdcall.isra.1+0xd8>
ffffffffea808114:	b94043a0 	ldr	w0, [x29, #64]
		if (args->smc_nr == SMC_SC_RESTART_LAST && stdcallstate.active_cpu == -1) {
ffffffffea808118:	52a78001 	mov	w1, #0x3c000000            	// #1006632960
ffffffffea80811c:	6b01001f 	cmp	w0, w1
ffffffffea808120:	54000441 	b.ne	ffffffffea8081a8 <sm_return_and_wait_for_next_stdcall.isra.1+0x120>  // b.any
ffffffffea808124:	b9406680 	ldr	w0, [x20, #100]
ffffffffea808128:	3100041f 	cmn	w0, #0x1
ffffffffea80812c:	540003e1 	b.ne	ffffffffea8081a8 <sm_return_and_wait_for_next_stdcall.isra.1+0x120>  // b.any
			stdcallstate.restart_count++;
ffffffffea808130:	b9407280 	ldr	w0, [x20, #112]
ffffffffea808134:	11000400 	add	w0, w0, #0x1
ffffffffea808138:	b9007280 	str	w0, [x20, #112]
	stdcallstate.active_cpu = cpu;
ffffffffea80813c:	9116e2b5 	add	x21, x21, #0x5b8
    arch_spin_unlock(lock);
ffffffffea808140:	aa1503e0 	mov	x0, x21
ffffffffea808144:	b90066b7 	str	w23, [x21, #100]
ffffffffea808148:	97ffe9dc 	bl	ffffffffea8028b8 <arch_spin_unlock>
}
ffffffffea80814c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808150:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea808154:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea808158:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80815c:	d65f03c0 	ret
	if (stdcallstate.event.signalled || stdcallstate.done) {
ffffffffea808160:	39418281 	ldrb	w1, [x20, #96]
		if (args->smc_nr == SMC_SC_RESTART_LAST) {
ffffffffea808164:	52a78002 	mov	w2, #0x3c000000            	// #1006632960
ffffffffea808168:	b94043a0 	ldr	w0, [x29, #64]
ffffffffea80816c:	6b02001f 	cmp	w0, w2
	if (stdcallstate.event.signalled || stdcallstate.done) {
ffffffffea808170:	35fffd41 	cbnz	w1, ffffffffea808118 <sm_return_and_wait_for_next_stdcall.isra.1+0x90>
		if (args->smc_nr == SMC_SC_RESTART_LAST) {
ffffffffea808174:	540002c0 	b.eq	ffffffffea8081cc <sm_return_and_wait_for_next_stdcall.isra.1+0x144>  // b.none
	stdcallstate.args = *args;
ffffffffea808178:	a94417a4 	ldp	x4, x5, [x29, #64]
	stdcallstate.ret = SM_ERR_INTERNAL_FAILURE;
ffffffffea80817c:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
	stdcallstate.args = *args;
ffffffffea808180:	a9450fa2 	ldp	x2, x3, [x29, #80]
ffffffffea808184:	a9039684 	stp	x4, x5, [x20, #56]
ffffffffea808188:	a9048e82 	stp	x2, x3, [x20, #72]
	event_signal(&stdcallstate.event, false);
ffffffffea80818c:	52800001 	mov	w1, #0x0                   	// #0
	stdcallstate.ret = SM_ERR_INTERNAL_FAILURE;
ffffffffea808190:	f9002e80 	str	x0, [x20, #88]
	event_signal(&stdcallstate.event, false);
ffffffffea808194:	91002280 	add	x0, x20, #0x8
	stdcallstate.initial_cpu = cpu;
ffffffffea808198:	b9006a97 	str	w23, [x20, #104]
	stdcallstate.restart_count = 0;
ffffffffea80819c:	b900729f 	str	wzr, [x20, #112]
	event_signal(&stdcallstate.event, false);
ffffffffea8081a0:	97fff5a6 	bl	ffffffffea805838 <event_signal>
ffffffffea8081a4:	17ffffe6 	b	ffffffffea80813c <sm_return_and_wait_for_next_stdcall.isra.1+0xb4>
		dprintf(CRITICAL, "%s: cpu %d, std call busy\n", __func__, cpu);
ffffffffea8081a8:	2a1703e2 	mov	w2, w23
ffffffffea8081ac:	aa1603e1 	mov	x1, x22
ffffffffea8081b0:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8081b4:	9123a000 	add	x0, x0, #0x8e8
ffffffffea8081b8:	9400263a 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea8081bc:	aa1403e0 	mov	x0, x20
ffffffffea8081c0:	97ffe9be 	bl	ffffffffea8028b8 <arch_spin_unlock>
		ret = SM_ERR_BUSY;
ffffffffea8081c4:	92800080 	mov	x0, #0xfffffffffffffffb    	// #-5
ffffffffea8081c8:	17ffffc3 	b	ffffffffea8080d4 <sm_return_and_wait_for_next_stdcall.isra.1+0x4c>
			dprintf(CRITICAL, "%s: cpu %d, unexpected restart, no std call active\n",
ffffffffea8081cc:	97ffea37 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea8081d0:	2a0003e2 	mov	w2, w0
ffffffffea8081d4:	aa1603e1 	mov	x1, x22
ffffffffea8081d8:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8081dc:	91242000 	add	x0, x0, #0x908
ffffffffea8081e0:	94002630 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea8081e4:	aa1403e0 	mov	x0, x20
ffffffffea8081e8:	97ffe9b4 	bl	ffffffffea8028b8 <arch_spin_unlock>
			ret = SM_ERR_UNEXPECTED_RESTART;
ffffffffea8081ec:	92800060 	mov	x0, #0xfffffffffffffffc    	// #-4
ffffffffea8081f0:	17ffffb9 	b	ffffffffea8080d4 <sm_return_and_wait_for_next_stdcall.isra.1+0x4c>
ffffffffea8081f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8081f8 <sm_wait_for_smcall>:
{
ffffffffea8081f8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea8081fc:	910003fd 	mov	x29, sp
ffffffffea808200:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea808204:	b0000093 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea808208:	a9025bf5 	stp	x21, x22, [sp, #32]
		if (cpu == stdcallstate.active_cpu) {
ffffffffea80820c:	9116e273 	add	x19, x19, #0x5b8
{
ffffffffea808210:	a90363f7 	stp	x23, x24, [sp, #48]
	stdcallstate.active_cpu = -1;
ffffffffea808214:	12800015 	mov	w21, #0xffffffff            	// #-1
ffffffffea808218:	d0000078 	adrp	x24, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80821c:	d0000077 	adrp	x23, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
			ret = SM_ERR_INTERRUPTED;
ffffffffea808220:	92800096 	mov	x22, #0xfffffffffffffffb    	// #-5
ffffffffea808224:	14000004 	b	ffffffffea808234 <sm_wait_for_smcall+0x3c>
		sm_return_and_wait_for_next_stdcall(ret, cpu);
ffffffffea808228:	aa1403e0 	mov	x0, x20
ffffffffea80822c:	97ffff97 	bl	ffffffffea808088 <sm_return_and_wait_for_next_stdcall.isra.1>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea808230:	d50342ff 	msr	daifclr, #0x2
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea808234:	d50342df 	msr	daifset, #0x2
		thread_yield();
ffffffffea808238:	97fff82e 	bl	ffffffffea8062f0 <thread_yield>
			ret = SM_ERR_NOP_DONE;
ffffffffea80823c:	928001d4 	mov	x20, #0xfffffffffffffff1    	// #-15
		cpu = arch_curr_cpu_num();
ffffffffea808240:	97ffea1a 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
		if (cpu == stdcallstate.active_cpu) {
ffffffffea808244:	b9406661 	ldr	w1, [x19, #100]
ffffffffea808248:	6b00003f 	cmp	w1, w0
ffffffffea80824c:	54fffee1 	b.ne	ffffffffea808228 <sm_wait_for_smcall+0x30>  // b.any
	uint cpu = arch_curr_cpu_num();
ffffffffea808250:	97ffea16 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea808254:	2a0003f4 	mov	w20, w0
    arch_spin_lock(lock);
ffffffffea808258:	aa1303e0 	mov	x0, x19
ffffffffea80825c:	97ffe98f 	bl	ffffffffea802898 <arch_spin_lock>
	if (stdcallstate.active_cpu != (int)cpu) {
ffffffffea808260:	b9406662 	ldr	w2, [x19, #100]
ffffffffea808264:	6b14005f 	cmp	w2, w20
ffffffffea808268:	54000241 	b.ne	ffffffffea8082b0 <sm_wait_for_smcall+0xb8>  // b.any
	if (stdcallstate.done) {
ffffffffea80826c:	39418260 	ldrb	w0, [x19, #96]
	stdcallstate.active_cpu = -1;
ffffffffea808270:	b9006675 	str	w21, [x19, #100]
	stdcallstate.last_cpu = stdcallstate.active_cpu;
ffffffffea808274:	b9006e62 	str	w2, [x19, #108]
	if (stdcallstate.done) {
ffffffffea808278:	340000c0 	cbz	w0, ffffffffea808290 <sm_wait_for_smcall+0x98>
		ret = stdcallstate.ret;
ffffffffea80827c:	f9402e74 	ldr	x20, [x19, #88]
		stdcallstate.done = false;
ffffffffea808280:	3901827f 	strb	wzr, [x19, #96]
    arch_spin_unlock(lock);
ffffffffea808284:	aa1303e0 	mov	x0, x19
ffffffffea808288:	97ffe98c 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea80828c:	17ffffe7 	b	ffffffffea808228 <sm_wait_for_smcall+0x30>
		if (sm_get_api_version() >= TRUSTY_API_VERSION_SMP) {/* ns using new api */
ffffffffea808290:	97ffff3a 	bl	ffffffffea807f78 <sm_get_api_version>
ffffffffea808294:	7100041f 	cmp	w0, #0x1
ffffffffea808298:	540001a8 	b.hi	ffffffffea8082cc <sm_wait_for_smcall+0xd4>  // b.pmore
		} else if (stdcallstate.restart_count) {
ffffffffea80829c:	b9407260 	ldr	w0, [x19, #112]
			ret = SM_ERR_INTERRUPTED;
ffffffffea8082a0:	92800054 	mov	x20, #0xfffffffffffffffd    	// #-3
ffffffffea8082a4:	7100001f 	cmp	w0, #0x0
ffffffffea8082a8:	9a9412d4 	csel	x20, x22, x20, ne  // ne = any
ffffffffea8082ac:	17fffff6 	b	ffffffffea808284 <sm_wait_for_smcall+0x8c>
		dprintf(CRITICAL, "%s: stdcallcpu, a%d != curr-cpu %d, l%d, i%d\n",
ffffffffea8082b0:	294d1265 	ldp	w5, w4, [x19, #104]
ffffffffea8082b4:	2a1403e3 	mov	w3, w20
ffffffffea8082b8:	911b6301 	add	x1, x24, #0x6d8
ffffffffea8082bc:	912782e0 	add	x0, x23, #0x9e0
		ret = SM_ERR_INTERNAL_FAILURE;
ffffffffea8082c0:	928000d4 	mov	x20, #0xfffffffffffffff9    	// #-7
		dprintf(CRITICAL, "%s: stdcallcpu, a%d != curr-cpu %d, l%d, i%d\n",
ffffffffea8082c4:	940025f7 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea8082c8:	17ffffef 	b	ffffffffea808284 <sm_wait_for_smcall+0x8c>
			ret = SM_ERR_CPU_IDLE;
ffffffffea8082cc:	92800194 	mov	x20, #0xfffffffffffffff3    	// #-13
ffffffffea8082d0:	17ffffed 	b	ffffffffea808284 <sm_wait_for_smcall+0x8c>
ffffffffea8082d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8082d8 <sm_irq_return_ns>:
{
ffffffffea8082d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8082dc:	910003fd 	mov	x29, sp
ffffffffea8082e0:	a90153f3 	stp	x19, x20, [sp, #16]
    arch_spin_lock(lock);
ffffffffea8082e4:	b0000094 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea8082e8:	9116e293 	add	x19, x20, #0x5b8
ffffffffea8082ec:	a9025bf5 	stp	x21, x22, [sp, #32]
	cpu = arch_curr_cpu_num();
ffffffffea8082f0:	97ffe9ee 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
ffffffffea8082f4:	2a0003f6 	mov	w22, w0
ffffffffea8082f8:	aa1303e0 	mov	x0, x19
ffffffffea8082fc:	97ffe967 	bl	ffffffffea802898 <arch_spin_lock>
	if (stdcallstate.active_cpu == cpu) {
ffffffffea808300:	b9406660 	ldr	w0, [x19, #100]
ffffffffea808304:	928001b5 	mov	x21, #0xfffffffffffffff2    	// #-14
ffffffffea808308:	6b16001f 	cmp	w0, w22
ffffffffea80830c:	540000a1 	b.ne	ffffffffea808320 <sm_irq_return_ns+0x48>  // b.any
		stdcallstate.active_cpu = -1;
ffffffffea808310:	12800001 	mov	w1, #0xffffffff            	// #-1
		ret = SM_ERR_INTERRUPTED;
ffffffffea808314:	92800055 	mov	x21, #0xfffffffffffffffd    	// #-3
		stdcallstate.active_cpu = -1;
ffffffffea808318:	b9006661 	str	w1, [x19, #100]
		stdcallstate.last_cpu = stdcallstate.active_cpu;
ffffffffea80831c:	b9006e60 	str	w0, [x19, #108]
    arch_spin_unlock(lock);
ffffffffea808320:	9116e280 	add	x0, x20, #0x5b8
ffffffffea808324:	97ffe965 	bl	ffffffffea8028b8 <arch_spin_unlock>
	sm_return_and_wait_for_next_stdcall(ret, cpu);
ffffffffea808328:	aa1503e0 	mov	x0, x21
}
ffffffffea80832c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808330:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea808334:	a8c37bfd 	ldp	x29, x30, [sp], #48
	sm_return_and_wait_for_next_stdcall(ret, cpu);
ffffffffea808338:	17ffff54 	b	ffffffffea808088 <sm_return_and_wait_for_next_stdcall.isra.1>
ffffffffea80833c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808340 <sm_irq_loop>:
{
ffffffffea808340:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808344:	910003fd 	mov	x29, sp
ffffffffea808348:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80834c:	aa0003f3 	mov	x19, x0
ffffffffea808350:	d50342df 	msr	daifset, #0x2
	irq_thread_ready[eventcpu] = true;
ffffffffea808354:	b00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea808358:	91336000 	add	x0, x0, #0xcd8
ffffffffea80835c:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808360:	3833c801 	strb	w1, [x0, w19, sxtw]
	cpu = arch_curr_cpu_num();
ffffffffea808364:	97ffe9d1 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
		event_wait(&nsirqevent[eventcpu]);
ffffffffea808368:	b00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80836c:	9134a000 	add	x0, x0, #0xd28
ffffffffea808370:	52800601 	mov	w1, #0x30                  	// #48
ffffffffea808374:	9b210273 	smaddl	x19, w19, w1, x0
static inline bool event_initialized(event_t *e) {
	return e->magic == EVENT_MAGIC;
}

static inline status_t event_wait(event_t *e) {
	return event_wait_timeout(e, INFINITE_TIME);
ffffffffea808378:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80837c:	aa1303e0 	mov	x0, x19
ffffffffea808380:	97fff50a 	bl	ffffffffea8057a8 <event_wait_timeout>
		sm_irq_return_ns();
ffffffffea808384:	97ffffd5 	bl	ffffffffea8082d8 <sm_irq_return_ns>
ffffffffea808388:	17fffffc 	b	ffffffffea808378 <sm_irq_loop+0x38>
ffffffffea80838c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808390 <sm_stdcall_loop>:
{
ffffffffea808390:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea808394:	910003fd 	mov	x29, sp
ffffffffea808398:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80839c:	b0000093 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea8083a0:	9116e273 	add	x19, x19, #0x5b8
ffffffffea8083a4:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8083a8:	91002274 	add	x20, x19, #0x8
		ret = sm_stdcall_table[SMC_ENTITY(stdcallstate.args.smc_nr)](&stdcallstate.args);
ffffffffea8083ac:	9100e276 	add	x22, x19, #0x38
{
ffffffffea8083b0:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea8083b4:	b0000098 	adrp	x24, ffffffffea819000 <_mem_phys_base>
		stdcallstate.done = true;
ffffffffea8083b8:	52800037 	mov	w23, #0x1                   	// #1
{
ffffffffea8083bc:	f90023f9 	str	x25, [sp, #64]
		ret = sm_stdcall_table[SMC_ENTITY(stdcallstate.args.smc_nr)](&stdcallstate.args);
ffffffffea8083c0:	912aa315 	add	x21, x24, #0xaa8
ffffffffea8083c4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8083c8:	aa1403e0 	mov	x0, x20
ffffffffea8083cc:	97fff4f7 	bl	ffffffffea8057a8 <event_wait_timeout>
ffffffffea8083d0:	3940ee61 	ldrb	w1, [x19, #59]
ffffffffea8083d4:	aa1603e0 	mov	x0, x22
ffffffffea8083d8:	92401421 	and	x1, x1, #0x3f
ffffffffea8083dc:	f8617aa1 	ldr	x1, [x21, x1, lsl #3]
ffffffffea8083e0:	d63f0020 	blr	x1
ffffffffea8083e4:	aa0003f9 	mov	x25, x0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8083e8:	d53b4221 	mrs	x1, daif
    arch_spin_lock(lock);
ffffffffea8083ec:	aa1303e0 	mov	x0, x19
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8083f0:	37380161 	tbnz	w1, #7, ffffffffea80841c <sm_stdcall_loop+0x8c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8083f4:	d50342df 	msr	daifset, #0x2
ffffffffea8083f8:	97ffe928 	bl	ffffffffea802898 <arch_spin_lock>
		stdcallstate.ret = ret;
ffffffffea8083fc:	f9002e79 	str	x25, [x19, #88]
		event_unsignal(&stdcallstate.event);
ffffffffea808400:	aa1403e0 	mov	x0, x20
		stdcallstate.done = true;
ffffffffea808404:	39018277 	strb	w23, [x19, #96]
		event_unsignal(&stdcallstate.event);
ffffffffea808408:	97fff54c 	bl	ffffffffea805938 <event_unsignal>
    arch_spin_unlock(lock);
ffffffffea80840c:	aa1303e0 	mov	x0, x19
ffffffffea808410:	97ffe92a 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea808414:	d50342ff 	msr	daifclr, #0x2
ffffffffea808418:	17ffffea 	b	ffffffffea8083c0 <sm_stdcall_loop+0x30>
    arch_spin_lock(lock);
ffffffffea80841c:	97ffe91f 	bl	ffffffffea802898 <arch_spin_lock>
		stdcallstate.ret = ret;
ffffffffea808420:	f9002e79 	str	x25, [x19, #88]
		stdcallstate.done = true;
ffffffffea808424:	39018277 	strb	w23, [x19, #96]
		event_unsignal(&stdcallstate.event);
ffffffffea808428:	aa1403e0 	mov	x0, x20
ffffffffea80842c:	97fff543 	bl	ffffffffea805938 <event_unsignal>
    arch_spin_unlock(lock);
ffffffffea808430:	aa1303e0 	mov	x0, x19
ffffffffea808434:	97ffe921 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea808438:	17ffffe3 	b	ffffffffea8083c4 <sm_stdcall_loop+0x34>
ffffffffea80843c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808440 <smc_sm_api_version>:
{
ffffffffea808440:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea808444:	910003fd 	mov	x29, sp
ffffffffea808448:	a90153f3 	stp	x19, x20, [sp, #16]
    arch_spin_lock(lock);
ffffffffea80844c:	b00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
	uint32_t api_version = args->params[0];
ffffffffea808450:	b9400413 	ldr	w19, [x0, #4]
ffffffffea808454:	913bc280 	add	x0, x20, #0xef0
ffffffffea808458:	97ffe910 	bl	ffffffffea802898 <arch_spin_lock>
	if (!sm_api_version_locked) {
ffffffffea80845c:	b00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea808460:	397be000 	ldrb	w0, [x0, #3832]
ffffffffea808464:	35000180 	cbnz	w0, ffffffffea808494 <smc_sm_api_version+0x54>
ffffffffea808468:	71000e7f 	cmp	w19, #0x3
ffffffffea80846c:	52800063 	mov	w3, #0x3                   	// #3
		sm_api_version = api_version;
ffffffffea808470:	b00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea808474:	1a839273 	csel	w19, w19, w3, ls  // ls = plast
ffffffffea808478:	b90ee813 	str	w19, [x0, #3816]
    arch_spin_unlock(lock);
ffffffffea80847c:	913bc280 	add	x0, x20, #0xef0
ffffffffea808480:	97ffe90e 	bl	ffffffffea8028b8 <arch_spin_unlock>
}
ffffffffea808484:	2a1303e0 	mov	w0, w19
ffffffffea808488:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80848c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808490:	d65f03c0 	ret
ffffffffea808494:	f90013b5 	str	x21, [x29, #32]
		TRACEF("ERROR: Tried to select api version %d after use, current version %d\n",
ffffffffea808498:	b00002b5 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80849c:	2a1303e3 	mov	w3, w19
ffffffffea8084a0:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8084a4:	b94eeaa4 	ldr	w4, [x21, #3816]
ffffffffea8084a8:	9118e021 	add	x1, x1, #0x638
ffffffffea8084ac:	52800ba2 	mov	w2, #0x5d                  	// #93
ffffffffea8084b0:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8084b4:	91284000 	add	x0, x0, #0xa10
ffffffffea8084b8:	94002b5e 	bl	ffffffffea813230 <_printf>
		api_version = sm_api_version;
ffffffffea8084bc:	b94eeab3 	ldr	w19, [x21, #3816]
ffffffffea8084c0:	913bc280 	add	x0, x20, #0xef0
ffffffffea8084c4:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea8084c8:	97ffe8fc 	bl	ffffffffea8028b8 <arch_spin_unlock>
}
ffffffffea8084cc:	2a1303e0 	mov	w0, w19
ffffffffea8084d0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8084d4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8084d8:	d65f03c0 	ret
ffffffffea8084dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8084e0 <sm_handle_irq>:
{
ffffffffea8084e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea8084e4:	910003fd 	mov	x29, sp
	int cpu = arch_curr_cpu_num();
ffffffffea8084e8:	97ffe970 	bl	ffffffffea802aa8 <arch_curr_cpu_num>
	if (irq_thread_ready[cpu]) {
ffffffffea8084ec:	b00002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8084f0:	91336021 	add	x1, x1, #0xcd8
ffffffffea8084f4:	3860c821 	ldrb	w1, [x1, w0, sxtw]
ffffffffea8084f8:	35000161 	cbnz	w1, ffffffffea808524 <sm_handle_irq+0x44>
		TRACEF("warning: got ns irq before irq thread is ready\n");
ffffffffea8084fc:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea808500:	9119c021 	add	x1, x1, #0x670
ffffffffea808504:	528038a2 	mov	w2, #0x1c5                 	// #453
ffffffffea808508:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80850c:	911d0000 	add	x0, x0, #0x740
ffffffffea808510:	94002b48 	bl	ffffffffea813230 <_printf>
		sm_irq_return_ns();
ffffffffea808514:	97ffff71 	bl	ffffffffea8082d8 <sm_irq_return_ns>
}
ffffffffea808518:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80851c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea808520:	d65f03c0 	ret
		event_signal(&nsirqevent[cpu], false);
ffffffffea808524:	b00002a2 	adrp	x2, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea808528:	9134a042 	add	x2, x2, #0xd28
ffffffffea80852c:	52800603 	mov	w3, #0x30                  	// #48
ffffffffea808530:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea808534:	9b230800 	smaddl	x0, w0, w3, x2
ffffffffea808538:	97fff4c0 	bl	ffffffffea805838 <event_signal>
}
ffffffffea80853c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea808540:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea808544:	d65f03c0 	ret

ffffffffea808548 <sm_handle_fiq>:
{
ffffffffea808548:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80854c:	910003fd 	mov	x29, sp
ffffffffea808550:	a90153f3 	stp	x19, x20, [sp, #16]
	smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);
ffffffffea808554:	a9027fbf 	stp	xzr, xzr, [x29, #32]
ffffffffea808558:	a9037fbf 	stp	xzr, xzr, [x29, #48]
	if (sm_get_api_version() >= TRUSTY_API_VERSION_RESTART_FIQ) {
ffffffffea80855c:	97fffe87 	bl	ffffffffea807f78 <sm_get_api_version>
ffffffffea808560:	340003a0 	cbz	w0, ffffffffea8085d4 <sm_handle_fiq+0x8c>
		sm_sched_nonsecure(SM_ERR_FIQ_INTERRUPTED, &args);
ffffffffea808564:	910083b4 	add	x20, x29, #0x20
		expected_return = SMC_SC_RESTART_FIQ;
ffffffffea808568:	52800053 	mov	w19, #0x2                   	// #2
		sm_sched_nonsecure(SM_ERR_FIQ_INTERRUPTED, &args);
ffffffffea80856c:	92800160 	mov	x0, #0xfffffffffffffff4    	// #-12
ffffffffea808570:	aa1403e1 	mov	x1, x20
		expected_return = SMC_SC_RESTART_FIQ;
ffffffffea808574:	72a78013 	movk	w19, #0x3c00, lsl #16
		sm_sched_nonsecure(SM_ERR_FIQ_INTERRUPTED, &args);
ffffffffea808578:	97fffd72 	bl	ffffffffea807b40 <sm_sched_nonsecure>
	if (args.smc_nr != expected_return) {
ffffffffea80857c:	b94023a3 	ldr	w3, [x29, #32]
ffffffffea808580:	6b13007f 	cmp	w3, w19
ffffffffea808584:	54000220 	b.eq	ffffffffea8085c8 <sm_handle_fiq+0x80>  // b.none
		TRACEF("got bad restart smc %x, expected %x\n",
ffffffffea808588:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80858c:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea808590:	2a1303e4 	mov	w4, w19
ffffffffea808594:	52803b22 	mov	w2, #0x1d9                 	// #473
ffffffffea808598:	911a0021 	add	x1, x1, #0x680
ffffffffea80859c:	911c4000 	add	x0, x0, #0x710
ffffffffea8085a0:	94002b24 	bl	ffffffffea813230 <_printf>
		while (args.smc_nr != expected_return)
ffffffffea8085a4:	b94023a0 	ldr	w0, [x29, #32]
ffffffffea8085a8:	6b00027f 	cmp	w19, w0
ffffffffea8085ac:	540000e0 	b.eq	ffffffffea8085c8 <sm_handle_fiq+0x80>  // b.none
			sm_sched_nonsecure(SM_ERR_INTERLEAVED_SMC, &args);
ffffffffea8085b0:	928000a0 	mov	x0, #0xfffffffffffffffa    	// #-6
ffffffffea8085b4:	aa1403e1 	mov	x1, x20
ffffffffea8085b8:	97fffd62 	bl	ffffffffea807b40 <sm_sched_nonsecure>
		while (args.smc_nr != expected_return)
ffffffffea8085bc:	b94023a0 	ldr	w0, [x29, #32]
ffffffffea8085c0:	6b13001f 	cmp	w0, w19
ffffffffea8085c4:	54ffff61 	b.ne	ffffffffea8085b0 <sm_handle_fiq+0x68>  // b.any
}
ffffffffea8085c8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8085cc:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8085d0:	d65f03c0 	ret
		sm_sched_nonsecure(SM_ERR_INTERRUPTED, &args);
ffffffffea8085d4:	910083b4 	add	x20, x29, #0x20
		expected_return = SMC_SC_RESTART_LAST;
ffffffffea8085d8:	52a78013 	mov	w19, #0x3c000000            	// #1006632960
		sm_sched_nonsecure(SM_ERR_INTERRUPTED, &args);
ffffffffea8085dc:	aa1403e1 	mov	x1, x20
ffffffffea8085e0:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
ffffffffea8085e4:	97fffd57 	bl	ffffffffea807b40 <sm_sched_nonsecure>
ffffffffea8085e8:	17ffffe5 	b	ffffffffea80857c <sm_handle_fiq+0x34>
ffffffffea8085ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8085f0 <sm_get_boot_args>:
{
ffffffffea8085f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if (!boot_argsp || !args_sizep) {
ffffffffea8085f4:	f100001f 	cmp	x0, #0x0
ffffffffea8085f8:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
{
ffffffffea8085fc:	910003fd 	mov	x29, sp
ffffffffea808600:	f90017f6 	str	x22, [sp, #40]
	if (!boot_argsp || !args_sizep) {
ffffffffea808604:	540003c0 	b.eq	ffffffffea80867c <sm_get_boot_args+0x8c>  // b.none
ffffffffea808608:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80860c:	aa0103f4 	mov	x20, x1
ffffffffea808610:	f90013b5 	str	x21, [x29, #32]
ffffffffea808614:	aa0003f3 	mov	x19, x0
ffffffffea808618:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80861c:	b0000095 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea808620:	911602a0 	add	x0, x21, #0x580
ffffffffea808624:	97fff4e5 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	if (!boot_args) {
ffffffffea808628:	b00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
		err = ERR_NOT_CONFIGURED;
ffffffffea80862c:	128004b6 	mov	w22, #0xffffffda            	// #-38
	if (!boot_args) {
ffffffffea808630:	f9466400 	ldr	x0, [x0, #3272]
ffffffffea808634:	b4000140 	cbz	x0, ffffffffea80865c <sm_get_boot_args+0x6c>
	boot_args_refcnt++;
ffffffffea808638:	b00002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
	*args_sizep = lk_boot_args[2];
ffffffffea80863c:	d00002a2 	adrp	x2, ffffffffea85e000 <rb_data+0x18>
	status_t err = NO_ERROR;
ffffffffea808640:	52800016 	mov	w22, #0x0                   	// #0
	*args_sizep = lk_boot_args[2];
ffffffffea808644:	f9402842 	ldr	x2, [x2, #80]
	*boot_argsp = boot_args;
ffffffffea808648:	f9000260 	str	x0, [x19]
	boot_args_refcnt++;
ffffffffea80864c:	b94cd020 	ldr	w0, [x1, #3280]
	*args_sizep = lk_boot_args[2];
ffffffffea808650:	f9000282 	str	x2, [x20]
	boot_args_refcnt++;
ffffffffea808654:	11000400 	add	w0, w0, #0x1
ffffffffea808658:	b90cd020 	str	w0, [x1, #3280]
	mutex_release(&boot_args_lock);
ffffffffea80865c:	911602a0 	add	x0, x21, #0x580
ffffffffea808660:	97fff502 	bl	ffffffffea805a68 <mutex_release>
	return err;
ffffffffea808664:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea808668:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80866c:	2a1603e0 	mov	w0, w22
ffffffffea808670:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea808674:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808678:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80867c:	128000f6 	mov	w22, #0xfffffff8            	// #-8
ffffffffea808680:	17fffffb 	b	ffffffffea80866c <sm_get_boot_args+0x7c>
ffffffffea808684:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808688 <sm_put_boot_args>:

void sm_put_boot_args(void)
{
ffffffffea808688:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80868c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808690:	910003fd 	mov	x29, sp
ffffffffea808694:	a90153f3 	stp	x19, x20, [sp, #16]
	mutex_acquire(&boot_args_lock);

	if (!boot_args) {
ffffffffea808698:	b00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80869c:	b0000093 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea8086a0:	91160260 	add	x0, x19, #0x580
ffffffffea8086a4:	97fff4c5 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
ffffffffea8086a8:	f9466681 	ldr	x1, [x20, #3272]
ffffffffea8086ac:	b40001e1 	cbz	x1, ffffffffea8086e8 <sm_put_boot_args+0x60>
		TRACEF("WARNING: caller does not own "
			"a reference to boot parameters\n");
		goto unlock;
	}

	boot_args_refcnt--;
ffffffffea8086b0:	b00002a2 	adrp	x2, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8086b4:	b94cd040 	ldr	w0, [x2, #3280]
ffffffffea8086b8:	51000400 	sub	w0, w0, #0x1
ffffffffea8086bc:	b90cd040 	str	w0, [x2, #3280]
	if (boot_args_refcnt == 0) {
ffffffffea8086c0:	350000c0 	cbnz	w0, ffffffffea8086d8 <sm_put_boot_args+0x50>
		vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)boot_args);
ffffffffea8086c4:	d00002a0 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
ffffffffea8086c8:	91034000 	add	x0, x0, #0xd0
ffffffffea8086cc:	94002395 	bl	ffffffffea811520 <vmm_free_region>
		boot_args = NULL;
ffffffffea8086d0:	f906669f 	str	xzr, [x20, #3272]
		resume_nsthreads();
ffffffffea8086d4:	97fffdad 	bl	ffffffffea807d88 <resume_nsthreads>
	}
unlock:
	mutex_release(&boot_args_lock);
ffffffffea8086d8:	91160260 	add	x0, x19, #0x580
}
ffffffffea8086dc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8086e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_release(&boot_args_lock);
ffffffffea8086e4:	17fff4e1 	b	ffffffffea805a68 <mutex_release>
		TRACEF("WARNING: caller does not own "
ffffffffea8086e8:	52804162 	mov	w2, #0x20b                 	// #523
ffffffffea8086ec:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8086f0:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8086f4:	911a4021 	add	x1, x1, #0x690
ffffffffea8086f8:	91214000 	add	x0, x0, #0x850
ffffffffea8086fc:	94002acd 	bl	ffffffffea813230 <_printf>
	mutex_release(&boot_args_lock);
ffffffffea808700:	91160260 	add	x0, x19, #0x580
}
ffffffffea808704:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808708:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_release(&boot_args_lock);
ffffffffea80870c:	17fff4d7 	b	ffffffffea805a68 <mutex_release>

ffffffffea808710 <sm_release_boot_args>:

static void sm_release_boot_args(uint level)
{
ffffffffea808710:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808714:	910003fd 	mov	x29, sp
ffffffffea808718:	f9000bf3 	str	x19, [sp, #16]
	if (boot_args) {
ffffffffea80871c:	b00002b3 	adrp	x19, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea808720:	f9466660 	ldr	x0, [x19, #3272]
ffffffffea808724:	b40001e0 	cbz	x0, ffffffffea808760 <sm_release_boot_args+0x50>
		sm_put_boot_args();
ffffffffea808728:	97ffffd8 	bl	ffffffffea808688 <sm_put_boot_args>
		 * the boot loader didn't pass bootargs
		 */
		resume_nsthreads();
	}

	if (boot_args) {
ffffffffea80872c:	f9466660 	ldr	x0, [x19, #3272]
ffffffffea808730:	b4000120 	cbz	x0, ffffffffea808754 <sm_release_boot_args+0x44>
		TRACEF("WARNING: outstanding reference to boot args"
				"at the end of initialzation!\n");
	}
}
ffffffffea808734:	f9400bf3 	ldr	x19, [sp, #16]
		TRACEF("WARNING: outstanding reference to boot args"
ffffffffea808738:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
}
ffffffffea80873c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		TRACEF("WARNING: outstanding reference to boot args"
ffffffffea808740:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea808744:	528044c2 	mov	w2, #0x226                 	// #550
ffffffffea808748:	911aa021 	add	x1, x1, #0x6a8
ffffffffea80874c:	91226000 	add	x0, x0, #0x898
ffffffffea808750:	14002ab8 	b	ffffffffea813230 <_printf>
}
ffffffffea808754:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808758:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80875c:	d65f03c0 	ret
		resume_nsthreads();
ffffffffea808760:	97fffd8a 	bl	ffffffffea807d88 <resume_nsthreads>
ffffffffea808764:	17fffff2 	b	ffffffffea80872c <sm_release_boot_args+0x1c>

ffffffffea808768 <smc_nop_stdcall>:
 * context switch that will perform other secure work.
 */
static long smc_nop_stdcall(smc32_args_t *args)
{
	return 0;
}
ffffffffea808768:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80876c:	d65f03c0 	ret

ffffffffea808770 <smc_nop_secure_monitor>:
/*
 * parameterized nop call handler
 */
static long smc_nop_secure_monitor(smc32_args_t *args)
{
	return (!args->params[0]) ? 0 : SM_ERR_UNDEFINED_SMC;
ffffffffea808770:	b9400401 	ldr	w1, [x0, #4]
ffffffffea808774:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
ffffffffea808778:	7100003f 	cmp	w1, #0x0
}
ffffffffea80877c:	9a9f1000 	csel	x0, x0, xzr, ne  // ne = any
ffffffffea808780:	d65f03c0 	ret
ffffffffea808784:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808788 <smc_undefined>:
{
ffffffffea808788:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	TRACE_SMC("Undefined monitor call!", args);
ffffffffea80878c:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea808790:	d0000063 	adrp	x3, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea808794:	912c2063 	add	x3, x3, #0xb08
{
ffffffffea808798:	910003fd 	mov	x29, sp
ffffffffea80879c:	a90153f3 	stp	x19, x20, [sp, #16]
	TRACE_SMC("Undefined monitor call!", args);
ffffffffea8087a0:	aa0003f4 	mov	x20, x0
ffffffffea8087a4:	d0000073 	adrp	x19, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8087a8:	912a2273 	add	x19, x19, #0xa88
{
ffffffffea8087ac:	a9025bf5 	stp	x21, x22, [sp, #32]
	TRACE_SMC("Undefined monitor call!", args);
ffffffffea8087b0:	aa1303e1 	mov	x1, x19
ffffffffea8087b4:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8087b8:	912c8000 	add	x0, x0, #0xb20
ffffffffea8087bc:	94002a9d 	bl	ffffffffea813230 <_printf>
ffffffffea8087c0:	d0000075 	adrp	x21, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8087c4:	b8404683 	ldr	w3, [x20], #4
ffffffffea8087c8:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8087cc:	d0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8087d0:	912c0021 	add	x1, x1, #0xb00
ffffffffea8087d4:	7100007f 	cmp	w3, #0x0
ffffffffea8087d8:	912bc084 	add	x4, x4, #0xaf0
ffffffffea8087dc:	912d82b5 	add	x21, x21, #0xb60
ffffffffea8087e0:	9a81b084 	csel	x4, x4, x1, lt  // lt = tstop
ffffffffea8087e4:	aa1303f6 	mov	x22, x19
ffffffffea8087e8:	aa1303e1 	mov	x1, x19
ffffffffea8087ec:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea8087f0:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8087f4:	12003c66 	and	w6, w3, #0xffff
ffffffffea8087f8:	d3587465 	ubfx	x5, x3, #24, #6
ffffffffea8087fc:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea808800:	912cc000 	add	x0, x0, #0xb30
ffffffffea808804:	94002a8b 	bl	ffffffffea813230 <_printf>
ffffffffea808808:	b8404684 	ldr	w4, [x20], #4
ffffffffea80880c:	2a1303e3 	mov	w3, w19
ffffffffea808810:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea808814:	aa1603e1 	mov	x1, x22
ffffffffea808818:	aa1503e0 	mov	x0, x21
ffffffffea80881c:	11000673 	add	w19, w19, #0x1
ffffffffea808820:	94002a84 	bl	ffffffffea813230 <_printf>
ffffffffea808824:	71001e7f 	cmp	w19, #0x7
ffffffffea808828:	54ffff01 	b.ne	ffffffffea808808 <smc_undefined+0x80>  // b.any
}
ffffffffea80882c:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
ffffffffea808830:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808834:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea808838:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80883c:	d65f03c0 	ret

ffffffffea808840 <smc_restart_stdcall>:
{
ffffffffea808840:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	TRACE_SMC("Unexpected stdcall restart!", args);
ffffffffea808844:	52800922 	mov	w2, #0x49                  	// #73
ffffffffea808848:	d0000063 	adrp	x3, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80884c:	912b4063 	add	x3, x3, #0xad0
{
ffffffffea808850:	910003fd 	mov	x29, sp
ffffffffea808854:	a90153f3 	stp	x19, x20, [sp, #16]
	TRACE_SMC("Unexpected stdcall restart!", args);
ffffffffea808858:	aa0003f4 	mov	x20, x0
ffffffffea80885c:	d0000073 	adrp	x19, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea808860:	912a6273 	add	x19, x19, #0xa98
{
ffffffffea808864:	a9025bf5 	stp	x21, x22, [sp, #32]
	TRACE_SMC("Unexpected stdcall restart!", args);
ffffffffea808868:	aa1303e1 	mov	x1, x19
ffffffffea80886c:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea808870:	912c8000 	add	x0, x0, #0xb20
ffffffffea808874:	94002a6f 	bl	ffffffffea813230 <_printf>
ffffffffea808878:	d0000075 	adrp	x21, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80887c:	b8404683 	ldr	w3, [x20], #4
ffffffffea808880:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea808884:	d0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea808888:	912c0021 	add	x1, x1, #0xb00
ffffffffea80888c:	7100007f 	cmp	w3, #0x0
ffffffffea808890:	912bc084 	add	x4, x4, #0xaf0
ffffffffea808894:	912d82b5 	add	x21, x21, #0xb60
ffffffffea808898:	9a81b084 	csel	x4, x4, x1, lt  // lt = tstop
ffffffffea80889c:	aa1303f6 	mov	x22, x19
ffffffffea8088a0:	aa1303e1 	mov	x1, x19
ffffffffea8088a4:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea8088a8:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8088ac:	12003c66 	and	w6, w3, #0xffff
ffffffffea8088b0:	d3587465 	ubfx	x5, x3, #24, #6
ffffffffea8088b4:	52800922 	mov	w2, #0x49                  	// #73
ffffffffea8088b8:	912cc000 	add	x0, x0, #0xb30
ffffffffea8088bc:	94002a5d 	bl	ffffffffea813230 <_printf>
ffffffffea8088c0:	b8404684 	ldr	w4, [x20], #4
ffffffffea8088c4:	2a1303e3 	mov	w3, w19
ffffffffea8088c8:	52800922 	mov	w2, #0x49                  	// #73
ffffffffea8088cc:	aa1603e1 	mov	x1, x22
ffffffffea8088d0:	aa1503e0 	mov	x0, x21
ffffffffea8088d4:	11000673 	add	w19, w19, #0x1
ffffffffea8088d8:	94002a56 	bl	ffffffffea813230 <_printf>
ffffffffea8088dc:	71001e7f 	cmp	w19, #0x7
ffffffffea8088e0:	54ffff01 	b.ne	ffffffffea8088c0 <smc_restart_stdcall+0x80>  // b.any
}
ffffffffea8088e4:	92800060 	mov	x0, #0xfffffffffffffffc    	// #-4
ffffffffea8088e8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8088ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8088f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8088f4:	d65f03c0 	ret

ffffffffea8088f8 <smc_fiq_exit>:
	}
	return handler_fn(args);
}

long smc_fiq_exit(smc32_args_t *args)
{
ffffffffea8088f8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea8088fc:	910003fd 	mov	x29, sp
	sm_intc_fiq_exit();
ffffffffea808900:	97fff144 	bl	ffffffffea804e10 <sm_intc_fiq_exit>
	return 1; /* 0: reeenter fiq handler, 1: return */
}
ffffffffea808904:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea808908:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80890c:	d65f03c0 	ret

ffffffffea808910 <smc_register_ns_dram_ranges>:
#endif

#if !defined(DISABLE_NS_DRAM_RANGE_CHECK)
static long smc_register_ns_dram_ranges(smc32_args_t *args)
{
	if (!args)
ffffffffea808910:	b4000080 	cbz	x0, ffffffffea808920 <smc_register_ns_dram_ranges+0x10>
		return ERR_INVALID_ARGS;

	ns_addr_t ns_base =  ((uint64_t)args->params[1] << 32) | args->params[0];

	return platform_register_ns_dram_ranges(ns_base, args->params[2]);
ffffffffea808914:	b9400c01 	ldr	w1, [x0, #12]
ffffffffea808918:	f8404000 	ldur	x0, [x0, #4]
ffffffffea80891c:	17ffe649 	b	ffffffffea802240 <platform_register_ns_dram_ranges>
}
ffffffffea808920:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea808924:	d65f03c0 	ret

ffffffffea808928 <smc_get_version_str>:
{
ffffffffea808928:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80892c:	910003fd 	mov	x29, sp
ffffffffea808930:	a90153f3 	stp	x19, x20, [sp, #16]
	size_t version_len = strlen(lk_version);
ffffffffea808934:	b0000093 	adrp	x19, ffffffffea819000 <_mem_phys_base>
	int32_t index = args->params[0];
ffffffffea808938:	b9400414 	ldr	w20, [x0, #4]
	size_t version_len = strlen(lk_version);
ffffffffea80893c:	913f2273 	add	x19, x19, #0xfc8
ffffffffea808940:	aa1303e0 	mov	x0, x19
ffffffffea808944:	94002b99 	bl	ffffffffea8137a8 <strlen>
	if (index == -1) {
ffffffffea808948:	3100069f 	cmn	w20, #0x1
ffffffffea80894c:	54000080 	b.eq	ffffffffea80895c <smc_get_version_str+0x34>  // b.none
	if ((size_t)index >= version_len) {
ffffffffea808950:	eb34c01f 	cmp	x0, w20, sxtw
ffffffffea808954:	540000a9 	b.ls	ffffffffea808968 <smc_get_version_str+0x40>  // b.plast
	return lk_version[index];
ffffffffea808958:	3874ca60 	ldrb	w0, [x19, w20, sxtw]
}
ffffffffea80895c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808960:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808964:	d65f03c0 	ret
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea808968:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80896c:	17fffffc 	b	ffffffffea80895c <smc_get_version_str+0x34>

ffffffffea808970 <smc_fiq_enter>:
{
ffffffffea808970:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea808974:	910003fd 	mov	x29, sp
	return sm_intc_fiq_enter();
ffffffffea808978:	97fff0e4 	bl	ffffffffea804d08 <sm_intc_fiq_enter>
}
ffffffffea80897c:	93407c00 	sxtw	x0, w0
ffffffffea808980:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea808984:	d65f03c0 	ret

ffffffffea808988 <smc_stdcall_secure_monitor>:
{
ffffffffea808988:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80898c:	910003fd 	mov	x29, sp
ffffffffea808990:	f9000bf3 	str	x19, [sp, #16]
	u_int function = SMC_FUNCTION(args->smc_nr);
ffffffffea808994:	79400013 	ldrh	w19, [x0]
	if (function < countof(sm_stdcall_function_table)) {
ffffffffea808998:	71000e7f 	cmp	w19, #0x3
ffffffffea80899c:	540000c9 	b.ls	ffffffffea8089b4 <smc_stdcall_secure_monitor+0x2c>  // b.plast
}
ffffffffea8089a0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8089a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
		handler_fn = smc_undefined;
ffffffffea8089a8:	90000001 	adrp	x1, ffffffffea808000 <sm_get_api_version+0x88>
ffffffffea8089ac:	911e2021 	add	x1, x1, #0x788
	return handler_fn(args);
ffffffffea8089b0:	d61f0020 	br	x1
ffffffffea8089b4:	f90017a0 	str	x0, [x29, #40]
		platform_arch_speculation_barrier();
ffffffffea8089b8:	97ffe61e 	bl	ffffffffea802230 <platform_arch_speculation_barrier>
		handler_fn = sm_stdcall_function_table[function];
ffffffffea8089bc:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8089c0:	912ac021 	add	x1, x1, #0xab0
	if (!handler_fn) {
ffffffffea8089c4:	f94017a0 	ldr	x0, [x29, #40]
		handler_fn = sm_stdcall_function_table[function];
ffffffffea8089c8:	f8737821 	ldr	x1, [x1, x19, lsl #3]
	if (!handler_fn) {
ffffffffea8089cc:	b4fffea1 	cbz	x1, ffffffffea8089a0 <smc_stdcall_secure_monitor+0x18>
}
ffffffffea8089d0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8089d4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return handler_fn(args);
ffffffffea8089d8:	d61f0020 	br	x1
ffffffffea8089dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8089e0 <smc_cpu_resume>:
{
ffffffffea8089e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
}

static inline void lk_init_level_all(enum lk_init_flags flags) {
	lk_init_level(flags, LK_INIT_LEVEL_EARLIEST, LK_INIT_LEVEL_LAST);
ffffffffea8089e4:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea8089e8:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8089ec:	910003fd 	mov	x29, sp
ffffffffea8089f0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea8089f4:	aa0003f3 	mov	x19, x0
ffffffffea8089f8:	52800100 	mov	w0, #0x8                   	// #8
ffffffffea8089fc:	97ffec8b 	bl	ffffffffea803c28 <lk_init_level>
	if (args->params[0] == MPIDR_MAX_AFFLVL)
ffffffffea808a00:	b9400660 	ldr	w0, [x19, #4]
ffffffffea808a04:	7100081f 	cmp	w0, #0x2
ffffffffea808a08:	540000a0 	b.eq	ffffffffea808a1c <smc_cpu_resume+0x3c>  // b.none
}
ffffffffea808a0c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea808a10:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808a14:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808a18:	d65f03c0 	ret
ffffffffea808a1c:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea808a20:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808a24:	52800400 	mov	w0, #0x20                  	// #32
ffffffffea808a28:	97ffec80 	bl	ffffffffea803c28 <lk_init_level>
ffffffffea808a2c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea808a30:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808a34:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808a38:	d65f03c0 	ret
ffffffffea808a3c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808a40 <smc_cpu_suspend>:
{
ffffffffea808a40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808a44:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea808a48:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808a4c:	910003fd 	mov	x29, sp
ffffffffea808a50:	f9000bf3 	str	x19, [sp, #16]
ffffffffea808a54:	aa0003f3 	mov	x19, x0
ffffffffea808a58:	52800080 	mov	w0, #0x4                   	// #4
ffffffffea808a5c:	97ffec73 	bl	ffffffffea803c28 <lk_init_level>
	if (args->params[0] == MPIDR_MAX_AFFLVL)
ffffffffea808a60:	b9400660 	ldr	w0, [x19, #4]
ffffffffea808a64:	7100081f 	cmp	w0, #0x2
ffffffffea808a68:	540000a0 	b.eq	ffffffffea808a7c <smc_cpu_suspend+0x3c>  // b.none
}
ffffffffea808a6c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea808a70:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808a74:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808a78:	d65f03c0 	ret
ffffffffea808a7c:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea808a80:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808a84:	52800200 	mov	w0, #0x10                  	// #16
ffffffffea808a88:	97ffec68 	bl	ffffffffea803c28 <lk_init_level>
ffffffffea808a8c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea808a90:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808a94:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808a98:	d65f03c0 	ret
ffffffffea808a9c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808aa0 <sm_register_entity>:
	[SMC_ENTITY_SECURE_MONITOR] = smc_stdcall_secure_monitor,
	[SMC_ENTITY_SECURE_MONITOR + 1 ... SMC_NUM_ENTITIES - 1] = smc_undefined
};

status_t sm_register_entity(uint entity_nr, smc32_entity_t *entity)
{
ffffffffea808aa0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	status_t err = NO_ERROR;

	if (entity_nr >= SMC_NUM_ENTITIES) {
ffffffffea808aa4:	7100fc1f 	cmp	w0, #0x3f
{
ffffffffea808aa8:	910003fd 	mov	x29, sp
ffffffffea808aac:	f9000bf3 	str	x19, [sp, #16]
	if (entity_nr >= SMC_NUM_ENTITIES) {
ffffffffea808ab0:	54000728 	b.hi	ffffffffea808b94 <sm_register_entity+0xf4>  // b.pmore
		return ERR_INVALID_ARGS;
	}
	if (entity_nr >= SMC_ENTITY_RESERVED && entity_nr < SMC_ENTITY_TRUSTED_APP) {
ffffffffea808ab4:	51001402 	sub	w2, w0, #0x5
ffffffffea808ab8:	7100a85f 	cmp	w2, #0x2a
ffffffffea808abc:	54000709 	b.ls	ffffffffea808b9c <sm_register_entity+0xfc>  // b.plast
		return ERR_NOT_ALLOWED;
	}
	if (!entity) {
ffffffffea808ac0:	b40006a1 	cbz	x1, ffffffffea808b94 <sm_register_entity+0xf4>
		return ERR_INVALID_ARGS;
	}
	if (!entity->fastcall_handler && !entity->stdcall_handler){
ffffffffea808ac4:	f9400022 	ldr	x2, [x1]
ffffffffea808ac8:	b4000302 	cbz	x2, ffffffffea808b28 <sm_register_entity+0x88>
ffffffffea808acc:	2a0003f3 	mov	w19, w0
ffffffffea808ad0:	a901d7b4 	stp	x20, x21, [x29, #24]
ffffffffea808ad4:	aa0103f4 	mov	x20, x1
ffffffffea808ad8:	b0000095 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea808adc:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808ae0:	9132a2a0 	add	x0, x21, #0xca8
ffffffffea808ae4:	97fff3b5 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	}

	mutex_acquire(&smc_table_lock);

	/* Check if entity is already claimed */
	if (sm_fastcall_table[entity_nr] != smc_undefined ||
ffffffffea808ae8:	2a1303e0 	mov	w0, w19
ffffffffea808aec:	b0000081 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea808af0:	911a8021 	add	x1, x1, #0x6a0
ffffffffea808af4:	90000002 	adrp	x2, ffffffffea808000 <sm_get_api_version+0x88>
ffffffffea808af8:	911e2042 	add	x2, x2, #0x788
		sm_nopcall_table[entity_nr] != smc_undefined ||
		sm_stdcall_table[entity_nr] != smc_undefined) {
		err = ERR_ALREADY_EXISTS;
ffffffffea808afc:	128001b3 	mov	w19, #0xfffffff2            	// #-14
	if (sm_fastcall_table[entity_nr] != smc_undefined ||
ffffffffea808b00:	f8607823 	ldr	x3, [x1, x0, lsl #3]
ffffffffea808b04:	eb02007f 	cmp	x3, x2
ffffffffea808b08:	54000180 	b.eq	ffffffffea808b38 <sm_register_entity+0x98>  // b.none
	}
	if (entity->stdcall_handler) {
		sm_stdcall_table[entity_nr] = entity->stdcall_handler;
	}
unlock:
	mutex_release(&smc_table_lock);
ffffffffea808b0c:	9132a2a0 	add	x0, x21, #0xca8
ffffffffea808b10:	97fff3d6 	bl	ffffffffea805a68 <mutex_release>
	return err;
ffffffffea808b14:	a941d7b4 	ldp	x20, x21, [x29, #24]
}
ffffffffea808b18:	2a1303e0 	mov	w0, w19
ffffffffea808b1c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808b20:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808b24:	d65f03c0 	ret
	if (!entity->fastcall_handler && !entity->stdcall_handler){
ffffffffea808b28:	f9400822 	ldr	x2, [x1, #16]
ffffffffea808b2c:	b5fffd02 	cbnz	x2, ffffffffea808acc <sm_register_entity+0x2c>
		return ERR_NOT_VALID;
ffffffffea808b30:	128000d3 	mov	w19, #0xfffffff9            	// #-7
ffffffffea808b34:	17fffff9 	b	ffffffffea808b18 <sm_register_entity+0x78>
		sm_nopcall_table[entity_nr] != smc_undefined ||
ffffffffea808b38:	b0000084 	adrp	x4, ffffffffea819000 <_mem_phys_base>
ffffffffea808b3c:	91228082 	add	x2, x4, #0x8a0
	if (sm_fastcall_table[entity_nr] != smc_undefined ||
ffffffffea808b40:	f8607842 	ldr	x2, [x2, x0, lsl #3]
ffffffffea808b44:	eb03005f 	cmp	x2, x3
ffffffffea808b48:	54fffe21 	b.ne	ffffffffea808b0c <sm_register_entity+0x6c>  // b.any
		sm_stdcall_table[entity_nr] != smc_undefined) {
ffffffffea808b4c:	b0000083 	adrp	x3, ffffffffea819000 <_mem_phys_base>
ffffffffea808b50:	912aa065 	add	x5, x3, #0xaa8
		sm_nopcall_table[entity_nr] != smc_undefined ||
ffffffffea808b54:	f86078a5 	ldr	x5, [x5, x0, lsl #3]
ffffffffea808b58:	eb0200bf 	cmp	x5, x2
ffffffffea808b5c:	54fffd81 	b.ne	ffffffffea808b0c <sm_register_entity+0x6c>  // b.any
	if (entity->fastcall_handler) {
ffffffffea808b60:	f9400282 	ldr	x2, [x20]
ffffffffea808b64:	b4000042 	cbz	x2, ffffffffea808b6c <sm_register_entity+0xcc>
		sm_fastcall_table[entity_nr] = entity->fastcall_handler;
ffffffffea808b68:	f8207822 	str	x2, [x1, x0, lsl #3]
	if (entity->nopcall_handler) {
ffffffffea808b6c:	f9400681 	ldr	x1, [x20, #8]
ffffffffea808b70:	b4000061 	cbz	x1, ffffffffea808b7c <sm_register_entity+0xdc>
		sm_nopcall_table[entity_nr] = entity->nopcall_handler;
ffffffffea808b74:	91228084 	add	x4, x4, #0x8a0
ffffffffea808b78:	f8207881 	str	x1, [x4, x0, lsl #3]
	if (entity->stdcall_handler) {
ffffffffea808b7c:	f9400a81 	ldr	x1, [x20, #16]
	status_t err = NO_ERROR;
ffffffffea808b80:	52800013 	mov	w19, #0x0                   	// #0
	if (entity->stdcall_handler) {
ffffffffea808b84:	b4fffc41 	cbz	x1, ffffffffea808b0c <sm_register_entity+0x6c>
		sm_stdcall_table[entity_nr] = entity->stdcall_handler;
ffffffffea808b88:	912aa063 	add	x3, x3, #0xaa8
ffffffffea808b8c:	f8207861 	str	x1, [x3, x0, lsl #3]
ffffffffea808b90:	17ffffdf 	b	ffffffffea808b0c <sm_register_entity+0x6c>
		return ERR_INVALID_ARGS;
ffffffffea808b94:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea808b98:	17ffffe0 	b	ffffffffea808b18 <sm_register_entity+0x78>
		return ERR_NOT_ALLOWED;
ffffffffea808b9c:	12800213 	mov	w19, #0xffffffef            	// #-17
ffffffffea808ba0:	17ffffde 	b	ffffffffea808b18 <sm_register_entity+0x78>
ffffffffea808ba4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808ba8 <sm_decode_ns_memory_attr>:
status_t sm_decode_ns_memory_attr(struct ns_page_info *pinf,
				  ns_addr_t *ppa, uint *pmmu)
{
	uint mmu_flags = 0;

	if(!pinf) {
ffffffffea808ba8:	b4000420 	cbz	x0, ffffffffea808c2c <sm_decode_ns_memory_attr+0x84>
		pinf->attr,
		NS_PTE_PHYSADDR(pinf->attr),
		(uint)NS_PTE_ATTR_MAIR(pinf->attr),
		(uint)NS_PTE_ATTR_SHAREABLE(pinf->attr));

	if (ppa) {
ffffffffea808bac:	b4000081 	cbz	x1, ffffffffea808bbc <sm_decode_ns_memory_attr+0x14>
		*ppa = (ns_addr_t)NS_PTE_PHYSADDR(pinf->attr);
ffffffffea808bb0:	f9400003 	ldr	x3, [x0]
ffffffffea808bb4:	92748c63 	and	x3, x3, #0xfffffffff000
ffffffffea808bb8:	f9000023 	str	x3, [x1]
			mmu_flags |= ARCH_MMU_FLAG_PERM_RO;

		*pmmu = mmu_flags | ARCH_MMU_FLAG_NS | ARCH_MMU_FLAG_PERM_NO_EXECUTE;
	}

	return NO_ERROR;
ffffffffea808bbc:	52800003 	mov	w3, #0x0                   	// #0
	if (pmmu) {
ffffffffea808bc0:	b4000282 	cbz	x2, ffffffffea808c10 <sm_decode_ns_memory_attr+0x68>
		switch ((uint)NS_PTE_ATTR_MAIR(pinf->attr)) {
ffffffffea808bc4:	f9400000 	ldr	x0, [x0]
ffffffffea808bc8:	d370dc01 	ubfx	x1, x0, #48, #8
ffffffffea808bcc:	7101103f 	cmp	w1, #0x44
ffffffffea808bd0:	54000240 	b.eq	ffffffffea808c18 <sm_decode_ns_memory_attr+0x70>  // b.none
ffffffffea808bd4:	7103fc3f 	cmp	w1, #0xff
ffffffffea808bd8:	54000241 	b.ne	ffffffffea808c20 <sm_decode_ns_memory_attr+0x78>  // b.any
			if(NS_PTE_ATTR_SHAREABLE(pinf->attr) != NS_INNER_SHAREABLE) {
ffffffffea808bdc:	d3482401 	ubfx	x1, x0, #8, #2
ffffffffea808be0:	f1000c3f 	cmp	x1, #0x3
ffffffffea808be4:	540001e1 	b.ne	ffffffffea808c20 <sm_decode_ns_memory_attr+0x78>  // b.any
				mmu_flags |= ARCH_MMU_FLAG_CACHED;
ffffffffea808be8:	52800001 	mov	w1, #0x0                   	// #0
			mmu_flags |= ARCH_MMU_FLAG_PERM_USER;
ffffffffea808bec:	f27a001f 	tst	x0, #0x40
ffffffffea808bf0:	321e0023 	orr	w3, w1, #0x4
ffffffffea808bf4:	1a811061 	csel	w1, w3, w1, ne  // ne = any
			mmu_flags |= ARCH_MMU_FLAG_PERM_RO;
ffffffffea808bf8:	f279001f 	tst	x0, #0x80
ffffffffea808bfc:	321d0020 	orr	w0, w1, #0x8
	return NO_ERROR;
ffffffffea808c00:	52800003 	mov	w3, #0x0                   	// #0
			mmu_flags |= ARCH_MMU_FLAG_PERM_RO;
ffffffffea808c04:	1a811001 	csel	w1, w0, w1, ne  // ne = any
		*pmmu = mmu_flags | ARCH_MMU_FLAG_NS | ARCH_MMU_FLAG_PERM_NO_EXECUTE;
ffffffffea808c08:	321c0421 	orr	w1, w1, #0x30
ffffffffea808c0c:	b9000041 	str	w1, [x2]
}
ffffffffea808c10:	2a0303e0 	mov	w0, w3
ffffffffea808c14:	d65f03c0 	ret
				mmu_flags |= ARCH_MMU_FLAG_UNCACHED;
ffffffffea808c18:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808c1c:	17fffff4 	b	ffffffffea808bec <sm_decode_ns_memory_attr+0x44>
				return ERR_NOT_SUPPORTED;
ffffffffea808c20:	128002e3 	mov	w3, #0xffffffe8            	// #-24
}
ffffffffea808c24:	2a0303e0 	mov	w0, w3
ffffffffea808c28:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea808c2c:	128000e3 	mov	w3, #0xfffffff8            	// #-8
ffffffffea808c30:	17fffff8 	b	ffffffffea808c10 <sm_decode_ns_memory_attr+0x68>
ffffffffea808c34:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808c38 <smc32_decode_mem_buf_info>:


/* Helper function to get NS memory buffer info out of smc32 call params */
status_t smc32_decode_mem_buf_info(struct smc32_args *args, ns_addr_t *ppa,
                                   ns_size_t *psz, uint *pmmu)
{
ffffffffea808c38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808c3c:	aa0003e4 	mov	x4, x0
ffffffffea808c40:	aa0203e5 	mov	x5, x2

	DEBUG_ASSERT(args);

	pi.attr = ((uint64_t)args->params[1] << 32) | args->params[0];

	res = sm_decode_ns_memory_attr(&pi, ppa, pmmu);
ffffffffea808c44:	aa0303e2 	mov	x2, x3
{
ffffffffea808c48:	910003fd 	mov	x29, sp
	pi.attr = ((uint64_t)args->params[1] << 32) | args->params[0];
ffffffffea808c4c:	910083a0 	add	x0, x29, #0x20
ffffffffea808c50:	f8404083 	ldur	x3, [x4, #4]
ffffffffea808c54:	f81f8c03 	str	x3, [x0, #-8]!
	res = sm_decode_ns_memory_attr(&pi, ppa, pmmu);
ffffffffea808c58:	97ffffd4 	bl	ffffffffea808ba8 <sm_decode_ns_memory_attr>
	if (res != NO_ERROR)
ffffffffea808c5c:	35000080 	cbnz	w0, ffffffffea808c6c <smc32_decode_mem_buf_info+0x34>
		return res;

	if (psz)
ffffffffea808c60:	b4000065 	cbz	x5, ffffffffea808c6c <smc32_decode_mem_buf_info+0x34>
		*psz = (ns_size_t)args->params[2];
ffffffffea808c64:	b9400c81 	ldr	w1, [x4, #12]
ffffffffea808c68:	b90000a1 	str	w1, [x5]

	return NO_ERROR;
}
ffffffffea808c6c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808c70:	d65f03c0 	ret
ffffffffea808c74:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808c78 <trusty_init>:
#include <lk/init.h>
#include <stdio.h>
#include <version.h>

static void trusty_init(uint level)
{
ffffffffea808c78:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	dprintf(INFO, "initializing trusty (%s)\n", lk_version);
ffffffffea808c7c:	b0000081 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea808c80:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea808c84:	913f2021 	add	x1, x1, #0xfc8
{
ffffffffea808c88:	910003fd 	mov	x29, sp
	dprintf(INFO, "initializing trusty (%s)\n", lk_version);
ffffffffea808c8c:	912f0000 	add	x0, x0, #0xbc0
ffffffffea808c90:	94002384 	bl	ffffffffea811aa0 <_dprintf>

	trusty_app_init();
}
ffffffffea808c94:	a8c17bfd 	ldp	x29, x30, [sp], #16
	trusty_app_init();
ffffffffea808c98:	14000086 	b	ffffffffea808eb0 <trusty_app_init>
ffffffffea808c9c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808ca0 <start_apps>:
		fn(ta, data);
	}
}

static void start_apps(uint level)
{
ffffffffea808ca0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	trusty_app_t *trusty_app;
	u_int i;
	int ret;

	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea808ca4:	b00002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
{
ffffffffea808ca8:	910003fd 	mov	x29, sp
ffffffffea808cac:	f90013f5 	str	x21, [sp, #32]
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea808cb0:	b00002b5 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
{
ffffffffea808cb4:	f9000bf3 	str	x19, [sp, #16]
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea808cb8:	b94f12a0 	ldr	w0, [x21, #3856]
ffffffffea808cbc:	f9479833 	ldr	x19, [x1, #3888]
ffffffffea808cc0:	340002e0 	cbz	w0, ffffffffea808d1c <start_apps+0x7c>
ffffffffea808cc4:	f9000fb4 	str	x20, [x29, #24]
ffffffffea808cc8:	913c42b5 	add	x21, x21, #0xf10
ffffffffea808ccc:	f90017b6 	str	x22, [x29, #40]
ffffffffea808cd0:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea808cd4:	aa1e03f6 	mov	x22, x30
ffffffffea808cd8:	14000006 	b	ffffffffea808cf0 <start_apps+0x50>
ffffffffea808cdc:	b94002a0 	ldr	w0, [x21]
ffffffffea808ce0:	11000694 	add	w20, w20, #0x1
ffffffffea808ce4:	9101a273 	add	x19, x19, #0x68
ffffffffea808ce8:	6b14001f 	cmp	w0, w20
ffffffffea808cec:	54000149 	b.ls	ffffffffea808d14 <start_apps+0x74>  // b.plast
		if (trusty_app->ut->entry) {
ffffffffea808cf0:	f9402e60 	ldr	x0, [x19, #88]
ffffffffea808cf4:	f9400401 	ldr	x1, [x0, #8]
ffffffffea808cf8:	b4ffff21 	cbz	x1, ffffffffea808cdc <start_apps+0x3c>
			ret = uthread_start(trusty_app->ut);
ffffffffea808cfc:	94002c2b 	bl	ffffffffea813da8 <uthread_start>
			if (ret) {
ffffffffea808d00:	34fffee0 	cbz	w0, ffffffffea808cdc <start_apps+0x3c>
				panic("Cannot start Trusty app!\n");
ffffffffea808d04:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea808d08:	aa1603e0 	mov	x0, x22
ffffffffea808d0c:	912fe021 	add	x1, x1, #0xbf8
ffffffffea808d10:	940023e2 	bl	ffffffffea811c98 <_panic>
ffffffffea808d14:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea808d18:	f94017b6 	ldr	x22, [x29, #40]
			}
		}
	}
	tegra_boot_profiler_record("start_apps: Done");
ffffffffea808d1c:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea808d20:	91306000 	add	x0, x0, #0xc18
ffffffffea808d24:	97fffa63 	bl	ffffffffea8076b0 <tegra_boot_profiler_record>
	/* Debug only: Prints all profiler records to UART during boot */
	/* tegra_boot_profiler_data_printnow(); */
	tegra_boot_profiler_deinit();
}
ffffffffea808d28:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808d2c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea808d30:	a8c37bfd 	ldp	x29, x30, [sp], #48
	tegra_boot_profiler_deinit();
ffffffffea808d34:	17fffa5b 	b	ffffffffea8076a0 <tegra_boot_profiler_deinit>

ffffffffea808d38 <trusty_register_app_notifier>:
{
ffffffffea808d38:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea808d3c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808d40:	910003fd 	mov	x29, sp
ffffffffea808d44:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea808d48:	aa0003f3 	mov	x19, x0
ffffffffea808d4c:	b0000094 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea808d50:	f90013f5 	str	x21, [sp, #32]
ffffffffea808d54:	9133c280 	add	x0, x20, #0xcf0
ffffffffea808d58:	97fff318 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	if (!apps_started) {
ffffffffea808d5c:	b00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea808d60:	397c2000 	ldrb	w0, [x0, #3848]
ffffffffea808d64:	35000220 	cbnz	w0, ffffffffea808da8 <trusty_register_app_notifier+0x70>
	item->prev = list->prev;
ffffffffea808d68:	b0000080 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea808d6c:	91338001 	add	x1, x0, #0xce0
	item->next = list;
ffffffffea808d70:	f9000661 	str	x1, [x19, #8]
	status_t ret = NO_ERROR;
ffffffffea808d74:	52800015 	mov	w21, #0x0                   	// #0
	item->prev = list->prev;
ffffffffea808d78:	f9467001 	ldr	x1, [x0, #3296]
ffffffffea808d7c:	f9000261 	str	x1, [x19]
	list->prev->next = item;
ffffffffea808d80:	f9467001 	ldr	x1, [x0, #3296]
	list->prev = item;
ffffffffea808d84:	f9067013 	str	x19, [x0, #3296]
	list->prev->next = item;
ffffffffea808d88:	f9000433 	str	x19, [x1, #8]
	mutex_release(&apps_lock);
ffffffffea808d8c:	9133c280 	add	x0, x20, #0xcf0
ffffffffea808d90:	97fff336 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea808d94:	2a1503e0 	mov	w0, w21
ffffffffea808d98:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea808d9c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808da0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808da4:	d65f03c0 	ret
		ret = ERR_ALREADY_STARTED;
ffffffffea808da8:	128000b5 	mov	w21, #0xfffffffa            	// #-6
ffffffffea808dac:	17fffff8 	b	ffffffffea808d8c <trusty_register_app_notifier+0x54>

ffffffffea808db0 <trusty_als_alloc_slot>:
{
ffffffffea808db0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808db4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808db8:	910003fd 	mov	x29, sp
ffffffffea808dbc:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea808dc0:	b0000094 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea808dc4:	9133c280 	add	x0, x20, #0xcf0
ffffffffea808dc8:	97fff2fc 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	if (!apps_started) {
ffffffffea808dcc:	b00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea808dd0:	397c2000 	ldrb	w0, [x0, #3848]
ffffffffea808dd4:	35000180 	cbnz	w0, ffffffffea808e04 <trusty_als_alloc_slot+0x54>
		ret = ++als_slot_cnt;
ffffffffea808dd8:	d00002a1 	adrp	x1, ffffffffea85e000 <rb_data+0x18>
ffffffffea808ddc:	b940cc20 	ldr	w0, [x1, #204]
ffffffffea808de0:	11000400 	add	w0, w0, #0x1
ffffffffea808de4:	b900cc20 	str	w0, [x1, #204]
ffffffffea808de8:	2a0003f3 	mov	w19, w0
	mutex_release(&apps_lock);
ffffffffea808dec:	9133c280 	add	x0, x20, #0xcf0
ffffffffea808df0:	97fff31e 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea808df4:	2a1303e0 	mov	w0, w19
ffffffffea808df8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808dfc:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808e00:	d65f03c0 	ret
		ret = ERR_ALREADY_STARTED;
ffffffffea808e04:	128000b3 	mov	w19, #0xfffffffa            	// #-6
ffffffffea808e08:	17fffff9 	b	ffffffffea808dec <trusty_als_alloc_slot+0x3c>
ffffffffea808e0c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808e10 <trusty_app_setup_mmio>:
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea808e10:	b9404008 	ldr	w8, [x0, #64]
ffffffffea808e14:	34000148 	cbz	w8, ffffffffea808e3c <trusty_app_setup_mmio+0x2c>
		if (trusty_app->props.config_blob[i] == TRUSTY_APP_CONFIG_KEY_MAP_MEM) {
ffffffffea808e18:	f9402407 	ldr	x7, [x0, #72]
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea808e1c:	52800004 	mov	w4, #0x0                   	// #0
		if (trusty_app->props.config_blob[i] == TRUSTY_APP_CONFIG_KEY_MAP_MEM) {
ffffffffea808e20:	b86458e6 	ldr	w6, [x7, w4, uxtw #2]
ffffffffea808e24:	11000485 	add	w5, w4, #0x1
ffffffffea808e28:	71000cdf 	cmp	w6, #0x3
ffffffffea808e2c:	540000c0 	b.eq	ffffffffea808e44 <trusty_app_setup_mmio+0x34>  // b.none
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea808e30:	110004a4 	add	w4, w5, #0x1
ffffffffea808e34:	6b04011f 	cmp	w8, w4
ffffffffea808e38:	54ffff48 	b.hi	ffffffffea808e20 <trusty_app_setup_mmio+0x10>  // b.pmore
	return ERR_NOT_FOUND;
ffffffffea808e3c:	12800020 	mov	w0, #0xfffffffe            	// #-2
ffffffffea808e40:	d65f03c0 	ret
			id = trusty_app->props.config_blob[++i];
ffffffffea808e44:	b86558e6 	ldr	w6, [x7, w5, uxtw #2]
			size = ROUNDUP(trusty_app->props.config_blob[++i],
ffffffffea808e48:	11000c85 	add	w5, w4, #0x3
			if (id != mmio_id) {
ffffffffea808e4c:	6b0100df 	cmp	w6, w1
ffffffffea808e50:	54ffff01 	b.ne	ffffffffea808e30 <trusty_app_setup_mmio+0x20>  // b.any
			size = ROUNDUP(trusty_app->props.config_blob[++i],
ffffffffea808e54:	b86558e5 	ldr	w5, [x7, w5, uxtw #2]
			map_size = ROUNDUP(map_size, PAGE_SIZE);
ffffffffea808e58:	113ffc63 	add	w3, w3, #0xfff
ffffffffea808e5c:	12144c63 	and	w3, w3, #0xfffff000
			size = ROUNDUP(trusty_app->props.config_blob[++i],
ffffffffea808e60:	113ffca5 	add	w5, w5, #0xfff
ffffffffea808e64:	12144ca5 	and	w5, w5, #0xfffff000
			if (map_size > size) {
ffffffffea808e68:	6b0300bf 	cmp	w5, w3
ffffffffea808e6c:	540001c3 	b.cc	ffffffffea808ea4 <trusty_app_setup_mmio+0x94>  // b.lo, b.ul, b.last
{
ffffffffea808e70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
			offset = trusty_app->props.config_blob[++i];
ffffffffea808e74:	11000886 	add	w6, w4, #0x2
ffffffffea808e78:	aa0203e1 	mov	x1, x2
	return uthread_map(ut, vaddrp, &paddr, size, flags, align);
ffffffffea808e7c:	52820005 	mov	w5, #0x1000                	// #4096
{
ffffffffea808e80:	910003fd 	mov	x29, sp
			return uthread_map_contig(trusty_app->ut, vaddr, offset,
ffffffffea808e84:	910083a2 	add	x2, x29, #0x20
ffffffffea808e88:	b86678e6 	ldr	w6, [x7, x6, lsl #2]
ffffffffea808e8c:	f9402c00 	ldr	x0, [x0, #88]
ffffffffea808e90:	52801464 	mov	w4, #0xa3                  	// #163
ffffffffea808e94:	f81f8c46 	str	x6, [x2, #-8]!
ffffffffea808e98:	94002be8 	bl	ffffffffea813e38 <uthread_map>
}
ffffffffea808e9c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808ea0:	d65f03c0 	ret
				return ERR_INVALID_ARGS;
ffffffffea808ea4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea808ea8:	d65f03c0 	ret
ffffffffea808eac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808eb0 <trusty_app_init>:
{
ffffffffea808eb0:	d10503ff 	sub	sp, sp, #0x140
	trusty_app_image_start = (char *)&__trusty_app_start;
ffffffffea808eb4:	d0000080 	adrp	x0, ffffffffea81a000 <__trusty_app_start>
	trusty_app_image_end = (char *)&__trusty_app_end;
ffffffffea808eb8:	90000221 	adrp	x1, ffffffffea84c000 <__trusty_app_start+0x32000>
	trusty_app_image_start = (char *)&__trusty_app_start;
ffffffffea808ebc:	91000000 	add	x0, x0, #0x0
	trusty_app_image_end = (char *)&__trusty_app_end;
ffffffffea808ec0:	91368021 	add	x1, x1, #0xda0
{
ffffffffea808ec4:	a9037bfd 	stp	x29, x30, [sp, #48]
ffffffffea808ec8:	9100c3fd 	add	x29, sp, #0x30
	trusty_app_image_size = (trusty_app_image_end - trusty_app_image_start);
ffffffffea808ecc:	cb000022 	sub	x2, x1, x0
	ASSERT(!((uintptr_t)trusty_app_image_start & PAGE_MASK));
ffffffffea808ed0:	f2402c1f 	tst	x0, #0xfff
{
ffffffffea808ed4:	f90027f4 	str	x20, [sp, #72]
	trusty_app_image_start = (char *)&__trusty_app_start;
ffffffffea808ed8:	b00002b4 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
{
ffffffffea808edc:	f9003ffa 	str	x26, [sp, #120]
	trusty_app_image_size = (trusty_app_image_end - trusty_app_image_start);
ffffffffea808ee0:	b00002ba 	adrp	x26, ffffffffea85d000 <idle_threads+0xeb0>
{
ffffffffea808ee4:	f90047fc 	str	x28, [sp, #136]
	trusty_app_image_end = (char *)&__trusty_app_end;
ffffffffea808ee8:	b00002bc 	adrp	x28, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea808eec:	f9000bb3 	str	x19, [x29, #16]
ffffffffea808ef0:	f9003bbe 	str	x30, [x29, #112]
	trusty_app_image_start = (char *)&__trusty_app_start;
ffffffffea808ef4:	f9079680 	str	x0, [x20, #3880]
	trusty_app_image_end = (char *)&__trusty_app_end;
ffffffffea808ef8:	f9078f81 	str	x1, [x28, #3864]
	trusty_app_image_size = (trusty_app_image_end - trusty_app_image_start);
ffffffffea808efc:	b90f2342 	str	w2, [x26, #3872]
	ASSERT(!((uintptr_t)trusty_app_image_start & PAGE_MASK));
ffffffffea808f00:	540045c1 	b.ne	ffffffffea8097b8 <trusty_app_init+0x908>  // b.any
ffffffffea808f04:	b0000093 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea808f08:	9133c273 	add	x19, x19, #0xcf0
ffffffffea808f0c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808f10:	aa1303e0 	mov	x0, x19
ffffffffea808f14:	f9001fb8 	str	x24, [x29, #56]
ffffffffea808f18:	97fff2a8 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	apps_started = true;
ffffffffea808f1c:	b00002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea808f20:	52800022 	mov	w2, #0x1                   	// #1
	mutex_release(&apps_lock);
ffffffffea808f24:	aa1303e0 	mov	x0, x19
ffffffffea808f28:	b00002b3 	adrp	x19, ffffffffea85d000 <idle_threads+0xeb0>
	apps_started = true;
ffffffffea808f2c:	393c2022 	strb	w2, [x1, #3848]
	mutex_release(&apps_lock);
ffffffffea808f30:	97fff2ce 	bl	ffffffffea805a68 <mutex_release>
	dprintf(SPEW, "trusty_app: start %p size 0x%08x end %p\n",
ffffffffea808f34:	f9478f83 	ldr	x3, [x28, #3864]
ffffffffea808f38:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea808f3c:	b94f2342 	ldr	w2, [x26, #3872]
ffffffffea808f40:	91324000 	add	x0, x0, #0xc90
ffffffffea808f44:	f9479681 	ldr	x1, [x20, #3880]
ffffffffea808f48:	940022d6 	bl	ffffffffea811aa0 <_dprintf>
	if (trusty_app_image_size) {
ffffffffea808f4c:	b94f2340 	ldr	w0, [x26, #3872]
ffffffffea808f50:	35001ce0 	cbnz	w0, ffffffffea8092ec <trusty_app_init+0x43c>
	platform_app_bootloader_epilog();
ffffffffea808f54:	97ffe2cb 	bl	ffffffffea801a80 <platform_app_bootloader_epilog>
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea808f58:	b94f1260 	ldr	w0, [x19, #3856]
ffffffffea808f5c:	b00002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea808f60:	f9479838 	ldr	x24, [x1, #3888]
ffffffffea808f64:	34001b40 	cbz	w0, ffffffffea8092cc <trusty_app_init+0x41c>
ffffffffea808f68:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea808f6c:	f9001bb7 	str	x23, [x29, #48]
ffffffffea808f70:	f90023b9 	str	x25, [x29, #64]
ffffffffea808f74:	f9002bbb 	str	x27, [x29, #80]
ffffffffea808f78:	b9009bbf 	str	wzr, [x29, #152]
		snprintf(name, sizeof(name), "trusty_app_%d_%08x-%04x-%04x",
ffffffffea808f7c:	79404f06 	ldrh	w6, [x24, #38]
ffffffffea808f80:	f0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea808f84:	79404b05 	ldrh	w5, [x24, #36]
ffffffffea808f88:	9100c002 	add	x2, x0, #0x30
ffffffffea808f8c:	b9402304 	ldr	w4, [x24, #32]
ffffffffea808f90:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea808f94:	b9409ba3 	ldr	w3, [x29, #152]
ffffffffea808f98:	9102c3a0 	add	x0, x29, #0xb0
ffffffffea808f9c:	94002887 	bl	ffffffffea8131b8 <snprintf>
		uthread = uthread_create(name, elf_hdr->e_entry,
ffffffffea808fa0:	f9402b00 	ldr	x0, [x24, #80]
ffffffffea808fa4:	aa1803e5 	mov	x5, x24
ffffffffea808fa8:	b9403704 	ldr	w4, [x24, #52]
ffffffffea808fac:	d2a02003 	mov	x3, #0x1000000             	// #16777216
ffffffffea808fb0:	52800202 	mov	w2, #0x10                  	// #16
ffffffffea808fb4:	b9401801 	ldr	w1, [x0, #24]
ffffffffea808fb8:	9102c3a0 	add	x0, x29, #0xb0
ffffffffea808fbc:	94002bdf 	bl	ffffffffea813f38 <uthread_create>
ffffffffea808fc0:	aa0003f4 	mov	x20, x0
		if (uthread == NULL) {
ffffffffea808fc4:	b40056e0 	cbz	x0, ffffffffea809aa0 <trusty_app_init+0xbf0>
		tegra_boot_profiler_record("app_init: uthread allocated");
ffffffffea808fc8:	f0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea808fcc:	9101c000 	add	x0, x0, #0x70
ffffffffea808fd0:	97fff9b8 	bl	ffffffffea8076b0 <tegra_boot_profiler_record>
	Elf32_Ehdr *elf_hdr = trusty_app->app_img;
ffffffffea808fd4:	f9402b1b 	ldr	x27, [x24, #80]
	trusty_app_idx = trusty_app - trusty_app_list;
ffffffffea808fd8:	b00002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
	for (i = 0; i < elf_hdr->e_phnum; i++) {
ffffffffea808fdc:	79405b61 	ldrh	w1, [x27, #44]
	trusty_app_idx = trusty_app - trusty_app_list;
ffffffffea808fe0:	f9479800 	ldr	x0, [x0, #3888]
		trusty_app->ut = uthread;
ffffffffea808fe4:	f9002f14 	str	x20, [x24, #88]
	trusty_app_idx = trusty_app - trusty_app_list;
ffffffffea808fe8:	f9004ba0 	str	x0, [x29, #144]
	for (i = 0; i < elf_hdr->e_phnum; i++) {
ffffffffea808fec:	34000c01 	cbz	w1, ffffffffea80916c <trusty_app_init+0x2bc>
ffffffffea808ff0:	d2800019 	mov	x25, #0x0                   	// #0
	vaddr_t end_data = 0;
ffffffffea808ff4:	d2800015 	mov	x21, #0x0                   	// #0
	vaddr_t end_code = 0;
ffffffffea808ff8:	d2800016 	mov	x22, #0x0                   	// #0
	vaddr_t start_data = 0;
ffffffffea808ffc:	d2800017 	mov	x23, #0x0                   	// #0
	vaddr_t start_code = ~0;
ffffffffea809000:	92800014 	mov	x20, #0xffffffffffffffff    	// #-1
		if ((prg_hdr->p_vaddr < TRUSTY_APP_START_ADDR) ||
ffffffffea809004:	528fffeb 	mov	w11, #0x7fff                	// #32767
ffffffffea809008:	14000006 	b	ffffffffea809020 <trusty_app_init+0x170>
ffffffffea80900c:	79405b61 	ldrh	w1, [x27, #44]
ffffffffea809010:	11000720 	add	w0, w25, #0x1
ffffffffea809014:	91000739 	add	x25, x25, #0x1
	for (i = 0; i < elf_hdr->e_phnum; i++) {
ffffffffea809018:	6b00003f 	cmp	w1, w0
ffffffffea80901c:	54000b09 	b.ls	ffffffffea80917c <trusty_app_init+0x2cc>  // b.plast
		prg_hdr = (Elf32_Phdr *)(trusty_app_image + elf_hdr->e_phoff +
ffffffffea809020:	b9401f60 	ldr	w0, [x27, #28]
ffffffffea809024:	8b191400 	add	x0, x0, x25, lsl #5
ffffffffea809028:	8b00037c 	add	x28, x27, x0
		if (prg_hdr->p_type != PT_LOAD) {
ffffffffea80902c:	b8606b60 	ldr	w0, [x27, x0]
ffffffffea809030:	7100041f 	cmp	w0, #0x1
ffffffffea809034:	54fffee1 	b.ne	ffffffffea809010 <trusty_app_init+0x160>  // b.any
		if ((prg_hdr->p_vaddr < TRUSTY_APP_START_ADDR) ||
ffffffffea809038:	b9400b80 	ldr	w0, [x28, #8]
ffffffffea80903c:	6b0b001f 	cmp	w0, w11
ffffffffea809040:	54fffe89 	b.ls	ffffffffea809010 <trusty_app_init+0x160>  // b.plast
ffffffffea809044:	f9400302 	ldr	x2, [x24]
ffffffffea809048:	eb20405f 	cmp	x2, w0, uxtw
ffffffffea80904c:	54fffe29 	b.ls	ffffffffea809010 <trusty_app_init+0x160>  // b.plast
		ASSERT(!(prg_hdr->p_vaddr & PAGE_MASK) &&
ffffffffea809050:	f2402c1f 	tst	x0, #0xfff
ffffffffea809054:	54004381 	b.ne	ffffffffea8098c4 <trusty_app_init+0xa14>  // b.any
ffffffffea809058:	b9400780 	ldr	w0, [x28, #4]
ffffffffea80905c:	f2402c1f 	tst	x0, #0xfff
ffffffffea809060:	2a0003e0 	mov	w0, w0
ffffffffea809064:	54004301 	b.ne	ffffffffea8098c4 <trusty_app_init+0xa14>  // b.any
		size_t size = (prg_hdr->p_memsz + PAGE_MASK) & ~PAGE_MASK;
ffffffffea809068:	b940179a 	ldr	w26, [x28, #20]
/* physical to virtual */
void *paddr_to_kvaddr(paddr_t pa);

/* virtual to physical */
paddr_t kvaddr_to_paddr(void *va);
static inline paddr_t vaddr_to_paddr(void *ptr) { return kvaddr_to_paddr(ptr); }
ffffffffea80906c:	8b000360 	add	x0, x27, x0
ffffffffea809070:	94001f8a 	bl	ffffffffea810e98 <kvaddr_to_paddr>
		u_int flags = PF_TO_UTM_FLAGS(prg_hdr->p_flags) | UTM_FIXED;
ffffffffea809074:	b9401b81 	ldr	w1, [x28, #24]
		size_t size = (prg_hdr->p_memsz + PAGE_MASK) & ~PAGE_MASK;
ffffffffea809078:	913fff5a 	add	x26, x26, #0xfff
		ret = uthread_map_contig(trusty_app->ut, &vaddr, paddr, size,
ffffffffea80907c:	f9402f02 	ldr	x2, [x24, #88]
		size_t size = (prg_hdr->p_memsz + PAGE_MASK) & ~PAGE_MASK;
ffffffffea809080:	9274cf5a 	and	x26, x26, #0xfffffffffffff000
ffffffffea809084:	f90053a0 	str	x0, [x29, #160]
ffffffffea809088:	52820005 	mov	w5, #0x1000                	// #4096
		u_int flags = PF_TO_UTM_FLAGS(prg_hdr->p_flags) | UTM_FIXED;
ffffffffea80908c:	d3420824 	ubfx	x4, x1, #2, #1
ffffffffea809090:	aa0203e0 	mov	x0, x2
ffffffffea809094:	121f0022 	and	w2, w1, #0x2
ffffffffea809098:	531e0021 	ubfiz	w1, w1, #2, #1
ffffffffea80909c:	32180042 	orr	w2, w2, #0x100
ffffffffea8090a0:	2a010084 	orr	w4, w4, w1
ffffffffea8090a4:	2a020084 	orr	w4, w4, w2
		vaddr_t vaddr = prg_hdr->p_vaddr;
ffffffffea8090a8:	b9400b81 	ldr	w1, [x28, #8]
ffffffffea8090ac:	f9006ba1 	str	x1, [x29, #208]
ffffffffea8090b0:	aa1a03e3 	mov	x3, x26
ffffffffea8090b4:	321b0084 	orr	w4, w4, #0x20
ffffffffea8090b8:	910283a2 	add	x2, x29, #0xa0
ffffffffea8090bc:	910343a1 	add	x1, x29, #0xd0
ffffffffea8090c0:	94002b5e 	bl	ffffffffea813e38 <uthread_map>
		if (ret) {
ffffffffea8090c4:	528fffeb 	mov	w11, #0x7fff                	// #32767
ffffffffea8090c8:	35004b20 	cbnz	w0, ffffffffea809a2c <trusty_app_init+0xb7c>
		vaddr_t stack_bot = TRUSTY_APP_STACK_TOP - trusty_app->props.min_stack_size;
ffffffffea8090cc:	b9403701 	ldr	w1, [x24, #52]
ffffffffea8090d0:	52a02000 	mov	w0, #0x1000000             	// #16777216
ffffffffea8090d4:	4b010001 	sub	w1, w0, w1
		if (stack_bot < vaddr + size) {
ffffffffea8090d8:	f9406ba0 	ldr	x0, [x29, #208]
ffffffffea8090dc:	8b000340 	add	x0, x26, x0
ffffffffea8090e0:	eb00003f 	cmp	x1, x0
ffffffffea8090e4:	54004b23 	b.cc	ffffffffea809a48 <trusty_app_init+0xb98>  // b.lo, b.ul, b.last
		first = prg_hdr->p_vaddr;
ffffffffea8090e8:	b9400b81 	ldr	w1, [x28, #8]
		last = prg_hdr->p_vaddr + prg_hdr->p_filesz;
ffffffffea8090ec:	b9401380 	ldr	w0, [x28, #16]
		if ((prg_hdr->p_flags & PF_X) && end_code < last) {
ffffffffea8090f0:	b9401b84 	ldr	w4, [x28, #24]
		first = prg_hdr->p_vaddr;
ffffffffea8090f4:	2a0103e3 	mov	w3, w1
		last = prg_hdr->p_vaddr + prg_hdr->p_filesz;
ffffffffea8090f8:	0b000020 	add	w0, w1, w0
ffffffffea8090fc:	eb03029f 	cmp	x20, x3
ffffffffea809100:	9a839294 	csel	x20, x20, x3, ls  // ls = plast
ffffffffea809104:	eb0302ff 	cmp	x23, x3
ffffffffea809108:	9a8322f7 	csel	x23, x23, x3, cs  // cs = hs, nlast
		if ((prg_hdr->p_flags & PF_X) && end_code < last) {
ffffffffea80910c:	eb16001f 	cmp	x0, x22
ffffffffea809110:	1a9f97e2 	cset	w2, hi  // hi = pmore
ffffffffea809114:	6a02009f 	tst	w4, w2
		if (last_mem > trusty_app->start_brk) {
ffffffffea809118:	f9400702 	ldr	x2, [x24, #8]
		if ((prg_hdr->p_flags & PF_X) && end_code < last) {
ffffffffea80911c:	9a8002d6 	csel	x22, x22, x0, eq  // eq = none
ffffffffea809120:	eb0002bf 	cmp	x21, x0
ffffffffea809124:	9a8022b5 	csel	x21, x21, x0, cs  // cs = hs, nlast
		last_mem = prg_hdr->p_vaddr + prg_hdr->p_memsz;
ffffffffea809128:	b9401780 	ldr	w0, [x28, #20]
ffffffffea80912c:	0b000021 	add	w1, w1, w0
		if (last_mem > trusty_app->start_brk) {
ffffffffea809130:	eb02003f 	cmp	x1, x2
ffffffffea809134:	54fff6c9 	b.ls	ffffffffea80900c <trusty_app_init+0x15c>  // b.plast
			void *segment_start = trusty_app_image + prg_hdr->p_offset;
ffffffffea809138:	b9400784 	ldr	w4, [x28, #4]
			trusty_app->end_brk = prg_hdr->p_vaddr + size;
ffffffffea80913c:	8b030343 	add	x3, x26, x3
			memset(segment_start + prg_hdr->p_memsz, 0,
ffffffffea809140:	2a0003e2 	mov	w2, w0
			trusty_app->start_brk = last_mem;
ffffffffea809144:	f9000701 	str	x1, [x24, #8]
			trusty_app->end_brk = prg_hdr->p_vaddr + size;
ffffffffea809148:	f9000f03 	str	x3, [x24, #24]
			memset(segment_start + prg_hdr->p_memsz, 0,
ffffffffea80914c:	8b020080 	add	x0, x4, x2
ffffffffea809150:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea809154:	cb020342 	sub	x2, x26, x2
ffffffffea809158:	8b000360 	add	x0, x27, x0
ffffffffea80915c:	94002931 	bl	ffffffffea813620 <memset>
ffffffffea809160:	79405b61 	ldrh	w1, [x27, #44]
ffffffffea809164:	528fffeb 	mov	w11, #0x7fff                	// #32767
ffffffffea809168:	17ffffaa 	b	ffffffffea809010 <trusty_app_init+0x160>
	vaddr_t end_data = 0;
ffffffffea80916c:	d2800015 	mov	x21, #0x0                   	// #0
	vaddr_t end_code = 0;
ffffffffea809170:	d2800016 	mov	x22, #0x0                   	// #0
	vaddr_t start_data = 0;
ffffffffea809174:	d2800017 	mov	x23, #0x0                   	// #0
	vaddr_t start_code = ~0;
ffffffffea809178:	92800014 	mov	x20, #0xffffffffffffffff    	// #-1
	trusty_app->cur_brk = trusty_app->start_brk;
ffffffffea80917c:	f9400702 	ldr	x2, [x24, #8]
	if ((trusty_app->end_brk - trusty_app->start_brk) >=
ffffffffea809180:	f9400f00 	ldr	x0, [x24, #24]
	    trusty_app->props.min_heap_size) {
ffffffffea809184:	b9403b01 	ldr	w1, [x24, #56]
	trusty_app->cur_brk = trusty_app->start_brk;
ffffffffea809188:	f9000b02 	str	x2, [x24, #16]
	if ((trusty_app->end_brk - trusty_app->start_brk) >=
ffffffffea80918c:	cb020000 	sub	x0, x0, x2
ffffffffea809190:	eb01001f 	cmp	x0, x1
ffffffffea809194:	54004123 	b.cc	ffffffffea8099b8 <trusty_app_init+0xb08>  // b.lo, b.ul, b.last
	trusty_app_idx = trusty_app - trusty_app_list;
ffffffffea809198:	f9404ba0 	ldr	x0, [x29, #144]
	dprintf(SPEW, "trusty_app %d: code: start 0x%08lx end 0x%08lx\n",
ffffffffea80919c:	aa1403e2 	mov	x2, x20
ffffffffea8091a0:	aa1603e3 	mov	x3, x22
	trusty_app_idx = trusty_app - trusty_app_list;
ffffffffea8091a4:	cb000301 	sub	x1, x24, x0
	dprintf(SPEW, "trusty_app %d: code: start 0x%08lx end 0x%08lx\n",
ffffffffea8091a8:	d0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea8091ac:	9105e000 	add	x0, x0, #0x178
	trusty_app_idx = trusty_app - trusty_app_list;
ffffffffea8091b0:	9343fc34 	asr	x20, x1, #3
ffffffffea8091b4:	d289d8a1 	mov	x1, #0x4ec5                	// #20165
ffffffffea8091b8:	f2b89d81 	movk	x1, #0xc4ec, lsl #16
ffffffffea8091bc:	f2dd89c1 	movk	x1, #0xec4e, lsl #32
ffffffffea8091c0:	f2e9d881 	movk	x1, #0x4ec4, lsl #48
ffffffffea8091c4:	9b017e94 	mul	x20, x20, x1
	dprintf(SPEW, "trusty_app %d: code: start 0x%08lx end 0x%08lx\n",
ffffffffea8091c8:	2a1403e1 	mov	w1, w20
ffffffffea8091cc:	94002235 	bl	ffffffffea811aa0 <_dprintf>
	dprintf(SPEW, "trusty_app %d: data: start 0x%08lx end 0x%08lx\n",
ffffffffea8091d0:	aa1503e3 	mov	x3, x21
ffffffffea8091d4:	aa1703e2 	mov	x2, x23
ffffffffea8091d8:	2a1403e1 	mov	w1, w20
ffffffffea8091dc:	d0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea8091e0:	9106a000 	add	x0, x0, #0x1a8
ffffffffea8091e4:	9400222f 	bl	ffffffffea811aa0 <_dprintf>
	dprintf(SPEW, "trusty_app %d: bss:                end 0x%08lx\n",
ffffffffea8091e8:	f9400302 	ldr	x2, [x24]
ffffffffea8091ec:	2a1403e1 	mov	w1, w20
ffffffffea8091f0:	d0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea8091f4:	91076000 	add	x0, x0, #0x1d8
ffffffffea8091f8:	9400222a 	bl	ffffffffea811aa0 <_dprintf>
	dprintf(SPEW, "trusty_app %d: brk:  start 0x%08lx end 0x%08lx\n",
ffffffffea8091fc:	f9400702 	ldr	x2, [x24, #8]
ffffffffea809200:	2a1403e1 	mov	w1, w20
ffffffffea809204:	f9400f03 	ldr	x3, [x24, #24]
ffffffffea809208:	d0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80920c:	91082000 	add	x0, x0, #0x208
ffffffffea809210:	94002224 	bl	ffffffffea811aa0 <_dprintf>
	dprintf(SPEW, "trusty_app %d: entry 0x%08lx\n", trusty_app_idx, trusty_app->ut->entry);
ffffffffea809214:	f9402f02 	ldr	x2, [x24, #88]
ffffffffea809218:	2a1403e1 	mov	w1, w20
ffffffffea80921c:	d0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea809220:	9108e000 	add	x0, x0, #0x238
ffffffffea809224:	f9400442 	ldr	x2, [x2, #8]
ffffffffea809228:	9400221e 	bl	ffffffffea811aa0 <_dprintf>
		trusty_app->als = calloc(1, als_slot_cnt * sizeof(void*));
ffffffffea80922c:	b00002a1 	adrp	x1, ffffffffea85e000 <rb_data+0x18>
ffffffffea809230:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea809234:	b940cc21 	ldr	w1, [x1, #204]
ffffffffea809238:	d37df021 	lsl	x1, x1, #3
ffffffffea80923c:	9400282b 	bl	ffffffffea8132e8 <calloc>
ffffffffea809240:	f9003300 	str	x0, [x24, #96]
		if (!trusty_app->als) {
ffffffffea809244:	b4004360 	cbz	x0, ffffffffea809ab0 <trusty_app_init+0xc00>
		list_for_every_entry(&app_notifier_list, n, trusty_app_notifier_t, node) {
ffffffffea809248:	90000096 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea80924c:	913382d6 	add	x22, x22, #0xce0
ffffffffea809250:	f94006d4 	ldr	x20, [x22, #8]
ffffffffea809254:	eb16029f 	cmp	x20, x22
ffffffffea809258:	54000140 	b.eq	ffffffffea809280 <trusty_app_init+0x3d0>  // b.none
ffffffffea80925c:	d503201f 	nop
			if (n->startup) {
ffffffffea809260:	f9400a81 	ldr	x1, [x20, #16]
ffffffffea809264:	b4000081 	cbz	x1, ffffffffea809274 <trusty_app_init+0x3c4>
				ret = n->startup(trusty_app);
ffffffffea809268:	aa1803e0 	mov	x0, x24
ffffffffea80926c:	d63f0020 	blr	x1
				if (ret != NO_ERROR) {
ffffffffea809270:	350040e0 	cbnz	w0, ffffffffea809a8c <trusty_app_init+0xbdc>
		list_for_every_entry(&app_notifier_list, n, trusty_app_notifier_t, node) {
ffffffffea809274:	f9400694 	ldr	x20, [x20, #8]
ffffffffea809278:	eb16029f 	cmp	x20, x22
ffffffffea80927c:	54ffff21 	b.ne	ffffffffea809260 <trusty_app_init+0x3b0>  // b.any
		snprintf(profiler_print, sizeof(profiler_print), "Loaded app: %s", name);
ffffffffea809280:	9102c3a3 	add	x3, x29, #0xb0
ffffffffea809284:	d0000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea809288:	910b2042 	add	x2, x2, #0x2c8
ffffffffea80928c:	d2800801 	mov	x1, #0x40                  	// #64
ffffffffea809290:	910343a0 	add	x0, x29, #0xd0
ffffffffea809294:	940027c9 	bl	ffffffffea8131b8 <snprintf>
		tegra_boot_profiler_record(profiler_print);
ffffffffea809298:	910343a0 	add	x0, x29, #0xd0
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea80929c:	9101a318 	add	x24, x24, #0x68
		tegra_boot_profiler_record(profiler_print);
ffffffffea8092a0:	97fff904 	bl	ffffffffea8076b0 <tegra_boot_profiler_record>
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea8092a4:	b9409ba1 	ldr	w1, [x29, #152]
ffffffffea8092a8:	b94f1260 	ldr	w0, [x19, #3856]
ffffffffea8092ac:	11000421 	add	w1, w1, #0x1
ffffffffea8092b0:	b9009ba1 	str	w1, [x29, #152]
ffffffffea8092b4:	6b01001f 	cmp	w0, w1
ffffffffea8092b8:	54ffe628 	b.hi	ffffffffea808f7c <trusty_app_init+0xcc>  // b.pmore
ffffffffea8092bc:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8092c0:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea8092c4:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea8092c8:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea8092cc:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8092d0:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea8092d4:	a9437bfd 	ldp	x29, x30, [sp, #48]
ffffffffea8092d8:	f94027f4 	ldr	x20, [sp, #72]
ffffffffea8092dc:	f9403ffa 	ldr	x26, [sp, #120]
ffffffffea8092e0:	f94047fc 	ldr	x28, [sp, #136]
ffffffffea8092e4:	910503ff 	add	sp, sp, #0x140
ffffffffea8092e8:	d65f03c0 	ret
		trusty_app_list = (trusty_app_t *)memalign(PAGE_SIZE, PAGE_SIZE);
ffffffffea8092ec:	d2820001 	mov	x1, #0x1000                	// #4096
ffffffffea8092f0:	f90013b5 	str	x21, [x29, #32]
ffffffffea8092f4:	aa0103e0 	mov	x0, x1
	trusty_app_image_addr = trusty_app_image_start;
ffffffffea8092f8:	f9479695 	ldr	x21, [x20, #3880]
		trusty_app_list = (trusty_app_t *)memalign(PAGE_SIZE, PAGE_SIZE);
ffffffffea8092fc:	940027f7 	bl	ffffffffea8132d8 <memalign>
ffffffffea809300:	aa0003f4 	mov	x20, x0
ffffffffea809304:	900002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
		memset(trusty_app, 0, PAGE_SIZE);
ffffffffea809308:	d2820002 	mov	x2, #0x1000                	// #4096
		trusty_app_list = (trusty_app_t *)memalign(PAGE_SIZE, PAGE_SIZE);
ffffffffea80930c:	f9079820 	str	x0, [x1, #3888]
		memset(trusty_app, 0, PAGE_SIZE);
ffffffffea809310:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea809314:	940028c3 	bl	ffffffffea813620 <memset>
	while (trusty_app_image_size > 0) {
ffffffffea809318:	b94f2340 	ldr	w0, [x26, #3872]
ffffffffea80931c:	34003d20 	cbz	w0, ffffffffea809ac0 <trusty_app_init+0xc10>
			if (!strcmp((shstbl + shdr[i].sh_name), ".bss")) {
ffffffffea809320:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809324:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea809328:	91364000 	add	x0, x0, #0xd90
ffffffffea80932c:	f90023b9 	str	x25, [x29, #64]
ffffffffea809330:	f9002bbb 	str	x27, [x29, #80]
	while (trusty_app_image_size > 0) {
ffffffffea809334:	b90067bf 	str	wzr, [x29, #100]
			if (!strcmp((shstbl + shdr[i].sh_name), ".bss")) {
ffffffffea809338:	f9004ba0 	str	x0, [x29, #144]
	if (!strcmp(*task_image_addr, NV_GUEST_TASK_MAGIC_STR)) {
ffffffffea80933c:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809340:	91330001 	add	x1, x0, #0xcc0
ffffffffea809344:	aa1503e0 	mov	x0, x21
ffffffffea809348:	940028d6 	bl	ffffffffea8136a0 <strcmp>
ffffffffea80934c:	35002000 	cbnz	w0, ffffffffea80974c <trusty_app_init+0x89c>
		guest_count++;
ffffffffea809350:	900002a1 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea809354:	b94f0c20 	ldr	w0, [x1, #3852]
ffffffffea809358:	11000400 	add	w0, w0, #0x1
ffffffffea80935c:	b90f0c20 	str	w0, [x1, #3852]
		if (guest_count == 1) {
ffffffffea809360:	7100041f 	cmp	w0, #0x1
ffffffffea809364:	54002260 	b.eq	ffffffffea8097b0 <trusty_app_init+0x900>  // b.none
		*task_vmid = strtoul(task_header, &endp, 0);
ffffffffea809368:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea80936c:	910343a1 	add	x1, x29, #0xd0
ffffffffea809370:	910032a0 	add	x0, x21, #0xc
ffffffffea809374:	9400242b 	bl	ffffffffea812420 <strtoul>
ffffffffea809378:	b90067a0 	str	w0, [x29, #100]
		if (*endp) {
ffffffffea80937c:	f9406ba0 	ldr	x0, [x29, #208]
ffffffffea809380:	39400000 	ldrb	w0, [x0]
ffffffffea809384:	350030c0 	cbnz	w0, ffffffffea80999c <trusty_app_init+0xaec>
		trusty_app_image_end -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809388:	f9478f83 	ldr	x3, [x28, #3864]
		memmove(*task_image_addr, new_task_image_addr, trusty_app_image_size);
ffffffffea80938c:	910082a1 	add	x1, x21, #0x20
		trusty_app_image_size -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809390:	b94f2342 	ldr	w2, [x26, #3872]
		memmove(*task_image_addr, new_task_image_addr, trusty_app_image_size);
ffffffffea809394:	aa1503e0 	mov	x0, x21
		trusty_app_image_end -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809398:	d1008063 	sub	x3, x3, #0x20
ffffffffea80939c:	f9078f83 	str	x3, [x28, #3864]
		trusty_app_image_size -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea8093a0:	51008042 	sub	w2, w2, #0x20
ffffffffea8093a4:	b90f2342 	str	w2, [x26, #3872]
		memmove(*task_image_addr, new_task_image_addr, trusty_app_image_size);
ffffffffea8093a8:	94002822 	bl	ffffffffea813430 <memmove>
		if (strncmp((char *)ehdr->e_ident, ELFMAG, SELFMAG)) {
ffffffffea8093ac:	b0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8093b0:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea8093b4:	9134a021 	add	x1, x1, #0xd28
ffffffffea8093b8:	aa1503e0 	mov	x0, x21
ffffffffea8093bc:	9400290f 	bl	ffffffffea8137f8 <strncmp>
ffffffffea8093c0:	35002dc0 	cbnz	w0, ffffffffea809978 <trusty_app_init+0xac8>
		shdr = (Elf32_Shdr *) ((intptr_t)ehdr + ehdr->e_shoff);
ffffffffea8093c4:	b94022a2 	ldr	w2, [x21, #32]
		shstbl = (char *)((intptr_t)ehdr + shdr[ehdr->e_shstrndx].sh_offset);
ffffffffea8093c8:	52800517 	mov	w23, #0x28                  	// #40
ffffffffea8093cc:	794066a1 	ldrh	w1, [x21, #50]
		shdr = (Elf32_Shdr *) ((intptr_t)ehdr + ehdr->e_shoff);
ffffffffea8093d0:	8b150042 	add	x2, x2, x21
		for (i = 0; i < ehdr->e_shnum; i++) {
ffffffffea8093d4:	794062a0 	ldrh	w0, [x21, #48]
		shstbl = (char *)((intptr_t)ehdr + shdr[ehdr->e_shstrndx].sh_offset);
ffffffffea8093d8:	d503201f 	nop
ffffffffea8093dc:	9bb70821 	umaddl	x1, w1, w23, x2
ffffffffea8093e0:	b9401038 	ldr	w24, [x1, #16]
ffffffffea8093e4:	8b150301 	add	x1, x24, x21
ffffffffea8093e8:	f9004fa1 	str	x1, [x29, #152]
		for (i = 0; i < ehdr->e_shnum; i++) {
ffffffffea8093ec:	34001b80 	cbz	w0, ffffffffea80975c <trusty_app_init+0x8ac>
ffffffffea8093f0:	9100a041 	add	x1, x2, #0x28
ffffffffea8093f4:	51000400 	sub	w0, w0, #0x1
ffffffffea8093f8:	aa0203f8 	mov	x24, x2
			else if (!strcmp((shstbl + shdr[i].sh_name), ".bss-pad")) {
ffffffffea8093fc:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809400:	91366082 	add	x2, x4, #0xd98
			else if (!strcmp((shstbl + shdr[i].sh_name),
ffffffffea809404:	b0000063 	adrp	x3, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
		bss_shdr = bss_pad_shdr = manifest_shdr = NULL;
ffffffffea809408:	a907ffa2 	stp	x2, xzr, [x29, #120]
ffffffffea80940c:	d2800019 	mov	x25, #0x0                   	// #0
			else if (!strcmp((shstbl + shdr[i].sh_name),
ffffffffea809410:	9136a062 	add	x2, x3, #0xda8
ffffffffea809414:	9bb70417 	umaddl	x23, w0, w23, x1
		trusty_app_max_extent = 0;
ffffffffea809418:	52800016 	mov	w22, #0x0                   	// #0
			else if (!strcmp((shstbl + shdr[i].sh_name),
ffffffffea80941c:	f90037a2 	str	x2, [x29, #104]
		bss_shdr = bss_pad_shdr = manifest_shdr = NULL;
ffffffffea809420:	f90047bf 	str	xzr, [x29, #136]
ffffffffea809424:	1400000f 	b	ffffffffea809460 <trusty_app_init+0x5b0>
				trusty_app->end_bss = bss_shdr->sh_addr + bss_shdr->sh_size;
ffffffffea809428:	b9400f00 	ldr	w0, [x24, #12]
ffffffffea80942c:	b9401701 	ldr	w1, [x24, #20]
ffffffffea809430:	f90047b8 	str	x24, [x29, #136]
ffffffffea809434:	0b010000 	add	w0, w0, w1
ffffffffea809438:	f9000280 	str	x0, [x20]
			if (shdr[i].sh_type != SHT_NOBITS) {
ffffffffea80943c:	7100237f 	cmp	w27, #0x8
ffffffffea809440:	540000a0 	b.eq	ffffffffea809454 <trusty_app_init+0x5a4>  // b.none
				extent = shdr[i].sh_offset + shdr[i].sh_size;
ffffffffea809444:	29420700 	ldp	w0, w1, [x24, #16]
ffffffffea809448:	0b010000 	add	w0, w0, w1
ffffffffea80944c:	6b0002df 	cmp	w22, w0
ffffffffea809450:	1a8022d6 	csel	w22, w22, w0, cs  // cs = hs, nlast
ffffffffea809454:	9100a318 	add	x24, x24, #0x28
		for (i = 0; i < ehdr->e_shnum; i++) {
ffffffffea809458:	eb1802ff 	cmp	x23, x24
ffffffffea80945c:	540002a0 	b.eq	ffffffffea8094b0 <trusty_app_init+0x600>  // b.none
			if (shdr[i].sh_type == SHT_NULL) {
ffffffffea809460:	b940071b 	ldr	w27, [x24, #4]
ffffffffea809464:	34ffff9b 	cbz	w27, ffffffffea809454 <trusty_app_init+0x5a4>
			if (!strcmp((shstbl + shdr[i].sh_name), ".bss")) {
ffffffffea809468:	a94903a1 	ldp	x1, x0, [x29, #144]
ffffffffea80946c:	b9400313 	ldr	w19, [x24]
ffffffffea809470:	8b130013 	add	x19, x0, x19
ffffffffea809474:	aa1303e0 	mov	x0, x19
ffffffffea809478:	9400288a 	bl	ffffffffea8136a0 <strcmp>
ffffffffea80947c:	34fffd60 	cbz	w0, ffffffffea809428 <trusty_app_init+0x578>
			else if (!strcmp((shstbl + shdr[i].sh_name), ".bss-pad")) {
ffffffffea809480:	f9403fa1 	ldr	x1, [x29, #120]
ffffffffea809484:	aa1303e0 	mov	x0, x19
ffffffffea809488:	94002886 	bl	ffffffffea8136a0 <strcmp>
ffffffffea80948c:	340000e0 	cbz	w0, ffffffffea8094a8 <trusty_app_init+0x5f8>
			else if (!strcmp((shstbl + shdr[i].sh_name),
ffffffffea809490:	f94037a1 	ldr	x1, [x29, #104]
ffffffffea809494:	aa1303e0 	mov	x0, x19
ffffffffea809498:	94002882 	bl	ffffffffea8136a0 <strcmp>
ffffffffea80949c:	7100001f 	cmp	w0, #0x0
ffffffffea8094a0:	9a981339 	csel	x25, x25, x24, ne  // ne = any
ffffffffea8094a4:	17ffffe6 	b	ffffffffea80943c <trusty_app_init+0x58c>
			else if (!strcmp((shstbl + shdr[i].sh_name), ".bss-pad")) {
ffffffffea8094a8:	f90043b8 	str	x24, [x29, #128]
ffffffffea8094ac:	17ffffe4 	b	ffffffffea80943c <trusty_app_init+0x58c>
		ASSERT(bss_shdr && bss_pad_shdr && manifest_shdr);
ffffffffea8094b0:	a94807a0 	ldp	x0, x1, [x29, #128]
ffffffffea8094b4:	f100003f 	cmp	x1, #0x0
ffffffffea8094b8:	fa401804 	ccmp	x0, #0x0, #0x4, ne  // ne = any
ffffffffea8094bc:	fa401b24 	ccmp	x25, #0x0, #0x4, ne  // ne = any
ffffffffea8094c0:	540014e0 	b.eq	ffffffffea80975c <trusty_app_init+0x8ac>  // b.none
		ASSERT((bss_shdr->sh_offset + bss_shdr->sh_size) <= trusty_app_max_extent);
ffffffffea8094c4:	29420820 	ldp	w0, w2, [x1, #16]
ffffffffea8094c8:	0b020001 	add	w1, w0, w2
ffffffffea8094cc:	6b16003f 	cmp	w1, w22
ffffffffea8094d0:	540018e8 	b.hi	ffffffffea8097ec <trusty_app_init+0x93c>  // b.pmore
		memset((uint8_t *)trusty_app_image_addr + bss_shdr->sh_offset, 0, bss_shdr->sh_size);
ffffffffea8094d4:	2a0203e2 	mov	w2, w2
ffffffffea8094d8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8094dc:	8b2042a0 	add	x0, x21, w0, uxtw
ffffffffea8094e0:	94002850 	bl	ffffffffea813620 <memset>
	ASSERT(shdr->sh_size >= sizeof(uuid_t));
ffffffffea8094e4:	29420323 	ldp	w3, w0, [x25, #16]
ffffffffea8094e8:	71003c1f 	cmp	w0, #0xf
ffffffffea8094ec:	54001929 	b.ls	ffffffffea809810 <trusty_app_init+0x960>  // b.plast
	trusty_app_idx = trusty_app - trusty_app_list;
ffffffffea8094f0:	900002a0 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
	trusty_app->props.vmid = task_vmid;
ffffffffea8094f4:	b94067a4 	ldr	w4, [x29, #100]
	manifest_data = (char *)(trusty_app_image_addr + shdr->sh_offset);
ffffffffea8094f8:	8b2342b3 	add	x19, x21, w3, uxtw
	trusty_app->props.min_stack_size = DEFAULT_STACK_SIZE;
ffffffffea8094fc:	52820003 	mov	w3, #0x1000                	// #4096
	trusty_app_idx = trusty_app - trusty_app_list;
ffffffffea809500:	f9479817 	ldr	x23, [x0, #3888]
	trusty_app->props.min_heap_size = 4 * PAGE_SIZE;
ffffffffea809504:	52880000 	mov	w0, #0x4000                	// #16384
ffffffffea809508:	b9003a80 	str	w0, [x20, #56]
	trusty_app_idx = trusty_app - trusty_app_list;
ffffffffea80950c:	d289d8a0 	mov	x0, #0x4ec5                	// #20165
ffffffffea809510:	cb170297 	sub	x23, x20, x23
ffffffffea809514:	f2b89d80 	movk	x0, #0xc4ec, lsl #16
ffffffffea809518:	f2dd89c0 	movk	x0, #0xec4e, lsl #32
	trusty_app->props.min_stack_size = DEFAULT_STACK_SIZE;
ffffffffea80951c:	29060e84 	stp	w4, w3, [x20, #48]
	trusty_app_idx = trusty_app - trusty_app_list;
ffffffffea809520:	9343fef7 	asr	x23, x23, #3
ffffffffea809524:	f2e9d880 	movk	x0, #0x4ec4, lsl #48
	memcpy(&trusty_app->props.uuid,
ffffffffea809528:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80952c:	aa1303e1 	mov	x1, x19
	trusty_app_idx = trusty_app - trusty_app_list;
ffffffffea809530:	9b007ef7 	mul	x23, x23, x0
	memcpy(&trusty_app->props.uuid,
ffffffffea809534:	91008280 	add	x0, x20, #0x20
ffffffffea809538:	9400277e 	bl	ffffffffea813330 <memcpy>
	PRINT_TRUSTY_APP_UUID(trusty_app_idx, &trusty_app->props.uuid, trusty_app->props.vmid);
ffffffffea80953c:	b9403280 	ldr	w0, [x20, #48]
ffffffffea809540:	2a1703e1 	mov	w1, w23
ffffffffea809544:	3940aa87 	ldrb	w7, [x20, #42]
ffffffffea809548:	3940a686 	ldrb	w6, [x20, #41]
ffffffffea80954c:	3940a285 	ldrb	w5, [x20, #40]
ffffffffea809550:	79404e84 	ldrh	w4, [x20, #38]
ffffffffea809554:	b9002be0 	str	w0, [sp, #40]
ffffffffea809558:	3940be80 	ldrb	w0, [x20, #47]
ffffffffea80955c:	b90023e0 	str	w0, [sp, #32]
ffffffffea809560:	3940ba80 	ldrb	w0, [x20, #46]
ffffffffea809564:	b9001be0 	str	w0, [sp, #24]
ffffffffea809568:	3940b680 	ldrb	w0, [x20, #45]
ffffffffea80956c:	b90013e0 	str	w0, [sp, #16]
ffffffffea809570:	3940b280 	ldrb	w0, [x20, #44]
ffffffffea809574:	b9000be0 	str	w0, [sp, #8]
ffffffffea809578:	3940ae80 	ldrb	w0, [x20, #43]
ffffffffea80957c:	b90003e0 	str	w0, [sp]
ffffffffea809580:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809584:	9138a000 	add	x0, x0, #0xe28
ffffffffea809588:	79404a83 	ldrh	w3, [x20, #36]
ffffffffea80958c:	b9402282 	ldr	w2, [x20, #32]
ffffffffea809590:	94002144 	bl	ffffffffea811aa0 <_dprintf>
	config_blob_size = (shdr->sh_size - sizeof(uuid_t));
ffffffffea809594:	b9401721 	ldr	w1, [x25, #20]
ffffffffea809598:	51004021 	sub	w1, w1, #0x10
	trusty_app->props.config_entry_cnt = config_blob_size / sizeof (u_int);
ffffffffea80959c:	53027c21 	lsr	w1, w1, #2
ffffffffea8095a0:	b9004281 	str	w1, [x20, #64]
	if (trusty_app->props.config_entry_cnt == 0) {
ffffffffea8095a4:	340004e1 	cbz	w1, ffffffffea809640 <trusty_app_init+0x790>
	manifest_data += sizeof(trusty_app->props.uuid);
ffffffffea8095a8:	91004263 	add	x3, x19, #0x10
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea8095ac:	52800000 	mov	w0, #0x0                   	// #0
	trusty_app->props.config_blob = config_blob;
ffffffffea8095b0:	f9002683 	str	x3, [x20, #72]
ffffffffea8095b4:	d503201f 	nop
		switch (config_blob[i]) {
ffffffffea8095b8:	b8605862 	ldr	w2, [x3, w0, uxtw #2]
ffffffffea8095bc:	7100085f 	cmp	w2, #0x2
ffffffffea8095c0:	54000260 	b.eq	ffffffffea80960c <trusty_app_init+0x75c>  // b.none
ffffffffea8095c4:	71000c5f 	cmp	w2, #0x3
ffffffffea8095c8:	54000b20 	b.eq	ffffffffea80972c <trusty_app_init+0x87c>  // b.none
ffffffffea8095cc:	7100045f 	cmp	w2, #0x1
ffffffffea8095d0:	540008a0 	b.eq	ffffffffea8096e4 <trusty_app_init+0x834>  // b.none
			dprintf(CRITICAL,
ffffffffea8095d4:	b0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8095d8:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8095dc:	912f8021 	add	x1, x1, #0xbe0
ffffffffea8095e0:	913c8000 	add	x0, x0, #0xf20
ffffffffea8095e4:	9400212f 	bl	ffffffffea811aa0 <_dprintf>
			ASSERT(0);
ffffffffea8095e8:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea8095ec:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8095f0:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8095f4:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8095f8:	52801be3 	mov	w3, #0xdf                  	// #223
ffffffffea8095fc:	913d0084 	add	x4, x4, #0xf40
ffffffffea809600:	9131a042 	add	x2, x2, #0xc68
ffffffffea809604:	9135a021 	add	x1, x1, #0xd68
ffffffffea809608:	940021a4 	bl	ffffffffea811c98 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 1);
ffffffffea80960c:	4b000022 	sub	w2, w1, w0
ffffffffea809610:	7100045f 	cmp	w2, #0x1
ffffffffea809614:	54001109 	b.ls	ffffffffea809834 <trusty_app_init+0x984>  // b.plast
			trusty_app->props.min_heap_size =
ffffffffea809618:	11000400 	add	w0, w0, #0x1
				ROUNDUP(config_blob[++i], 4096);
ffffffffea80961c:	b8605862 	ldr	w2, [x3, w0, uxtw #2]
ffffffffea809620:	113ffc42 	add	w2, w2, #0xfff
ffffffffea809624:	12144c42 	and	w2, w2, #0xfffff000
			trusty_app->props.min_heap_size =
ffffffffea809628:	b9003a82 	str	w2, [x20, #56]
			ASSERT(trusty_app->props.min_heap_size > 0);
ffffffffea80962c:	340013a2 	cbz	w2, ffffffffea8098a0 <trusty_app_init+0x9f0>
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea809630:	11000400 	add	w0, w0, #0x1
ffffffffea809634:	6b00003f 	cmp	w1, w0
ffffffffea809638:	54fffc08 	b.hi	ffffffffea8095b8 <trusty_app_init+0x708>  // b.pmore
ffffffffea80963c:	d503201f 	nop
	ASSERT(ROUNDUP(max_extent, 4) == elf_hdr->e_shoff);
ffffffffea809640:	b94022a0 	ldr	w0, [x21, #32]
ffffffffea809644:	11000ed6 	add	w22, w22, #0x3
		trusty_app->app_img = ehdr;
ffffffffea809648:	f9002a95 	str	x21, [x20, #80]
	ASSERT(ROUNDUP(max_extent, 4) == elf_hdr->e_shoff);
ffffffffea80964c:	121e76d6 	and	w22, w22, #0xfffffffc
ffffffffea809650:	6b0002df 	cmp	w22, w0
ffffffffea809654:	540014a1 	b.ne	ffffffffea8098e8 <trusty_app_init+0xa38>  // b.any
	max_extent = (elf_hdr->e_shoff + (elf_hdr->e_shnum * elf_hdr->e_shentsize)) - 1;
ffffffffea809658:	794062a1 	ldrh	w1, [x21, #48]
ffffffffea80965c:	79405ea2 	ldrh	w2, [x21, #46]
	ASSERT((trusty_app_image_addr + max_extent + 1) <= trusty_app_image_end);
ffffffffea809660:	f9478f80 	ldr	x0, [x28, #3864]
	max_extent = (elf_hdr->e_shoff + (elf_hdr->e_shnum * elf_hdr->e_shentsize)) - 1;
ffffffffea809664:	1b025836 	madd	w22, w1, w2, w22
ffffffffea809668:	510006d7 	sub	w23, w22, #0x1
ffffffffea80966c:	aa1703f6 	mov	x22, x23
	ASSERT((trusty_app_image_addr + max_extent + 1) <= trusty_app_image_end);
ffffffffea809670:	910006f7 	add	x23, x23, #0x1
ffffffffea809674:	8b1702a1 	add	x1, x21, x23
ffffffffea809678:	eb00003f 	cmp	x1, x0
ffffffffea80967c:	54001488 	b.hi	ffffffffea80990c <trusty_app_init+0xa5c>  // b.pmore
	next_trusty_app_align_start = trusty_app_image_addr + pad_hdr->sh_offset + pad_hdr->sh_size;
ffffffffea809680:	f94043a2 	ldr	x2, [x29, #128]
ffffffffea809684:	29420858 	ldp	w24, w2, [x2, #16]
ffffffffea809688:	8b020318 	add	x24, x24, x2
ffffffffea80968c:	8b1802b5 	add	x21, x21, x24
	ASSERT(next_trusty_app_align_start <= next_trusty_app_fsize_start);
ffffffffea809690:	eb15003f 	cmp	x1, x21
ffffffffea809694:	540014e3 	b.cc	ffffffffea809930 <trusty_app_init+0xa80>  // b.lo, b.ul, b.last
	copy_size = trusty_app_image_end - next_trusty_app_fsize_start;
ffffffffea809698:	cb010000 	sub	x0, x0, x1
	if (copy_size) {
ffffffffea80969c:	35000720 	cbnz	w0, ffffffffea809780 <trusty_app_init+0x8d0>
	trusty_app_image_size -= (max_extent + 1);
ffffffffea8096a0:	b94f2340 	ldr	w0, [x26, #3872]
		ASSERT((trusty_app_count + 1) < MAX_TRUSTY_APP_COUNT);
ffffffffea8096a4:	900002b3 	adrp	x19, ffffffffea85d000 <idle_threads+0xeb0>
	trusty_app_image_size -= (max_extent + 1);
ffffffffea8096a8:	51000400 	sub	w0, w0, #0x1
		ASSERT((trusty_app_count + 1) < MAX_TRUSTY_APP_COUNT);
ffffffffea8096ac:	b94f1261 	ldr	w1, [x19, #3856]
	trusty_app_image_size -= (max_extent + 1);
ffffffffea8096b0:	4b160016 	sub	w22, w0, w22
ffffffffea8096b4:	b90f2356 	str	w22, [x26, #3872]
		ASSERT((trusty_app_count + 1) < MAX_TRUSTY_APP_COUNT);
ffffffffea8096b8:	11000420 	add	w0, w1, #0x1
ffffffffea8096bc:	7100981f 	cmp	w0, #0x26
ffffffffea8096c0:	540014a8 	b.hi	ffffffffea809954 <trusty_app_init+0xaa4>  // b.pmore
		trusty_app_count++;
ffffffffea8096c4:	b90f1260 	str	w0, [x19, #3856]
		trusty_app++;
ffffffffea8096c8:	9101a294 	add	x20, x20, #0x68
	while (trusty_app_image_size > 0) {
ffffffffea8096cc:	35ffe396 	cbnz	w22, ffffffffea80933c <trusty_app_init+0x48c>
ffffffffea8096d0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8096d4:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea8096d8:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea8096dc:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea8096e0:	17fffe1d 	b	ffffffffea808f54 <trusty_app_init+0xa4>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 1);
ffffffffea8096e4:	4b000022 	sub	w2, w1, w0
ffffffffea8096e8:	7100045f 	cmp	w2, #0x1
ffffffffea8096ec:	54000b69 	b.ls	ffffffffea809858 <trusty_app_init+0x9a8>  // b.plast
			trusty_app->props.min_stack_size =
ffffffffea8096f0:	11000400 	add	w0, w0, #0x1
				ROUNDUP(config_blob[++i], 4096);
ffffffffea8096f4:	b8605862 	ldr	w2, [x3, w0, uxtw #2]
ffffffffea8096f8:	113ffc42 	add	w2, w2, #0xfff
ffffffffea8096fc:	12144c42 	and	w2, w2, #0xfffff000
			trusty_app->props.min_stack_size =
ffffffffea809700:	b9003682 	str	w2, [x20, #52]
			ASSERT(trusty_app->props.min_stack_size > 0);
ffffffffea809704:	35fff962 	cbnz	w2, ffffffffea809630 <trusty_app_init+0x780>
ffffffffea809708:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea80970c:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809710:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809714:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809718:	913a8084 	add	x4, x4, #0xea0
ffffffffea80971c:	52801983 	mov	w3, #0xcc                  	// #204
ffffffffea809720:	9131a042 	add	x2, x2, #0xc68
ffffffffea809724:	9135a021 	add	x1, x1, #0xd68
ffffffffea809728:	9400215c 	bl	ffffffffea811c98 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 3);
ffffffffea80972c:	4b000022 	sub	w2, w1, w0
ffffffffea809730:	71000c5f 	cmp	w2, #0x3
ffffffffea809734:	54000a49 	b.ls	ffffffffea80987c <trusty_app_init+0x9cc>  // b.plast
			trusty_app->props.map_io_mem_cnt++;
ffffffffea809738:	b9403e82 	ldr	w2, [x20, #60]
			i += 3;
ffffffffea80973c:	11000c00 	add	w0, w0, #0x3
			trusty_app->props.map_io_mem_cnt++;
ffffffffea809740:	11000442 	add	w2, w2, #0x1
ffffffffea809744:	b9003e82 	str	w2, [x20, #60]
ffffffffea809748:	17ffffba 	b	ffffffffea809630 <trusty_app_init+0x780>
		dprintf(SPEW, "VMID not found\n");
ffffffffea80974c:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809750:	91346000 	add	x0, x0, #0xd18
ffffffffea809754:	940020d3 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea809758:	17ffff15 	b	ffffffffea8093ac <trusty_app_init+0x4fc>
		ASSERT(bss_shdr && bss_pad_shdr && manifest_shdr);
ffffffffea80975c:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea809760:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809764:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809768:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80976c:	91358084 	add	x4, x4, #0xd60
ffffffffea809770:	52804723 	mov	w3, #0x239                 	// #569
ffffffffea809774:	9131a042 	add	x2, x2, #0xc68
ffffffffea809778:	9135a021 	add	x1, x1, #0xd68
ffffffffea80977c:	94002147 	bl	ffffffffea811c98 <_panic>
		memcpy(next_trusty_app_align_start, next_trusty_app_fsize_start, copy_size);
ffffffffea809780:	92407c13 	and	x19, x0, #0xffffffff
ffffffffea809784:	aa1503e0 	mov	x0, x21
ffffffffea809788:	aa1303e2 	mov	x2, x19
ffffffffea80978c:	940026e9 	bl	ffffffffea813330 <memcpy>
		arch_sync_cache_range((addr_t)next_trusty_app_align_start,
ffffffffea809790:	aa1503e0 	mov	x0, x21
ffffffffea809794:	aa1303e1 	mov	x1, x19
		trusty_app_image_end -= (next_trusty_app_fsize_start - next_trusty_app_align_start);
ffffffffea809798:	cb1802f7 	sub	x23, x23, x24
		arch_sync_cache_range((addr_t)next_trusty_app_align_start,
ffffffffea80979c:	97ffe0b7 	bl	ffffffffea801a78 <arch_sync_cache_range>
		trusty_app_image_end -= (next_trusty_app_fsize_start - next_trusty_app_align_start);
ffffffffea8097a0:	f9478f80 	ldr	x0, [x28, #3864]
ffffffffea8097a4:	cb170017 	sub	x23, x0, x23
ffffffffea8097a8:	f9078f97 	str	x23, [x28, #3864]
ffffffffea8097ac:	17ffffbd 	b	ffffffffea8096a0 <trusty_app_init+0x7f0>
			platform_disable_debug_intf();
ffffffffea8097b0:	97ffe28a 	bl	ffffffffea8021d8 <platform_disable_debug_intf>
ffffffffea8097b4:	17fffeed 	b	ffffffffea809368 <trusty_app_init+0x4b8>
	ASSERT(!((uintptr_t)trusty_app_image_start & PAGE_MASK));
ffffffffea8097b8:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8097bc:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8097c0:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8097c4:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8097c8:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea8097cc:	9130c084 	add	x4, x4, #0xc30
ffffffffea8097d0:	52804f23 	mov	w3, #0x279                 	// #633
ffffffffea8097d4:	9131a042 	add	x2, x2, #0xc68
ffffffffea8097d8:	9135a021 	add	x1, x1, #0xd68
ffffffffea8097dc:	aa1e03e0 	mov	x0, x30
ffffffffea8097e0:	f90023b9 	str	x25, [x29, #64]
ffffffffea8097e4:	f9002bbb 	str	x27, [x29, #80]
ffffffffea8097e8:	9400212c 	bl	ffffffffea811c98 <_panic>
		ASSERT((bss_shdr->sh_offset + bss_shdr->sh_size) <= trusty_app_max_extent);
ffffffffea8097ec:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea8097f0:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8097f4:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8097f8:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8097fc:	91370084 	add	x4, x4, #0xdc0
ffffffffea809800:	52804783 	mov	w3, #0x23c                 	// #572
ffffffffea809804:	9131a042 	add	x2, x2, #0xc68
ffffffffea809808:	9135a021 	add	x1, x1, #0xd68
ffffffffea80980c:	94002123 	bl	ffffffffea811c98 <_panic>
	ASSERT(shdr->sh_size >= sizeof(uuid_t));
ffffffffea809810:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea809814:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809818:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80981c:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809820:	91382084 	add	x4, x4, #0xe08
ffffffffea809824:	528013e3 	mov	w3, #0x9f                  	// #159
ffffffffea809828:	9131a042 	add	x2, x2, #0xc68
ffffffffea80982c:	9135a021 	add	x1, x1, #0xd68
ffffffffea809830:	9400211a 	bl	ffffffffea811c98 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 1);
ffffffffea809834:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea809838:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80983c:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809840:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809844:	9139c084 	add	x4, x4, #0xe70
ffffffffea809848:	52801a03 	mov	w3, #0xd0                  	// #208
ffffffffea80984c:	9131a042 	add	x2, x2, #0xc68
ffffffffea809850:	9135a021 	add	x1, x1, #0xd68
ffffffffea809854:	94002111 	bl	ffffffffea811c98 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 1);
ffffffffea809858:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea80985c:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809860:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809864:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809868:	9139c084 	add	x4, x4, #0xe70
ffffffffea80986c:	52801923 	mov	w3, #0xc9                  	// #201
ffffffffea809870:	9131a042 	add	x2, x2, #0xc68
ffffffffea809874:	9135a021 	add	x1, x1, #0xd68
ffffffffea809878:	94002108 	bl	ffffffffea811c98 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 3);
ffffffffea80987c:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea809880:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809884:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809888:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80988c:	913bc084 	add	x4, x4, #0xef0
ffffffffea809890:	52801ae3 	mov	w3, #0xd7                  	// #215
ffffffffea809894:	9131a042 	add	x2, x2, #0xc68
ffffffffea809898:	9135a021 	add	x1, x1, #0xd68
ffffffffea80989c:	940020ff 	bl	ffffffffea811c98 <_panic>
			ASSERT(trusty_app->props.min_heap_size > 0);
ffffffffea8098a0:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea8098a4:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8098a8:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8098ac:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8098b0:	913b2084 	add	x4, x4, #0xec8
ffffffffea8098b4:	52801a63 	mov	w3, #0xd3                  	// #211
ffffffffea8098b8:	9131a042 	add	x2, x2, #0xc68
ffffffffea8098bc:	9135a021 	add	x1, x1, #0xd68
ffffffffea8098c0:	940020f6 	bl	ffffffffea811c98 <_panic>
		ASSERT(!(prg_hdr->p_vaddr & PAGE_MASK) &&
ffffffffea8098c4:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea8098c8:	d0000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea8098cc:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8098d0:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8098d4:	91024084 	add	x4, x4, #0x90
ffffffffea8098d8:	528027e3 	mov	w3, #0x13f                 	// #319
ffffffffea8098dc:	9131a042 	add	x2, x2, #0xc68
ffffffffea8098e0:	9135a021 	add	x1, x1, #0xd68
ffffffffea8098e4:	940020ed 	bl	ffffffffea811c98 <_panic>
	ASSERT(ROUNDUP(max_extent, 4) == elf_hdr->e_shoff);
ffffffffea8098e8:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea8098ec:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8098f0:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8098f4:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8098f8:	913d2084 	add	x4, x4, #0xf48
ffffffffea8098fc:	52803523 	mov	w3, #0x1a9                 	// #425
ffffffffea809900:	9131a042 	add	x2, x2, #0xc68
ffffffffea809904:	9135a021 	add	x1, x1, #0xd68
ffffffffea809908:	940020e4 	bl	ffffffffea811c98 <_panic>
	ASSERT((trusty_app_image_addr + max_extent + 1) <= trusty_app_image_end);
ffffffffea80990c:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea809910:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809914:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809918:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80991c:	913de084 	add	x4, x4, #0xf78
ffffffffea809920:	528035c3 	mov	w3, #0x1ae                 	// #430
ffffffffea809924:	9131a042 	add	x2, x2, #0xc68
ffffffffea809928:	9135a021 	add	x1, x1, #0xd68
ffffffffea80992c:	940020db 	bl	ffffffffea811c98 <_panic>
	ASSERT(next_trusty_app_align_start <= next_trusty_app_fsize_start);
ffffffffea809930:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea809934:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809938:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80993c:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809940:	913f0084 	add	x4, x4, #0xfc0
ffffffffea809944:	52803643 	mov	w3, #0x1b2                 	// #434
ffffffffea809948:	9131a042 	add	x2, x2, #0xc68
ffffffffea80994c:	9135a021 	add	x1, x1, #0xd68
ffffffffea809950:	940020d2 	bl	ffffffffea811c98 <_panic>
		ASSERT((trusty_app_count + 1) < MAX_TRUSTY_APP_COUNT);
ffffffffea809954:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea809958:	d0000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80995c:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea809960:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809964:	91000084 	add	x4, x4, #0x0
ffffffffea809968:	528048a3 	mov	w3, #0x245                 	// #581
ffffffffea80996c:	9131a042 	add	x2, x2, #0xc68
ffffffffea809970:	9135a021 	add	x1, x1, #0xd68
ffffffffea809974:	940020c9 	bl	ffffffffea811c98 <_panic>
			dprintf(CRITICAL, "trusty_app_bootloader: ELF header not found\n");
ffffffffea809978:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea80997c:	900002b3 	adrp	x19, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea809980:	9134c000 	add	x0, x0, #0xd30
ffffffffea809984:	94002047 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea809988:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80998c:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea809990:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea809994:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea809998:	17fffd6f 	b	ffffffffea808f54 <trusty_app_init+0xa4>
			dprintf(CRITICAL, "VMID convert fail\n");
ffffffffea80999c:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8099a0:	91334000 	add	x0, x0, #0xcd0
ffffffffea8099a4:	9400203f 	bl	ffffffffea811aa0 <_dprintf>
			panic("failed to get trusty app image address \n");
ffffffffea8099a8:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea8099ac:	b0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1770+0x420>
ffffffffea8099b0:	9133a021 	add	x1, x1, #0xce8
ffffffffea8099b4:	940020b9 	bl	ffffffffea811c98 <_panic>
	heap = memalign(PAGE_SIZE, trusty_app->props.min_heap_size);
ffffffffea8099b8:	d2820000 	mov	x0, #0x1000                	// #4096
ffffffffea8099bc:	94002647 	bl	ffffffffea8132d8 <memalign>
ffffffffea8099c0:	aa0003fa 	mov	x26, x0
	if (heap == 0) {
ffffffffea8099c4:	b40005c0 	cbz	x0, ffffffffea809a7c <trusty_app_init+0xbcc>
	memset(heap, 0, trusty_app->props.min_heap_size);
ffffffffea8099c8:	b9403b02 	ldr	w2, [x24, #56]
ffffffffea8099cc:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8099d0:	94002714 	bl	ffffffffea813620 <memset>
	status = uthread_map_contig(trusty_app->ut, &vaddr,
ffffffffea8099d4:	f9402f19 	ldr	x25, [x24, #88]
	vaddr = trusty_app->end_brk;
ffffffffea8099d8:	f9400f00 	ldr	x0, [x24, #24]
ffffffffea8099dc:	f9006ba0 	str	x0, [x29, #208]
ffffffffea8099e0:	aa1a03e0 	mov	x0, x26
ffffffffea8099e4:	94001d2d 	bl	ffffffffea810e98 <kvaddr_to_paddr>
ffffffffea8099e8:	910443a2 	add	x2, x29, #0x110
	status = uthread_map_contig(trusty_app->ut, &vaddr,
ffffffffea8099ec:	b9403b03 	ldr	w3, [x24, #56]
ffffffffea8099f0:	52820005 	mov	w5, #0x1000                	// #4096
ffffffffea8099f4:	52802464 	mov	w4, #0x123                 	// #291
ffffffffea8099f8:	910343a1 	add	x1, x29, #0xd0
ffffffffea8099fc:	f8198c40 	str	x0, [x2, #-104]!
ffffffffea809a00:	aa1903e0 	mov	x0, x25
ffffffffea809a04:	9400290d 	bl	ffffffffea813e38 <uthread_map>
	if (status != NO_ERROR || vaddr != trusty_app->end_brk) {
ffffffffea809a08:	35000280 	cbnz	w0, ffffffffea809a58 <trusty_app_init+0xba8>
ffffffffea809a0c:	f9400f01 	ldr	x1, [x24, #24]
ffffffffea809a10:	f9406ba0 	ldr	x0, [x29, #208]
ffffffffea809a14:	eb00003f 	cmp	x1, x0
ffffffffea809a18:	54000201 	b.ne	ffffffffea809a58 <trusty_app_init+0xba8>  // b.any
	trusty_app->end_brk += trusty_app->props.min_heap_size;
ffffffffea809a1c:	b9403b00 	ldr	w0, [x24, #56]
ffffffffea809a20:	8b010000 	add	x0, x0, x1
ffffffffea809a24:	f9000f00 	str	x0, [x24, #24]
ffffffffea809a28:	17fffddc 	b	ffffffffea809198 <trusty_app_init+0x2e8>
			dprintf(CRITICAL, "cannot map the segment\n");
ffffffffea809a2c:	d0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea809a30:	91036000 	add	x0, x0, #0xd8
ffffffffea809a34:	9400201b 	bl	ffffffffea811aa0 <_dprintf>
			panic("failed to load address map\n");
ffffffffea809a38:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea809a3c:	d0000061 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea809a40:	91096021 	add	x1, x1, #0x258
ffffffffea809a44:	94002095 	bl	ffffffffea811c98 <_panic>
			dprintf(CRITICAL,
ffffffffea809a48:	d0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea809a4c:	9103c000 	add	x0, x0, #0xf0
ffffffffea809a50:	94002014 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea809a54:	17fffff9 	b	ffffffffea809a38 <trusty_app_init+0xb88>
		dprintf(CRITICAL, "cannot map brk\n");
ffffffffea809a58:	d0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea809a5c:	9104a000 	add	x0, x0, #0x128
ffffffffea809a60:	94002010 	bl	ffffffffea811aa0 <_dprintf>
		free(heap);
ffffffffea809a64:	aa1a03e0 	mov	x0, x26
ffffffffea809a68:	94002630 	bl	ffffffffea813328 <free>
		dprintf(CRITICAL, "failed to load trusty_app: trusty_app heap creation error\n");
ffffffffea809a6c:	d0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea809a70:	9104e000 	add	x0, x0, #0x138
ffffffffea809a74:	9400200b 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea809a78:	17fffff0 	b	ffffffffea809a38 <trusty_app_init+0xb88>
ffffffffea809a7c:	d0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea809a80:	9104e000 	add	x0, x0, #0x138
ffffffffea809a84:	94002007 	bl	ffffffffea811aa0 <_dprintf>
ffffffffea809a88:	17ffffec 	b	ffffffffea809a38 <trusty_app_init+0xb88>
					panic("failed (%d) to invoke startup notifier\n", ret);
ffffffffea809a8c:	2a0003e2 	mov	w2, w0
ffffffffea809a90:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea809a94:	d0000061 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea809a98:	910a8021 	add	x1, x1, #0x2a0
ffffffffea809a9c:	9400207f 	bl	ffffffffea811c98 <_panic>
			panic("allocate user thread failed\n");
ffffffffea809aa0:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea809aa4:	d0000061 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea809aa8:	91014021 	add	x1, x1, #0x50
ffffffffea809aac:	9400207b 	bl	ffffffffea811c98 <_panic>
			panic("allocate app local storage failed\n");
ffffffffea809ab0:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea809ab4:	d0000061 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea809ab8:	9109e021 	add	x1, x1, #0x278
ffffffffea809abc:	94002077 	bl	ffffffffea811c98 <_panic>
ffffffffea809ac0:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea809ac4:	17fffd24 	b	ffffffffea808f54 <trusty_app_init+0xa4>

ffffffffea809ac8 <sys_std_write>:
	return uthread_is_valid_range(uthread_get_current(), addr, size);
}

/* handle stdout/stderr */
static int32_t sys_std_write(uint32_t fd, user_addr_t user_ptr, uint32_t size)
{
ffffffffea809ac8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea809acc:	910003fd 	mov	x29, sp
ffffffffea809ad0:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea809ad4:	2a0203f5 	mov	w21, w2
	/* check buffer is in task's address space */
	if (!valid_address((vaddr_t)user_ptr, size)) {
ffffffffea809ad8:	2a0103f4 	mov	w20, w1
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea809adc:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea809ae0:	f9415800 	ldr	x0, [x0, #688]
ffffffffea809ae4:	aa1503e2 	mov	x2, x21
ffffffffea809ae8:	aa1403e1 	mov	x1, x20
ffffffffea809aec:	94002a8b 	bl	ffffffffea814518 <uthread_is_valid_range>
	if (!valid_address((vaddr_t)user_ptr, size)) {
ffffffffea809af0:	72001c1f 	tst	w0, #0xff
ffffffffea809af4:	54000140 	b.eq	ffffffffea809b1c <sys_std_write+0x54>  // b.none
ffffffffea809af8:	f9000bb3 	str	x19, [x29, #16]
		return ERR_INVALID_ARGS;
	}
	/* always send out error logs */
	dwrite((fd == 2) ? ALWAYS : INFO, (const void *)(uintptr_t)user_ptr, size);
ffffffffea809afc:	aa1503e1 	mov	x1, x21
ffffffffea809b00:	aa1403e0 	mov	x0, x20
ffffffffea809b04:	94001fbd 	bl	ffffffffea8119f8 <_dwrite>

	return size;
ffffffffea809b08:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea809b0c:	2a1503e0 	mov	w0, w21
}
ffffffffea809b10:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea809b14:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809b18:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea809b1c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea809b20:	17fffffc 	b	ffffffffea809b10 <sys_std_write+0x48>
ffffffffea809b24:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809b28 <sys_write>:
	if (fd >= countof(sys_fds)) {
ffffffffea809b28:	7100241f 	cmp	w0, #0x9
ffffffffea809b2c:	540001c8 	b.hi	ffffffffea809b64 <sys_write+0x3c>  // b.pmore
ffffffffea809b30:	2a0003e4 	mov	w4, w0
	return sys_fds[fd];
ffffffffea809b34:	90000083 	adrp	x3, ffffffffea819000 <_mem_phys_base>
ffffffffea809b38:	9134a063 	add	x3, x3, #0xd28
ffffffffea809b3c:	f8645863 	ldr	x3, [x3, w4, uxtw #3]

long sys_write(uint32_t fd, user_addr_t user_ptr, uint32_t size)
{
	const struct sys_fd_ops *ops = get_sys_fd_handler(fd);

	if (ops && ops->write) {
ffffffffea809b40:	b4000123 	cbz	x3, ffffffffea809b64 <sys_write+0x3c>
ffffffffea809b44:	f9400463 	ldr	x3, [x3, #8]
ffffffffea809b48:	b40000e3 	cbz	x3, ffffffffea809b64 <sys_write+0x3c>
{
ffffffffea809b4c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809b50:	910003fd 	mov	x29, sp
		return ops->write(fd, user_ptr, size);
ffffffffea809b54:	d63f0060 	blr	x3
ffffffffea809b58:	93407c00 	sxtw	x0, w0
	}
	return ERR_NOT_SUPPORTED;
}
ffffffffea809b5c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809b60:	d65f03c0 	ret
	return ERR_NOT_SUPPORTED;
ffffffffea809b64:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
}
ffffffffea809b68:	d65f03c0 	ret
ffffffffea809b6c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809b70 <sys_brk>:
ffffffffea809b70:	d538d081 	mrs	x1, tpidr_el1

long sys_brk(u_int brk)
{
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea809b74:	f9415821 	ldr	x1, [x1, #688]

	/* update brk, if within range */
	if ((brk >= trusty_app->start_brk) && (brk <= trusty_app->end_brk)) {
ffffffffea809b78:	2a0003e0 	mov	w0, w0
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea809b7c:	f9404821 	ldr	x1, [x1, #144]
	if ((brk >= trusty_app->start_brk) && (brk <= trusty_app->end_brk)) {
ffffffffea809b80:	f9400422 	ldr	x2, [x1, #8]
ffffffffea809b84:	eb02001f 	cmp	x0, x2
ffffffffea809b88:	540000c3 	b.cc	ffffffffea809ba0 <sys_brk+0x30>  // b.lo, b.ul, b.last
ffffffffea809b8c:	f9400c22 	ldr	x2, [x1, #24]
ffffffffea809b90:	eb02001f 	cmp	x0, x2
ffffffffea809b94:	54000068 	b.hi	ffffffffea809ba0 <sys_brk+0x30>  // b.pmore
		trusty_app->cur_brk = brk;
ffffffffea809b98:	f9000820 	str	x0, [x1, #16]
	}
	return (long) trusty_app->cur_brk;
}
ffffffffea809b9c:	d65f03c0 	ret
ffffffffea809ba0:	f9400820 	ldr	x0, [x1, #16]
ffffffffea809ba4:	d65f03c0 	ret

ffffffffea809ba8 <sys_exit_group>:

long sys_exit_group(void)
{
ffffffffea809ba8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809bac:	910003fd 	mov	x29, sp
ffffffffea809bb0:	d538d081 	mrs	x1, tpidr_el1
	thread_t *current = get_current_thread();
	dprintf(CRITICAL, "exit called, thread %p, name %s\n",
ffffffffea809bb4:	910ae022 	add	x2, x1, #0x2b8
ffffffffea809bb8:	d0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea809bbc:	910b6000 	add	x0, x0, #0x2d8
ffffffffea809bc0:	94001fb8 	bl	ffffffffea811aa0 <_dprintf>
		current, current->name);
	uthread_exit(0);
ffffffffea809bc4:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea809bc8:	9400287e 	bl	ffffffffea813dc0 <uthread_exit>
ffffffffea809bcc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809bd0 <sys_read>:
	if (fd >= countof(sys_fds)) {
ffffffffea809bd0:	7100241f 	cmp	w0, #0x9
ffffffffea809bd4:	540001c8 	b.hi	ffffffffea809c0c <sys_read+0x3c>  // b.pmore
ffffffffea809bd8:	2a0003e4 	mov	w4, w0
	return sys_fds[fd];
ffffffffea809bdc:	90000083 	adrp	x3, ffffffffea819000 <_mem_phys_base>
ffffffffea809be0:	9134a063 	add	x3, x3, #0xd28
ffffffffea809be4:	f8645863 	ldr	x3, [x3, w4, uxtw #3]

long sys_read(uint32_t fd, user_addr_t user_ptr, uint32_t size)
{
	const struct sys_fd_ops *ops = get_sys_fd_handler(fd);

	if (ops && ops->read) {
ffffffffea809be8:	b4000123 	cbz	x3, ffffffffea809c0c <sys_read+0x3c>
ffffffffea809bec:	f9400063 	ldr	x3, [x3]
ffffffffea809bf0:	b40000e3 	cbz	x3, ffffffffea809c0c <sys_read+0x3c>
{
ffffffffea809bf4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809bf8:	910003fd 	mov	x29, sp
		return ops->read(fd, user_ptr, size);
ffffffffea809bfc:	d63f0060 	blr	x3
ffffffffea809c00:	93407c00 	sxtw	x0, w0
	}
	return ERR_NOT_SUPPORTED;
}
ffffffffea809c04:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809c08:	d65f03c0 	ret
	return ERR_NOT_SUPPORTED;
ffffffffea809c0c:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
}
ffffffffea809c10:	d65f03c0 	ret
ffffffffea809c14:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809c18 <sys_ioctl>:
	if (fd >= countof(sys_fds)) {
ffffffffea809c18:	7100241f 	cmp	w0, #0x9
ffffffffea809c1c:	540001c8 	b.hi	ffffffffea809c54 <sys_ioctl+0x3c>  // b.pmore
ffffffffea809c20:	2a0003e4 	mov	w4, w0
	return sys_fds[fd];
ffffffffea809c24:	90000083 	adrp	x3, ffffffffea819000 <_mem_phys_base>
ffffffffea809c28:	9134a063 	add	x3, x3, #0xd28
ffffffffea809c2c:	f8645863 	ldr	x3, [x3, w4, uxtw #3]

long sys_ioctl(uint32_t fd, uint32_t req, user_addr_t user_ptr)
{
	const struct sys_fd_ops *ops = get_sys_fd_handler(fd);

	if (ops && ops->ioctl) {
ffffffffea809c30:	b4000123 	cbz	x3, ffffffffea809c54 <sys_ioctl+0x3c>
ffffffffea809c34:	f9400863 	ldr	x3, [x3, #16]
ffffffffea809c38:	b40000e3 	cbz	x3, ffffffffea809c54 <sys_ioctl+0x3c>
{
ffffffffea809c3c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809c40:	910003fd 	mov	x29, sp
		return ops->ioctl(fd, req, user_ptr);
ffffffffea809c44:	d63f0060 	blr	x3
ffffffffea809c48:	93407c00 	sxtw	x0, w0
	}
	return ERR_NOT_SUPPORTED;
}
ffffffffea809c4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809c50:	d65f03c0 	ret
	return ERR_NOT_SUPPORTED;
ffffffffea809c54:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
}
ffffffffea809c58:	d65f03c0 	ret
ffffffffea809c5c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809c60 <sys_nanosleep>:
#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))

long sys_nanosleep(uint32_t clock_id, uint32_t flags,
		   uint32_t sleep_time_l, uint32_t sleep_time_h)
{
	uint64_t sleep_time = sleep_time_l + ((uint64_t)sleep_time_h << 32);
ffffffffea809c60:	2a0203e2 	mov	w2, w2
	thread_sleep((lk_time_t)(DIV_ROUND_UP(sleep_time, 1000 * 1000)));
ffffffffea809c64:	d2869b61 	mov	x1, #0x34db                	// #13531
	uint64_t sleep_time = sleep_time_l + ((uint64_t)sleep_time_h << 32);
ffffffffea809c68:	8b038040 	add	x0, x2, x3, lsl #32
	thread_sleep((lk_time_t)(DIV_ROUND_UP(sleep_time, 1000 * 1000)));
ffffffffea809c6c:	f2baf6c1 	movk	x1, #0xd7b6, lsl #16
ffffffffea809c70:	9143d000 	add	x0, x0, #0xf4, lsl #12
ffffffffea809c74:	f2dbd041 	movk	x1, #0xde82, lsl #32
ffffffffea809c78:	9108fc00 	add	x0, x0, #0x23f
ffffffffea809c7c:	f2e86361 	movk	x1, #0x431b, lsl #48
{
ffffffffea809c80:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	thread_sleep((lk_time_t)(DIV_ROUND_UP(sleep_time, 1000 * 1000)));
ffffffffea809c84:	9bc17c00 	umulh	x0, x0, x1
{
ffffffffea809c88:	910003fd 	mov	x29, sp
	thread_sleep((lk_time_t)(DIV_ROUND_UP(sleep_time, 1000 * 1000)));
ffffffffea809c8c:	d352c400 	ubfx	x0, x0, #18, #32
ffffffffea809c90:	97fff23e 	bl	ffffffffea806588 <thread_sleep>

	return NO_ERROR;
}
ffffffffea809c94:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea809c98:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809c9c:	d65f03c0 	ret

ffffffffea809ca0 <sys_gettime>:

long sys_gettime(uint32_t clock_id, uint32_t flags, user_addr_t time)
{
ffffffffea809ca0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea809ca4:	910003fd 	mov	x29, sp
ffffffffea809ca8:	f9000bf3 	str	x19, [sp, #16]
ffffffffea809cac:	2a0203f3 	mov	w19, w2
	// return time in nanoseconds
	lk_bigtime_t t = current_time_hires() * 1000;
ffffffffea809cb0:	97ffedde 	bl	ffffffffea805428 <current_time_hires>
ffffffffea809cb4:	aa0003e4 	mov	x4, x0
ffffffffea809cb8:	9100c3a1 	add	x1, x29, #0x30
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea809cbc:	2a1303e0 	mov	w0, w19
ffffffffea809cc0:	d37be883 	lsl	x3, x4, #5
ffffffffea809cc4:	d2800102 	mov	x2, #0x8                   	// #8
ffffffffea809cc8:	cb040063 	sub	x3, x3, x4
ffffffffea809ccc:	8b030883 	add	x3, x4, x3, lsl #2
ffffffffea809cd0:	d37df063 	lsl	x3, x3, #3
ffffffffea809cd4:	f81f8c23 	str	x3, [x1, #-8]!
ffffffffea809cd8:	94002710 	bl	ffffffffea813918 <arch_copy_to_user>

	return copy_to_user(time, &t, sizeof(uint64_t));
}
ffffffffea809cdc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea809ce0:	93407c00 	sxtw	x0, w0
ffffffffea809ce4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809ce8:	d65f03c0 	ret
ffffffffea809cec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809cf0 <sys_mmap>:

long sys_mmap(user_addr_t uaddr, uint32_t size, uint32_t flags, uint32_t handle)
{
ffffffffea809cf0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea809cf4:	2a0303e5 	mov	w5, w3
ffffffffea809cf8:	910003fd 	mov	x29, sp
ffffffffea809cfc:	d538d083 	mrs	x3, tpidr_el1
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea809d00:	f9415863 	ldr	x3, [x3, #688]
ffffffffea809d04:	f9404864 	ldr	x4, [x3, #144]
	long ret;

	/*
	 * Allocate and map memory with Device attributes
	 */
	if (flags & MMAP_FLAG_DEVICE_MEM) {
ffffffffea809d08:	370801e2 	tbnz	w2, #1, ffffffffea809d44 <sys_mmap+0x54>
	/*
	 * Only allows mapping on IO region specified by handle (id) and uaddr
	 * must be 0 for now.
	 * TBD: Add support in uthread_map to use uaddr as a hint.
	 */
	if (flags != MMAP_FLAG_IO_HANDLE || uaddr != 0) {
ffffffffea809d0c:	7100001f 	cmp	w0, #0x0
ffffffffea809d10:	7a410840 	ccmp	w2, #0x1, #0x0, eq  // eq = none
ffffffffea809d14:	54000301 	b.ne	ffffffffea809d74 <sys_mmap+0x84>  // b.any
		return ERR_INVALID_ARGS;
	}
	ret = trusty_app_setup_mmio(trusty_app, handle, &vaddr, size);
ffffffffea809d18:	2a0103e3 	mov	w3, w1
ffffffffea809d1c:	910063a2 	add	x2, x29, #0x18
ffffffffea809d20:	2a0503e1 	mov	w1, w5
ffffffffea809d24:	aa0403e0 	mov	x0, x4
ffffffffea809d28:	97fffc3a 	bl	ffffffffea808e10 <trusty_app_setup_mmio>
ffffffffea809d2c:	93407c00 	sxtw	x0, w0
	if (ret != NO_ERROR) {
		return ret;
	}
	return vaddr;
ffffffffea809d30:	f9400fa1 	ldr	x1, [x29, #24]
ffffffffea809d34:	f100001f 	cmp	x0, #0x0
ffffffffea809d38:	9a800020 	csel	x0, x1, x0, eq  // eq = none
}
ffffffffea809d3c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea809d40:	d65f03c0 	ret
		ret = uthread_pmm_alloc_and_map(trusty_app->ut, &vaddr, size,
ffffffffea809d44:	f9402c80 	ldr	x0, [x4, #88]
ffffffffea809d48:	2a0203e3 	mov	w3, w2
ffffffffea809d4c:	52800024 	mov	w4, #0x1                   	// #1
ffffffffea809d50:	2a0103e2 	mov	w2, w1
ffffffffea809d54:	910063a1 	add	x1, x29, #0x18
ffffffffea809d58:	9400290c 	bl	ffffffffea814188 <uthread_pmm_alloc_and_map>
ffffffffea809d5c:	93407c00 	sxtw	x0, w0
		return vaddr;
ffffffffea809d60:	f9400fa1 	ldr	x1, [x29, #24]
ffffffffea809d64:	f100001f 	cmp	x0, #0x0
}
ffffffffea809d68:	a8c27bfd 	ldp	x29, x30, [sp], #32
		return vaddr;
ffffffffea809d6c:	9a800020 	csel	x0, x1, x0, eq  // eq = none
}
ffffffffea809d70:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea809d74:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea809d78:	17fffff1 	b	ffffffffea809d3c <sys_mmap+0x4c>
ffffffffea809d7c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809d80 <sys_munmap>:

long sys_munmap(user_addr_t uaddr, uint32_t size)
{
ffffffffea809d80:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809d84:	910003fd 	mov	x29, sp
ffffffffea809d88:	d538d082 	mrs	x2, tpidr_el1
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea809d8c:	f9415843 	ldr	x3, [x2, #688]

	/*
	 * uthread_unmap always unmaps whole region.
	 * TBD: Add support to unmap partial region when there's use case.
	 */
	return uthread_unmap(trusty_app->ut, uaddr, size);
ffffffffea809d90:	2a0103e2 	mov	w2, w1
ffffffffea809d94:	2a0003e1 	mov	w1, w0
ffffffffea809d98:	f9404860 	ldr	x0, [x3, #144]
ffffffffea809d9c:	f9402c00 	ldr	x0, [x0, #88]
ffffffffea809da0:	94002974 	bl	ffffffffea814370 <uthread_unmap>
}
ffffffffea809da4:	93407c00 	sxtw	x0, w0
ffffffffea809da8:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809dac:	d65f03c0 	ret

ffffffffea809db0 <sys_prepare_dma>:

#if UTHREAD_WITH_MEMORY_MAPPING_SUPPORT

long sys_prepare_dma(user_addr_t uaddr, uint32_t size, uint32_t flags,
		user_addr_t pmem)
{
ffffffffea809db0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea809db4:	910003fd 	mov	x29, sp
ffffffffea809db8:	f9000ff4 	str	x20, [sp, #24]
ffffffffea809dbc:	2a0103f4 	mov	w20, w1
ffffffffea809dc0:	f9001bf7 	str	x23, [sp, #48]
ffffffffea809dc4:	d538d081 	mrs	x1, tpidr_el1
}

static inline uthread_t *uthread_get_current(void)
{
	return (uthread_t *)tls_get(TLS_ENTRY_UTHREAD);
ffffffffea809dc8:	f9415837 	ldr	x23, [x1, #688]
	long ret;

	LTRACEF("uaddr 0x%x, size 0x%x, flags 0x%x, pmem 0x%x\n",
	        uaddr, size, flags, pmem);

	if (size == 0 || !valid_address((vaddr_t)uaddr, size)) {
ffffffffea809dcc:	340009b4 	cbz	w20, ffffffffea809f00 <sys_prepare_dma+0x150>
ffffffffea809dd0:	f9000bb3 	str	x19, [x29, #16]
ffffffffea809dd4:	2a0303f3 	mov	w19, w3
ffffffffea809dd8:	f90017b6 	str	x22, [x29, #40]
ffffffffea809ddc:	2a0003f6 	mov	w22, w0
ffffffffea809de0:	f90027ba 	str	x26, [x29, #72]
ffffffffea809de4:	2a0203fa 	mov	w26, w2
ffffffffea809de8:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea809dec:	f9415800 	ldr	x0, [x0, #688]
ffffffffea809df0:	2a1403e2 	mov	w2, w20
ffffffffea809df4:	aa1603e1 	mov	x1, x22
ffffffffea809df8:	940029c8 	bl	ffffffffea814518 <uthread_is_valid_range>
	if (size == 0 || !valid_address((vaddr_t)uaddr, size)) {
ffffffffea809dfc:	72001c1f 	tst	w0, #0xff
ffffffffea809e00:	540007a0 	b.eq	ffffffffea809ef4 <sys_prepare_dma+0x144>  // b.none
ffffffffea809e04:	f90013b5 	str	x21, [x29, #32]
	uint32_t entries = 0;
ffffffffea809e08:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea809e0c:	a903e7b8 	stp	x24, x25, [x29, #56]
		pmem += sizeof(struct dma_pmem);

		mapped_size += kpmem.size;
		entries++;

	} while (mapped_size < size && (flags & DMA_FLAG_MULTI_PMEM));
ffffffffea809e10:	121e0359 	and	w25, w26, #0x4
ffffffffea809e14:	f9002bbb 	str	x27, [x29, #80]
		kpmem.size = MIN(size - mapped_size,
ffffffffea809e18:	d2820018 	mov	x24, #0x1000                	// #4096
	uint32_t mapped_size = 0;
ffffffffea809e1c:	5280001b 	mov	w27, #0x0                   	// #0
ffffffffea809e20:	14000014 	b	ffffffffea809e70 <sys_prepare_dma+0xc0>
		kpmem.size = MIN(size - mapped_size,
ffffffffea809e24:	f94033a3 	ldr	x3, [x29, #96]
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea809e28:	2a1303e0 	mov	w0, w19
ffffffffea809e2c:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea809e30:	910183a1 	add	x1, x29, #0x60
ffffffffea809e34:	92402c63 	and	x3, x3, #0xfff
		pmem += sizeof(struct dma_pmem);
ffffffffea809e38:	11004273 	add	w19, w19, #0x10
		kpmem.size = MIN(size - mapped_size,
ffffffffea809e3c:	cb030303 	sub	x3, x24, x3
		entries++;
ffffffffea809e40:	110006b5 	add	w21, w21, #0x1
		kpmem.size = MIN(size - mapped_size,
ffffffffea809e44:	eb04007f 	cmp	x3, x4
ffffffffea809e48:	9a849063 	csel	x3, x3, x4, ls  // ls = plast
ffffffffea809e4c:	b9006ba3 	str	w3, [x29, #104]
ffffffffea809e50:	940026b2 	bl	ffffffffea813918 <arch_copy_to_user>
		ret = copy_to_user(pmem, &kpmem, sizeof(struct dma_pmem));
ffffffffea809e54:	93407c00 	sxtw	x0, w0
		if (ret != NO_ERROR) {
ffffffffea809e58:	b50001a0 	cbnz	x0, ffffffffea809e8c <sys_prepare_dma+0xdc>
		mapped_size += kpmem.size;
ffffffffea809e5c:	b9406ba0 	ldr	w0, [x29, #104]
ffffffffea809e60:	0b00037b 	add	w27, w27, w0
	} while (mapped_size < size && (flags & DMA_FLAG_MULTI_PMEM));
ffffffffea809e64:	6b1b029f 	cmp	w20, w27
ffffffffea809e68:	54000229 	b.ls	ffffffffea809eac <sys_prepare_dma+0xfc>  // b.plast
ffffffffea809e6c:	34000219 	cbz	w25, ffffffffea809eac <sys_prepare_dma+0xfc>
		ret = uthread_virt_to_phys(current,
ffffffffea809e70:	8b3b42c1 	add	x1, x22, w27, uxtw
ffffffffea809e74:	910183a2 	add	x2, x29, #0x60
ffffffffea809e78:	aa1703e0 	mov	x0, x23
ffffffffea809e7c:	940029d1 	bl	ffffffffea8145c0 <uthread_virt_to_phys>
		kpmem.size = MIN(size - mapped_size,
ffffffffea809e80:	4b1b0284 	sub	w4, w20, w27
		ret = uthread_virt_to_phys(current,
ffffffffea809e84:	93407c00 	sxtw	x0, w0
		if (ret != NO_ERROR) {
ffffffffea809e88:	b4fffce0 	cbz	x0, ffffffffea809e24 <sys_prepare_dma+0x74>
ffffffffea809e8c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea809e90:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea809e94:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea809e98:	a944efba 	ldp	x26, x27, [x29, #72]
	}
	if (!(flags & DMA_FLAG_ALLOW_PARTIAL) && mapped_size != size) {
		return ERR_BAD_LEN;
	}
	return entries;
}
ffffffffea809e9c:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea809ea0:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea809ea4:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea809ea8:	d65f03c0 	ret
ffffffffea809eac:	2a1b03e1 	mov	w1, w27
		arch_clean_invalidate_cache_range(uaddr, mapped_size);
ffffffffea809eb0:	aa1603e0 	mov	x0, x22
	if (flags & DMA_FLAG_FROM_DEVICE) {
ffffffffea809eb4:	360801da 	tbz	w26, #1, ffffffffea809eec <sys_prepare_dma+0x13c>
		arch_clean_invalidate_cache_range(uaddr, mapped_size);
ffffffffea809eb8:	97ffe28a 	bl	ffffffffea8028e0 <arch_clean_invalidate_cache_range>
	if (!(flags & DMA_FLAG_ALLOW_PARTIAL) && mapped_size != size) {
ffffffffea809ebc:	f27d035f 	tst	x26, #0x8
	return entries;
ffffffffea809ec0:	f9400bb3 	ldr	x19, [x29, #16]
	if (!(flags & DMA_FLAG_ALLOW_PARTIAL) && mapped_size != size) {
ffffffffea809ec4:	7a5b0284 	ccmp	w20, w27, #0x4, eq  // eq = none
}
ffffffffea809ec8:	f9401bf7 	ldr	x23, [sp, #48]
	return entries;
ffffffffea809ecc:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea809ed0:	928003e0 	mov	x0, #0xffffffffffffffe0    	// #-32
ffffffffea809ed4:	a944efba 	ldp	x26, x27, [x29, #72]
ffffffffea809ed8:	9a8002a0 	csel	x0, x21, x0, eq  // eq = none
ffffffffea809edc:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea809ee0:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea809ee4:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea809ee8:	d65f03c0 	ret
		arch_clean_cache_range(uaddr, mapped_size);
ffffffffea809eec:	97ffe275 	bl	ffffffffea8028c0 <arch_clean_cache_range>
ffffffffea809ef0:	17fffff3 	b	ffffffffea809ebc <sys_prepare_dma+0x10c>
ffffffffea809ef4:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea809ef8:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea809efc:	f94027ba 	ldr	x26, [x29, #72]
		return ERR_INVALID_ARGS;
ffffffffea809f00:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea809f04:	17ffffe6 	b	ffffffffea809e9c <sys_prepare_dma+0xec>

ffffffffea809f08 <sys_finish_dma>:

long sys_finish_dma(user_addr_t uaddr, uint32_t size, uint32_t flags)
{
ffffffffea809f08:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea809f0c:	910003fd 	mov	x29, sp
ffffffffea809f10:	a90153f3 	stp	x19, x20, [sp, #16]
	LTRACEF("uaddr 0x%x, size 0x%x, flags 0x%x\n", uaddr, size, flags);

	/* check buffer is in task's address space */
	if (!valid_address((vaddr_t)uaddr, size)) {
ffffffffea809f14:	2a0003f3 	mov	w19, w0
{
ffffffffea809f18:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (!valid_address((vaddr_t)uaddr, size)) {
ffffffffea809f1c:	2a0103f4 	mov	w20, w1
{
ffffffffea809f20:	2a0203f6 	mov	w22, w2
ffffffffea809f24:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea809f28:	f9415800 	ldr	x0, [x0, #688]
ffffffffea809f2c:	aa1403e2 	mov	x2, x20
ffffffffea809f30:	aa1303e1 	mov	x1, x19
ffffffffea809f34:	94002979 	bl	ffffffffea814518 <uthread_is_valid_range>
	if (!valid_address((vaddr_t)uaddr, size)) {
ffffffffea809f38:	72001c1f 	tst	w0, #0xff
ffffffffea809f3c:	54000160 	b.eq	ffffffffea809f68 <sys_finish_dma+0x60>  // b.none
		return ERR_INVALID_ARGS;
	}
	if (flags & DMA_FLAG_FROM_DEVICE) {
		arch_clean_invalidate_cache_range(uaddr, size);
	}
	return NO_ERROR;
ffffffffea809f40:	d2800015 	mov	x21, #0x0                   	// #0
	if (flags & DMA_FLAG_FROM_DEVICE) {
ffffffffea809f44:	36080096 	tbz	w22, #1, ffffffffea809f54 <sys_finish_dma+0x4c>
		arch_clean_invalidate_cache_range(uaddr, size);
ffffffffea809f48:	aa1403e1 	mov	x1, x20
ffffffffea809f4c:	aa1303e0 	mov	x0, x19
ffffffffea809f50:	97ffe264 	bl	ffffffffea8028e0 <arch_clean_invalidate_cache_range>
}
ffffffffea809f54:	aa1503e0 	mov	x0, x21
ffffffffea809f58:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809f5c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea809f60:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809f64:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea809f68:	928000f5 	mov	x21, #0xfffffffffffffff8    	// #-8
ffffffffea809f6c:	17fffffa 	b	ffffffffea809f54 <sys_finish_dma+0x4c>

ffffffffea809f70 <_finish_wait_handle>:
	spin_unlock_restore(&handle->slock, state, SPIN_LOCK_FLAG_INTERRUPTS);
	return ret;
}

static void _finish_wait_handle(handle_t *handle)
{
ffffffffea809f70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea809f74:	910003fd 	mov	x29, sp
ffffffffea809f78:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea809f7c:	aa0003f4 	mov	x20, x0
	spin_lock_saved_state_t state;

	/* clear out our event ptr */
	spin_lock_save(&handle->slock, &state, SPIN_LOCK_FLAG_INTERRUPTS);
ffffffffea809f80:	91006013 	add	x19, x0, #0x18
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea809f84:	d53b4220 	mrs	x0, daif
ffffffffea809f88:	37380160 	tbnz	w0, #7, ffffffffea809fb4 <_finish_wait_handle+0x44>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea809f8c:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea809f90:	aa1303e0 	mov	x0, x19
ffffffffea809f94:	97ffe241 	bl	ffffffffea802898 <arch_spin_lock>
	handle->wait_event = NULL;
ffffffffea809f98:	f9000a9f 	str	xzr, [x20, #16]
    arch_spin_unlock(lock);
ffffffffea809f9c:	aa1303e0 	mov	x0, x19
ffffffffea809fa0:	97ffe246 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea809fa4:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&handle->slock, state, SPIN_LOCK_FLAG_INTERRUPTS);
}
ffffffffea809fa8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809fac:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea809fb0:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea809fb4:	aa1303e0 	mov	x0, x19
ffffffffea809fb8:	97ffe238 	bl	ffffffffea802898 <arch_spin_lock>
	handle->wait_event = NULL;
ffffffffea809fbc:	f9000a9f 	str	xzr, [x20, #16]
    arch_spin_unlock(lock);
ffffffffea809fc0:	aa1303e0 	mov	x0, x19
}
ffffffffea809fc4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809fc8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea809fcc:	17ffe23b 	b	ffffffffea8028b8 <arch_spin_unlock>

ffffffffea809fd0 <_prepare_wait_handle>:
{
ffffffffea809fd0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea809fd4:	910003fd 	mov	x29, sp
ffffffffea809fd8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea809fdc:	aa0103f3 	mov	x19, x1
ffffffffea809fe0:	f90013f5 	str	x21, [sp, #32]
	spin_lock_save(&handle->slock, &state, SPIN_LOCK_FLAG_INTERRUPTS);
ffffffffea809fe4:	91006034 	add	x20, x1, #0x18
{
ffffffffea809fe8:	aa0003f5 	mov	x21, x0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea809fec:	d53b4220 	mrs	x0, daif
ffffffffea809ff0:	373801e0 	tbnz	w0, #7, ffffffffea80a02c <_prepare_wait_handle+0x5c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea809ff4:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea809ff8:	aa1403e0 	mov	x0, x20
ffffffffea809ffc:	97ffe227 	bl	ffffffffea802898 <arch_spin_lock>
	if (unlikely(handle->wait_event)) {
ffffffffea80a000:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80a004:	b50003a0 	cbnz	x0, ffffffffea80a078 <_prepare_wait_handle+0xa8>
		handle->wait_event = ev;
ffffffffea80a008:	f9000a75 	str	x21, [x19, #16]
    arch_spin_unlock(lock);
ffffffffea80a00c:	aa1403e0 	mov	x0, x20
ffffffffea80a010:	97ffe22a 	bl	ffffffffea8028b8 <arch_spin_unlock>
	int ret = 0;
ffffffffea80a014:	52800000 	mov	w0, #0x0                   	// #0
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80a018:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea80a01c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a020:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80a024:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a028:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea80a02c:	aa1403e0 	mov	x0, x20
ffffffffea80a030:	97ffe21a 	bl	ffffffffea802898 <arch_spin_lock>
	if (unlikely(handle->wait_event)) {
ffffffffea80a034:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80a038:	b5000120 	cbnz	x0, ffffffffea80a05c <_prepare_wait_handle+0x8c>
		handle->wait_event = ev;
ffffffffea80a03c:	f9000a75 	str	x21, [x19, #16]
    arch_spin_unlock(lock);
ffffffffea80a040:	aa1403e0 	mov	x0, x20
ffffffffea80a044:	97ffe21d 	bl	ffffffffea8028b8 <arch_spin_unlock>
}
ffffffffea80a048:	f94013f5 	ldr	x21, [sp, #32]
	int ret = 0;
ffffffffea80a04c:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea80a050:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a054:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a058:	d65f03c0 	ret
ffffffffea80a05c:	aa1403e0 	mov	x0, x20
ffffffffea80a060:	97ffe216 	bl	ffffffffea8028b8 <arch_spin_unlock>
		ret = ERR_ALREADY_STARTED;
ffffffffea80a064:	128000a0 	mov	w0, #0xfffffffa            	// #-6
}
ffffffffea80a068:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80a06c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a070:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a074:	d65f03c0 	ret
ffffffffea80a078:	aa1403e0 	mov	x0, x20
ffffffffea80a07c:	97ffe20f 	bl	ffffffffea8028b8 <arch_spin_unlock>
		ret = ERR_ALREADY_STARTED;
ffffffffea80a080:	128000a0 	mov	w0, #0xfffffffa            	// #-6
ffffffffea80a084:	d50342ff 	msr	daifclr, #0x2
ffffffffea80a088:	17ffffe5 	b	ffffffffea80a01c <_prepare_wait_handle+0x4c>
ffffffffea80a08c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a090 <_hlist_do_poll_locked>:
 *  handle until the ready one is found and return it to caller.
 *  Undo prepare op if ready handle is found or en error occured.
 */
static int _hlist_do_poll_locked(handle_list_t *hlist, handle_t **handle_ptr,
				 uint32_t *event_ptr, bool prepare)
{
ffffffffea80a090:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80a094:	910003fd 	mov	x29, sp
ffffffffea80a098:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80a09c:	f90023f9 	str	x25, [sp, #64]
	return (list->next == list) ? true : false;
ffffffffea80a0a0:	f9400413 	ldr	x19, [x0, #8]
	int ret = 0;

	DEBUG_ASSERT(hlist->wait_event);

	if (list_is_empty(&hlist->handles))
ffffffffea80a0a4:	eb13001f 	cmp	x0, x19
ffffffffea80a0a8:	54000840 	b.eq	ffffffffea80a1b0 <_hlist_do_poll_locked+0x120>  // b.none
ffffffffea80a0ac:	a901d7b4 	stp	x20, x21, [x29, #24]
		return ERR_NOT_FOUND;  /* no handles in the list */

	handle_t *next;
	handle_t *last_prep = NULL;
	list_for_every_entry(&hlist->handles, next, handle_t, hlist_node) {
ffffffffea80a0b0:	d1008273 	sub	x19, x19, #0x20
ffffffffea80a0b4:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea80a0b8:	12001c75 	and	w21, w3, #0xff
ffffffffea80a0bc:	aa0203f7 	mov	x23, x2
ffffffffea80a0c0:	aa0103f6 	mov	x22, x1
ffffffffea80a0c4:	aa0003f4 	mov	x20, x0
ffffffffea80a0c8:	f9001fb8 	str	x24, [x29, #56]
	handle_t *last_prep = NULL;
ffffffffea80a0cc:	d2800018 	mov	x24, #0x0                   	// #0
		if (prepare) {
ffffffffea80a0d0:	35000275 	cbnz	w21, ffffffffea80a11c <_hlist_do_poll_locked+0x8c>
			if (ret)
				break;
			last_prep = next;
		}

		uint32_t event = next->ops->poll(next);
ffffffffea80a0d4:	f9400663 	ldr	x3, [x19, #8]
ffffffffea80a0d8:	aa1303e0 	mov	x0, x19
ffffffffea80a0dc:	f9400063 	ldr	x3, [x3]
ffffffffea80a0e0:	d63f0060 	blr	x3
		if (event) {
ffffffffea80a0e4:	35000320 	cbnz	w0, ffffffffea80a148 <_hlist_do_poll_locked+0xb8>
	list_for_every_entry(&hlist->handles, next, handle_t, hlist_node) {
ffffffffea80a0e8:	f9401663 	ldr	x3, [x19, #40]
ffffffffea80a0ec:	d1008073 	sub	x19, x3, #0x20
ffffffffea80a0f0:	eb03029f 	cmp	x20, x3
ffffffffea80a0f4:	54fffee1 	b.ne	ffffffffea80a0d0 <_hlist_do_poll_locked+0x40>  // b.any
			*event_ptr = event;
			*handle_ptr = next;
			ret = 1;
ffffffffea80a0f8:	52800019 	mov	w25, #0x0                   	// #0
ffffffffea80a0fc:	f9401fb8 	ldr	x24, [x29, #56]
	if (ret && prepare && last_prep) {
		/* need to undo prepare */
		_hlist_finish_wait_locked(hlist, last_prep);
	}
	return ret;
}
ffffffffea80a100:	2a1903e0 	mov	w0, w25
ffffffffea80a104:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80a108:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea80a10c:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80a110:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80a114:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80a118:	d65f03c0 	ret
			ret = _prepare_wait_handle(hlist->wait_event, next);
ffffffffea80a11c:	f9402680 	ldr	x0, [x20, #72]
ffffffffea80a120:	aa1303e1 	mov	x1, x19
ffffffffea80a124:	97ffffab 	bl	ffffffffea809fd0 <_prepare_wait_handle>
ffffffffea80a128:	2a0003f9 	mov	w25, w0
			if (ret)
ffffffffea80a12c:	35000160 	cbnz	w0, ffffffffea80a158 <_hlist_do_poll_locked+0xc8>
		uint32_t event = next->ops->poll(next);
ffffffffea80a130:	f9400663 	ldr	x3, [x19, #8]
ffffffffea80a134:	aa1303f8 	mov	x24, x19
ffffffffea80a138:	aa1303e0 	mov	x0, x19
ffffffffea80a13c:	f9400063 	ldr	x3, [x3]
ffffffffea80a140:	d63f0060 	blr	x3
		if (event) {
ffffffffea80a144:	34fffd20 	cbz	w0, ffffffffea80a0e8 <_hlist_do_poll_locked+0x58>
			*event_ptr = event;
ffffffffea80a148:	b90002e0 	str	w0, [x23]
			ret = 1;
ffffffffea80a14c:	52800039 	mov	w25, #0x1                   	// #1
			*handle_ptr = next;
ffffffffea80a150:	f90002d3 	str	x19, [x22]
	if (ret && prepare && last_prep) {
ffffffffea80a154:	340001f5 	cbz	w21, ffffffffea80a190 <_hlist_do_poll_locked+0x100>
ffffffffea80a158:	b40001d8 	cbz	x24, ffffffffea80a190 <_hlist_do_poll_locked+0x100>
	list_for_every_entry(&hlist->handles, handle, handle_t, hlist_node) {
ffffffffea80a15c:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80a160:	d1008013 	sub	x19, x0, #0x20
ffffffffea80a164:	eb00029f 	cmp	x20, x0
ffffffffea80a168:	540000c1 	b.ne	ffffffffea80a180 <_hlist_do_poll_locked+0xf0>  // b.any
ffffffffea80a16c:	14000009 	b	ffffffffea80a190 <_hlist_do_poll_locked+0x100>
ffffffffea80a170:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80a174:	d1008013 	sub	x19, x0, #0x20
ffffffffea80a178:	eb00029f 	cmp	x20, x0
ffffffffea80a17c:	540000a0 	b.eq	ffffffffea80a190 <_hlist_do_poll_locked+0x100>  // b.none
		_finish_wait_handle(handle);
ffffffffea80a180:	aa1303e0 	mov	x0, x19
ffffffffea80a184:	97ffff7b 	bl	ffffffffea809f70 <_finish_wait_handle>
		if (handle == last) {
ffffffffea80a188:	eb18027f 	cmp	x19, x24
ffffffffea80a18c:	54ffff21 	b.ne	ffffffffea80a170 <_hlist_do_poll_locked+0xe0>  // b.any
ffffffffea80a190:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea80a194:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80a198:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea80a19c:	2a1903e0 	mov	w0, w25
ffffffffea80a1a0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80a1a4:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80a1a8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80a1ac:	d65f03c0 	ret
		return ERR_NOT_FOUND;  /* no handles in the list */
ffffffffea80a1b0:	12800039 	mov	w25, #0xfffffffe            	// #-2
ffffffffea80a1b4:	17fffffa 	b	ffffffffea80a19c <_hlist_do_poll_locked+0x10c>

ffffffffea80a1b8 <handle_init>:
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea80a1b8:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea80a1bc:	885f7c03 	ldxr	w3, [x0]
ffffffffea80a1c0:	88047c02 	stxr	w4, w2, [x0]
ffffffffea80a1c4:	35ffffc4 	cbnz	w4, ffffffffea80a1bc <handle_init+0x4>
    return __atomic_fetch_add(ptr, val, __ATOMIC_RELAXED);
ffffffffea80a1c8:	885f7c02 	ldxr	w2, [x0]
ffffffffea80a1cc:	11000442 	add	w2, w2, #0x1
ffffffffea80a1d0:	88037c02 	stxr	w3, w2, [x0]
ffffffffea80a1d4:	35ffffa3 	cbnz	w3, ffffffffea80a1c8 <handle_init+0x10>
	handle->wait_event = NULL;
ffffffffea80a1d8:	a900fc01 	stp	x1, xzr, [x0, #8]
	handle->guest_id = DEFAULT_GUEST_ID;
ffffffffea80a1dc:	529fdda1 	mov	w1, #0xfeed                	// #65261
ffffffffea80a1e0:	72bbd5a1 	movk	w1, #0xdead, lsl #16
	item->prev = item->next = 0;
ffffffffea80a1e4:	a901fc1f 	stp	xzr, xzr, [x0, #24]
	handle->cookie = NULL;
ffffffffea80a1e8:	a902fc1f 	stp	xzr, xzr, [x0, #40]
	handle->guest_id = DEFAULT_GUEST_ID;
ffffffffea80a1ec:	b9003801 	str	w1, [x0, #56]
}
ffffffffea80a1f0:	d65f03c0 	ret
ffffffffea80a1f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a1f8 <handle_incref>:
ffffffffea80a1f8:	885f7c01 	ldxr	w1, [x0]
ffffffffea80a1fc:	11000421 	add	w1, w1, #0x1
ffffffffea80a200:	88027c01 	stxr	w2, w1, [x0]
ffffffffea80a204:	35ffffa2 	cbnz	w2, ffffffffea80a1f8 <handle_incref>
}
ffffffffea80a208:	d65f03c0 	ret
ffffffffea80a20c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a210 <handle_decref>:
{
ffffffffea80a210:	aa0003e1 	mov	x1, x0
ffffffffea80a214:	885f7c22 	ldxr	w2, [x1]
ffffffffea80a218:	51000443 	sub	w3, w2, #0x1
ffffffffea80a21c:	88047c23 	stxr	w4, w3, [x1]
ffffffffea80a220:	35ffffa4 	cbnz	w4, ffffffffea80a214 <handle_decref+0x4>

static inline __ALWAYS_INLINE
void refcount_dec(refcount_t *ref, refcount_destroy_func destroy)
{
	/* decerementing from 1? destroy */
	if (atomic_add(&ref->cnt, -1) == 1)
ffffffffea80a224:	7100045f 	cmp	w2, #0x1
ffffffffea80a228:	54000081 	b.ne	ffffffffea80a238 <handle_decref+0x28>  // b.any
	handle->ops->destroy(handle);
ffffffffea80a22c:	f9400421 	ldr	x1, [x1, #8]
ffffffffea80a230:	f9400c21 	ldr	x1, [x1, #24]
ffffffffea80a234:	d61f0020 	br	x1
}
ffffffffea80a238:	d65f03c0 	ret
ffffffffea80a23c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a240 <_handle_list_del_locked>:
{
ffffffffea80a240:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80a244:	910003fd 	mov	x29, sp
ffffffffea80a248:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a24c:	aa0003f4 	mov	x20, x0
	item->next->prev = item->prev;
ffffffffea80a250:	a9420022 	ldp	x2, x0, [x1, #32]
ffffffffea80a254:	aa0103f3 	mov	x19, x1
	if (hlist->wait_event) {
ffffffffea80a258:	f9402681 	ldr	x1, [x20, #72]
ffffffffea80a25c:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea80a260:	f9401262 	ldr	x2, [x19, #32]
ffffffffea80a264:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80a268:	a9027e7f 	stp	xzr, xzr, [x19, #32]
ffffffffea80a26c:	b40000c1 	cbz	x1, ffffffffea80a284 <_handle_list_del_locked+0x44>
		_finish_wait_handle(handle);
ffffffffea80a270:	aa1303e0 	mov	x0, x19
ffffffffea80a274:	97ffff3f 	bl	ffffffffea809f70 <_finish_wait_handle>
		if (list_is_empty(&hlist->handles)) {
ffffffffea80a278:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80a27c:	eb00029f 	cmp	x20, x0
ffffffffea80a280:	540000a0 	b.eq	ffffffffea80a294 <_handle_list_del_locked+0x54>  // b.none
	handle_decref(handle);
ffffffffea80a284:	aa1303e0 	mov	x0, x19
}
ffffffffea80a288:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a28c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	handle_decref(handle);
ffffffffea80a290:	17ffffe0 	b	ffffffffea80a210 <handle_decref>
			event_signal(hlist->wait_event, true);
ffffffffea80a294:	f9402680 	ldr	x0, [x20, #72]
ffffffffea80a298:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea80a29c:	97ffed67 	bl	ffffffffea805838 <event_signal>
	handle_decref(handle);
ffffffffea80a2a0:	aa1303e0 	mov	x0, x19
}
ffffffffea80a2a4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a2a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	handle_decref(handle);
ffffffffea80a2ac:	17ffffd9 	b	ffffffffea80a210 <handle_decref>

ffffffffea80a2b0 <handle_close>:
{
ffffffffea80a2b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80a2b4:	910003fd 	mov	x29, sp
	if (handle->ops->shutdown) {
ffffffffea80a2b8:	f9400401 	ldr	x1, [x0, #8]
ffffffffea80a2bc:	f9400821 	ldr	x1, [x1, #16]
{
ffffffffea80a2c0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80a2c4:	aa0003f3 	mov	x19, x0
	if (handle->ops->shutdown) {
ffffffffea80a2c8:	b4000041 	cbz	x1, ffffffffea80a2d0 <handle_close+0x20>
		handle->ops->shutdown(handle);
ffffffffea80a2cc:	d63f0020 	blr	x1
	handle_decref(handle);
ffffffffea80a2d0:	aa1303e0 	mov	x0, x19
}
ffffffffea80a2d4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80a2d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	handle_decref(handle);
ffffffffea80a2dc:	17ffffcd 	b	ffffffffea80a210 <handle_decref>

ffffffffea80a2e0 <handle_wait>:
{
ffffffffea80a2e0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
	if (!handle || !handle_event) {
ffffffffea80a2e4:	f100001f 	cmp	x0, #0x0
ffffffffea80a2e8:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
{
ffffffffea80a2ec:	910003fd 	mov	x29, sp
ffffffffea80a2f0:	f90017f6 	str	x22, [sp, #40]
	if (!handle || !handle_event) {
ffffffffea80a2f4:	54000620 	b.eq	ffffffffea80a3b8 <handle_wait+0xd8>  // b.none
ffffffffea80a2f8:	f90013b5 	str	x21, [x29, #32]
ffffffffea80a2fc:	2a0203f5 	mov	w21, w2
	event_init(&ev, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea80a300:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80a304:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80a308:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80a30c:	aa0003f3 	mov	x19, x0
ffffffffea80a310:	aa0103f7 	mov	x23, x1
ffffffffea80a314:	910103a0 	add	x0, x29, #0x40
ffffffffea80a318:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80a31c:	97ffeced 	bl	ffffffffea8056d0 <event_init>
	ret = _prepare_wait_handle(&ev, handle);
ffffffffea80a320:	aa1303e1 	mov	x1, x19
ffffffffea80a324:	910103a0 	add	x0, x29, #0x40
ffffffffea80a328:	97ffff2a 	bl	ffffffffea809fd0 <_prepare_wait_handle>
ffffffffea80a32c:	2a0003f6 	mov	w22, w0
	if (ret) {
ffffffffea80a330:	350002e0 	cbnz	w0, ffffffffea80a38c <handle_wait+0xac>
ffffffffea80a334:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80a338:	14000005 	b	ffffffffea80a34c <handle_wait+0x6c>
	ret = event_wait_timeout(ev, timeout);
ffffffffea80a33c:	2a1503e1 	mov	w1, w21
ffffffffea80a340:	910103a0 	add	x0, x29, #0x40
ffffffffea80a344:	97ffed19 	bl	ffffffffea8057a8 <event_wait_timeout>
		if (ret < 0) {
ffffffffea80a348:	37f80340 	tbnz	w0, #31, ffffffffea80a3b0 <handle_wait+0xd0>
		event = handle->ops->poll(handle);
ffffffffea80a34c:	f9400663 	ldr	x3, [x19, #8]
ffffffffea80a350:	aa1303e0 	mov	x0, x19
ffffffffea80a354:	f9400063 	ldr	x3, [x3]
ffffffffea80a358:	d63f0060 	blr	x3
ffffffffea80a35c:	2a0003f4 	mov	w20, w0
		if (event) {
ffffffffea80a360:	34fffee0 	cbz	w0, ffffffffea80a33c <handle_wait+0x5c>
	if (handle->ops->finalize_event) {
ffffffffea80a364:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80a368:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80a36c:	b4000082 	cbz	x2, ffffffffea80a37c <handle_wait+0x9c>
		handle->ops->finalize_event(handle, event);
ffffffffea80a370:	2a1403e1 	mov	w1, w20
ffffffffea80a374:	aa1303e0 	mov	x0, x19
ffffffffea80a378:	d63f0040 	blr	x2
	*handle_event = event;
ffffffffea80a37c:	b90002f4 	str	w20, [x23]
	_finish_wait_handle(handle);
ffffffffea80a380:	aa1303e0 	mov	x0, x19
ffffffffea80a384:	97fffefb 	bl	ffffffffea809f70 <_finish_wait_handle>
ffffffffea80a388:	f9400fb4 	ldr	x20, [x29, #24]
	event_destroy(&ev);
ffffffffea80a38c:	910103a0 	add	x0, x29, #0x40
ffffffffea80a390:	97ffecdc 	bl	ffffffffea805700 <event_destroy>
	return ret;
ffffffffea80a394:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80a398:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80a39c:	f9401bb7 	ldr	x23, [x29, #48]
}
ffffffffea80a3a0:	2a1603e0 	mov	w0, w22
ffffffffea80a3a4:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80a3a8:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80a3ac:	d65f03c0 	ret
	ret = event_wait_timeout(ev, timeout);
ffffffffea80a3b0:	2a0003f6 	mov	w22, w0
ffffffffea80a3b4:	17fffff3 	b	ffffffffea80a380 <handle_wait+0xa0>
		return ERR_INVALID_ARGS;
ffffffffea80a3b8:	128000f6 	mov	w22, #0xfffffff8            	// #-8
ffffffffea80a3bc:	17fffff9 	b	ffffffffea80a3a0 <handle_wait+0xc0>

ffffffffea80a3c0 <handle_notify>:
{
ffffffffea80a3c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80a3c4:	910003fd 	mov	x29, sp
ffffffffea80a3c8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a3cc:	aa0003f3 	mov	x19, x0
	spin_lock_save(&handle->slock, &state, SPIN_LOCK_FLAG_INTERRUPTS);
ffffffffea80a3d0:	91006014 	add	x20, x0, #0x18
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80a3d4:	d53b4220 	mrs	x0, daif
ffffffffea80a3d8:	373801c0 	tbnz	w0, #7, ffffffffea80a410 <handle_notify+0x50>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80a3dc:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80a3e0:	aa1403e0 	mov	x0, x20
ffffffffea80a3e4:	97ffe12d 	bl	ffffffffea802898 <arch_spin_lock>
	if (handle->wait_event) {
ffffffffea80a3e8:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80a3ec:	b4000060 	cbz	x0, ffffffffea80a3f8 <handle_notify+0x38>
		event_signal(handle->wait_event, false);
ffffffffea80a3f0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80a3f4:	97ffed11 	bl	ffffffffea805838 <event_signal>
    arch_spin_unlock(lock);
ffffffffea80a3f8:	aa1403e0 	mov	x0, x20
ffffffffea80a3fc:	97ffe12f 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80a400:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea80a404:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a408:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80a40c:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea80a410:	aa1403e0 	mov	x0, x20
ffffffffea80a414:	97ffe121 	bl	ffffffffea802898 <arch_spin_lock>
	if (handle->wait_event) {
ffffffffea80a418:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80a41c:	b50000a0 	cbnz	x0, ffffffffea80a430 <handle_notify+0x70>
    arch_spin_unlock(lock);
ffffffffea80a420:	aa1403e0 	mov	x0, x20
}
ffffffffea80a424:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a428:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80a42c:	17ffe123 	b	ffffffffea8028b8 <arch_spin_unlock>
		event_signal(handle->wait_event, false);
ffffffffea80a430:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80a434:	97ffed01 	bl	ffffffffea805838 <event_signal>
ffffffffea80a438:	17fffffa 	b	ffffffffea80a420 <handle_notify+0x60>
ffffffffea80a43c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a440 <handle_list_init>:
	*hlist = (handle_list_t)HANDLE_LIST_INITIAL_VALUE(*hlist);
ffffffffea80a440:	a9017c1f 	stp	xzr, xzr, [x0, #16]
ffffffffea80a444:	528e8f03 	mov	w3, #0x7478                	// #29816
ffffffffea80a448:	a9027c1f 	stp	xzr, xzr, [x0, #32]
ffffffffea80a44c:	528d2e82 	mov	w2, #0x6974                	// #26996
ffffffffea80a450:	72adaea3 	movk	w3, #0x6d75, lsl #16
ffffffffea80a454:	9100c001 	add	x1, x0, #0x30
ffffffffea80a458:	72aeec22 	movk	w2, #0x7761, lsl #16
ffffffffea80a45c:	a9000000 	stp	x0, x0, [x0]
ffffffffea80a460:	b9001003 	str	w3, [x0, #16]
ffffffffea80a464:	b9002802 	str	w2, [x0, #40]
ffffffffea80a468:	a9030401 	stp	x1, x1, [x0, #48]
ffffffffea80a46c:	a9047c1f 	stp	xzr, xzr, [x0, #64]
}
ffffffffea80a470:	d65f03c0 	ret
ffffffffea80a474:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a478 <handle_list_add>:
{
ffffffffea80a478:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a47c:	910003fd 	mov	x29, sp
ffffffffea80a480:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a484:	aa0003f4 	mov	x20, x0
ffffffffea80a488:	aa0103f3 	mov	x19, x1
ffffffffea80a48c:	f90013f5 	str	x21, [sp, #32]
    return __atomic_fetch_add(ptr, val, __ATOMIC_RELAXED);
ffffffffea80a490:	885f7e60 	ldxr	w0, [x19]
ffffffffea80a494:	11000400 	add	w0, w0, #0x1
ffffffffea80a498:	88017e60 	stxr	w1, w0, [x19]
ffffffffea80a49c:	35ffffa1 	cbnz	w1, ffffffffea80a490 <handle_list_add+0x18>
	mutex_acquire(&hlist->lock);
ffffffffea80a4a0:	91004295 	add	x21, x20, #0x10
ffffffffea80a4a4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80a4a8:	aa1503e0 	mov	x0, x21
ffffffffea80a4ac:	97ffed43 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	item->prev = list->prev;
ffffffffea80a4b0:	f9400280 	ldr	x0, [x20]
	list_add_tail(&hlist->handles, &handle->hlist_node);
ffffffffea80a4b4:	91008261 	add	x1, x19, #0x20
	item->next = list;
ffffffffea80a4b8:	a9025260 	stp	x0, x20, [x19, #32]
	if (hlist->wait_event) {
ffffffffea80a4bc:	f9402680 	ldr	x0, [x20, #72]
	list->prev->next = item;
ffffffffea80a4c0:	f9400282 	ldr	x2, [x20]
ffffffffea80a4c4:	f9000441 	str	x1, [x2, #8]
	list->prev = item;
ffffffffea80a4c8:	f9000281 	str	x1, [x20]
ffffffffea80a4cc:	b4000100 	cbz	x0, ffffffffea80a4ec <handle_list_add+0x74>
		_prepare_wait_handle(hlist->wait_event, handle);
ffffffffea80a4d0:	aa1303e1 	mov	x1, x19
ffffffffea80a4d4:	97fffebf 	bl	ffffffffea809fd0 <_prepare_wait_handle>
		uint32_t event = handle->ops->poll(handle);
ffffffffea80a4d8:	f9400661 	ldr	x1, [x19, #8]
ffffffffea80a4dc:	aa1303e0 	mov	x0, x19
ffffffffea80a4e0:	f9400021 	ldr	x1, [x1]
ffffffffea80a4e4:	d63f0020 	blr	x1
		if (event) {
ffffffffea80a4e8:	350000c0 	cbnz	w0, ffffffffea80a500 <handle_list_add+0x88>
	mutex_release(&hlist->lock);
ffffffffea80a4ec:	aa1503e0 	mov	x0, x21
}
ffffffffea80a4f0:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80a4f4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a4f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&hlist->lock);
ffffffffea80a4fc:	17ffed5b 	b	ffffffffea805a68 <mutex_release>
			handle_notify(handle);
ffffffffea80a500:	aa1303e0 	mov	x0, x19
ffffffffea80a504:	97ffffaf 	bl	ffffffffea80a3c0 <handle_notify>
	mutex_release(&hlist->lock);
ffffffffea80a508:	aa1503e0 	mov	x0, x21
}
ffffffffea80a50c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80a510:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a514:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&hlist->lock);
ffffffffea80a518:	17ffed54 	b	ffffffffea805a68 <mutex_release>
ffffffffea80a51c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a520 <handle_list_del>:
{
ffffffffea80a520:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a524:	910003fd 	mov	x29, sp
ffffffffea80a528:	a90153f3 	stp	x19, x20, [sp, #16]
	mutex_acquire(&hlist->lock);
ffffffffea80a52c:	91004013 	add	x19, x0, #0x10
{
ffffffffea80a530:	f90013f5 	str	x21, [sp, #32]
ffffffffea80a534:	aa0003f4 	mov	x20, x0
ffffffffea80a538:	aa0103f5 	mov	x21, x1
ffffffffea80a53c:	aa1303e0 	mov	x0, x19
ffffffffea80a540:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80a544:	97ffed1d 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	_handle_list_del_locked(hlist, handle);
ffffffffea80a548:	aa1503e1 	mov	x1, x21
ffffffffea80a54c:	aa1403e0 	mov	x0, x20
ffffffffea80a550:	97ffff3c 	bl	ffffffffea80a240 <_handle_list_del_locked>
}
ffffffffea80a554:	f94013f5 	ldr	x21, [sp, #32]
	mutex_release(&hlist->lock);
ffffffffea80a558:	aa1303e0 	mov	x0, x19
}
ffffffffea80a55c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a560:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&hlist->lock);
ffffffffea80a564:	17ffed41 	b	ffffffffea805a68 <mutex_release>

ffffffffea80a568 <handle_list_wait>:
/* fills in the handle that has a pending event. The reference taken by the list
 * is not dropped until the caller has had a chance to process the handle.
 */
int handle_list_wait(handle_list_t *hlist, handle_t **handle_ptr,
                     uint32_t *event_ptr, lk_time_t timeout)
{
ffffffffea80a568:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea80a56c:	910003fd 	mov	x29, sp
ffffffffea80a570:	f90023f9 	str	x25, [sp, #64]
ffffffffea80a574:	aa0203f9 	mov	x25, x2
ffffffffea80a578:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80a57c:	aa0103f8 	mov	x24, x1

	DEBUG_ASSERT(hlist);
	DEBUG_ASSERT(handle_ptr);
	DEBUG_ASSERT(event_ptr);

	event_init(&ev, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea80a580:	910143b7 	add	x23, x29, #0x50
{
ffffffffea80a584:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a588:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80a58c:	aa0003f4 	mov	x20, x0
ffffffffea80a590:	2a0303f5 	mov	w21, w3
	event_init(&ev, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea80a594:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80a598:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80a59c:	aa1703e0 	mov	x0, x23
ffffffffea80a5a0:	97ffec4c 	bl	ffffffffea8056d0 <event_init>

	*event_ptr = 0;
ffffffffea80a5a4:	b900033f 	str	wzr, [x25]
	*handle_ptr = 0;
ffffffffea80a5a8:	f900031f 	str	xzr, [x24]

	mutex_acquire(&hlist->lock);
ffffffffea80a5ac:	91004296 	add	x22, x20, #0x10
ffffffffea80a5b0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80a5b4:	aa1603e0 	mov	x0, x22
ffffffffea80a5b8:	97ffed00 	bl	ffffffffea8059b8 <mutex_acquire_timeout>

	DEBUG_ASSERT(hlist->wait_event == NULL);

	hlist->wait_event = &ev;
ffffffffea80a5bc:	f9002697 	str	x23, [x20, #72]
	ret = _hlist_do_poll_locked(hlist, handle_ptr, event_ptr, true);
ffffffffea80a5c0:	52800023 	mov	w3, #0x1                   	// #1
ffffffffea80a5c4:	aa1903e2 	mov	x2, x25
ffffffffea80a5c8:	aa1803e1 	mov	x1, x24
ffffffffea80a5cc:	aa1403e0 	mov	x0, x20
ffffffffea80a5d0:	97fffeb0 	bl	ffffffffea80a090 <_hlist_do_poll_locked>
ffffffffea80a5d4:	2a0003f3 	mov	w19, w0
	if (ret < 0) {
ffffffffea80a5d8:	7100001f 	cmp	w0, #0x0
ffffffffea80a5dc:	5400008b 	b.lt	ffffffffea80a5ec <handle_list_wait+0x84>  // b.tstop
		goto err_do_poll;
	}
	if (ret == 0) {
ffffffffea80a5e0:	540002c0 	b.eq	ffffffffea80a638 <handle_list_wait+0xd0>  // b.none
		} while (!ret);

		_hlist_finish_wait_locked(hlist, NULL);
	}

	if (ret == 1) {
ffffffffea80a5e4:	7100067f 	cmp	w19, #0x1
ffffffffea80a5e8:	54000580 	b.eq	ffffffffea80a698 <handle_list_wait+0x130>  // b.none

		ret = NO_ERROR;
	}

err_do_poll:
	hlist->wait_event = NULL;
ffffffffea80a5ec:	f900269f 	str	xzr, [x20, #72]
	mutex_release(&hlist->lock);
ffffffffea80a5f0:	aa1603e0 	mov	x0, x22
ffffffffea80a5f4:	97ffed1d 	bl	ffffffffea805a68 <mutex_release>
	event_destroy(&ev);
ffffffffea80a5f8:	aa1703e0 	mov	x0, x23
ffffffffea80a5fc:	97ffec41 	bl	ffffffffea805700 <event_destroy>
	return ret;
}
ffffffffea80a600:	2a1303e0 	mov	w0, w19
ffffffffea80a604:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80a608:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a60c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80a610:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80a614:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80a618:	d65f03c0 	ret
			ret = _hlist_do_poll_locked(hlist, handle_ptr,
ffffffffea80a61c:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea80a620:	aa1903e2 	mov	x2, x25
ffffffffea80a624:	aa1803e1 	mov	x1, x24
ffffffffea80a628:	aa1403e0 	mov	x0, x20
ffffffffea80a62c:	97fffe99 	bl	ffffffffea80a090 <_hlist_do_poll_locked>
ffffffffea80a630:	2a0003f3 	mov	w19, w0
		} while (!ret);
ffffffffea80a634:	35000620 	cbnz	w0, ffffffffea80a6f8 <handle_list_wait+0x190>
			mutex_release(&hlist->lock);
ffffffffea80a638:	aa1603e0 	mov	x0, x22
ffffffffea80a63c:	97ffed0b 	bl	ffffffffea805a68 <mutex_release>
	ret = event_wait_timeout(ev, timeout);
ffffffffea80a640:	2a1503e1 	mov	w1, w21
ffffffffea80a644:	aa1703e0 	mov	x0, x23
ffffffffea80a648:	97ffec58 	bl	ffffffffea8057a8 <event_wait_timeout>
ffffffffea80a64c:	2a0003f3 	mov	w19, w0
ffffffffea80a650:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80a654:	aa1603e0 	mov	x0, x22
ffffffffea80a658:	97ffecd8 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
			if (ret < 0) {
ffffffffea80a65c:	36fffe13 	tbz	w19, #31, ffffffffea80a61c <handle_list_wait+0xb4>
	list_for_every_entry(&hlist->handles, handle, handle_t, hlist_node) {
ffffffffea80a660:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80a664:	d1008015 	sub	x21, x0, #0x20
ffffffffea80a668:	eb00029f 	cmp	x20, x0
ffffffffea80a66c:	540000c1 	b.ne	ffffffffea80a684 <handle_list_wait+0x11c>  // b.any
ffffffffea80a670:	17ffffdf 	b	ffffffffea80a5ec <handle_list_wait+0x84>
ffffffffea80a674:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80a678:	d1008015 	sub	x21, x0, #0x20
ffffffffea80a67c:	eb00029f 	cmp	x20, x0
ffffffffea80a680:	54fffb20 	b.eq	ffffffffea80a5e4 <handle_list_wait+0x7c>  // b.none
		_finish_wait_handle(handle);
ffffffffea80a684:	aa1503e0 	mov	x0, x21
ffffffffea80a688:	97fffe3a 	bl	ffffffffea809f70 <_finish_wait_handle>
		if (handle == last) {
ffffffffea80a68c:	b5ffff55 	cbnz	x21, ffffffffea80a674 <handle_list_wait+0x10c>
	if (ret == 1) {
ffffffffea80a690:	7100067f 	cmp	w19, #0x1
ffffffffea80a694:	54fffac1 	b.ne	ffffffffea80a5ec <handle_list_wait+0x84>  // b.any
		handle_t *handle = *handle_ptr;
ffffffffea80a698:	f9400315 	ldr	x21, [x24]
		if (handle->ops->finalize_event) {
ffffffffea80a69c:	f94006a0 	ldr	x0, [x21, #8]
ffffffffea80a6a0:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80a6a4:	b4000082 	cbz	x2, ffffffffea80a6b4 <handle_list_wait+0x14c>
			handle->ops->finalize_event(handle, *event_ptr);
ffffffffea80a6a8:	b9400321 	ldr	w1, [x25]
ffffffffea80a6ac:	aa1503e0 	mov	x0, x21
ffffffffea80a6b0:	d63f0040 	blr	x2
ffffffffea80a6b4:	885f7ea0 	ldxr	w0, [x21]
ffffffffea80a6b8:	11000400 	add	w0, w0, #0x1
ffffffffea80a6bc:	88017ea0 	stxr	w1, w0, [x21]
ffffffffea80a6c0:	35ffffa1 	cbnz	w1, ffffffffea80a6b4 <handle_list_wait+0x14c>
	item->next->prev = item->prev;
ffffffffea80a6c4:	a9400282 	ldp	x2, x0, [x20]
		list_add_head(&handle->hlist_node, &hlist->handles);
ffffffffea80a6c8:	910082a1 	add	x1, x21, #0x20
		ret = NO_ERROR;
ffffffffea80a6cc:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea80a6d0:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea80a6d4:	f9400282 	ldr	x2, [x20]
ffffffffea80a6d8:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80a6dc:	f900069f 	str	xzr, [x20, #8]
	item->next = list->next;
ffffffffea80a6e0:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80a6e4:	a9000281 	stp	x1, x0, [x20]
	list->next->prev = item;
ffffffffea80a6e8:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80a6ec:	f9000014 	str	x20, [x0]
	list->next = item;
ffffffffea80a6f0:	f90016b4 	str	x20, [x21, #40]
ffffffffea80a6f4:	17ffffbe 	b	ffffffffea80a5ec <handle_list_wait+0x84>
	list_for_every_entry(&hlist->handles, handle, handle_t, hlist_node) {
ffffffffea80a6f8:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80a6fc:	d1008015 	sub	x21, x0, #0x20
ffffffffea80a700:	eb00029f 	cmp	x20, x0
ffffffffea80a704:	54fffc01 	b.ne	ffffffffea80a684 <handle_list_wait+0x11c>  // b.any
ffffffffea80a708:	17ffffb7 	b	ffffffffea80a5e4 <handle_list_wait+0x7c>
ffffffffea80a70c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a710 <uctx_init>:
	trusty_als_set(app, _uctx_slot_id, uctx);
	return NO_ERROR;
}

static void uctx_init(uint level)
{
ffffffffea80a710:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80a714:	910003fd 	mov	x29, sp
ffffffffea80a718:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80a71c:	aa1e03f3 	mov	x19, x30
	int res;

	/* allocate als slot */
	res = trusty_als_alloc_slot();
ffffffffea80a720:	97fff9a4 	bl	ffffffffea808db0 <trusty_als_alloc_slot>
ffffffffea80a724:	2a0003e2 	mov	w2, w0
	if (res < 0) {
ffffffffea80a728:	37f80140 	tbnz	w0, #31, ffffffffea80a750 <uctx_init+0x40>
		panic("failed (%d) to alloc als slot\n", res);
	}
	_uctx_slot_id = res;
ffffffffea80a72c:	f0000281 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>

	/* register notifier */
	res = trusty_register_app_notifier(&_uctx_notifier);
ffffffffea80a730:	f0000060 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea80a734:	9135e000 	add	x0, x0, #0xd78
	_uctx_slot_id = res;
ffffffffea80a738:	b90f3822 	str	w2, [x1, #3896]
	res = trusty_register_app_notifier(&_uctx_notifier);
ffffffffea80a73c:	97fff97f 	bl	ffffffffea808d38 <trusty_register_app_notifier>
	if (res < 0) {
ffffffffea80a740:	37f80100 	tbnz	w0, #31, ffffffffea80a760 <uctx_init+0x50>
		panic("failed (%d) to register uctx notifier\n", res);
	}
}
ffffffffea80a744:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80a748:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80a74c:	d65f03c0 	ret
		panic("failed (%d) to alloc als slot\n", res);
ffffffffea80a750:	b0000061 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a754:	aa1303e0 	mov	x0, x19
ffffffffea80a758:	91104021 	add	x1, x1, #0x410
ffffffffea80a75c:	94001d4f 	bl	ffffffffea811c98 <_panic>
		panic("failed (%d) to register uctx notifier\n", res);
ffffffffea80a760:	b0000061 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a764:	2a0003e2 	mov	w2, w0
ffffffffea80a768:	9110c021 	add	x1, x1, #0x430
ffffffffea80a76c:	aa1303e0 	mov	x0, x19
ffffffffea80a770:	94001d4a 	bl	ffffffffea811c98 <_panic>
ffffffffea80a774:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a778 <_check_handle_id>:
 */
static int _check_handle_id(uctx_t *ctx, handle_id_t handle_id)
{
	DEBUG_ASSERT(ctx);

	if (unlikely(handle_id >= IPC_MAX_HANDLES)) {
ffffffffea80a778:	7101fc3f 	cmp	w1, #0x7f
ffffffffea80a77c:	540002e8 	b.hi	ffffffffea80a7d8 <_check_handle_id+0x60>  // b.pmore
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80a780:	2a0103e2 	mov	w2, w1
ffffffffea80a784:	aa0003e4 	mov	x4, x0
ffffffffea80a788:	d346fc43 	lsr	x3, x2, #6
ffffffffea80a78c:	f8637803 	ldr	x3, [x0, x3, lsl #3]
ffffffffea80a790:	9ac12461 	lsr	x1, x3, x1
		LTRACEF("%d is invalid handle id\n", handle_id);
		return ERR_BAD_HANDLE;
	}

	if (!bitmap_test(ctx->inuse, handle_id)) {
ffffffffea80a794:	36000261 	tbz	w1, #0, ffffffffea80a7e0 <_check_handle_id+0x68>
		LTRACEF("%d is unused handle id\n", handle_id);
		return ERR_NOT_FOUND;
	}

	/* there should be a handle there */
	ASSERT(ctx->handles[handle_id]);
ffffffffea80a798:	91000842 	add	x2, x2, #0x2

	return NO_ERROR;
ffffffffea80a79c:	52800000 	mov	w0, #0x0                   	// #0
	ASSERT(ctx->handles[handle_id]);
ffffffffea80a7a0:	f8627881 	ldr	x1, [x4, x2, lsl #3]
ffffffffea80a7a4:	b4000041 	cbz	x1, ffffffffea80a7ac <_check_handle_id+0x34>
}
ffffffffea80a7a8:	d65f03c0 	ret
{
ffffffffea80a7ac:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(ctx->handles[handle_id]);
ffffffffea80a7b0:	b0000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a7b4:	b0000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a7b8:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
{
ffffffffea80a7bc:	910003fd 	mov	x29, sp
ffffffffea80a7c0:	aa1e03e0 	mov	x0, x30
	ASSERT(ctx->handles[handle_id]);
ffffffffea80a7c4:	910d2084 	add	x4, x4, #0x348
ffffffffea80a7c8:	52801283 	mov	w3, #0x94                  	// #148
ffffffffea80a7cc:	910d8042 	add	x2, x2, #0x360
ffffffffea80a7d0:	9135a021 	add	x1, x1, #0xd68
ffffffffea80a7d4:	94001d31 	bl	ffffffffea811c98 <_panic>
		return ERR_BAD_HANDLE;
ffffffffea80a7d8:	12800520 	mov	w0, #0xffffffd6            	// #-42
ffffffffea80a7dc:	d65f03c0 	ret
		return ERR_NOT_FOUND;
ffffffffea80a7e0:	12800020 	mov	w0, #0xfffffffe            	// #-2
}
ffffffffea80a7e4:	d65f03c0 	ret

ffffffffea80a7e8 <set_current_guest>:
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80a7e8:	d538d083 	mrs	x3, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80a7ec:	f0000281 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
extern uint als_slot_cnt;

static inline void *trusty_als_get(struct trusty_app *app, int slot_id)
{
	uint slot = slot_id - 1;
	ASSERT(slot < als_slot_cnt);
ffffffffea80a7f0:	900002a2 	adrp	x2, ffffffffea85e000 <rb_data+0x18>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80a7f4:	f9415863 	ldr	x3, [x3, #688]
	uint slot = slot_id - 1;
ffffffffea80a7f8:	b94f3821 	ldr	w1, [x1, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a7fc:	b940cc42 	ldr	w2, [x2, #204]
	uint slot = slot_id - 1;
ffffffffea80a800:	51000421 	sub	w1, w1, #0x1
ffffffffea80a804:	f9404863 	ldr	x3, [x3, #144]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a808:	6b02003f 	cmp	w1, w2
ffffffffea80a80c:	540001e2 	b.cs	ffffffffea80a848 <set_current_guest+0x60>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80a810:	f9403062 	ldr	x2, [x3, #96]
ffffffffea80a814:	f8615841 	ldr	x1, [x2, w1, uxtw #3]

static void set_current_guest(handle_t *handle)
{
	uctx_t *ctx = current_uctx();

	if (handle == NULL) {
ffffffffea80a818:	b4000080 	cbz	x0, ffffffffea80a828 <set_current_guest+0x40>
		TRACEF("%s: handle pointer NULL\n", __func__);
		return;
	}

	ctx->cur_guest = handle->guest_id;
ffffffffea80a81c:	b9403800 	ldr	w0, [x0, #56]
ffffffffea80a820:	b9046820 	str	w0, [x1, #1128]
ffffffffea80a824:	d65f03c0 	ret
		TRACEF("%s: handle pointer NULL\n", __func__);
ffffffffea80a828:	b0000063 	adrp	x3, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a82c:	b0000061 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a830:	b0000060 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a834:	910cc063 	add	x3, x3, #0x330
ffffffffea80a838:	52802762 	mov	w2, #0x13b                 	// #315
ffffffffea80a83c:	910c6021 	add	x1, x1, #0x318
ffffffffea80a840:	910f4000 	add	x0, x0, #0x3d0
ffffffffea80a844:	1400227b 	b	ffffffffea813230 <_printf>
{
ffffffffea80a848:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(slot < als_slot_cnt);
ffffffffea80a84c:	b0000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a850:	b0000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a854:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80a858:	910003fd 	mov	x29, sp
ffffffffea80a85c:	aa1e03e0 	mov	x0, x30
ffffffffea80a860:	910e0084 	add	x4, x4, #0x380
ffffffffea80a864:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80a868:	910e6042 	add	x2, x2, #0x398
ffffffffea80a86c:	9135a021 	add	x1, x1, #0xd68
ffffffffea80a870:	94001d0a 	bl	ffffffffea811c98 <_panic>
ffffffffea80a874:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a878 <uctx_get_current_guest>:
ffffffffea80a878:	d538d083 	mrs	x3, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80a87c:	f0000281 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80a880:	900002a2 	adrp	x2, ffffffffea85e000 <rb_data+0x18>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80a884:	f9415863 	ldr	x3, [x3, #688]
	uint slot = slot_id - 1;
ffffffffea80a888:	b94f3821 	ldr	w1, [x1, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a88c:	b940cc42 	ldr	w2, [x2, #204]
	uint slot = slot_id - 1;
ffffffffea80a890:	51000421 	sub	w1, w1, #0x1
ffffffffea80a894:	f9404863 	ldr	x3, [x3, #144]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a898:	6b02003f 	cmp	w1, w2
ffffffffea80a89c:	540000a2 	b.cs	ffffffffea80a8b0 <uctx_get_current_guest+0x38>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80a8a0:	f9403060 	ldr	x0, [x3, #96]
	return ctx->cur_guest;
ffffffffea80a8a4:	f8615800 	ldr	x0, [x0, w1, uxtw #3]
}
ffffffffea80a8a8:	b9446800 	ldr	w0, [x0, #1128]
ffffffffea80a8ac:	d65f03c0 	ret
{
ffffffffea80a8b0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(slot < als_slot_cnt);
ffffffffea80a8b4:	b0000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a8b8:	b0000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a8bc:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80a8c0:	910003fd 	mov	x29, sp
ffffffffea80a8c4:	aa1e03e0 	mov	x0, x30
ffffffffea80a8c8:	910e0084 	add	x4, x4, #0x380
ffffffffea80a8cc:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80a8d0:	910e6042 	add	x2, x2, #0x398
ffffffffea80a8d4:	9135a021 	add	x1, x1, #0xd68
ffffffffea80a8d8:	94001cf0 	bl	ffffffffea811c98 <_panic>
ffffffffea80a8dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a8e0 <current_uctx>:
ffffffffea80a8e0:	d538d083 	mrs	x3, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80a8e4:	f0000281 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80a8e8:	900002a2 	adrp	x2, ffffffffea85e000 <rb_data+0x18>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80a8ec:	f9415863 	ldr	x3, [x3, #688]
	uint slot = slot_id - 1;
ffffffffea80a8f0:	b94f3821 	ldr	w1, [x1, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a8f4:	b940cc42 	ldr	w2, [x2, #204]
	uint slot = slot_id - 1;
ffffffffea80a8f8:	51000421 	sub	w1, w1, #0x1
ffffffffea80a8fc:	f9404863 	ldr	x3, [x3, #144]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a900:	6b02003f 	cmp	w1, w2
ffffffffea80a904:	54000082 	b.cs	ffffffffea80a914 <current_uctx+0x34>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80a908:	f9403060 	ldr	x0, [x3, #96]
}
ffffffffea80a90c:	f8615800 	ldr	x0, [x0, w1, uxtw #3]
ffffffffea80a910:	d65f03c0 	ret
{
ffffffffea80a914:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(slot < als_slot_cnt);
ffffffffea80a918:	b0000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a91c:	b0000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80a920:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80a924:	910003fd 	mov	x29, sp
ffffffffea80a928:	aa1e03e0 	mov	x0, x30
ffffffffea80a92c:	910e0084 	add	x4, x4, #0x380
ffffffffea80a930:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80a934:	910e6042 	add	x2, x2, #0x398
ffffffffea80a938:	9135a021 	add	x1, x1, #0xd68
ffffffffea80a93c:	94001cd7 	bl	ffffffffea811c98 <_panic>

ffffffffea80a940 <uctx_create>:
{
ffffffffea80a940:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a944:	910003fd 	mov	x29, sp
ffffffffea80a948:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea80a94c:	aa0003f5 	mov	x21, x0
ffffffffea80a950:	aa0103f4 	mov	x20, x1
	new_ctx = calloc(1, sizeof(uctx_t));
ffffffffea80a954:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80a958:	d2808e01 	mov	x1, #0x470                 	// #1136
ffffffffea80a95c:	94002263 	bl	ffffffffea8132e8 <calloc>
	if (!new_ctx) {
ffffffffea80a960:	b40001e0 	cbz	x0, ffffffffea80a99c <uctx_create+0x5c>
ffffffffea80a964:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80a968:	aa0003f3 	mov	x19, x0
	new_ctx->cur_guest = DEFAULT_GUEST_ID;
ffffffffea80a96c:	529fdda1 	mov	w1, #0xfeed                	// #65261
	handle_list_init(&new_ctx->handle_list);
ffffffffea80a970:	91106000 	add	x0, x0, #0x418
	new_ctx->cur_guest = DEFAULT_GUEST_ID;
ffffffffea80a974:	72bbd5a1 	movk	w1, #0xdead, lsl #16
	new_ctx->priv = priv;
ffffffffea80a978:	f9020a75 	str	x21, [x19, #1040]
	new_ctx->cur_guest = DEFAULT_GUEST_ID;
ffffffffea80a97c:	b9046a61 	str	w1, [x19, #1128]
	handle_list_init(&new_ctx->handle_list);
ffffffffea80a980:	97fffeb0 	bl	ffffffffea80a440 <handle_list_init>
	*ctx = new_ctx;
ffffffffea80a984:	f9000293 	str	x19, [x20]
	return NO_ERROR;
ffffffffea80a988:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80a98c:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea80a990:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80a994:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a998:	d65f03c0 	ret
		return ERR_NO_MEMORY;
ffffffffea80a99c:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea80a9a0:	17fffffc 	b	ffffffffea80a990 <uctx_create+0x50>
ffffffffea80a9a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a9a8 <_uctx_startup>:
{
ffffffffea80a9a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a9ac:	910003fd 	mov	x29, sp
ffffffffea80a9b0:	a90153f3 	stp	x19, x20, [sp, #16]
	int err = uctx_create(app, &uctx);
ffffffffea80a9b4:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80a9b8:	aa1e03f4 	mov	x20, x30
{
ffffffffea80a9bc:	aa0003f3 	mov	x19, x0
	int err = uctx_create(app, &uctx);
ffffffffea80a9c0:	97ffffe0 	bl	ffffffffea80a940 <uctx_create>
	if (err) {
ffffffffea80a9c4:	34000080 	cbz	w0, ffffffffea80a9d4 <_uctx_startup+0x2c>
}
ffffffffea80a9c8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a9cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a9d0:	d65f03c0 	ret
	trusty_als_set(app, _uctx_slot_id, uctx);
ffffffffea80a9d4:	f0000281 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
}

static inline void trusty_als_set(struct trusty_app *app, int slot_id, void *ptr)
{
	uint slot = slot_id - 1;
	ASSERT(slot < als_slot_cnt);
ffffffffea80a9d8:	900002a2 	adrp	x2, ffffffffea85e000 <rb_data+0x18>
ffffffffea80a9dc:	f94017a3 	ldr	x3, [x29, #40]
	uint slot = slot_id - 1;
ffffffffea80a9e0:	b94f3821 	ldr	w1, [x1, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a9e4:	b940cc42 	ldr	w2, [x2, #204]
	uint slot = slot_id - 1;
ffffffffea80a9e8:	51000421 	sub	w1, w1, #0x1
	ASSERT(slot < als_slot_cnt);
ffffffffea80a9ec:	6b02003f 	cmp	w1, w2
ffffffffea80a9f0:	540000c2 	b.cs	ffffffffea80aa08 <_uctx_startup+0x60>  // b.hs, b.nlast
	app->als[slot] = ptr;
ffffffffea80a9f4:	f9403262 	ldr	x2, [x19, #96]
}
ffffffffea80a9f8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a9fc:	f8215843 	str	x3, [x2, w1, uxtw #3]
ffffffffea80aa00:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80aa04:	d65f03c0 	ret
	ASSERT(slot < als_slot_cnt);
ffffffffea80aa08:	b0000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80aa0c:	b0000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80aa10:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80aa14:	910e0084 	add	x4, x4, #0x380
ffffffffea80aa18:	52800d63 	mov	w3, #0x6b                  	// #107
ffffffffea80aa1c:	910e6042 	add	x2, x2, #0x398
ffffffffea80aa20:	9135a021 	add	x1, x1, #0xd68
ffffffffea80aa24:	aa1403e0 	mov	x0, x20
ffffffffea80aa28:	94001c9c 	bl	ffffffffea811c98 <_panic>
ffffffffea80aa2c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80aa30 <uctx_handle_install>:
{
ffffffffea80aa30:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80aa34:	910003fd 	mov	x29, sp
ffffffffea80aa38:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80aa3c:	52800013 	mov	w19, #0x0                   	// #0
{
	uint i;
	int bit;

	for (i = 0; i < BITMAP_NUM_WORDS(numbits); i++) {
		if (bitmap[i] == ~0UL)
ffffffffea80aa40:	f9400004 	ldr	x4, [x0]
ffffffffea80aa44:	b100049f 	cmn	x4, #0x1
ffffffffea80aa48:	54000380 	b.eq	ffffffffea80aab8 <uctx_handle_install+0x88>  // b.none
	return __builtin_ffsl(~x) - 1;
ffffffffea80aa4c:	aa2403e4 	mvn	x4, x4
ffffffffea80aa50:	aa0203f4 	mov	x20, x2
ffffffffea80aa54:	dac00083 	rbit	x3, x4
ffffffffea80aa58:	f100009f 	cmp	x4, #0x0
ffffffffea80aa5c:	dac01063 	clz	x3, x3
ffffffffea80aa60:	5a9f1063 	csinv	w3, w3, wzr, ne  // ne = any
			continue;
		bit = i * BITMAP_BITS_PER_WORD + _ffz(bitmap[i]);
ffffffffea80aa64:	0b130063 	add	w3, w3, w19
ffffffffea80aa68:	aa0303f3 	mov	x19, x3
ffffffffea80aa6c:	8b030c04 	add	x4, x0, x3, lsl #3
	ASSERT(ctx->handles[new_id] == NULL);
ffffffffea80aa70:	f9400882 	ldr	x2, [x4, #16]
ffffffffea80aa74:	b50002c2 	cbnz	x2, ffffffffea80aacc <uctx_handle_install+0x9c>
	return atomic_or(&((int*)bitmap)[BITMAP_INT(bit)], mask) & mask ? 1 : 0;
ffffffffea80aa78:	d345fc63 	lsr	x3, x3, #5
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80aa7c:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80aa80:	1ad32042 	lsl	w2, w2, w19
    return __atomic_fetch_or(ptr, val, __ATOMIC_RELAXED);
ffffffffea80aa84:	8b030803 	add	x3, x0, x3, lsl #2
ffffffffea80aa88:	885f7c65 	ldxr	w5, [x3]
ffffffffea80aa8c:	2a0200a5 	orr	w5, w5, w2
ffffffffea80aa90:	88067c65 	stxr	w6, w5, [x3]
ffffffffea80aa94:	35ffffa6 	cbnz	w6, ffffffffea80aa88 <uctx_handle_install+0x58>
	ctx->handles[new_id] = handle;
ffffffffea80aa98:	f9000881 	str	x1, [x4, #16]
	handle_list_add(&ctx->handle_list, handle);
ffffffffea80aa9c:	91106000 	add	x0, x0, #0x418
ffffffffea80aaa0:	97fffe76 	bl	ffffffffea80a478 <handle_list_add>
	*id = (handle_id_t) new_id;
ffffffffea80aaa4:	b9000293 	str	w19, [x20]
	return NO_ERROR;
ffffffffea80aaa8:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea80aaac:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80aab0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80aab4:	d65f03c0 	ret
		if (bitmap[i] == ~0UL)
ffffffffea80aab8:	f9400404 	ldr	x4, [x0, #8]
ffffffffea80aabc:	b100049f 	cmn	x4, #0x1
ffffffffea80aac0:	54000180 	b.eq	ffffffffea80aaf0 <uctx_handle_install+0xc0>  // b.none
ffffffffea80aac4:	52800813 	mov	w19, #0x40                  	// #64
ffffffffea80aac8:	17ffffe1 	b	ffffffffea80aa4c <uctx_handle_install+0x1c>
	ASSERT(ctx->handles[new_id] == NULL);
ffffffffea80aacc:	b0000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80aad0:	b0000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80aad4:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80aad8:	910fc084 	add	x4, x4, #0x3f0
ffffffffea80aadc:	52801e23 	mov	w3, #0xf1                  	// #241
ffffffffea80aae0:	910d8042 	add	x2, x2, #0x360
ffffffffea80aae4:	9135a021 	add	x1, x1, #0xd68
ffffffffea80aae8:	aa1e03e0 	mov	x0, x30
ffffffffea80aaec:	94001c6b 	bl	ffffffffea811c98 <_panic>
		return ERR_NO_RESOURCES;
ffffffffea80aaf0:	12800500 	mov	w0, #0xffffffd7            	// #-41
ffffffffea80aaf4:	17ffffee 	b	ffffffffea80aaac <uctx_handle_install+0x7c>

ffffffffea80aaf8 <uctx_handle_get>:
{
ffffffffea80aaf8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80aafc:	910003fd 	mov	x29, sp
ffffffffea80ab00:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80ab04:	2a0103f4 	mov	w20, w1
ffffffffea80ab08:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80ab0c:	aa0003f6 	mov	x22, x0
ffffffffea80ab10:	aa0203f5 	mov	x21, x2
	int ret = _check_handle_id (ctx, handle_id);
ffffffffea80ab14:	97ffff19 	bl	ffffffffea80a778 <_check_handle_id>
ffffffffea80ab18:	2a0003f3 	mov	w19, w0
	if (ret == NO_ERROR) {
ffffffffea80ab1c:	350000e0 	cbnz	w0, ffffffffea80ab38 <uctx_handle_get+0x40>
		handle_t *handle = ctx->handles[handle_id];
ffffffffea80ab20:	8b344ed4 	add	x20, x22, w20, uxtw #3
		platform_arch_speculation_barrier();
ffffffffea80ab24:	97ffddc3 	bl	ffffffffea802230 <platform_arch_speculation_barrier>
		handle_t *handle = ctx->handles[handle_id];
ffffffffea80ab28:	f9400a94 	ldr	x20, [x20, #16]
		handle_incref(handle);
ffffffffea80ab2c:	aa1403e0 	mov	x0, x20
ffffffffea80ab30:	97fffdb2 	bl	ffffffffea80a1f8 <handle_incref>
		*handle_ptr = handle;
ffffffffea80ab34:	f90002b4 	str	x20, [x21]
}
ffffffffea80ab38:	2a1303e0 	mov	w0, w19
ffffffffea80ab3c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ab40:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ab44:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ab48:	d65f03c0 	ret
ffffffffea80ab4c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80ab50 <uctx_handle_remove>:
{
ffffffffea80ab50:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80ab54:	910003fd 	mov	x29, sp
ffffffffea80ab58:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80ab5c:	aa0003f4 	mov	x20, x0
ffffffffea80ab60:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80ab64:	2a0103f5 	mov	w21, w1
ffffffffea80ab68:	aa0203f6 	mov	x22, x2
	int ret = _check_handle_id(ctx, handle_id);
ffffffffea80ab6c:	97ffff03 	bl	ffffffffea80a778 <_check_handle_id>
ffffffffea80ab70:	2a0003f3 	mov	w19, w0
	if (ret == NO_ERROR) {
ffffffffea80ab74:	340000c0 	cbz	w0, ffffffffea80ab8c <uctx_handle_remove+0x3c>
}
ffffffffea80ab78:	2a1303e0 	mov	w0, w19
ffffffffea80ab7c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ab80:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ab84:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ab88:	d65f03c0 	ret
		platform_arch_speculation_barrier();
ffffffffea80ab8c:	97ffdda9 	bl	ffffffffea802230 <platform_arch_speculation_barrier>
ffffffffea80ab90:	8b354e82 	add	x2, x20, w21, uxtw #3
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80ab94:	93437ea0 	sbfx	x0, x21, #3, #29
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80ab98:	52800021 	mov	w1, #0x1                   	// #1
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea80ab9c:	927ee800 	and	x0, x0, #0x1ffffffffffffffc
ffffffffea80aba0:	1ad52021 	lsl	w1, w1, w21
ffffffffea80aba4:	8b000280 	add	x0, x20, x0
		handle_t *handle = ctx->handles[handle_id];
ffffffffea80aba8:	f9400855 	ldr	x21, [x2, #16]
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80abac:	2a2103e1 	mvn	w1, w1
ffffffffea80abb0:	885f7c03 	ldxr	w3, [x0]
ffffffffea80abb4:	0a010063 	and	w3, w3, w1
ffffffffea80abb8:	88047c03 	stxr	w4, w3, [x0]
ffffffffea80abbc:	35ffffa4 	cbnz	w4, ffffffffea80abb0 <uctx_handle_remove+0x60>
		ctx->handles[handle_id] = NULL;
ffffffffea80abc0:	f900085f 	str	xzr, [x2, #16]
		handle_list_del(&ctx->handle_list, handle);
ffffffffea80abc4:	aa1503e1 	mov	x1, x21
ffffffffea80abc8:	91106280 	add	x0, x20, #0x418
ffffffffea80abcc:	97fffe55 	bl	ffffffffea80a520 <handle_list_del>
		*handle_ptr = handle;
ffffffffea80abd0:	f90002d5 	str	x21, [x22]
}
ffffffffea80abd4:	2a1303e0 	mov	w0, w19
ffffffffea80abd8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80abdc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80abe0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80abe4:	d65f03c0 	ret

ffffffffea80abe8 <sys_wait>:
/*
 *   wait on single handle specified by handle id
 */
long __SYSCALL sys_wait(uint32_t handle_id, user_addr_t user_event,
                        unsigned long timeout_msecs)
{
ffffffffea80abe8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80abec:	910003fd 	mov	x29, sp
ffffffffea80abf0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80abf4:	2a0003f4 	mov	w20, w0
ffffffffea80abf8:	f90013f5 	str	x21, [sp, #32]
ffffffffea80abfc:	aa0203f3 	mov	x19, x2
ffffffffea80ac00:	2a0103f5 	mov	w21, w1
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80ac04:	d538d082 	mrs	x2, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80ac08:	f0000280 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
	ASSERT(slot < als_slot_cnt);
ffffffffea80ac0c:	900002a1 	adrp	x1, ffffffffea85e000 <rb_data+0x18>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80ac10:	f9415842 	ldr	x2, [x2, #688]
	uint slot = slot_id - 1;
ffffffffea80ac14:	b94f3800 	ldr	w0, [x0, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80ac18:	b940cc21 	ldr	w1, [x1, #204]
	uint slot = slot_id - 1;
ffffffffea80ac1c:	51000400 	sub	w0, w0, #0x1
ffffffffea80ac20:	f9404842 	ldr	x2, [x2, #144]
	ASSERT(slot < als_slot_cnt);
ffffffffea80ac24:	6b01001f 	cmp	w0, w1
ffffffffea80ac28:	540004e2 	b.cs	ffffffffea80acc4 <sys_wait+0xdc>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80ac2c:	f9403043 	ldr	x3, [x2, #96]
	int ret;

	LTRACEF("[%p][%d]: %ld msec\n", uthread_get_current(),
	                                handle_id, timeout_msecs);

	ret = uctx_handle_get(ctx, handle_id, &handle);
ffffffffea80ac30:	2a1403e1 	mov	w1, w20
ffffffffea80ac34:	9100e3a2 	add	x2, x29, #0x38
ffffffffea80ac38:	f8605860 	ldr	x0, [x3, w0, uxtw #3]
ffffffffea80ac3c:	97ffffaf 	bl	ffffffffea80aaf8 <uctx_handle_get>
	if (ret != NO_ERROR) {
ffffffffea80ac40:	340000c0 	cbz	w0, ffffffffea80ac58 <sys_wait+0x70>
	handle_decref(handle);

	LTRACEF("[%p][%d]: ret = %d\n", uthread_get_current(),
	                                handle_id, ret);
	return ret;
}
ffffffffea80ac44:	a94153f3 	ldp	x19, x20, [sp, #16]
		return ret;
ffffffffea80ac48:	93407c00 	sxtw	x0, w0
}
ffffffffea80ac4c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ac50:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80ac54:	d65f03c0 	ret
	ret = handle_wait(handle, &tmp_event.event,
ffffffffea80ac58:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80ac5c:	2a1303e2 	mov	w2, w19
ffffffffea80ac60:	910113a1 	add	x1, x29, #0x44
ffffffffea80ac64:	97fffd9f 	bl	ffffffffea80a2e0 <handle_wait>
ffffffffea80ac68:	2a0003f3 	mov	w19, w0
	if (ret < 0) {
ffffffffea80ac6c:	36f80100 	tbz	w0, #31, ffffffffea80ac8c <sys_wait+0xa4>
	handle_decref(handle);
ffffffffea80ac70:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80ac74:	97fffd67 	bl	ffffffffea80a210 <handle_decref>
	return ret;
ffffffffea80ac78:	93407e60 	sxtw	x0, w19
}
ffffffffea80ac7c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ac80:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ac84:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80ac88:	d65f03c0 	ret
	handle->cookie = cookie;
}

static inline void *handle_get_cookie(handle_t *handle)
{
	return handle->cookie;
ffffffffea80ac8c:	f9401fa3 	ldr	x3, [x29, #56]
ffffffffea80ac90:	d2800182 	mov	x2, #0xc                   	// #12
ffffffffea80ac94:	910103a1 	add	x1, x29, #0x40
ffffffffea80ac98:	2a1503e0 	mov	w0, w21
	tmp_event.handle = handle_id;
ffffffffea80ac9c:	b90043b4 	str	w20, [x29, #64]
	tmp_event.cookie = (user_addr_t)(uintptr_t)handle_get_cookie(handle);
ffffffffea80aca0:	f9401863 	ldr	x3, [x3, #48]
ffffffffea80aca4:	b9004ba3 	str	w3, [x29, #72]
ffffffffea80aca8:	9400231c 	bl	ffffffffea813918 <arch_copy_to_user>
	if (status) {
ffffffffea80acac:	340001e0 	cbz	w0, ffffffffea80ace8 <sys_wait+0x100>
ffffffffea80acb0:	2a0003f3 	mov	w19, w0
	handle_decref(handle);
ffffffffea80acb4:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80acb8:	97fffd56 	bl	ffffffffea80a210 <handle_decref>
	return ret;
ffffffffea80acbc:	93407e60 	sxtw	x0, w19
ffffffffea80acc0:	17ffffef 	b	ffffffffea80ac7c <sys_wait+0x94>
	ASSERT(slot < als_slot_cnt);
ffffffffea80acc4:	b0000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80acc8:	b0000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80accc:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80acd0:	910e0084 	add	x4, x4, #0x380
ffffffffea80acd4:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80acd8:	910e6042 	add	x2, x2, #0x398
ffffffffea80acdc:	9135a021 	add	x1, x1, #0xd68
ffffffffea80ace0:	aa1e03e0 	mov	x0, x30
ffffffffea80ace4:	94001bed 	bl	ffffffffea811c98 <_panic>
		set_current_guest(handle);
ffffffffea80ace8:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80acec:	97fffebf 	bl	ffffffffea80a7e8 <set_current_guest>
out:
ffffffffea80acf0:	17ffffe0 	b	ffffffffea80ac70 <sys_wait+0x88>
ffffffffea80acf4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80acf8 <sys_wait_any>:

/*
 *   Wait on any handle existing in user context.
 */
long __SYSCALL sys_wait_any(user_addr_t user_event, unsigned long timeout_msecs)
{
ffffffffea80acf8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80acfc:	910003fd 	mov	x29, sp
ffffffffea80ad00:	f90013f5 	str	x21, [sp, #32]
ffffffffea80ad04:	2a0003f5 	mov	w21, w0
ffffffffea80ad08:	d538d084 	mrs	x4, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80ad0c:	f0000280 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80ad10:	f9415884 	ldr	x4, [x4, #688]
ffffffffea80ad14:	900002a2 	adrp	x2, ffffffffea85e000 <rb_data+0x18>
	uint slot = slot_id - 1;
ffffffffea80ad18:	b94f3800 	ldr	w0, [x0, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80ad1c:	b940cc42 	ldr	w2, [x2, #204]
ffffffffea80ad20:	f9404883 	ldr	x3, [x4, #144]
	uint slot = slot_id - 1;
ffffffffea80ad24:	51000400 	sub	w0, w0, #0x1
ffffffffea80ad28:	a90153b3 	stp	x19, x20, [x29, #16]
	ASSERT(slot < als_slot_cnt);
ffffffffea80ad2c:	6b02001f 	cmp	w0, w2
ffffffffea80ad30:	54000562 	b.cs	ffffffffea80addc <sys_wait_any+0xe4>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80ad34:	f9403064 	ldr	x4, [x3, #96]
	                            timeout_msecs);
	/*
	 * Get a handle that has a pending event. The returned handle has
	 * extra ref taken.
	 */
	ret = handle_list_wait(&ctx->handle_list, &handle, &tmp_event.event,
ffffffffea80ad38:	910113a2 	add	x2, x29, #0x44
ffffffffea80ad3c:	2a0103e3 	mov	w3, w1
ffffffffea80ad40:	9100e3a1 	add	x1, x29, #0x38
ffffffffea80ad44:	f8605893 	ldr	x19, [x4, w0, uxtw #3]
ffffffffea80ad48:	91106260 	add	x0, x19, #0x418
ffffffffea80ad4c:	97fffe07 	bl	ffffffffea80a568 <handle_list_wait>
ffffffffea80ad50:	2a0003f4 	mov	w20, w0
			       timeout_msecs);
	if (ret < 0) {
ffffffffea80ad54:	37f802c0 	tbnz	w0, #31, ffffffffea80adac <sys_wait_any+0xb4>
ffffffffea80ad58:	91004261 	add	x1, x19, #0x10
	for (int i = 0; i < IPC_MAX_HANDLES; i++) {
ffffffffea80ad5c:	52800002 	mov	w2, #0x0                   	// #0
		goto out;
	}

	DEBUG_ASSERT(handle); /* there should be a handle */

	tmp_event.handle = _handle_to_id_locked(ctx, handle);
ffffffffea80ad60:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80ad64:	14000005 	b	ffffffffea80ad78 <sys_wait_any+0x80>
	for (int i = 0; i < IPC_MAX_HANDLES; i++) {
ffffffffea80ad68:	11000442 	add	w2, w2, #0x1
ffffffffea80ad6c:	91002021 	add	x1, x1, #0x8
ffffffffea80ad70:	7102005f 	cmp	w2, #0x80
ffffffffea80ad74:	54000460 	b.eq	ffffffffea80ae00 <sys_wait_any+0x108>  // b.none
		if (ctx->handles[i] == handle) {
ffffffffea80ad78:	f9400023 	ldr	x3, [x1]
ffffffffea80ad7c:	eb03001f 	cmp	x0, x3
ffffffffea80ad80:	54ffff41 	b.ne	ffffffffea80ad68 <sys_wait_any+0x70>  // b.any
	tmp_event.cookie = (user_addr_t)(uintptr_t)handle_get_cookie(handle);
ffffffffea80ad84:	f9401801 	ldr	x1, [x0, #48]
	tmp_event.handle = _handle_to_id_locked(ctx, handle);
ffffffffea80ad88:	b90043a2 	str	w2, [x29, #64]
	tmp_event.cookie = (user_addr_t)(uintptr_t)handle_get_cookie(handle);
ffffffffea80ad8c:	b9004ba1 	str	w1, [x29, #72]

	/* drop the reference that was taken by wait_any */
	handle_decref(handle);
ffffffffea80ad90:	97fffd20 	bl	ffffffffea80a210 <handle_decref>
ffffffffea80ad94:	d2800182 	mov	x2, #0xc                   	// #12
ffffffffea80ad98:	910103a1 	add	x1, x29, #0x40
ffffffffea80ad9c:	2a1503e0 	mov	w0, w21
ffffffffea80ada0:	940022de 	bl	ffffffffea813918 <arch_copy_to_user>

	/* there should be a handle id */
	DEBUG_ASSERT(tmp_event.handle < IPC_MAX_HANDLES);

	status = copy_to_user(user_event, &tmp_event, sizeof(tmp_event));
	if (status) {
ffffffffea80ada4:	340000e0 	cbz	w0, ffffffffea80adc0 <sys_wait_any+0xc8>
ffffffffea80ada8:	2a0003f4 	mov	w20, w0
	}
out:
	LTRACEF("[%p][%d]: ret = %d\n", uthread_get_current(),
	                                tmp_event.handle, ret);
	return ret;
}
ffffffffea80adac:	93407e80 	sxtw	x0, w20
ffffffffea80adb0:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80adb4:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80adb8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80adbc:	d65f03c0 	ret
		set_current_guest(handle);
ffffffffea80adc0:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80adc4:	97fffe89 	bl	ffffffffea80a7e8 <set_current_guest>
}
ffffffffea80adc8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80adcc:	93407e80 	sxtw	x0, w20
ffffffffea80add0:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80add4:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80add8:	d65f03c0 	ret
	ASSERT(slot < als_slot_cnt);
ffffffffea80addc:	b0000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80ade0:	b0000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80ade4:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80ade8:	910e0084 	add	x4, x4, #0x380
ffffffffea80adec:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80adf0:	910e6042 	add	x2, x2, #0x398
ffffffffea80adf4:	9135a021 	add	x1, x1, #0xd68
ffffffffea80adf8:	aa1e03e0 	mov	x0, x30
ffffffffea80adfc:	94001ba7 	bl	ffffffffea811c98 <_panic>
	return INVALID_HANDLE_ID;
ffffffffea80ae00:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea80ae04:	17ffffe0 	b	ffffffffea80ad84 <sys_wait_any+0x8c>

ffffffffea80ae08 <sys_close>:

long __SYSCALL sys_close(uint32_t handle_id)
{
ffffffffea80ae08:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80ae0c:	910003fd 	mov	x29, sp
ffffffffea80ae10:	d538d084 	mrs	x4, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80ae14:	f0000283 	adrp	x3, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80ae18:	900002a2 	adrp	x2, ffffffffea85e000 <rb_data+0x18>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80ae1c:	f9415884 	ldr	x4, [x4, #688]
	uint slot = slot_id - 1;
ffffffffea80ae20:	b94f3863 	ldr	w3, [x3, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80ae24:	b940cc42 	ldr	w2, [x2, #204]
	uint slot = slot_id - 1;
ffffffffea80ae28:	51000463 	sub	w3, w3, #0x1
ffffffffea80ae2c:	f9404881 	ldr	x1, [x4, #144]
	ASSERT(slot < als_slot_cnt);
ffffffffea80ae30:	6b02007f 	cmp	w3, w2
ffffffffea80ae34:	540001e2 	b.cs	ffffffffea80ae70 <sys_close+0x68>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80ae38:	f9403024 	ldr	x4, [x1, #96]
	handle_t *handle;

	LTRACEF("[%p][%d]\n", uthread_get_current(),
	                      handle_id);

	int ret = uctx_handle_remove(current_uctx(), handle_id, &handle);
ffffffffea80ae3c:	2a0003e1 	mov	w1, w0
ffffffffea80ae40:	910063a2 	add	x2, x29, #0x18
ffffffffea80ae44:	f8635880 	ldr	x0, [x4, w3, uxtw #3]
ffffffffea80ae48:	97ffff42 	bl	ffffffffea80ab50 <uctx_handle_remove>
	if (ret != NO_ERROR) {
ffffffffea80ae4c:	34000080 	cbz	w0, ffffffffea80ae5c <sys_close+0x54>
		return ret;
ffffffffea80ae50:	93407c00 	sxtw	x0, w0
	}
	handle_close(handle);
	return NO_ERROR;
}
ffffffffea80ae54:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80ae58:	d65f03c0 	ret
	handle_close(handle);
ffffffffea80ae5c:	f9400fa0 	ldr	x0, [x29, #24]
ffffffffea80ae60:	97fffd14 	bl	ffffffffea80a2b0 <handle_close>
	return NO_ERROR;
ffffffffea80ae64:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80ae68:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80ae6c:	d65f03c0 	ret
	ASSERT(slot < als_slot_cnt);
ffffffffea80ae70:	b0000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80ae74:	b0000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80ae78:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80ae7c:	910e0084 	add	x4, x4, #0x380
ffffffffea80ae80:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80ae84:	910e6042 	add	x2, x2, #0x398
ffffffffea80ae88:	9135a021 	add	x1, x1, #0xd68
ffffffffea80ae8c:	aa1e03e0 	mov	x0, x30
ffffffffea80ae90:	94001b82 	bl	ffffffffea811c98 <_panic>
ffffffffea80ae94:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80ae98 <sys_set_cookie>:

long __SYSCALL sys_set_cookie(uint32_t handle_id, user_addr_t cookie)
{
ffffffffea80ae98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80ae9c:	910003fd 	mov	x29, sp
ffffffffea80aea0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80aea4:	2a0103f3 	mov	w19, w1
ffffffffea80aea8:	d538d082 	mrs	x2, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80aeac:	f0000283 	adrp	x3, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80aeb0:	900002a1 	adrp	x1, ffffffffea85e000 <rb_data+0x18>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80aeb4:	f9415842 	ldr	x2, [x2, #688]
	uint slot = slot_id - 1;
ffffffffea80aeb8:	b94f3863 	ldr	w3, [x3, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80aebc:	b940cc21 	ldr	w1, [x1, #204]
	uint slot = slot_id - 1;
ffffffffea80aec0:	51000463 	sub	w3, w3, #0x1
ffffffffea80aec4:	f9404842 	ldr	x2, [x2, #144]
	ASSERT(slot < als_slot_cnt);
ffffffffea80aec8:	6b01007f 	cmp	w3, w1
ffffffffea80aecc:	54000262 	b.cs	ffffffffea80af18 <sys_set_cookie+0x80>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80aed0:	f9403044 	ldr	x4, [x2, #96]
	handle_t *handle;

	LTRACEF("[%p][%d]: cookie = 0x%08x\n", uthread_get_current(),
	                              handle_id, (uint) cookie);

	int ret = uctx_handle_get(current_uctx(), handle_id, &handle);
ffffffffea80aed4:	2a0003e1 	mov	w1, w0
ffffffffea80aed8:	9100a3a2 	add	x2, x29, #0x28
ffffffffea80aedc:	f8635880 	ldr	x0, [x4, w3, uxtw #3]
ffffffffea80aee0:	97ffff06 	bl	ffffffffea80aaf8 <uctx_handle_get>
	if (ret != NO_ERROR) {
ffffffffea80aee4:	340000a0 	cbz	w0, ffffffffea80aef8 <sys_set_cookie+0x60>
	}
	handle_set_cookie(handle, (void *)(uintptr_t)cookie);

	handle_decref(handle);
	return NO_ERROR;
}
ffffffffea80aee8:	f9400bf3 	ldr	x19, [sp, #16]
		return ret;
ffffffffea80aeec:	93407c00 	sxtw	x0, w0
}
ffffffffea80aef0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80aef4:	d65f03c0 	ret
	handle_set_cookie(handle, (void *)(uintptr_t)cookie);
ffffffffea80aef8:	f94017a1 	ldr	x1, [x29, #40]
	handle_decref(handle);
ffffffffea80aefc:	aa0103e0 	mov	x0, x1
	handle_set_cookie(handle, (void *)(uintptr_t)cookie);
ffffffffea80af00:	f9001833 	str	x19, [x1, #48]
	handle_decref(handle);
ffffffffea80af04:	97fffcc3 	bl	ffffffffea80a210 <handle_decref>
}
ffffffffea80af08:	f9400bf3 	ldr	x19, [sp, #16]
	return NO_ERROR;
ffffffffea80af0c:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80af10:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80af14:	d65f03c0 	ret
	ASSERT(slot < als_slot_cnt);
ffffffffea80af18:	b0000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80af1c:	b0000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80af20:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80af24:	910e0084 	add	x4, x4, #0x380
ffffffffea80af28:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80af2c:	910e6042 	add	x2, x2, #0x398
ffffffffea80af30:	9135a021 	add	x1, x1, #0xd68
ffffffffea80af34:	aa1e03e0 	mov	x0, x30
ffffffffea80af38:	94001b58 	bl	ffffffffea811c98 <_panic>
ffffffffea80af3c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80af40 <port_poll>:
	}
	return NULL;
}

static uint32_t port_poll(handle_t *phandle)
{
ffffffffea80af40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80af44:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80af48:	910003fd 	mov	x29, sp
ffffffffea80af4c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80af50:	aa0003f3 	mov	x19, x0
ffffffffea80af54:	f0000074 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea80af58:	9136e280 	add	x0, x20, #0xdb8
ffffffffea80af5c:	97ffea97 	bl	ffffffffea8059b8 <mutex_acquire_timeout>

	ipc_port_t *port = containerof(phandle, ipc_port_t, handle);
	uint32_t events = 0;

	mutex_acquire(&ipc_lock);
	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80af60:	b85e8260 	ldur	w0, [x19, #-24]
ffffffffea80af64:	7100041f 	cmp	w0, #0x1
ffffffffea80af68:	54000161 	b.ne	ffffffffea80af94 <port_poll+0x54>  // b.any
		events |= IPC_HANDLE_POLL_ERROR;
	} else if (!list_is_empty(&port->pending_list)) {
ffffffffea80af6c:	f9402660 	ldr	x0, [x19, #72]
ffffffffea80af70:	91010273 	add	x19, x19, #0x40
ffffffffea80af74:	eb13001f 	cmp	x0, x19
		events |= IPC_HANDLE_POLL_READY;
	} else {
		/* All if-else chains must end with an else clause */
	}
	LTRACEF("%s in state %d events %x\n", port->path, port->state, events);
	mutex_release(&ipc_lock);
ffffffffea80af78:	9136e280 	add	x0, x20, #0xdb8
	} else if (!list_is_empty(&port->pending_list)) {
ffffffffea80af7c:	1a9f07f3 	cset	w19, ne  // ne = any
	mutex_release(&ipc_lock);
ffffffffea80af80:	97ffeaba 	bl	ffffffffea805a68 <mutex_release>

	return events;
}
ffffffffea80af84:	2a1303e0 	mov	w0, w19
ffffffffea80af88:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80af8c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80af90:	d65f03c0 	ret
		events |= IPC_HANDLE_POLL_ERROR;
ffffffffea80af94:	52800053 	mov	w19, #0x2                   	// #2
	mutex_release(&ipc_lock);
ffffffffea80af98:	9136e280 	add	x0, x20, #0xdb8
ffffffffea80af9c:	97ffeab3 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea80afa0:	2a1303e0 	mov	w0, w19
ffffffffea80afa4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80afa8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80afac:	d65f03c0 	ret

ffffffffea80afb0 <chan_poll>:

/*
 *  Poll channel state
 */
static uint32_t chan_poll(handle_t *chandle)
{
ffffffffea80afb0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80afb4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80afb8:	910003fd 	mov	x29, sp
ffffffffea80afbc:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80afc0:	aa0003f4 	mov	x20, x0
ffffffffea80afc4:	f90013f5 	str	x21, [sp, #32]
ffffffffea80afc8:	f0000075 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea80afcc:	9136e2a0 	add	x0, x21, #0xdb8
ffffffffea80afd0:	97ffea7a 	bl	ffffffffea8059b8 <mutex_acquire_timeout>

	ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);

	uint32_t events = 0;

	if (chan->state == IPC_CHAN_STATE_INVALID) {
ffffffffea80afd4:	b85e0293 	ldur	w19, [x20, #-32]
ffffffffea80afd8:	340002f3 	cbz	w19, ffffffffea80b034 <chan_poll+0x84>
	if (chan->state == IPC_CHAN_STATE_DISCONNECTING) {
		events |= IPC_HANDLE_POLL_HUP;
	}

	/* server accepted our connection */
	if (chan->aux_state & IPC_CHAN_AUX_STATE_CONNECTED) {
ffffffffea80afdc:	b85e8281 	ldur	w1, [x20, #-24]
	uint32_t events = 0;
ffffffffea80afe0:	7100127f 	cmp	w19, #0x4
		events |= IPC_HANDLE_POLL_READY;
	}

	/* have a pending message? */
	if (chan->msg_queue && !ipc_msg_queue_is_empty(chan->msg_queue)) {
ffffffffea80afe4:	f9403280 	ldr	x0, [x20, #96]
	uint32_t events = 0;
ffffffffea80afe8:	1a9f0273 	csel	w19, w19, wzr, eq  // eq = none
		events |= IPC_HANDLE_POLL_READY;
ffffffffea80afec:	32000262 	orr	w2, w19, #0x1
ffffffffea80aff0:	f27e003f 	tst	x1, #0x4
ffffffffea80aff4:	1a931053 	csel	w19, w2, w19, ne  // ne = any
	if (chan->msg_queue && !ipc_msg_queue_is_empty(chan->msg_queue)) {
ffffffffea80aff8:	b40000a0 	cbz	x0, ffffffffea80b00c <chan_poll+0x5c>
ffffffffea80affc:	940006d9 	bl	ffffffffea80cb60 <ipc_msg_queue_is_empty>
ffffffffea80b000:	72001c1f 	tst	w0, #0xff
ffffffffea80b004:	b85e8281 	ldur	w1, [x20, #-24]
ffffffffea80b008:	54000260 	b.eq	ffffffffea80b054 <chan_poll+0xa4>  // b.none
		events |= IPC_HANDLE_POLL_MSG;
	}

	/* check if we were send blocked */
	if (chan->aux_state & IPC_CHAN_AUX_STATE_SEND_UNBLOCKED) {
		events |= IPC_HANDLE_POLL_SEND_UNBLOCKED;
ffffffffea80b00c:	f27f003f 	tst	x1, #0x2
ffffffffea80b010:	321c0260 	orr	w0, w19, #0x10
ffffffffea80b014:	1a931013 	csel	w19, w0, w19, ne  // ne = any
	}

done:
	mutex_release(&ipc_lock);
ffffffffea80b018:	9136e2a0 	add	x0, x21, #0xdb8
ffffffffea80b01c:	97ffea93 	bl	ffffffffea805a68 <mutex_release>
	return events;
}
ffffffffea80b020:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80b024:	2a1303e0 	mov	w0, w19
ffffffffea80b028:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b02c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b030:	d65f03c0 	ret
		events |= IPC_HANDLE_POLL_ERROR;
ffffffffea80b034:	52800053 	mov	w19, #0x2                   	// #2
	mutex_release(&ipc_lock);
ffffffffea80b038:	9136e2a0 	add	x0, x21, #0xdb8
ffffffffea80b03c:	97ffea8b 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea80b040:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80b044:	2a1303e0 	mov	w0, w19
ffffffffea80b048:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b04c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b050:	d65f03c0 	ret
		events |= IPC_HANDLE_POLL_MSG;
ffffffffea80b054:	321d0273 	orr	w19, w19, #0x8
ffffffffea80b058:	17ffffed 	b	ffffffffea80b00c <chan_poll+0x5c>
ffffffffea80b05c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b060 <chan_alloc>:
{
ffffffffea80b060:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80b064:	910003fd 	mov	x29, sp
ffffffffea80b068:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b06c:	2a0003f4 	mov	w20, w0
ffffffffea80b070:	f90013f5 	str	x21, [sp, #32]
ffffffffea80b074:	aa0203f3 	mov	x19, x2
ffffffffea80b078:	aa0103f5 	mov	x21, x1
	chan = calloc(1, sizeof(ipc_chan_t));
ffffffffea80b07c:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80b080:	d2801801 	mov	x1, #0xc0                  	// #192
ffffffffea80b084:	94002099 	bl	ffffffffea8132e8 <calloc>
	if (!chan) {
ffffffffea80b088:	b4000100 	cbz	x0, ffffffffea80b0a8 <chan_alloc+0x48>
	list->prev->next = item;
ffffffffea80b08c:	a9004c13 	stp	x19, x19, [x0]
}

static inline __ALWAYS_INLINE
void obj_ref_init(obj_ref_t *ref)
{
	*ref = (obj_ref_t)OBJ_REF_INITIAL_VALUE(*ref);
ffffffffea80b090:	a9017c1f 	stp	xzr, xzr, [x0, #16]
	chan->uuid  = uuid;
ffffffffea80b094:	f9001415 	str	x21, [x0, #40]
	chan->flags = flags;
ffffffffea80b098:	2906501f 	stp	wzr, w20, [x0, #48]
ffffffffea80b09c:	a9047c1f 	stp	xzr, xzr, [x0, #64]
ffffffffea80b0a0:	a9097c1f 	stp	xzr, xzr, [x0, #144]
	item->next = list;
ffffffffea80b0a4:	a9000260 	stp	x0, x0, [x19]
}
ffffffffea80b0a8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b0ac:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80b0b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b0b4:	d65f03c0 	ret

ffffffffea80b0b8 <port_find_locked>:
{
ffffffffea80b0b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80b0bc:	910003fd 	mov	x29, sp
ffffffffea80b0c0:	a90153f3 	stp	x19, x20, [sp, #16]
	list_for_every_entry(&ipc_port_list, port, ipc_port_t, node) {
ffffffffea80b0c4:	d0000074 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea80b0c8:	91384294 	add	x20, x20, #0xe10
ffffffffea80b0cc:	f9400681 	ldr	x1, [x20, #8]
ffffffffea80b0d0:	eb01029f 	cmp	x20, x1
ffffffffea80b0d4:	54000300 	b.eq	ffffffffea80b134 <port_find_locked+0x7c>  // b.none
ffffffffea80b0d8:	f90013b5 	str	x21, [x29, #32]
ffffffffea80b0dc:	d102c033 	sub	x19, x1, #0xb0
ffffffffea80b0e0:	aa0003f5 	mov	x21, x0
ffffffffea80b0e4:	14000005 	b	ffffffffea80b0f8 <port_find_locked+0x40>
ffffffffea80b0e8:	f9405e61 	ldr	x1, [x19, #184]
ffffffffea80b0ec:	d102c033 	sub	x19, x1, #0xb0
ffffffffea80b0f0:	eb01029f 	cmp	x20, x1
ffffffffea80b0f4:	54000140 	b.eq	ffffffffea80b11c <port_find_locked+0x64>  // b.none
		if (!strcmp(path, port->path)) {
ffffffffea80b0f8:	aa1303e1 	mov	x1, x19
ffffffffea80b0fc:	aa1503e0 	mov	x0, x21
ffffffffea80b100:	94002168 	bl	ffffffffea8136a0 <strcmp>
ffffffffea80b104:	35ffff20 	cbnz	w0, ffffffffea80b0e8 <port_find_locked+0x30>
ffffffffea80b108:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80b10c:	aa1303e0 	mov	x0, x19
ffffffffea80b110:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b114:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b118:	d65f03c0 	ret
	return NULL;
ffffffffea80b11c:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea80b120:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80b124:	aa1303e0 	mov	x0, x19
ffffffffea80b128:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b12c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b130:	d65f03c0 	ret
	return NULL;
ffffffffea80b134:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea80b138:	17fffff5 	b	ffffffffea80b10c <port_find_locked+0x54>
ffffffffea80b13c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b140 <chan_finalize_event>:
static void chan_finalize_event(handle_t *chandle, uint32_t event)
{
	DEBUG_ASSERT(chandle);
	DEBUG_ASSERT(ipc_is_channel(chandle));

	if (event & (IPC_HANDLE_POLL_SEND_UNBLOCKED | IPC_HANDLE_POLL_READY)) {
ffffffffea80b140:	52800222 	mov	w2, #0x11                  	// #17
ffffffffea80b144:	6a02003f 	tst	w1, w2
ffffffffea80b148:	54000041 	b.ne	ffffffffea80b150 <chan_finalize_event+0x10>  // b.any
ffffffffea80b14c:	d65f03c0 	ret
{
ffffffffea80b150:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80b154:	910003fd 	mov	x29, sp
ffffffffea80b158:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b15c:	2a0103f3 	mov	w19, w1
ffffffffea80b160:	f90013f5 	str	x21, [sp, #32]
ffffffffea80b164:	aa0003f4 	mov	x20, x0
ffffffffea80b168:	d0000075 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea80b16c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b170:	9136e2a0 	add	x0, x21, #0xdb8
ffffffffea80b174:	97ffea11 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
		mutex_acquire(&ipc_lock);
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		if (event & IPC_HANDLE_POLL_SEND_UNBLOCKED) {
ffffffffea80b178:	36200093 	tbz	w19, #4, ffffffffea80b188 <chan_finalize_event+0x48>
			chan->aux_state &= ~IPC_CHAN_AUX_STATE_SEND_UNBLOCKED;
ffffffffea80b17c:	b85e8280 	ldur	w0, [x20, #-24]
ffffffffea80b180:	121e7800 	and	w0, w0, #0xfffffffd
ffffffffea80b184:	b81e8280 	stur	w0, [x20, #-24]
		}
		if (event & IPC_HANDLE_POLL_READY) {
ffffffffea80b188:	36000093 	tbz	w19, #0, ffffffffea80b198 <chan_finalize_event+0x58>
			chan->aux_state &= ~IPC_CHAN_AUX_STATE_CONNECTED;
ffffffffea80b18c:	b85e8280 	ldur	w0, [x20, #-24]
ffffffffea80b190:	121d7800 	and	w0, w0, #0xfffffffb
ffffffffea80b194:	b81e8280 	stur	w0, [x20, #-24]
		}
		mutex_release(&ipc_lock);
ffffffffea80b198:	9136e2a0 	add	x0, x21, #0xdb8
	}
}
ffffffffea80b19c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80b1a0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b1a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
		mutex_release(&ipc_lock);
ffffffffea80b1a8:	17ffea30 	b	ffffffffea805a68 <mutex_release>
ffffffffea80b1ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b1b0 <port_handle_destroy>:
{
ffffffffea80b1b0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80b1b4:	910003fd 	mov	x29, sp
	ASSERT(phandle);
ffffffffea80b1b8:	b4000120 	cbz	x0, ffffffffea80b1dc <port_handle_destroy+0x2c>
	ASSERT(ipc_is_port(phandle));
ffffffffea80b1bc:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80b1c0:	d0000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea80b1c4:	9137c021 	add	x1, x1, #0xdf0
ffffffffea80b1c8:	eb01005f 	cmp	x2, x1
ffffffffea80b1cc:	540001a1 	b.ne	ffffffffea80b200 <port_handle_destroy+0x50>  // b.any
}
ffffffffea80b1d0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(port);
ffffffffea80b1d4:	d1018000 	sub	x0, x0, #0x60
ffffffffea80b1d8:	14002054 	b	ffffffffea813328 <free>
	ASSERT(phandle);
ffffffffea80b1dc:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b1e0:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b1e4:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b1e8:	91144084 	add	x4, x4, #0x510
ffffffffea80b1ec:	52801b83 	mov	w3, #0xdc                  	// #220
ffffffffea80b1f0:	91146042 	add	x2, x2, #0x518
ffffffffea80b1f4:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b1f8:	aa1e03e0 	mov	x0, x30
ffffffffea80b1fc:	94001aa7 	bl	ffffffffea811c98 <_panic>
	ASSERT(ipc_is_port(phandle));
ffffffffea80b200:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b204:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b208:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b20c:	9114e084 	add	x4, x4, #0x538
ffffffffea80b210:	52801ba3 	mov	w3, #0xdd                  	// #221
ffffffffea80b214:	91146042 	add	x2, x2, #0x518
ffffffffea80b218:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b21c:	aa1e03e0 	mov	x0, x30
ffffffffea80b220:	94001a9e 	bl	ffffffffea811c98 <_panic>
ffffffffea80b224:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b228 <chan_handle_destroy>:
{
ffffffffea80b228:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80b22c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b230:	910003fd 	mov	x29, sp
ffffffffea80b234:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b238:	aa0003f3 	mov	x19, x0
ffffffffea80b23c:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80b240:	d0000074 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea80b244:	aa1e03f6 	mov	x22, x30
ffffffffea80b248:	9136e280 	add	x0, x20, #0xdb8
ffffffffea80b24c:	97ffe9db 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
ffffffffea80b250:	d1014275 	sub	x21, x19, #0x50
	item->next->prev = item->prev;
ffffffffea80b254:	a97f0261 	ldp	x1, x0, [x19, #-16]
ffffffffea80b258:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b25c:	f85f0261 	ldur	x1, [x19, #-16]
ffffffffea80b260:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b264:	a93f7e7f 	stp	xzr, xzr, [x19, #-16]
	assert(list_in_list(&ref->ref_node));
	assert(destroy);

	list_delete(&ref->ref_node);
	dead = list_is_empty(&obj->ref_list);
	if (dead)
ffffffffea80b268:	f85b8260 	ldur	x0, [x19, #-72]
ffffffffea80b26c:	eb0002bf 	cmp	x21, x0
ffffffffea80b270:	540000c0 	b.eq	ffffffffea80b288 <chan_handle_destroy+0x60>  // b.none
	mutex_release(&ipc_lock);
ffffffffea80b274:	9136e280 	add	x0, x20, #0xdb8
}
ffffffffea80b278:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b27c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80b280:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&ipc_lock);
ffffffffea80b284:	17ffe9f9 	b	ffffffffea805a68 <mutex_release>
	ASSERT(chan->peer == NULL);
ffffffffea80b288:	f85d0260 	ldur	x0, [x19, #-48]
ffffffffea80b28c:	b5000380 	cbnz	x0, ffffffffea80b2fc <chan_handle_destroy+0xd4>
	if (item->prev == 0 && item->next == 0)
ffffffffea80b290:	f94052a0 	ldr	x0, [x21, #160]
ffffffffea80b294:	b4000140 	cbz	x0, ffffffffea80b2bc <chan_handle_destroy+0x94>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b298:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b29c:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b2a0:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b2a4:	9112e084 	add	x4, x4, #0x4b8
ffffffffea80b2a8:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b2ac:	91146042 	add	x2, x2, #0x518
ffffffffea80b2b0:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b2b4:	aa1603e0 	mov	x0, x22
ffffffffea80b2b8:	94001a78 	bl	ffffffffea811c98 <_panic>
ffffffffea80b2bc:	f94056a0 	ldr	x0, [x21, #168]
ffffffffea80b2c0:	b5fffec0 	cbnz	x0, ffffffffea80b298 <chan_handle_destroy+0x70>
	if (chan->path) {
ffffffffea80b2c4:	f9405ea0 	ldr	x0, [x21, #184]
ffffffffea80b2c8:	b4000040 	cbz	x0, ffffffffea80b2d0 <chan_handle_destroy+0xa8>
		free((void *)chan->path);
ffffffffea80b2cc:	94002017 	bl	ffffffffea813328 <free>
	if (chan->msg_queue) {
ffffffffea80b2d0:	f9405aa0 	ldr	x0, [x21, #176]
ffffffffea80b2d4:	b4000060 	cbz	x0, ffffffffea80b2e0 <chan_handle_destroy+0xb8>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b2d8:	94000618 	bl	ffffffffea80cb38 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b2dc:	f9005abf 	str	xzr, [x21, #176]
	free(chan);
ffffffffea80b2e0:	aa1503e0 	mov	x0, x21
ffffffffea80b2e4:	94002011 	bl	ffffffffea813328 <free>
	mutex_release(&ipc_lock);
ffffffffea80b2e8:	9136e280 	add	x0, x20, #0xdb8
}
ffffffffea80b2ec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b2f0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80b2f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&ipc_lock);
ffffffffea80b2f8:	17ffe9dc 	b	ffffffffea805a68 <mutex_release>
	ASSERT(chan->peer == NULL);
ffffffffea80b2fc:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b300:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b304:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b308:	91128084 	add	x4, x4, #0x4a0
ffffffffea80b30c:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b310:	91146042 	add	x2, x2, #0x518
ffffffffea80b314:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b318:	aa1603e0 	mov	x0, x22
ffffffffea80b31c:	94001a5f 	bl	ffffffffea811c98 <_panic>

ffffffffea80b320 <_chan_shutdown_locked>:
	switch (chan->state) {
ffffffffea80b320:	b9403001 	ldr	w1, [x0, #48]
ffffffffea80b324:	71000c3f 	cmp	w1, #0x3
ffffffffea80b328:	54000188 	b.hi	ffffffffea80b358 <_chan_shutdown_locked+0x38>  // b.pmore
ffffffffea80b32c:	7100083f 	cmp	w1, #0x2
ffffffffea80b330:	540000c2 	b.cs	ffffffffea80b348 <_chan_shutdown_locked+0x28>  // b.hs, b.nlast
ffffffffea80b334:	7100043f 	cmp	w1, #0x1
ffffffffea80b338:	54000581 	b.ne	ffffffffea80b3e8 <_chan_shutdown_locked+0xc8>  // b.any
		chan->state = IPC_CHAN_STATE_DISCONNECTING;
ffffffffea80b33c:	52800081 	mov	w1, #0x4                   	// #4
ffffffffea80b340:	b9003001 	str	w1, [x0, #48]
ffffffffea80b344:	d65f03c0 	ret
		chan->state = IPC_CHAN_STATE_DISCONNECTING;
ffffffffea80b348:	52800081 	mov	w1, #0x4                   	// #4
ffffffffea80b34c:	b9003001 	str	w1, [x0, #48]
		handle_notify(&chan->handle);
ffffffffea80b350:	91014000 	add	x0, x0, #0x50
ffffffffea80b354:	17fffc1b 	b	ffffffffea80a3c0 <handle_notify>
	switch (chan->state) {
ffffffffea80b358:	7100143f 	cmp	w1, #0x5
ffffffffea80b35c:	54000481 	b.ne	ffffffffea80b3ec <_chan_shutdown_locked+0xcc>  // b.any
{
ffffffffea80b360:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80b364:	910003fd 	mov	x29, sp
ffffffffea80b368:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80b36c:	aa0003f3 	mov	x19, x0
ffffffffea80b370:	a94a0001 	ldp	x1, x0, [x0, #160]
ffffffffea80b374:	b4000261 	cbz	x1, ffffffffea80b3c0 <_chan_shutdown_locked+0xa0>
	item->next->prev = item->prev;
ffffffffea80b378:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b37c:	f9405262 	ldr	x2, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80b380:	f9404a61 	ldr	x1, [x19, #144]
	item->prev->next = item->next;
ffffffffea80b384:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80b388:	a90a7e7f 	stp	xzr, xzr, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80b38c:	f9404e60 	ldr	x0, [x19, #152]
ffffffffea80b390:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b394:	f9404a61 	ldr	x1, [x19, #144]
ffffffffea80b398:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b39c:	a9097e7f 	stp	xzr, xzr, [x19, #144]
ffffffffea80b3a0:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80b3a4:	eb00027f 	cmp	x19, x0
ffffffffea80b3a8:	54000240 	b.eq	ffffffffea80b3f0 <_chan_shutdown_locked+0xd0>  // b.none
		chan->state = IPC_CHAN_STATE_DISCONNECTING;
ffffffffea80b3ac:	52800080 	mov	w0, #0x4                   	// #4
ffffffffea80b3b0:	b9003260 	str	w0, [x19, #48]
}
ffffffffea80b3b4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80b3b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80b3bc:	d65f03c0 	ret
	if (item->prev == 0 && item->next == 0)
ffffffffea80b3c0:	b5fffdc0 	cbnz	x0, ffffffffea80b378 <_chan_shutdown_locked+0x58>
		ASSERT(list_in_list(&chan->node));
ffffffffea80b3c4:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b3c8:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b3cc:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b3d0:	91120084 	add	x4, x4, #0x480
ffffffffea80b3d4:	52803b43 	mov	w3, #0x1da                 	// #474
ffffffffea80b3d8:	91146042 	add	x2, x2, #0x518
ffffffffea80b3dc:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b3e0:	aa1e03e0 	mov	x0, x30
ffffffffea80b3e4:	94001a2d 	bl	ffffffffea811c98 <_panic>
ffffffffea80b3e8:	d65f03c0 	ret
ffffffffea80b3ec:	d65f03c0 	ret
	ASSERT(chan->peer == NULL);
ffffffffea80b3f0:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80b3f4:	b5000300 	cbnz	x0, ffffffffea80b454 <_chan_shutdown_locked+0x134>
ffffffffea80b3f8:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80b3fc:	b4000140 	cbz	x0, ffffffffea80b424 <_chan_shutdown_locked+0x104>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b400:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b404:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b408:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b40c:	9112e084 	add	x4, x4, #0x4b8
ffffffffea80b410:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b414:	91146042 	add	x2, x2, #0x518
ffffffffea80b418:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b41c:	aa1e03e0 	mov	x0, x30
ffffffffea80b420:	94001a1e 	bl	ffffffffea811c98 <_panic>
ffffffffea80b424:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80b428:	b5fffec0 	cbnz	x0, ffffffffea80b400 <_chan_shutdown_locked+0xe0>
	if (chan->path) {
ffffffffea80b42c:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80b430:	b4000040 	cbz	x0, ffffffffea80b438 <_chan_shutdown_locked+0x118>
		free((void *)chan->path);
ffffffffea80b434:	94001fbd 	bl	ffffffffea813328 <free>
	if (chan->msg_queue) {
ffffffffea80b438:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80b43c:	b4000060 	cbz	x0, ffffffffea80b448 <_chan_shutdown_locked+0x128>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b440:	940005be 	bl	ffffffffea80cb38 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b444:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80b448:	aa1303e0 	mov	x0, x19
ffffffffea80b44c:	94001fb7 	bl	ffffffffea813328 <free>
ffffffffea80b450:	17ffffd7 	b	ffffffffea80b3ac <_chan_shutdown_locked+0x8c>
	ASSERT(chan->peer == NULL);
ffffffffea80b454:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b458:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b45c:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b460:	91128084 	add	x4, x4, #0x4a0
ffffffffea80b464:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b468:	91146042 	add	x2, x2, #0x518
ffffffffea80b46c:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b470:	aa1e03e0 	mov	x0, x30
ffffffffea80b474:	94001a09 	bl	ffffffffea811c98 <_panic>

ffffffffea80b478 <chan_shutdown_locked>:
{
ffffffffea80b478:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80b47c:	910003fd 	mov	x29, sp
ffffffffea80b480:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80b484:	aa0003f3 	mov	x19, x0
ffffffffea80b488:	f90013f5 	str	x21, [sp, #32]
ffffffffea80b48c:	aa1e03f5 	mov	x21, x30
	_chan_shutdown_locked(chan);
ffffffffea80b490:	97ffffa4 	bl	ffffffffea80b320 <_chan_shutdown_locked>
	if (chan->peer) {
ffffffffea80b494:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80b498:	b40001c0 	cbz	x0, ffffffffea80b4d0 <chan_shutdown_locked+0x58>
ffffffffea80b49c:	f9000fb4 	str	x20, [x29, #24]
		_chan_shutdown_locked(chan->peer);
ffffffffea80b4a0:	97ffffa0 	bl	ffffffffea80b320 <_chan_shutdown_locked>
	item->next->prev = item->prev;
ffffffffea80b4a4:	a9410261 	ldp	x1, x0, [x19, #16]
		chan_del_ref(chan->peer, &chan->peer_ref);
ffffffffea80b4a8:	f9401274 	ldr	x20, [x19, #32]
ffffffffea80b4ac:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b4b0:	f9400a61 	ldr	x1, [x19, #16]
ffffffffea80b4b4:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b4b8:	a9017e7f 	stp	xzr, xzr, [x19, #16]
ffffffffea80b4bc:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80b4c0:	eb00029f 	cmp	x20, x0
ffffffffea80b4c4:	540000e0 	b.eq	ffffffffea80b4e0 <chan_shutdown_locked+0x68>  // b.none
		chan->peer = NULL;
ffffffffea80b4c8:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80b4cc:	f900127f 	str	xzr, [x19, #32]
}
ffffffffea80b4d0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80b4d4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80b4d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b4dc:	d65f03c0 	ret
	ASSERT(chan->peer == NULL);
ffffffffea80b4e0:	f9401280 	ldr	x0, [x20, #32]
ffffffffea80b4e4:	b5000300 	cbnz	x0, ffffffffea80b544 <chan_shutdown_locked+0xcc>
	if (item->prev == 0 && item->next == 0)
ffffffffea80b4e8:	f9405280 	ldr	x0, [x20, #160]
ffffffffea80b4ec:	b4000140 	cbz	x0, ffffffffea80b514 <chan_shutdown_locked+0x9c>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b4f0:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b4f4:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b4f8:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b4fc:	9112e084 	add	x4, x4, #0x4b8
ffffffffea80b500:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b504:	91146042 	add	x2, x2, #0x518
ffffffffea80b508:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b50c:	aa1503e0 	mov	x0, x21
ffffffffea80b510:	940019e2 	bl	ffffffffea811c98 <_panic>
ffffffffea80b514:	f9405680 	ldr	x0, [x20, #168]
ffffffffea80b518:	b5fffec0 	cbnz	x0, ffffffffea80b4f0 <chan_shutdown_locked+0x78>
	if (chan->path) {
ffffffffea80b51c:	f9405e80 	ldr	x0, [x20, #184]
ffffffffea80b520:	b4000040 	cbz	x0, ffffffffea80b528 <chan_shutdown_locked+0xb0>
		free((void *)chan->path);
ffffffffea80b524:	94001f81 	bl	ffffffffea813328 <free>
	if (chan->msg_queue) {
ffffffffea80b528:	f9405a80 	ldr	x0, [x20, #176]
ffffffffea80b52c:	b4000060 	cbz	x0, ffffffffea80b538 <chan_shutdown_locked+0xc0>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b530:	94000582 	bl	ffffffffea80cb38 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b534:	f9005a9f 	str	xzr, [x20, #176]
	free(chan);
ffffffffea80b538:	aa1403e0 	mov	x0, x20
ffffffffea80b53c:	94001f7b 	bl	ffffffffea813328 <free>
ffffffffea80b540:	17ffffe2 	b	ffffffffea80b4c8 <chan_shutdown_locked+0x50>
	ASSERT(chan->peer == NULL);
ffffffffea80b544:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b548:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b54c:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b550:	91128084 	add	x4, x4, #0x4a0
ffffffffea80b554:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b558:	91146042 	add	x2, x2, #0x518
ffffffffea80b55c:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b560:	aa1503e0 	mov	x0, x21
ffffffffea80b564:	940019cd 	bl	ffffffffea811c98 <_panic>

ffffffffea80b568 <chan_shutdown>:
{
ffffffffea80b568:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80b56c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b570:	910003fd 	mov	x29, sp
ffffffffea80b574:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b578:	d0000073 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea80b57c:	9136e273 	add	x19, x19, #0xdb8
ffffffffea80b580:	aa0003f4 	mov	x20, x0
ffffffffea80b584:	aa1303e0 	mov	x0, x19
ffffffffea80b588:	97ffe90c 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	chan_shutdown_locked(chan);
ffffffffea80b58c:	d1014280 	sub	x0, x20, #0x50
ffffffffea80b590:	97ffffba 	bl	ffffffffea80b478 <chan_shutdown_locked>
	mutex_release(&ipc_lock);
ffffffffea80b594:	aa1303e0 	mov	x0, x19
}
ffffffffea80b598:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b59c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_release(&ipc_lock);
ffffffffea80b5a0:	17ffe932 	b	ffffffffea805a68 <mutex_release>
ffffffffea80b5a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b5a8 <port_shutdown>:
{
ffffffffea80b5a8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80b5ac:	910003fd 	mov	x29, sp
ffffffffea80b5b0:	f9001ff8 	str	x24, [sp, #56]
ffffffffea80b5b4:	aa1e03f8 	mov	x24, x30
	ASSERT(phandle);
ffffffffea80b5b8:	b4000b80 	cbz	x0, ffffffffea80b728 <port_shutdown+0x180>
ffffffffea80b5bc:	f90017b6 	str	x22, [x29, #40]
ffffffffea80b5c0:	aa0003f6 	mov	x22, x0
	ASSERT(ipc_is_port(phandle));
ffffffffea80b5c4:	d0000060 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea80b5c8:	9137c000 	add	x0, x0, #0xdf0
ffffffffea80b5cc:	f94006c1 	ldr	x1, [x22, #8]
ffffffffea80b5d0:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80b5d4:	f90013b5 	str	x21, [x29, #32]
ffffffffea80b5d8:	eb00003f 	cmp	x1, x0
ffffffffea80b5dc:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80b5e0:	54000bc1 	b.ne	ffffffffea80b758 <port_shutdown+0x1b0>  // b.any
	ipc_port_t *port = containerof(phandle, ipc_port_t, handle);
ffffffffea80b5e4:	d10182d5 	sub	x21, x22, #0x60
ffffffffea80b5e8:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b5ec:	d0000077 	adrp	x23, ffffffffea819000 <_mem_phys_base>
ffffffffea80b5f0:	9136e2e0 	add	x0, x23, #0xdb8
ffffffffea80b5f4:	97ffe8f1 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
ffffffffea80b5f8:	f9405aa0 	ldr	x0, [x21, #176]
	port->state = IPC_PORT_STATE_CLOSING;
ffffffffea80b5fc:	52800041 	mov	w1, #0x2                   	// #2
ffffffffea80b600:	b81e82c1 	stur	w1, [x22, #-24]
ffffffffea80b604:	f9405ea1 	ldr	x1, [x21, #184]
ffffffffea80b608:	b4000740 	cbz	x0, ffffffffea80b6f0 <port_shutdown+0x148>
	item->next->prev = item->prev;
ffffffffea80b60c:	f9000020 	str	x0, [x1]
		handle_decref(phandle);
ffffffffea80b610:	aa1603e0 	mov	x0, x22
	item->prev->next = item->next;
ffffffffea80b614:	f9405aa2 	ldr	x2, [x21, #176]
ffffffffea80b618:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80b61c:	a90b7ebf 	stp	xzr, xzr, [x21, #176]
ffffffffea80b620:	97fffafc 	bl	ffffffffea80a210 <handle_decref>
	list_for_every_entry_safe(&port->pending_list, server, temp, ipc_chan_t, node) {
ffffffffea80b624:	f94056b3 	ldr	x19, [x21, #168]
ffffffffea80b628:	d1028273 	sub	x19, x19, #0xa0
ffffffffea80b62c:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80b630:	eb1302bf 	cmp	x21, x19
ffffffffea80b634:	d1028014 	sub	x20, x0, #0xa0
ffffffffea80b638:	54000141 	b.ne	ffffffffea80b660 <port_shutdown+0xb8>  // b.any
ffffffffea80b63c:	14000026 	b	ffffffffea80b6d4 <port_shutdown+0x12c>
		handle_decref(phandle);
ffffffffea80b640:	aa1603e0 	mov	x0, x22
ffffffffea80b644:	97fffaf3 	bl	ffffffffea80a210 <handle_decref>
	list_for_every_entry_safe(&port->pending_list, server, temp, ipc_chan_t, node) {
ffffffffea80b648:	f9405680 	ldr	x0, [x20, #168]
ffffffffea80b64c:	aa1403f3 	mov	x19, x20
ffffffffea80b650:	eb15029f 	cmp	x20, x21
ffffffffea80b654:	d1028000 	sub	x0, x0, #0xa0
ffffffffea80b658:	540003e0 	b.eq	ffffffffea80b6d4 <port_shutdown+0x12c>  // b.none
ffffffffea80b65c:	aa0003f4 	mov	x20, x0
		chan_shutdown_locked(server);
ffffffffea80b660:	aa1303e0 	mov	x0, x19
ffffffffea80b664:	97ffff85 	bl	ffffffffea80b478 <chan_shutdown_locked>
	item->next->prev = item->prev;
ffffffffea80b668:	a94a0261 	ldp	x1, x0, [x19, #160]
ffffffffea80b66c:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b670:	f9405262 	ldr	x2, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80b674:	f9404a61 	ldr	x1, [x19, #144]
	item->prev->next = item->next;
ffffffffea80b678:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80b67c:	a90a7e7f 	stp	xzr, xzr, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80b680:	f9404e60 	ldr	x0, [x19, #152]
ffffffffea80b684:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b688:	f9404a61 	ldr	x1, [x19, #144]
ffffffffea80b68c:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b690:	a9097e7f 	stp	xzr, xzr, [x19, #144]
ffffffffea80b694:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80b698:	eb00027f 	cmp	x19, x0
ffffffffea80b69c:	54fffd21 	b.ne	ffffffffea80b640 <port_shutdown+0x98>  // b.any
	ASSERT(chan->peer == NULL);
ffffffffea80b6a0:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80b6a4:	b50006c0 	cbnz	x0, ffffffffea80b77c <port_shutdown+0x1d4>
	if (item->prev == 0 && item->next == 0)
ffffffffea80b6a8:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80b6ac:	b4000260 	cbz	x0, ffffffffea80b6f8 <port_shutdown+0x150>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b6b0:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b6b4:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b6b8:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b6bc:	9112e084 	add	x4, x4, #0x4b8
ffffffffea80b6c0:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b6c4:	91146042 	add	x2, x2, #0x518
ffffffffea80b6c8:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b6cc:	aa1803e0 	mov	x0, x24
ffffffffea80b6d0:	94001972 	bl	ffffffffea811c98 <_panic>
	mutex_release(&ipc_lock);
ffffffffea80b6d4:	9136e2e0 	add	x0, x23, #0xdb8
}
ffffffffea80b6d8:	f9401ff8 	ldr	x24, [sp, #56]
	mutex_release(&ipc_lock);
ffffffffea80b6dc:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80b6e0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80b6e4:	f9401bb7 	ldr	x23, [x29, #48]
}
ffffffffea80b6e8:	a8c47bfd 	ldp	x29, x30, [sp], #64
	mutex_release(&ipc_lock);
ffffffffea80b6ec:	17ffe8df 	b	ffffffffea805a68 <mutex_release>
ffffffffea80b6f0:	b5fff8e1 	cbnz	x1, ffffffffea80b60c <port_shutdown+0x64>
ffffffffea80b6f4:	17ffffcc 	b	ffffffffea80b624 <port_shutdown+0x7c>
ffffffffea80b6f8:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80b6fc:	b5fffda0 	cbnz	x0, ffffffffea80b6b0 <port_shutdown+0x108>
	if (chan->path) {
ffffffffea80b700:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80b704:	b4000040 	cbz	x0, ffffffffea80b70c <port_shutdown+0x164>
		free((void *)chan->path);
ffffffffea80b708:	94001f08 	bl	ffffffffea813328 <free>
	if (chan->msg_queue) {
ffffffffea80b70c:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80b710:	b4000060 	cbz	x0, ffffffffea80b71c <port_shutdown+0x174>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b714:	94000509 	bl	ffffffffea80cb38 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b718:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80b71c:	aa1303e0 	mov	x0, x19
ffffffffea80b720:	94001f02 	bl	ffffffffea813328 <free>
ffffffffea80b724:	17ffffc7 	b	ffffffffea80b640 <port_shutdown+0x98>
	ASSERT(phandle);
ffffffffea80b728:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b72c:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b730:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b734:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80b738:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80b73c:	91144084 	add	x4, x4, #0x510
ffffffffea80b740:	528015a3 	mov	w3, #0xad                  	// #173
ffffffffea80b744:	91146042 	add	x2, x2, #0x518
ffffffffea80b748:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b74c:	aa1e03e0 	mov	x0, x30
ffffffffea80b750:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80b754:	94001951 	bl	ffffffffea811c98 <_panic>
	ASSERT(ipc_is_port(phandle));
ffffffffea80b758:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b75c:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b760:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b764:	9114e084 	add	x4, x4, #0x538
ffffffffea80b768:	528015c3 	mov	w3, #0xae                  	// #174
ffffffffea80b76c:	91146042 	add	x2, x2, #0x518
ffffffffea80b770:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b774:	aa1e03e0 	mov	x0, x30
ffffffffea80b778:	94001948 	bl	ffffffffea811c98 <_panic>
	ASSERT(chan->peer == NULL);
ffffffffea80b77c:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b780:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b784:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b788:	91128084 	add	x4, x4, #0x4a0
ffffffffea80b78c:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b790:	91146042 	add	x2, x2, #0x518
ffffffffea80b794:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b798:	aa1803e0 	mov	x0, x24
ffffffffea80b79c:	9400193f 	bl	ffffffffea811c98 <_panic>

ffffffffea80b7a0 <port_attach_client>:

	return ERR_ACCESS_DENIED;
}

static int port_attach_client(ipc_port_t *port, ipc_chan_t *client)
{
ffffffffea80b7a0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80b7a4:	910003fd 	mov	x29, sp
	int ret;
	ipc_chan_t *server;
	obj_ref_t   tmp_server_ref = OBJ_REF_INITIAL_VALUE(tmp_server_ref);

	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80b7a8:	b9404802 	ldr	w2, [x0, #72]
{
ffffffffea80b7ac:	f9001bf7 	str	x23, [sp, #48]
	obj_ref_t   tmp_server_ref = OBJ_REF_INITIAL_VALUE(tmp_server_ref);
ffffffffea80b7b0:	a9047fbf 	stp	xzr, xzr, [x29, #64]
	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80b7b4:	7100045f 	cmp	w2, #0x1
ffffffffea80b7b8:	54000ca1 	b.ne	ffffffffea80b94c <port_attach_client+0x1ac>  // b.any
ffffffffea80b7bc:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80b7c0:	aa0003f3 	mov	x19, x0
			 port->path, port->state);
		return ERR_NOT_READY;
	}

	/* check if we are allowed to connect */
	ret = check_access(port, client->uuid);
ffffffffea80b7c4:	f9401420 	ldr	x0, [x1, #40]
	if (!uuid) {
ffffffffea80b7c8:	b4000500 	cbz	x0, ffffffffea80b868 <port_attach_client+0xc8>
ffffffffea80b7cc:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80b7d0:	aa0103f4 	mov	x20, x1
ffffffffea80b7d4:	f90017b6 	str	x22, [x29, #40]
ffffffffea80b7d8:	aa1e03f6 	mov	x22, x30
	if (is_ns_client(uuid)) {
ffffffffea80b7dc:	9400132f 	bl	ffffffffea810498 <is_ns_client>
ffffffffea80b7e0:	72001c1f 	tst	w0, #0xff
		if (port->flags & IPC_PORT_ALLOW_NS_CONNECT) {
ffffffffea80b7e4:	b9404e60 	ldr	w0, [x19, #76]
	if (is_ns_client(uuid)) {
ffffffffea80b7e8:	540003a1 	b.ne	ffffffffea80b85c <port_attach_client+0xbc>  // b.any
		if (port->flags & IPC_PORT_ALLOW_TA_CONNECT) {
ffffffffea80b7ec:	360003a0 	tbz	w0, #0, ffffffffea80b860 <port_attach_client+0xc0>
	if (ret != NO_ERROR) {
		LTRACEF("access denied: %d\n", ret);
		return ret;
	}

	server = chan_alloc(IPC_CHAN_FLAG_SERVER, port->uuid, &tmp_server_ref);
ffffffffea80b7f0:	f9402261 	ldr	x1, [x19, #64]
ffffffffea80b7f4:	910103a2 	add	x2, x29, #0x40
ffffffffea80b7f8:	f90013b5 	str	x21, [x29, #32]
ffffffffea80b7fc:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80b800:	97fffe18 	bl	ffffffffea80b060 <chan_alloc>
ffffffffea80b804:	aa0003f5 	mov	x21, x0
	if (!server) {
ffffffffea80b808:	b40001c0 	cbz	x0, ffffffffea80b840 <port_attach_client+0xa0>
		LTRACEF("failed to alloc server: %d\n", ret);
		return ERR_NO_MEMORY;
	}

	/* allocate msg queues */
	ret = ipc_msg_queue_create(port->num_recv_bufs,
ffffffffea80b80c:	b9405260 	ldr	w0, [x19, #80]
ffffffffea80b810:	9102c282 	add	x2, x20, #0xb0
ffffffffea80b814:	f9402e61 	ldr	x1, [x19, #88]
ffffffffea80b818:	94000484 	bl	ffffffffea80ca28 <ipc_msg_queue_create>
				   port->recv_buf_size,
				   &client->msg_queue);
	if (ret != NO_ERROR) {
ffffffffea80b81c:	340002c0 	cbz	w0, ffffffffea80b874 <port_attach_client+0xd4>
	item->next->prev = item->prev;
ffffffffea80b820:	a94403a1 	ldp	x1, x0, [x29, #64]
ffffffffea80b824:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b828:	f94023a1 	ldr	x1, [x29, #64]
ffffffffea80b82c:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b830:	a9047fbf 	stp	xzr, xzr, [x29, #64]
	return (list->next == list) ? true : false;
ffffffffea80b834:	f94006b3 	ldr	x19, [x21, #8]
ffffffffea80b838:	eb15027f 	cmp	x19, x21
ffffffffea80b83c:	54000b00 	b.eq	ffffffffea80b99c <port_attach_client+0x1fc>  // b.none
ffffffffea80b840:	a94153b3 	ldp	x19, x20, [x29, #16]
		return ERR_NO_MEMORY;
ffffffffea80b844:	12800097 	mov	w23, #0xfffffffb            	// #-5
ffffffffea80b848:	a9425bb5 	ldp	x21, x22, [x29, #32]
	ipc_msg_queue_destroy(client->msg_queue);
	client->msg_queue = NULL;
err_client_mq:
	chan_del_ref(server, &tmp_server_ref);
	return ERR_NO_MEMORY;
}
ffffffffea80b84c:	2a1703e0 	mov	w0, w23
ffffffffea80b850:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80b854:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80b858:	d65f03c0 	ret
		if (port->flags & IPC_PORT_ALLOW_NS_CONNECT) {
ffffffffea80b85c:	370ffca0 	tbnz	w0, #1, ffffffffea80b7f0 <port_attach_client+0x50>
ffffffffea80b860:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80b864:	f94017b6 	ldr	x22, [x29, #40]
		return ERR_ACCESS_DENIED;
ffffffffea80b868:	12800557 	mov	w23, #0xffffffd5            	// #-43
ffffffffea80b86c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80b870:	17fffff7 	b	ffffffffea80b84c <port_attach_client+0xac>
	ret = ipc_msg_queue_create(port->num_recv_bufs,
ffffffffea80b874:	b9405260 	ldr	w0, [x19, #80]
ffffffffea80b878:	9102c2a2 	add	x2, x21, #0xb0
ffffffffea80b87c:	f9402e61 	ldr	x1, [x19, #88]
ffffffffea80b880:	9400046a 	bl	ffffffffea80ca28 <ipc_msg_queue_create>
ffffffffea80b884:	2a0003f7 	mov	w23, w0
	if (ret != NO_ERROR) {
ffffffffea80b888:	35000660 	cbnz	w0, ffffffffea80b954 <port_attach_client+0x1b4>
	item->prev = list->prev;
ffffffffea80b88c:	f94002a1 	ldr	x1, [x21]
	server->state = IPC_CHAN_STATE_ACCEPTING;
ffffffffea80b890:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80b894:	f9001fb8 	str	x24, [x29, #56]
	list_add_tail(&obj->ref_list, &ref->ref_node);
ffffffffea80b898:	91004285 	add	x5, x20, #0x10
ffffffffea80b89c:	b90032a0 	str	w0, [x21, #48]
	client->state = IPC_CHAN_STATE_CONNECTING;
ffffffffea80b8a0:	52800040 	mov	w0, #0x2                   	// #2
	item->next = list;
ffffffffea80b8a4:	a9015681 	stp	x1, x21, [x20, #16]
ffffffffea80b8a8:	910042a4 	add	x4, x21, #0x10
ffffffffea80b8ac:	b9003280 	str	w0, [x20, #48]
	list->prev = item;
ffffffffea80b8b0:	aa1503e1 	mov	x1, x21
	list->prev->next = item;
ffffffffea80b8b4:	f94002a0 	ldr	x0, [x21]
ffffffffea80b8b8:	910242a3 	add	x3, x21, #0x90
	item->prev = list->prev;
ffffffffea80b8bc:	aa1303e2 	mov	x2, x19
	handle_incref(&port->handle);
ffffffffea80b8c0:	91018278 	add	x24, x19, #0x60
	list->prev->next = item;
ffffffffea80b8c4:	f9000405 	str	x5, [x0, #8]
ffffffffea80b8c8:	aa1803e0 	mov	x0, x24
	list->prev = item;
ffffffffea80b8cc:	f90002a5 	str	x5, [x21]
	client->peer = server;
ffffffffea80b8d0:	f9001295 	str	x21, [x20, #32]
	item->prev = list->prev;
ffffffffea80b8d4:	f9400285 	ldr	x5, [x20]
	item->next = list;
ffffffffea80b8d8:	a90152a5 	stp	x5, x20, [x21, #16]
	list->prev->next = item;
ffffffffea80b8dc:	f9400285 	ldr	x5, [x20]
ffffffffea80b8e0:	f90004a4 	str	x4, [x5, #8]
	list->prev = item;
ffffffffea80b8e4:	f9000284 	str	x4, [x20]
	server->peer = client;
ffffffffea80b8e8:	f90012b4 	str	x20, [x21, #32]
	item->prev = list->prev;
ffffffffea80b8ec:	f94002a4 	ldr	x4, [x21]
	item->next = list;
ffffffffea80b8f0:	a90956a4 	stp	x4, x21, [x21, #144]
	list->prev->next = item;
ffffffffea80b8f4:	f9000483 	str	x3, [x4, #8]
	list->prev = item;
ffffffffea80b8f8:	f80a0423 	str	x3, [x1], #160
	item->prev = list->prev;
ffffffffea80b8fc:	f84a0c43 	ldr	x3, [x2, #160]!
	item->next = list;
ffffffffea80b900:	a90a0aa3 	stp	x3, x2, [x21, #160]
	list->prev->next = item;
ffffffffea80b904:	f9405262 	ldr	x2, [x19, #160]
ffffffffea80b908:	f9000441 	str	x1, [x2, #8]
	list->prev = item;
ffffffffea80b90c:	f9005261 	str	x1, [x19, #160]
	handle_incref(&port->handle);
ffffffffea80b910:	97fffa3a 	bl	ffffffffea80a1f8 <handle_incref>
	handle_notify(&port->handle);
ffffffffea80b914:	aa1803e0 	mov	x0, x24
ffffffffea80b918:	97fffaaa 	bl	ffffffffea80a3c0 <handle_notify>
	item->next->prev = item->prev;
ffffffffea80b91c:	a94403a1 	ldp	x1, x0, [x29, #64]
ffffffffea80b920:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b924:	f94023a1 	ldr	x1, [x29, #64]
ffffffffea80b928:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b92c:	a9047fbf 	stp	xzr, xzr, [x29, #64]
	if (dead)
ffffffffea80b930:	f94006a0 	ldr	x0, [x21, #8]
ffffffffea80b934:	eb15001f 	cmp	x0, x21
ffffffffea80b938:	54000160 	b.eq	ffffffffea80b964 <port_attach_client+0x1c4>  // b.none
ffffffffea80b93c:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80b940:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80b944:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80b948:	17ffffc1 	b	ffffffffea80b84c <port_attach_client+0xac>
		return ERR_NOT_READY;
ffffffffea80b94c:	12800057 	mov	w23, #0xfffffffd            	// #-3
ffffffffea80b950:	17ffffbf 	b	ffffffffea80b84c <port_attach_client+0xac>
	ipc_msg_queue_destroy(client->msg_queue);
ffffffffea80b954:	f9405a80 	ldr	x0, [x20, #176]
ffffffffea80b958:	94000478 	bl	ffffffffea80cb38 <ipc_msg_queue_destroy>
	client->msg_queue = NULL;
ffffffffea80b95c:	f9005a9f 	str	xzr, [x20, #176]
ffffffffea80b960:	17ffffb0 	b	ffffffffea80b820 <port_attach_client+0x80>
	ASSERT(chan->peer == NULL);
ffffffffea80b964:	f9401000 	ldr	x0, [x0, #32]
ffffffffea80b968:	b5000460 	cbnz	x0, ffffffffea80b9f4 <port_attach_client+0x254>
	if (item->prev == 0 && item->next == 0)
ffffffffea80b96c:	f94052a0 	ldr	x0, [x21, #160]
ffffffffea80b970:	b4000540 	cbz	x0, ffffffffea80ba18 <port_attach_client+0x278>
ffffffffea80b974:	d503201f 	nop
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b978:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b97c:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b980:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b984:	9112e084 	add	x4, x4, #0x4b8
ffffffffea80b988:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b98c:	91146042 	add	x2, x2, #0x518
ffffffffea80b990:	9135a021 	add	x1, x1, #0xd68
ffffffffea80b994:	aa1603e0 	mov	x0, x22
ffffffffea80b998:	940018c0 	bl	ffffffffea811c98 <_panic>
	ASSERT(chan->peer == NULL);
ffffffffea80b99c:	f94012a0 	ldr	x0, [x21, #32]
ffffffffea80b9a0:	b5000280 	cbnz	x0, ffffffffea80b9f0 <port_attach_client+0x250>
ffffffffea80b9a4:	f94052a0 	ldr	x0, [x21, #160]
ffffffffea80b9a8:	b4000060 	cbz	x0, ffffffffea80b9b4 <port_attach_client+0x214>
ffffffffea80b9ac:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80b9b0:	17fffff2 	b	ffffffffea80b978 <port_attach_client+0x1d8>
ffffffffea80b9b4:	f94056a0 	ldr	x0, [x21, #168]
ffffffffea80b9b8:	b5ffffa0 	cbnz	x0, ffffffffea80b9ac <port_attach_client+0x20c>
	if (chan->path) {
ffffffffea80b9bc:	f9405ea0 	ldr	x0, [x21, #184]
ffffffffea80b9c0:	b4000040 	cbz	x0, ffffffffea80b9c8 <port_attach_client+0x228>
		free((void *)chan->path);
ffffffffea80b9c4:	94001e59 	bl	ffffffffea813328 <free>
	if (chan->msg_queue) {
ffffffffea80b9c8:	f9405aa0 	ldr	x0, [x21, #176]
ffffffffea80b9cc:	b4000060 	cbz	x0, ffffffffea80b9d8 <port_attach_client+0x238>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b9d0:	9400045a 	bl	ffffffffea80cb38 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b9d4:	f9005abf 	str	xzr, [x21, #176]
	free(chan);
ffffffffea80b9d8:	aa1303e0 	mov	x0, x19
	return ERR_NO_MEMORY;
ffffffffea80b9dc:	12800097 	mov	w23, #0xfffffffb            	// #-5
	free(chan);
ffffffffea80b9e0:	94001e52 	bl	ffffffffea813328 <free>
ffffffffea80b9e4:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80b9e8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80b9ec:	17ffff98 	b	ffffffffea80b84c <port_attach_client+0xac>
ffffffffea80b9f0:	f9001fb8 	str	x24, [x29, #56]
	ASSERT(chan->peer == NULL);
ffffffffea80b9f4:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b9f8:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80b9fc:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80ba00:	91128084 	add	x4, x4, #0x4a0
ffffffffea80ba04:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80ba08:	91146042 	add	x2, x2, #0x518
ffffffffea80ba0c:	9135a021 	add	x1, x1, #0xd68
ffffffffea80ba10:	aa1603e0 	mov	x0, x22
ffffffffea80ba14:	940018a1 	bl	ffffffffea811c98 <_panic>
ffffffffea80ba18:	f94056a0 	ldr	x0, [x21, #168]
ffffffffea80ba1c:	b5fffae0 	cbnz	x0, ffffffffea80b978 <port_attach_client+0x1d8>
	if (chan->path) {
ffffffffea80ba20:	f9405ea0 	ldr	x0, [x21, #184]
ffffffffea80ba24:	b4000040 	cbz	x0, ffffffffea80ba2c <port_attach_client+0x28c>
		free((void *)chan->path);
ffffffffea80ba28:	94001e40 	bl	ffffffffea813328 <free>
	if (chan->msg_queue) {
ffffffffea80ba2c:	f9405aa0 	ldr	x0, [x21, #176]
ffffffffea80ba30:	b4000060 	cbz	x0, ffffffffea80ba3c <port_attach_client+0x29c>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80ba34:	94000441 	bl	ffffffffea80cb38 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80ba38:	f9005abf 	str	xzr, [x21, #176]
	free(chan);
ffffffffea80ba3c:	aa1503e0 	mov	x0, x21
ffffffffea80ba40:	94001e3a 	bl	ffffffffea813328 <free>
ffffffffea80ba44:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80ba48:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80ba4c:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80ba50:	17ffff7f 	b	ffffffffea80b84c <port_attach_client+0xac>
ffffffffea80ba54:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80ba58 <ipc_is_channel>:
	return likely(handle->ops == &ipc_chan_handle_ops);
ffffffffea80ba58:	f9400401 	ldr	x1, [x0, #8]
ffffffffea80ba5c:	d0000060 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea80ba60:	91366000 	add	x0, x0, #0xd98
ffffffffea80ba64:	eb00003f 	cmp	x1, x0
}
ffffffffea80ba68:	1a9f17e0 	cset	w0, eq  // eq = none
ffffffffea80ba6c:	d65f03c0 	ret

ffffffffea80ba70 <ipc_port_create>:
{
ffffffffea80ba70:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80ba74:	910003fd 	mov	x29, sp
ffffffffea80ba78:	f9000ff4 	str	x20, [sp, #24]
	if (!sid) {
ffffffffea80ba7c:	b40007e0 	cbz	x0, ffffffffea80bb78 <ipc_port_create+0x108>
	if (!num_recv_bufs || num_recv_bufs > IPC_CHAN_MAX_BUFS ||
ffffffffea80ba80:	51000446 	sub	w6, w2, #0x1
ffffffffea80ba84:	71007cdf 	cmp	w6, #0x1f
ffffffffea80ba88:	54000788 	b.hi	ffffffffea80bb78 <ipc_port_create+0x108>  // b.pmore
	    !recv_buf_size || recv_buf_size > IPC_CHAN_MAX_BUF_SIZE) {
ffffffffea80ba8c:	d1000466 	sub	x6, x3, #0x1
ffffffffea80ba90:	f13ffcdf 	cmp	x6, #0xfff
ffffffffea80ba94:	54000728 	b.hi	ffffffffea80bb78 <ipc_port_create+0x108>  // b.pmore
ffffffffea80ba98:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80ba9c:	aa0103f4 	mov	x20, x1
ffffffffea80baa0:	a9025bb5 	stp	x21, x22, [x29, #32]
	new_port = calloc(1, sizeof(ipc_port_t));
ffffffffea80baa4:	d2801801 	mov	x1, #0xc0                  	// #192
ffffffffea80baa8:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80baac:	2a0203f6 	mov	w22, w2
ffffffffea80bab0:	f90023b9 	str	x25, [x29, #64]
ffffffffea80bab4:	aa0503f7 	mov	x23, x5
ffffffffea80bab8:	2a0403f8 	mov	w24, w4
ffffffffea80babc:	aa0003f5 	mov	x21, x0
ffffffffea80bac0:	aa0303f9 	mov	x25, x3
ffffffffea80bac4:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80bac8:	94001e08 	bl	ffffffffea8132e8 <calloc>
ffffffffea80bacc:	aa0003f3 	mov	x19, x0
	if (!new_port) {
ffffffffea80bad0:	b4000580 	cbz	x0, ffffffffea80bb80 <ipc_port_create+0x110>
	ret = strlcpy(new_port->path, path, sizeof(new_port->path));
ffffffffea80bad4:	d2800802 	mov	x2, #0x40                  	// #64
ffffffffea80bad8:	aa1403e1 	mov	x1, x20
ffffffffea80badc:	94001f13 	bl	ffffffffea813728 <strlcpy>
	if (ret == 0) {
ffffffffea80bae0:	340001c0 	cbz	w0, ffffffffea80bb18 <ipc_port_create+0xa8>
		ret = ERR_TOO_BIG;
ffffffffea80bae4:	12800314 	mov	w20, #0xffffffe7            	// #-25
	if ((uint) ret >= sizeof(new_port->path)) {
ffffffffea80bae8:	7100fc1f 	cmp	w0, #0x3f
ffffffffea80baec:	540001a9 	b.ls	ffffffffea80bb20 <ipc_port_create+0xb0>  // b.plast
	free(new_port);
ffffffffea80baf0:	aa1303e0 	mov	x0, x19
ffffffffea80baf4:	94001e0d 	bl	ffffffffea813328 <free>
	return ret;
ffffffffea80baf8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80bafc:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80bb00:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80bb04:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea80bb08:	2a1403e0 	mov	w0, w20
ffffffffea80bb0c:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80bb10:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80bb14:	d65f03c0 	ret
		ret = ERR_INVALID_ARGS;
ffffffffea80bb18:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80bb1c:	17fffff5 	b	ffffffffea80baf0 <ipc_port_create+0x80>
ffffffffea80bb20:	f90027ba 	str	x26, [x29, #72]
	list_initialize(&new_port->pending_list);
ffffffffea80bb24:	91028260 	add	x0, x19, #0xa0
	handle_init(&new_port->handle, &ipc_port_handle_ops);
ffffffffea80bb28:	9101827a 	add	x26, x19, #0x60
	new_port->uuid = sid;
ffffffffea80bb2c:	f9002275 	str	x21, [x19, #64]
	new_port->flags = flags;
ffffffffea80bb30:	2909627f 	stp	wzr, w24, [x19, #72]
	handle_init(&new_port->handle, &ipc_port_handle_ops);
ffffffffea80bb34:	d0000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
	new_port->num_recv_bufs = num_recv_bufs;
ffffffffea80bb38:	b9005276 	str	w22, [x19, #80]
	handle_init(&new_port->handle, &ipc_port_handle_ops);
ffffffffea80bb3c:	9137c021 	add	x1, x1, #0xdf0
	new_port->recv_buf_size = recv_buf_size;
ffffffffea80bb40:	f9002e79 	str	x25, [x19, #88]
	return NO_ERROR;
ffffffffea80bb44:	52800014 	mov	w20, #0x0                   	// #0
	list->prev = list->next = list;
ffffffffea80bb48:	a90a0260 	stp	x0, x0, [x19, #160]
	handle_init(&new_port->handle, &ipc_port_handle_ops);
ffffffffea80bb4c:	aa1a03e0 	mov	x0, x26
ffffffffea80bb50:	97fff99a 	bl	ffffffffea80a1b8 <handle_init>
	return NO_ERROR;
ffffffffea80bb54:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80bb58:	a9425bb5 	ldp	x21, x22, [x29, #32]
	*phandle_ptr = &new_port->handle;
ffffffffea80bb5c:	f90002fa 	str	x26, [x23]
}
ffffffffea80bb60:	2a1403e0 	mov	w0, w20
ffffffffea80bb64:	f9400ff4 	ldr	x20, [sp, #24]
	return NO_ERROR;
ffffffffea80bb68:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80bb6c:	a9446bb9 	ldp	x25, x26, [x29, #64]
}
ffffffffea80bb70:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80bb74:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80bb78:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80bb7c:	17ffffe3 	b	ffffffffea80bb08 <ipc_port_create+0x98>
		return ERR_NO_MEMORY;
ffffffffea80bb80:	12800094 	mov	w20, #0xfffffffb            	// #-5
ffffffffea80bb84:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80bb88:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80bb8c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80bb90:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80bb94:	17ffffdd 	b	ffffffffea80bb08 <ipc_port_create+0x98>

ffffffffea80bb98 <ipc_port_publish>:
{
ffffffffea80bb98:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea80bb9c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80bba0:	910003fd 	mov	x29, sp
ffffffffea80bba4:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80bba8:	aa0003f3 	mov	x19, x0
ffffffffea80bbac:	a9025bf5 	stp	x21, x22, [sp, #32]
	ipc_port_t *port = containerof(phandle, ipc_port_t, handle);
ffffffffea80bbb0:	d1018015 	sub	x21, x0, #0x60
{
ffffffffea80bbb4:	f9002bfb 	str	x27, [sp, #80]
ffffffffea80bbb8:	d000007b 	adrp	x27, ffffffffea819000 <_mem_phys_base>
ffffffffea80bbbc:	f90037be 	str	x30, [x29, #104]
ffffffffea80bbc0:	9136e360 	add	x0, x27, #0xdb8
ffffffffea80bbc4:	97ffe77d 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	if (port_find_locked(port->path)) {
ffffffffea80bbc8:	aa1503e0 	mov	x0, x21
ffffffffea80bbcc:	97fffd3b 	bl	ffffffffea80b0b8 <port_find_locked>
ffffffffea80bbd0:	b5001520 	cbnz	x0, ffffffffea80be74 <ipc_port_publish+0x2dc>
	item->prev = list->prev;
ffffffffea80bbd4:	d0000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea80bbd8:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80bbdc:	f9001bb7 	str	x23, [x29, #48]
		port->state = IPC_PORT_STATE_LISTENING;
ffffffffea80bbe0:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80bbe4:	f9470822 	ldr	x2, [x1, #3600]
		list_add_tail(&ipc_port_list, &port->node);
ffffffffea80bbe8:	91014263 	add	x3, x19, #0x50
		port->state = IPC_PORT_STATE_LISTENING;
ffffffffea80bbec:	b81e8260 	stur	w0, [x19, #-24]
ffffffffea80bbf0:	91384020 	add	x0, x1, #0xe10
	item->next = list;
ffffffffea80bbf4:	a90b02a2 	stp	x2, x0, [x21, #176]
		handle_incref(&port->handle); /* and inc usage count */
ffffffffea80bbf8:	aa1303e0 	mov	x0, x19
	list->prev->next = item;
ffffffffea80bbfc:	f9000443 	str	x3, [x2, #8]
		list_for_every_entry_safe(&waiting_for_port_chan_list, client, temp, ipc_chan_t, node) {
ffffffffea80bc00:	d0000077 	adrp	x23, ffffffffea819000 <_mem_phys_base>
	list->prev = item;
ffffffffea80bc04:	f9070823 	str	x3, [x1, #3600]
		handle_incref(&port->handle); /* and inc usage count */
ffffffffea80bc08:	97fff97c 	bl	ffffffffea80a1f8 <handle_incref>
		obj_ref_t tmp_client_ref = OBJ_REF_INITIAL_VALUE(tmp_client_ref);
ffffffffea80bc0c:	a9077fbf 	stp	xzr, xzr, [x29, #112]
		list_for_every_entry_safe(&waiting_for_port_chan_list, client, temp, ipc_chan_t, node) {
ffffffffea80bc10:	913882e1 	add	x1, x23, #0xe20
ffffffffea80bc14:	f9400420 	ldr	x0, [x1, #8]
ffffffffea80bc18:	d1028013 	sub	x19, x0, #0xa0
ffffffffea80bc1c:	eb00003f 	cmp	x1, x0
ffffffffea80bc20:	f9405674 	ldr	x20, [x19, #168]
ffffffffea80bc24:	d1028294 	sub	x20, x20, #0xa0
ffffffffea80bc28:	54000fe0 	b.eq	ffffffffea80be24 <ipc_port_publish+0x28c>  // b.none
ffffffffea80bc2c:	a903e7b8 	stp	x24, x25, [x29, #56]
	int ret = NO_ERROR;
ffffffffea80bc30:	52800016 	mov	w22, #0x0                   	// #0
				TRACEF("guest %u access to port denied, ret = %d\n",
ffffffffea80bc34:	90000079 	adrp	x25, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80bc38:	f90027ba 	str	x26, [x29, #72]
	list->prev->next = item;
ffffffffea80bc3c:	9101c3b8 	add	x24, x29, #0x70
ffffffffea80bc40:	9000007a 	adrp	x26, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80bc44:	91136339 	add	x25, x25, #0x4d8
ffffffffea80bc48:	f9002fbc 	str	x28, [x29, #88]
ffffffffea80bc4c:	9111635a 	add	x26, x26, #0x458
ffffffffea80bc50:	14000016 	b	ffffffffea80bca8 <ipc_port_publish+0x110>
ffffffffea80bc54:	b9408a63 	ldr	w3, [x19, #136]
ffffffffea80bc58:	2a0003e4 	mov	w4, w0
ffffffffea80bc5c:	52802382 	mov	w2, #0x11c                 	// #284
ffffffffea80bc60:	aa1a03e1 	mov	x1, x26
ffffffffea80bc64:	aa1903e0 	mov	x0, x25
ffffffffea80bc68:	94001d72 	bl	ffffffffea813230 <_printf>
	item->next->prev = item->prev;
ffffffffea80bc6c:	a94703a1 	ldp	x1, x0, [x29, #112]
ffffffffea80bc70:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80bc74:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea80bc78:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80bc7c:	a9077fbf 	stp	xzr, xzr, [x29, #112]
ffffffffea80bc80:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80bc84:	eb00027f 	cmp	x19, x0
ffffffffea80bc88:	54000700 	b.eq	ffffffffea80bd68 <ipc_port_publish+0x1d0>  // b.none
		list_for_every_entry_safe(&waiting_for_port_chan_list, client, temp, ipc_chan_t, node) {
ffffffffea80bc8c:	f9405681 	ldr	x1, [x20, #168]
ffffffffea80bc90:	91028282 	add	x2, x20, #0xa0
ffffffffea80bc94:	913882e0 	add	x0, x23, #0xe20
ffffffffea80bc98:	aa1403f3 	mov	x19, x20
ffffffffea80bc9c:	eb02001f 	cmp	x0, x2
ffffffffea80bca0:	d1028034 	sub	x20, x1, #0xa0
ffffffffea80bca4:	540008e0 	b.eq	ffffffffea80bdc0 <ipc_port_publish+0x228>  // b.none
			if (strcmp(client->path, port->path)) {
ffffffffea80bca8:	f9405e7c 	ldr	x28, [x19, #184]
ffffffffea80bcac:	aa1503e1 	mov	x1, x21
ffffffffea80bcb0:	aa1c03e0 	mov	x0, x28
ffffffffea80bcb4:	94001e7b 	bl	ffffffffea8136a0 <strcmp>
ffffffffea80bcb8:	35fffea0 	cbnz	w0, ffffffffea80bc8c <ipc_port_publish+0xf4>
			free((void *)client->path);
ffffffffea80bcbc:	aa1c03e0 	mov	x0, x28
ffffffffea80bcc0:	94001d9a 	bl	ffffffffea813328 <free>
	item->prev = list->prev;
ffffffffea80bcc4:	f9400260 	ldr	x0, [x19]
	item->next = list;
ffffffffea80bcc8:	a9074fa0 	stp	x0, x19, [x29, #112]
			client->path = NULL;
ffffffffea80bccc:	f9005e7f 	str	xzr, [x19, #184]
	list->prev->next = item;
ffffffffea80bcd0:	f9400260 	ldr	x0, [x19]
	item->next->prev = item->prev;
ffffffffea80bcd4:	f9405261 	ldr	x1, [x19, #160]
	list->prev->next = item;
ffffffffea80bcd8:	f9000418 	str	x24, [x0, #8]
	list->prev = item;
ffffffffea80bcdc:	f9000278 	str	x24, [x19]
	item->next->prev = item->prev;
ffffffffea80bce0:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80bce4:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80bce8:	f9405262 	ldr	x2, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80bcec:	f9404a61 	ldr	x1, [x19, #144]
	item->prev->next = item->next;
ffffffffea80bcf0:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80bcf4:	a90a7e7f 	stp	xzr, xzr, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80bcf8:	f9404e60 	ldr	x0, [x19, #152]
ffffffffea80bcfc:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80bd00:	f9404a61 	ldr	x1, [x19, #144]
ffffffffea80bd04:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80bd08:	a9097e7f 	stp	xzr, xzr, [x19, #144]
ffffffffea80bd0c:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80bd10:	eb13001f 	cmp	x0, x19
ffffffffea80bd14:	540006e0 	b.eq	ffffffffea80bdf0 <ipc_port_publish+0x258>  // b.none
			ret = trusty_hyp_check_guest_access(client->handle.guest_id, port->uuid);
ffffffffea80bd18:	b9408a60 	ldr	w0, [x19, #136]
ffffffffea80bd1c:	f94022a1 	ldr	x1, [x21, #64]
ffffffffea80bd20:	97ffdab0 	bl	ffffffffea8027e0 <trusty_hyp_check_guest_access>
ffffffffea80bd24:	2a0003f6 	mov	w22, w0
			if (ret) {
ffffffffea80bd28:	35fff960 	cbnz	w0, ffffffffea80bc54 <ipc_port_publish+0xbc>
				int err = port_attach_client(port, client);
ffffffffea80bd2c:	aa1303e1 	mov	x1, x19
ffffffffea80bd30:	aa1503e0 	mov	x0, x21
ffffffffea80bd34:	97fffe9b 	bl	ffffffffea80b7a0 <port_attach_client>
				if (err) {
ffffffffea80bd38:	34fff9a0 	cbz	w0, ffffffffea80bc6c <ipc_port_publish+0xd4>
					chan_shutdown_locked(client);
ffffffffea80bd3c:	aa1303e0 	mov	x0, x19
ffffffffea80bd40:	97fffdce 	bl	ffffffffea80b478 <chan_shutdown_locked>
	item->next->prev = item->prev;
ffffffffea80bd44:	a94703a1 	ldp	x1, x0, [x29, #112]
ffffffffea80bd48:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80bd4c:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea80bd50:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80bd54:	a9077fbf 	stp	xzr, xzr, [x29, #112]
ffffffffea80bd58:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80bd5c:	eb00027f 	cmp	x19, x0
ffffffffea80bd60:	54fff961 	b.ne	ffffffffea80bc8c <ipc_port_publish+0xf4>  // b.any
ffffffffea80bd64:	d503201f 	nop
	ASSERT(chan->peer == NULL);
ffffffffea80bd68:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80bd6c:	b5000880 	cbnz	x0, ffffffffea80be7c <ipc_port_publish+0x2e4>
	if (item->prev == 0 && item->next == 0)
ffffffffea80bd70:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80bd74:	b5000460 	cbnz	x0, ffffffffea80be00 <ipc_port_publish+0x268>
ffffffffea80bd78:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80bd7c:	b5000420 	cbnz	x0, ffffffffea80be00 <ipc_port_publish+0x268>
	if (chan->path) {
ffffffffea80bd80:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80bd84:	b4000040 	cbz	x0, ffffffffea80bd8c <ipc_port_publish+0x1f4>
		free((void *)chan->path);
ffffffffea80bd88:	94001d68 	bl	ffffffffea813328 <free>
	if (chan->msg_queue) {
ffffffffea80bd8c:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80bd90:	b4000060 	cbz	x0, ffffffffea80bd9c <ipc_port_publish+0x204>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80bd94:	94000369 	bl	ffffffffea80cb38 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80bd98:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80bd9c:	aa1303e0 	mov	x0, x19
ffffffffea80bda0:	94001d62 	bl	ffffffffea813328 <free>
		list_for_every_entry_safe(&waiting_for_port_chan_list, client, temp, ipc_chan_t, node) {
ffffffffea80bda4:	f9405681 	ldr	x1, [x20, #168]
ffffffffea80bda8:	91028282 	add	x2, x20, #0xa0
ffffffffea80bdac:	913882e0 	add	x0, x23, #0xe20
ffffffffea80bdb0:	aa1403f3 	mov	x19, x20
ffffffffea80bdb4:	eb02001f 	cmp	x0, x2
ffffffffea80bdb8:	d1028034 	sub	x20, x1, #0xa0
ffffffffea80bdbc:	54fff761 	b.ne	ffffffffea80bca8 <ipc_port_publish+0x110>  // b.any
ffffffffea80bdc0:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80bdc4:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80bdc8:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80bdcc:	f9402fbc 	ldr	x28, [x29, #88]
	mutex_release(&ipc_lock);
ffffffffea80bdd0:	9136e360 	add	x0, x27, #0xdb8
ffffffffea80bdd4:	97ffe725 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea80bdd8:	2a1603e0 	mov	w0, w22
ffffffffea80bddc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80bde0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80bde4:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea80bde8:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80bdec:	d65f03c0 	ret
	ASSERT(chan->peer == NULL);
ffffffffea80bdf0:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80bdf4:	b5000440 	cbnz	x0, ffffffffea80be7c <ipc_port_publish+0x2e4>
ffffffffea80bdf8:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80bdfc:	b40002a0 	cbz	x0, ffffffffea80be50 <ipc_port_publish+0x2b8>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80be00:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea80be04:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80be08:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80be0c:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80be10:	9112e084 	add	x4, x4, #0x4b8
ffffffffea80be14:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80be18:	91146042 	add	x2, x2, #0x518
ffffffffea80be1c:	9135a021 	add	x1, x1, #0xd68
ffffffffea80be20:	9400179e 	bl	ffffffffea811c98 <_panic>
ffffffffea80be24:	f9400fb4 	ldr	x20, [x29, #24]
	int ret = NO_ERROR;
ffffffffea80be28:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea80be2c:	f9401bb7 	ldr	x23, [x29, #48]
	mutex_release(&ipc_lock);
ffffffffea80be30:	9136e360 	add	x0, x27, #0xdb8
ffffffffea80be34:	97ffe70d 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea80be38:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80be3c:	2a1603e0 	mov	w0, w22
ffffffffea80be40:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea80be44:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80be48:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80be4c:	d65f03c0 	ret
ffffffffea80be50:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80be54:	b5fffd60 	cbnz	x0, ffffffffea80be00 <ipc_port_publish+0x268>
	if (chan->msg_queue) {
ffffffffea80be58:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80be5c:	b4000060 	cbz	x0, ffffffffea80be68 <ipc_port_publish+0x2d0>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80be60:	94000336 	bl	ffffffffea80cb38 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80be64:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80be68:	aa1303e0 	mov	x0, x19
ffffffffea80be6c:	94001d2f 	bl	ffffffffea813328 <free>
ffffffffea80be70:	17ffffaa 	b	ffffffffea80bd18 <ipc_port_publish+0x180>
		ret = ERR_ALREADY_EXISTS;
ffffffffea80be74:	128001b6 	mov	w22, #0xfffffff2            	// #-14
ffffffffea80be78:	17ffffd6 	b	ffffffffea80bdd0 <ipc_port_publish+0x238>
	ASSERT(chan->peer == NULL);
ffffffffea80be7c:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea80be80:	90000064 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80be84:	90000062 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80be88:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80be8c:	91128084 	add	x4, x4, #0x4a0
ffffffffea80be90:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80be94:	91146042 	add	x2, x2, #0x518
ffffffffea80be98:	9135a021 	add	x1, x1, #0xd68
ffffffffea80be9c:	9400177f 	bl	ffffffffea811c98 <_panic>

ffffffffea80bea0 <sys_port_create>:
{
ffffffffea80bea0:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
ffffffffea80bea4:	910003fd 	mov	x29, sp
ffffffffea80bea8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80beac:	2a0003f3 	mov	w19, w0
ffffffffea80beb0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80beb4:	2a0103f5 	mov	w21, w1
ffffffffea80beb8:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80bebc:	aa0203f6 	mov	x22, x2
ffffffffea80bec0:	2a0303f7 	mov	w23, w3
ffffffffea80bec4:	d538d080 	mrs	x0, tpidr_el1
	trusty_app_t *tapp = ut->private_data;
ffffffffea80bec8:	f9415800 	ldr	x0, [x0, #688]
ffffffffea80becc:	f9404814 	ldr	x20, [x0, #144]
	uctx_t *ctx = current_uctx();
ffffffffea80bed0:	97fffa84 	bl	ffffffffea80a8e0 <current_uctx>
	handle_t *port_handle = NULL;
ffffffffea80bed4:	f90027bf 	str	xzr, [x29, #72]
	uctx_t *ctx = current_uctx();
ffffffffea80bed8:	aa0003f8 	mov	x24, x0
	return arch_strlcpy_from_user(kdest, usrc, len);
ffffffffea80bedc:	d2800802 	mov	x2, #0x40                  	// #64
ffffffffea80bee0:	910143a0 	add	x0, x29, #0x50
ffffffffea80bee4:	2a1303e1 	mov	w1, w19
ffffffffea80bee8:	94001e9c 	bl	ffffffffea813958 <arch_strlcpy_from_user>
	if (ret < 0) {
ffffffffea80beec:	37f803c0 	tbnz	w0, #31, ffffffffea80bf64 <sys_port_create+0xc4>
	if ((uint)ret >= sizeof(tmp_path)) {
ffffffffea80bef0:	7100fc1f 	cmp	w0, #0x3f
ffffffffea80bef4:	54000528 	b.hi	ffffffffea80bf98 <sys_port_create+0xf8>  // b.pmore
	ret = ipc_port_create(&tapp->props.uuid, tmp_path,
ffffffffea80bef8:	2a1703e4 	mov	w4, w23
ffffffffea80befc:	910123a5 	add	x5, x29, #0x48
ffffffffea80bf00:	aa1603e3 	mov	x3, x22
ffffffffea80bf04:	2a1503e2 	mov	w2, w21
ffffffffea80bf08:	910143a1 	add	x1, x29, #0x50
ffffffffea80bf0c:	91008280 	add	x0, x20, #0x20
ffffffffea80bf10:	97fffed8 	bl	ffffffffea80ba70 <ipc_port_create>
ffffffffea80bf14:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80bf18:	340000e0 	cbz	w0, ffffffffea80bf34 <sys_port_create+0x94>
	return (long) ret;
ffffffffea80bf1c:	93407e60 	sxtw	x0, w19
}
ffffffffea80bf20:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80bf24:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80bf28:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80bf2c:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80bf30:	d65f03c0 	ret
	ret = uctx_handle_install(ctx, port_handle, &handle_id);
ffffffffea80bf34:	f94027a1 	ldr	x1, [x29, #72]
ffffffffea80bf38:	910113a2 	add	x2, x29, #0x44
ffffffffea80bf3c:	aa1803e0 	mov	x0, x24
ffffffffea80bf40:	97fffabc 	bl	ffffffffea80aa30 <uctx_handle_install>
ffffffffea80bf44:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80bf48:	35000220 	cbnz	w0, ffffffffea80bf8c <sys_port_create+0xec>
	ret = ipc_port_publish(port_handle);
ffffffffea80bf4c:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80bf50:	97ffff12 	bl	ffffffffea80bb98 <ipc_port_publish>
ffffffffea80bf54:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80bf58:	35000120 	cbnz	w0, ffffffffea80bf7c <sys_port_create+0xdc>
	return (long) handle_id;
ffffffffea80bf5c:	b94047a0 	ldr	w0, [x29, #68]
ffffffffea80bf60:	17fffff0 	b	ffffffffea80bf20 <sys_port_create+0x80>
}
ffffffffea80bf64:	a94153f3 	ldp	x19, x20, [sp, #16]
		return (long) ret;
ffffffffea80bf68:	93407c00 	sxtw	x0, w0
}
ffffffffea80bf6c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80bf70:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80bf74:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80bf78:	d65f03c0 	ret
	(void) uctx_handle_remove(ctx, handle_id, &port_handle);
ffffffffea80bf7c:	b94047a1 	ldr	w1, [x29, #68]
ffffffffea80bf80:	910123a2 	add	x2, x29, #0x48
ffffffffea80bf84:	aa1803e0 	mov	x0, x24
ffffffffea80bf88:	97fffaf2 	bl	ffffffffea80ab50 <uctx_handle_remove>
	handle_decref(port_handle);
ffffffffea80bf8c:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80bf90:	97fff8a0 	bl	ffffffffea80a210 <handle_decref>
ffffffffea80bf94:	17ffffe2 	b	ffffffffea80bf1c <sys_port_create+0x7c>
		return ERR_INVALID_ARGS;
ffffffffea80bf98:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80bf9c:	17ffffe1 	b	ffffffffea80bf20 <sys_port_create+0x80>

ffffffffea80bfa0 <ipc_port_connect_async>:
 * Client requests a connection to a port. It can be called in context
 * of user task as well as vdev RX thread.
 */
int ipc_port_connect_async(uint32_t guest, const uuid_t *cid, const char *path, size_t max_path,
			   uint flags, handle_t **chandle_ptr)
{
ffffffffea80bfa0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80bfa4:	910003fd 	mov	x29, sp
ffffffffea80bfa8:	f90013f5 	str	x21, [sp, #32]
	ipc_port_t *port;
	ipc_chan_t *client;
	obj_ref_t   tmp_client_ref = OBJ_REF_INITIAL_VALUE(tmp_client_ref);
ffffffffea80bfac:	a9067fbf 	stp	xzr, xzr, [x29, #96]
	int ret;

	if (!cid) {
ffffffffea80bfb0:	b4001281 	cbz	x1, ffffffffea80c200 <ipc_port_connect_async+0x260>
ffffffffea80bfb4:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80bfb8:	aa0103f5 	mov	x21, x1
ffffffffea80bfbc:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea80bfc0:	aa0303f3 	mov	x19, x3
ffffffffea80bfc4:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea80bfc8:	2a0403f7 	mov	w23, w4
ffffffffea80bfcc:	aa0503f8 	mov	x24, x5
ffffffffea80bfd0:	aa0203f4 	mov	x20, x2
ffffffffea80bfd4:	2a0003f6 	mov	w22, w0
ffffffffea80bfd8:	aa1e03f9 	mov	x25, x30
		/* client uuid is required */
		LTRACEF("client uuid is required\n");
		return ERR_INVALID_ARGS;
	}

	size_t len = strnlen(path, max_path);
ffffffffea80bfdc:	aa0303e1 	mov	x1, x3
ffffffffea80bfe0:	aa0203e0 	mov	x0, x2
ffffffffea80bfe4:	94001e1b 	bl	ffffffffea813850 <strnlen>
	if (len == 0 || len >= max_path) {
ffffffffea80bfe8:	f100001f 	cmp	x0, #0x0
ffffffffea80bfec:	fa401260 	ccmp	x19, x0, #0x0, ne  // ne = any
ffffffffea80bff0:	54000e29 	b.ls	ffffffffea80c1b4 <ipc_port_connect_async+0x214>  // b.plast
		return ERR_INVALID_ARGS;
	}
	/* After this point path is zero terminated */

	/* allocate channel pair */
	client = chan_alloc(0, cid, &tmp_client_ref);
ffffffffea80bff4:	910183a2 	add	x2, x29, #0x60
ffffffffea80bff8:	aa1503e1 	mov	x1, x21
ffffffffea80bffc:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80c000:	97fffc18 	bl	ffffffffea80b060 <chan_alloc>
ffffffffea80c004:	aa0003f3 	mov	x19, x0
	if (!client) {
ffffffffea80c008:	b4000e00 	cbz	x0, ffffffffea80c1c8 <ipc_port_connect_async+0x228>
ffffffffea80c00c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80c010:	a904efba 	stp	x26, x27, [x29, #72]
ffffffffea80c014:	b000007a 	adrp	x26, ffffffffea819000 <_mem_phys_base>
ffffffffea80c018:	9136e340 	add	x0, x26, #0xdb8
ffffffffea80c01c:	97ffe667 	bl	ffffffffea8059b8 <mutex_acquire_timeout>

	LTRACEF("Connecting to '%s'\n", path);

	mutex_acquire(&ipc_lock);

	port = port_find_locked(path);
ffffffffea80c020:	aa1403e0 	mov	x0, x20
ffffffffea80c024:	97fffc25 	bl	ffffffffea80b0b8 <port_find_locked>
ffffffffea80c028:	aa0003fb 	mov	x27, x0
	if (port) {
ffffffffea80c02c:	b4000300 	cbz	x0, ffffffffea80c08c <ipc_port_connect_async+0xec>
		/* found  */
		ret = trusty_hyp_check_guest_access(guest, port->uuid);
ffffffffea80c030:	f9402361 	ldr	x1, [x27, #64]
ffffffffea80c034:	2a1603e0 	mov	w0, w22
ffffffffea80c038:	97ffd9ea 	bl	ffffffffea8027e0 <trusty_hyp_check_guest_access>
ffffffffea80c03c:	2a0003f5 	mov	w21, w0
		if (ret) {
ffffffffea80c040:	34000520 	cbz	w0, ffffffffea80c0e4 <ipc_port_connect_async+0x144>
	item->next->prev = item->prev;
ffffffffea80c044:	a94603a1 	ldp	x1, x0, [x29, #96]
ffffffffea80c048:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c04c:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea80c050:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c054:	a9067fbf 	stp	xzr, xzr, [x29, #96]
	return (list->next == list) ? true : false;
ffffffffea80c058:	f9400674 	ldr	x20, [x19, #8]
ffffffffea80c05c:	eb13029f 	cmp	x20, x19
ffffffffea80c060:	54000780 	b.eq	ffffffffea80c150 <ipc_port_connect_async+0x1b0>  // b.none

err_alloc_path:
err_attach_client:
err_find_ports:
	chan_del_ref(client, &tmp_client_ref);
	mutex_release(&ipc_lock);
ffffffffea80c064:	9136e340 	add	x0, x26, #0xdb8
ffffffffea80c068:	97ffe680 	bl	ffffffffea805a68 <mutex_release>
	return ret;
ffffffffea80c06c:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80c070:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80c074:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80c078:	a944efba 	ldp	x26, x27, [x29, #72]
}
ffffffffea80c07c:	2a1503e0 	mov	w0, w21
ffffffffea80c080:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80c084:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80c088:	d65f03c0 	ret
			ret = ERR_NOT_FOUND;
ffffffffea80c08c:	12800035 	mov	w21, #0xfffffffe            	// #-2
		if (!(flags & IPC_CONNECT_WAIT_FOR_PORT)) {
ffffffffea80c090:	3607fdb7 	tbz	w23, #0, ffffffffea80c044 <ipc_port_connect_async+0xa4>
		client->path = strdup(path);
ffffffffea80c094:	aa1403e0 	mov	x0, x20
ffffffffea80c098:	94001d90 	bl	ffffffffea8136d8 <strdup>
ffffffffea80c09c:	f9005e60 	str	x0, [x19, #184]
			ret = ERR_NO_MEMORY;
ffffffffea80c0a0:	12800095 	mov	w21, #0xfffffffb            	// #-5
		if (!client->path) {
ffffffffea80c0a4:	b4fffd00 	cbz	x0, ffffffffea80c044 <ipc_port_connect_async+0xa4>
	item->prev = list->prev;
ffffffffea80c0a8:	b0000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
		list_add_tail(&waiting_for_port_chan_list, &client->node);
ffffffffea80c0ac:	91028260 	add	x0, x19, #0xa0
ffffffffea80c0b0:	91388023 	add	x3, x1, #0xe20
		client->state = IPC_CHAN_STATE_WAITING_FOR_PORT;
ffffffffea80c0b4:	528000a4 	mov	w4, #0x5                   	// #5
ffffffffea80c0b8:	f9471022 	ldr	x2, [x1, #3616]
	list->prev = item;
ffffffffea80c0bc:	f9071020 	str	x0, [x1, #3616]
ffffffffea80c0c0:	b9003264 	str	w4, [x19, #48]
	item->prev = list->prev;
ffffffffea80c0c4:	f9400261 	ldr	x1, [x19]
	item->next = list;
ffffffffea80c0c8:	a90a0e62 	stp	x2, x3, [x19, #160]
	list->prev->next = item;
ffffffffea80c0cc:	f9000440 	str	x0, [x2, #8]
	list_add_tail(&obj->ref_list, &ref->ref_node);
ffffffffea80c0d0:	91024260 	add	x0, x19, #0x90
	item->next = list;
ffffffffea80c0d4:	a9094e61 	stp	x1, x19, [x19, #144]
	list->prev->next = item;
ffffffffea80c0d8:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea80c0dc:	f9000260 	str	x0, [x19]
ffffffffea80c0e0:	14000007 	b	ffffffffea80c0fc <ipc_port_connect_async+0x15c>
		port->handle.guest_id = guest;
ffffffffea80c0e4:	b9009b76 	str	w22, [x27, #152]
		ret = port_attach_client(port, client);
ffffffffea80c0e8:	aa1303e1 	mov	x1, x19
ffffffffea80c0ec:	aa1b03e0 	mov	x0, x27
ffffffffea80c0f0:	97fffdac 	bl	ffffffffea80b7a0 <port_attach_client>
ffffffffea80c0f4:	2a0003f5 	mov	w21, w0
		if (ret) {
ffffffffea80c0f8:	35fffa60 	cbnz	w0, ffffffffea80c044 <ipc_port_connect_async+0xa4>
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c0fc:	91014274 	add	x20, x19, #0x50
ffffffffea80c100:	b0000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea80c104:	aa1403e0 	mov	x0, x20
ffffffffea80c108:	91366021 	add	x1, x1, #0xd98
ffffffffea80c10c:	97fff82b 	bl	ffffffffea80a1b8 <handle_init>
	ret = NO_ERROR;
ffffffffea80c110:	52800015 	mov	w21, #0x0                   	// #0
	item->prev = list->prev;
ffffffffea80c114:	f9400261 	ldr	x1, [x19]
ffffffffea80c118:	91010260 	add	x0, x19, #0x40
	item->next = list;
ffffffffea80c11c:	a9044e61 	stp	x1, x19, [x19, #64]
	list->prev->next = item;
ffffffffea80c120:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea80c124:	f9000260 	str	x0, [x19]
	*chandle_ptr = chan_handle_init(client);
ffffffffea80c128:	f9000314 	str	x20, [x24]
	item->next->prev = item->prev;
ffffffffea80c12c:	a94603a1 	ldp	x1, x0, [x29, #96]
	client->handle.guest_id = guest;
ffffffffea80c130:	b9008a76 	str	w22, [x19, #136]
ffffffffea80c134:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c138:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea80c13c:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c140:	a9067fbf 	stp	xzr, xzr, [x29, #96]
	return (list->next == list) ? true : false;
ffffffffea80c144:	f9400674 	ldr	x20, [x19, #8]
	if (dead)
ffffffffea80c148:	eb13029f 	cmp	x20, x19
ffffffffea80c14c:	54fff8c1 	b.ne	ffffffffea80c064 <ipc_port_connect_async+0xc4>  // b.any
	ASSERT(chan->peer == NULL);
ffffffffea80c150:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80c154:	b5000440 	cbnz	x0, ffffffffea80c1dc <ipc_port_connect_async+0x23c>
	if (item->prev == 0 && item->next == 0)
ffffffffea80c158:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80c15c:	b4000140 	cbz	x0, ffffffffea80c184 <ipc_port_connect_async+0x1e4>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80c160:	f0000044 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80c164:	f0000042 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80c168:	b0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80c16c:	9112e084 	add	x4, x4, #0x4b8
ffffffffea80c170:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80c174:	91146042 	add	x2, x2, #0x518
ffffffffea80c178:	9135a021 	add	x1, x1, #0xd68
ffffffffea80c17c:	aa1903e0 	mov	x0, x25
ffffffffea80c180:	940016c6 	bl	ffffffffea811c98 <_panic>
ffffffffea80c184:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80c188:	b5fffec0 	cbnz	x0, ffffffffea80c160 <ipc_port_connect_async+0x1c0>
	if (chan->path) {
ffffffffea80c18c:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80c190:	b4000040 	cbz	x0, ffffffffea80c198 <ipc_port_connect_async+0x1f8>
		free((void *)chan->path);
ffffffffea80c194:	94001c65 	bl	ffffffffea813328 <free>
	if (chan->msg_queue) {
ffffffffea80c198:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80c19c:	b4000060 	cbz	x0, ffffffffea80c1a8 <ipc_port_connect_async+0x208>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80c1a0:	94000266 	bl	ffffffffea80cb38 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80c1a4:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80c1a8:	aa1403e0 	mov	x0, x20
ffffffffea80c1ac:	94001c5f 	bl	ffffffffea813328 <free>
ffffffffea80c1b0:	17ffffad 	b	ffffffffea80c064 <ipc_port_connect_async+0xc4>
		return ERR_INVALID_ARGS;
ffffffffea80c1b4:	128000f5 	mov	w21, #0xfffffff8            	// #-8
ffffffffea80c1b8:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80c1bc:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80c1c0:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80c1c4:	17ffffae 	b	ffffffffea80c07c <ipc_port_connect_async+0xdc>
		return ERR_NO_MEMORY;
ffffffffea80c1c8:	12800095 	mov	w21, #0xfffffffb            	// #-5
ffffffffea80c1cc:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80c1d0:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80c1d4:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80c1d8:	17ffffa9 	b	ffffffffea80c07c <ipc_port_connect_async+0xdc>
	ASSERT(chan->peer == NULL);
ffffffffea80c1dc:	f0000044 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80c1e0:	f0000042 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80c1e4:	b0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80c1e8:	91128084 	add	x4, x4, #0x4a0
ffffffffea80c1ec:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80c1f0:	91146042 	add	x2, x2, #0x518
ffffffffea80c1f4:	9135a021 	add	x1, x1, #0xd68
ffffffffea80c1f8:	aa1903e0 	mov	x0, x25
ffffffffea80c1fc:	940016a7 	bl	ffffffffea811c98 <_panic>
		return ERR_INVALID_ARGS;
ffffffffea80c200:	128000f5 	mov	w21, #0xfffffff8            	// #-8
ffffffffea80c204:	17ffff9e 	b	ffffffffea80c07c <ipc_port_connect_async+0xdc>

ffffffffea80c208 <sys_connect>:
#ifndef DEFAULT_IPC_CONNECT_WARN_TIMEOUT
#define DEFAULT_IPC_CONNECT_WARN_TIMEOUT   INFINITE_TIME
#endif

long __SYSCALL sys_connect(user_addr_t path, uint flags)
{
ffffffffea80c208:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea80c20c:	910003fd 	mov	x29, sp
ffffffffea80c210:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80c214:	2a0003f4 	mov	w20, w0
ffffffffea80c218:	2a0103f3 	mov	w19, w1
ffffffffea80c21c:	f90013f5 	str	x21, [sp, #32]
ffffffffea80c220:	d538d080 	mrs	x0, tpidr_el1
	uthread_t *ut = uthread_get_current();
	trusty_app_t *tapp = ut->private_data;
ffffffffea80c224:	f9415800 	ldr	x0, [x0, #688]
ffffffffea80c228:	f9404815 	ldr	x21, [x0, #144]
	uctx_t *ctx = current_uctx();
ffffffffea80c22c:	97fff9ad 	bl	ffffffffea80a8e0 <current_uctx>
	char tmp_path[IPC_PORT_PATH_MAX];
	int ret;
	handle_id_t handle_id;
	uint32_t cur_guest;

	if (flags & ~IPC_CONNECT_MASK) {
ffffffffea80c230:	721e767f 	tst	w19, #0xfffffffc
ffffffffea80c234:	540007a1 	b.ne	ffffffffea80c328 <sys_connect+0x120>  // b.any
ffffffffea80c238:	f90017b6 	str	x22, [x29, #40]
ffffffffea80c23c:	d2800802 	mov	x2, #0x40                  	// #64
ffffffffea80c240:	aa0003f6 	mov	x22, x0
ffffffffea80c244:	2a1403e1 	mov	w1, w20
ffffffffea80c248:	8b0203a0 	add	x0, x29, x2
ffffffffea80c24c:	94001dc3 	bl	ffffffffea813958 <arch_strlcpy_from_user>
		/* unsupported flags specified */
		return ERR_INVALID_ARGS;
	}

	ret = (int) strncpy_from_user(tmp_path, path, sizeof(tmp_path));
	if (ret < 0) {
ffffffffea80c250:	37f804e0 	tbnz	w0, #31, ffffffffea80c2ec <sys_connect+0xe4>
		return (long) ret;
	}
	if ((uint)ret >= sizeof(tmp_path)) {
ffffffffea80c254:	7100fc1f 	cmp	w0, #0x3f
ffffffffea80c258:	54000668 	b.hi	ffffffffea80c324 <sys_connect+0x11c>  // b.pmore
		return (long) ERR_INVALID_ARGS;
	}
	cur_guest = uctx_get_current_guest();
ffffffffea80c25c:	97fff987 	bl	ffffffffea80a878 <uctx_get_current_guest>

	ret = ipc_port_connect_async(cur_guest, &tapp->props.uuid,
ffffffffea80c260:	d2800803 	mov	x3, #0x40                  	// #64
ffffffffea80c264:	9100e3a5 	add	x5, x29, #0x38
ffffffffea80c268:	2a1303e4 	mov	w4, w19
ffffffffea80c26c:	8b0303a2 	add	x2, x29, x3
ffffffffea80c270:	910082a1 	add	x1, x21, #0x20
ffffffffea80c274:	97ffff4b 	bl	ffffffffea80bfa0 <ipc_port_connect_async>
				     tmp_path, sizeof(tmp_path),
				     flags, &chandle);
	if (ret != NO_ERROR) {
ffffffffea80c278:	350003a0 	cbnz	w0, ffffffffea80c2ec <sys_connect+0xe4>
	}
	if (!(flags & IPC_CONNECT_ASYNC)) {
		uint32_t event;
		lk_time_t timeout_msecs = DEFAULT_IPC_CONNECT_WARN_TIMEOUT;

		ret = handle_wait(chandle, &event, timeout_msecs);
ffffffffea80c27c:	9100d3b4 	add	x20, x29, #0x34
ffffffffea80c280:	f9401fa0 	ldr	x0, [x29, #56]
	if (!(flags & IPC_CONNECT_ASYNC)) {
ffffffffea80c284:	370801d3 	tbnz	w19, #1, ffffffffea80c2bc <sys_connect+0xb4>
		ret = handle_wait(chandle, &event, timeout_msecs);
ffffffffea80c288:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea80c28c:	aa1403e1 	mov	x1, x20
ffffffffea80c290:	97fff814 	bl	ffffffffea80a2e0 <handle_wait>
ffffffffea80c294:	2a0003f3 	mov	w19, w0
		if (ret == ERR_TIMED_OUT) {
ffffffffea80c298:	3100341f 	cmn	w0, #0xd
ffffffffea80c29c:	540004a0 	b.eq	ffffffffea80c330 <sys_connect+0x128>  // b.none
			TRACEF("Timedout connecting to %s\n", tmp_path);
			ret = handle_wait(chandle, &event, INFINITE_TIME);
		}

		if (ret < 0) {
ffffffffea80c2a0:	37f80333 	tbnz	w19, #31, ffffffffea80c304 <sys_connect+0xfc>
			/* timeout or other error */
			handle_close(chandle);
			return ret;
		}

		if ((event & IPC_HANDLE_POLL_HUP) &&
ffffffffea80c2a4:	b94037a3 	ldr	w3, [x29, #52]
ffffffffea80c2a8:	121e0460 	and	w0, w3, #0xc
ffffffffea80c2ac:	7100101f 	cmp	w0, #0x4
ffffffffea80c2b0:	54000700 	b.eq	ffffffffea80c390 <sys_connect+0x188>  // b.none
			/* hangup and no pending messages */
			handle_close(chandle);
			return ERR_CHANNEL_CLOSED;
		}

		if (!(event & IPC_HANDLE_POLL_READY)) {
ffffffffea80c2b4:	36000583 	tbz	w3, #0, ffffffffea80c364 <sys_connect+0x15c>
ffffffffea80c2b8:	f9401fa0 	ldr	x0, [x29, #56]
			handle_close(chandle);
			return ERR_NOT_READY;
		}
	}

	ret = uctx_handle_install(ctx, chandle, &handle_id);
ffffffffea80c2bc:	aa0003e1 	mov	x1, x0
ffffffffea80c2c0:	aa1403e2 	mov	x2, x20
ffffffffea80c2c4:	aa1603e0 	mov	x0, x22
ffffffffea80c2c8:	97fff9da 	bl	ffffffffea80aa30 <uctx_handle_install>
ffffffffea80c2cc:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c2d0:	350001a0 	cbnz	w0, ffffffffea80c304 <sys_connect+0xfc>
		/* Failed to install handle into user context */
		handle_close(chandle);
		return (long) ret;
	}

	return (long) handle_id;
ffffffffea80c2d4:	b94037a0 	ldr	w0, [x29, #52]
ffffffffea80c2d8:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea80c2dc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c2e0:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80c2e4:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80c2e8:	d65f03c0 	ret
		return (long) ret;
ffffffffea80c2ec:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c2f0:	93407c00 	sxtw	x0, w0
}
ffffffffea80c2f4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c2f8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80c2fc:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80c300:	d65f03c0 	ret
		handle_close(chandle);
ffffffffea80c304:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c308:	97fff7ea 	bl	ffffffffea80a2b0 <handle_close>
		return (long) ret;
ffffffffea80c30c:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c310:	93407e60 	sxtw	x0, w19
}
ffffffffea80c314:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80c318:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c31c:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80c320:	d65f03c0 	ret
ffffffffea80c324:	f94017b6 	ldr	x22, [x29, #40]
		return ERR_INVALID_ARGS;
ffffffffea80c328:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80c32c:	17fffff2 	b	ffffffffea80c2f4 <sys_connect+0xec>
			TRACEF("Timedout connecting to %s\n", tmp_path);
ffffffffea80c330:	910103a3 	add	x3, x29, #0x40
ffffffffea80c334:	528066e2 	mov	w2, #0x337                 	// #823
ffffffffea80c338:	f0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80c33c:	f0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80c340:	9111c021 	add	x1, x1, #0x470
ffffffffea80c344:	91154000 	add	x0, x0, #0x550
ffffffffea80c348:	94001bba 	bl	ffffffffea813230 <_printf>
			ret = handle_wait(chandle, &event, INFINITE_TIME);
ffffffffea80c34c:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c350:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea80c354:	aa1403e1 	mov	x1, x20
ffffffffea80c358:	97fff7e2 	bl	ffffffffea80a2e0 <handle_wait>
ffffffffea80c35c:	2a0003f3 	mov	w19, w0
ffffffffea80c360:	17ffffd0 	b	ffffffffea80c2a0 <sys_connect+0x98>
			TRACEF("Unexpected channel state: event = 0x%x\n", event);
ffffffffea80c364:	52806942 	mov	w2, #0x34a                 	// #842
ffffffffea80c368:	f0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80c36c:	f0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80c370:	9111c021 	add	x1, x1, #0x470
ffffffffea80c374:	9115e000 	add	x0, x0, #0x578
ffffffffea80c378:	94001bae 	bl	ffffffffea813230 <_printf>
			handle_close(chandle);
ffffffffea80c37c:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c380:	97fff7cc 	bl	ffffffffea80a2b0 <handle_close>
			return ERR_NOT_READY;
ffffffffea80c384:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c388:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
ffffffffea80c38c:	17ffffda 	b	ffffffffea80c2f4 <sys_connect+0xec>
			handle_close(chandle);
ffffffffea80c390:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c394:	97fff7c7 	bl	ffffffffea80a2b0 <handle_close>
			return ERR_CHANNEL_CLOSED;
ffffffffea80c398:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c39c:	928001c0 	mov	x0, #0xfffffffffffffff1    	// #-15
ffffffffea80c3a0:	17ffffd5 	b	ffffffffea80c2f4 <sys_connect+0xec>
ffffffffea80c3a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80c3a8 <ipc_port_accept>:
/*
 *  Called by user task to accept incomming connection
 */
int ipc_port_accept(handle_t *phandle, handle_t **chandle_ptr,
                    const uuid_t **uuid_ptr)
{
ffffffffea80c3a8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80c3ac:	910003fd 	mov	x29, sp
ffffffffea80c3b0:	f90017f6 	str	x22, [sp, #40]
	ipc_port_t *port;
	ipc_chan_t *server = NULL;
	ipc_chan_t *client = NULL;
	obj_ref_t tmp_server_ref = OBJ_REF_INITIAL_VALUE(tmp_server_ref);
ffffffffea80c3b4:	a9067fbf 	stp	xzr, xzr, [x29, #96]
	int ret = NO_ERROR;

	DEBUG_ASSERT(chandle_ptr);
	DEBUG_ASSERT(uuid_ptr);

	if (!phandle || !ipc_is_port(phandle)) {
ffffffffea80c3b8:	b4000aa0 	cbz	x0, ffffffffea80c50c <ipc_port_accept+0x164>
ffffffffea80c3bc:	f9400404 	ldr	x4, [x0, #8]
ffffffffea80c3c0:	b0000063 	adrp	x3, ffffffffea819000 <_mem_phys_base>
ffffffffea80c3c4:	9137c063 	add	x3, x3, #0xdf0
ffffffffea80c3c8:	eb03009f 	cmp	x4, x3
ffffffffea80c3cc:	54000a01 	b.ne	ffffffffea80c50c <ipc_port_accept+0x164>  // b.any
ffffffffea80c3d0:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80c3d4:	aa0003f3 	mov	x19, x0
ffffffffea80c3d8:	f90013b5 	str	x21, [x29, #32]
ffffffffea80c3dc:	b0000075 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea80c3e0:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80c3e4:	9136e2a0 	add	x0, x21, #0xdb8
ffffffffea80c3e8:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea80c3ec:	aa0203f8 	mov	x24, x2
ffffffffea80c3f0:	aa0103f9 	mov	x25, x1
ffffffffea80c3f4:	aa1e03f7 	mov	x23, x30
ffffffffea80c3f8:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80c3fc:	97ffe56f 	bl	ffffffffea8059b8 <mutex_acquire_timeout>

	port = containerof(phandle, ipc_port_t, handle);

	mutex_acquire(&ipc_lock);

	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80c400:	b85e8260 	ldur	w0, [x19, #-24]
		/* Not in listening state: caller should close port.
		 * is it really possible to get here?
		 */
		ret = ERR_CHANNEL_CLOSED;
ffffffffea80c404:	128001d6 	mov	w22, #0xfffffff1            	// #-15
	port = containerof(phandle, ipc_port_t, handle);
ffffffffea80c408:	d101827a 	sub	x26, x19, #0x60
	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80c40c:	7100041f 	cmp	w0, #0x1
ffffffffea80c410:	54000160 	b.eq	ffffffffea80c43c <ipc_port_accept+0x94>  // b.none

err_bad_chan_state:
	chan_del_ref(server, &tmp_server_ref);
err_no_connections:
err_bad_port_state:
	mutex_release(&ipc_lock);
ffffffffea80c414:	9136e2a0 	add	x0, x21, #0xdb8
ffffffffea80c418:	97ffe594 	bl	ffffffffea805a68 <mutex_release>
	return ret;
}
ffffffffea80c41c:	2a1603e0 	mov	w0, w22
	return ret;
ffffffffea80c420:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80c424:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c428:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80c42c:	a9446bb9 	ldp	x25, x26, [x29, #64]
}
ffffffffea80c430:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80c434:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80c438:	d65f03c0 	ret
ffffffffea80c43c:	f9000fb4 	str	x20, [x29, #24]
	server = list_remove_head_type(&port->pending_list, ipc_chan_t, node);
ffffffffea80c440:	91010260 	add	x0, x19, #0x40
	if (list->next != list) {
ffffffffea80c444:	f9405754 	ldr	x20, [x26, #168]
ffffffffea80c448:	eb00029f 	cmp	x20, x0
ffffffffea80c44c:	540005a0 	b.eq	ffffffffea80c500 <ipc_port_accept+0x158>  // b.none
	item->next->prev = item->prev;
ffffffffea80c450:	a9400281 	ldp	x1, x0, [x20]
	item->prev = item->next = 0;
ffffffffea80c454:	aa1403f3 	mov	x19, x20
	if (!server) {
ffffffffea80c458:	f102829f 	cmp	x20, #0xa0
	item->next->prev = item->prev;
ffffffffea80c45c:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c460:	f9400281 	ldr	x1, [x20]
ffffffffea80c464:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c468:	f900069f 	str	xzr, [x20, #8]
ffffffffea80c46c:	f816067f 	str	xzr, [x19], #-160
ffffffffea80c470:	54000480 	b.eq	ffffffffea80c500 <ipc_port_accept+0x158>  // b.none
	item->prev = list->prev;
ffffffffea80c474:	f8560280 	ldur	x0, [x20, #-160]
	item->next = list;
ffffffffea80c478:	a9064fa0 	stp	x0, x19, [x29, #96]
	list->prev->next = item;
ffffffffea80c47c:	910183a0 	add	x0, x29, #0x60
	item->next->prev = item->prev;
ffffffffea80c480:	f85f0281 	ldur	x1, [x20, #-16]
	list->prev->next = item;
ffffffffea80c484:	f8560282 	ldur	x2, [x20, #-160]
ffffffffea80c488:	f9000440 	str	x0, [x2, #8]
	list->prev = item;
ffffffffea80c48c:	f8160280 	stur	x0, [x20, #-160]
	item->next->prev = item->prev;
ffffffffea80c490:	f85f8280 	ldur	x0, [x20, #-8]
ffffffffea80c494:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c498:	f85f0281 	ldur	x1, [x20, #-16]
ffffffffea80c49c:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c4a0:	a93f7e9f 	stp	xzr, xzr, [x20, #-16]
ffffffffea80c4a4:	f8568280 	ldur	x0, [x20, #-152]
ffffffffea80c4a8:	eb13001f 	cmp	x0, x19
ffffffffea80c4ac:	54000760 	b.eq	ffffffffea80c598 <ipc_port_accept+0x1f0>  // b.none
	handle_decref(&port->handle);
ffffffffea80c4b0:	91018340 	add	x0, x26, #0x60
ffffffffea80c4b4:	97fff757 	bl	ffffffffea80a210 <handle_decref>
	client = server->peer;
ffffffffea80c4b8:	f858029a 	ldur	x26, [x20, #-128]
	if (!client ||
ffffffffea80c4bc:	b400009a 	cbz	x26, ffffffffea80c4cc <ipc_port_accept+0x124>
ffffffffea80c4c0:	b8590280 	ldur	w0, [x20, #-112]
ffffffffea80c4c4:	7100041f 	cmp	w0, #0x1
ffffffffea80c4c8:	540002c0 	b.eq	ffffffffea80c520 <ipc_port_accept+0x178>  // b.none
		chan_shutdown_locked(server);
ffffffffea80c4cc:	aa1303e0 	mov	x0, x19
		ret = ERR_CHANNEL_CLOSED;
ffffffffea80c4d0:	128001d6 	mov	w22, #0xfffffff1            	// #-15
		chan_shutdown_locked(server);
ffffffffea80c4d4:	97fffbe9 	bl	ffffffffea80b478 <chan_shutdown_locked>
	item->next->prev = item->prev;
ffffffffea80c4d8:	a94603a1 	ldp	x1, x0, [x29, #96]
ffffffffea80c4dc:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c4e0:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea80c4e4:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c4e8:	a9067fbf 	stp	xzr, xzr, [x29, #96]
ffffffffea80c4ec:	f8568280 	ldur	x0, [x20, #-152]
ffffffffea80c4f0:	eb00027f 	cmp	x19, x0
ffffffffea80c4f4:	540006e0 	b.eq	ffffffffea80c5d0 <ipc_port_accept+0x228>  // b.none
ffffffffea80c4f8:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80c4fc:	17ffffc6 	b	ffffffffea80c414 <ipc_port_accept+0x6c>
		ret = ERR_NO_MSG;
ffffffffea80c500:	12800076 	mov	w22, #0xfffffffc            	// #-4
ffffffffea80c504:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80c508:	17ffffc3 	b	ffffffffea80c414 <ipc_port_accept+0x6c>
		return ERR_INVALID_ARGS;
ffffffffea80c50c:	128000f6 	mov	w22, #0xfffffff8            	// #-8
}
ffffffffea80c510:	2a1603e0 	mov	w0, w22
ffffffffea80c514:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80c518:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80c51c:	d65f03c0 	ret
	    server->state != IPC_CHAN_STATE_ACCEPTING ||
ffffffffea80c520:	b9403340 	ldr	w0, [x26, #48]
ffffffffea80c524:	7100081f 	cmp	w0, #0x2
ffffffffea80c528:	54fffd21 	b.ne	ffffffffea80c4cc <ipc_port_accept+0x124>  // b.any
	client->aux_state |= IPC_CHAN_AUX_STATE_CONNECTED;
ffffffffea80c52c:	b9403b40 	ldr	w0, [x26, #56]
	server->state = IPC_CHAN_STATE_CONNECTED;
ffffffffea80c530:	52800061 	mov	w1, #0x3                   	// #3
ffffffffea80c534:	f9002bbb 	str	x27, [x29, #80]
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c538:	9101427b 	add	x27, x19, #0x50
	server->state = IPC_CHAN_STATE_CONNECTED;
ffffffffea80c53c:	b8190281 	stur	w1, [x20, #-112]
	client->aux_state |= IPC_CHAN_AUX_STATE_CONNECTED;
ffffffffea80c540:	321e0000 	orr	w0, w0, #0x4
	client->state = IPC_CHAN_STATE_CONNECTED;
ffffffffea80c544:	b9003341 	str	w1, [x26, #48]
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c548:	b0000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
	client->aux_state |= IPC_CHAN_AUX_STATE_CONNECTED;
ffffffffea80c54c:	b9003b40 	str	w0, [x26, #56]
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c550:	91366021 	add	x1, x1, #0xd98
ffffffffea80c554:	aa1b03e0 	mov	x0, x27
	ret = NO_ERROR;
ffffffffea80c558:	52800016 	mov	w22, #0x0                   	// #0
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c55c:	97fff717 	bl	ffffffffea80a1b8 <handle_init>
	item->prev = list->prev;
ffffffffea80c560:	f8560281 	ldur	x1, [x20, #-160]
	list_add_tail(&obj->ref_list, &ref->ref_node);
ffffffffea80c564:	91010260 	add	x0, x19, #0x40
	*uuid_ptr = client->uuid;
ffffffffea80c568:	f9401742 	ldr	x2, [x26, #40]
	item->next = list;
ffffffffea80c56c:	a93a4e81 	stp	x1, x19, [x20, #-96]
	list->prev->next = item;
ffffffffea80c570:	f9000420 	str	x0, [x1, #8]
	server->handle.guest_id = client->handle.guest_id;
ffffffffea80c574:	b9408b41 	ldr	w1, [x26, #136]
	list->prev = item;
ffffffffea80c578:	f8160280 	stur	x0, [x20, #-160]
	handle_notify(&client->handle);
ffffffffea80c57c:	91014340 	add	x0, x26, #0x50
	*chandle_ptr = chan_handle_init(server);
ffffffffea80c580:	f900033b 	str	x27, [x25]
	*uuid_ptr = client->uuid;
ffffffffea80c584:	f9000302 	str	x2, [x24]
	server->handle.guest_id = client->handle.guest_id;
ffffffffea80c588:	b81e8281 	stur	w1, [x20, #-24]
	handle_notify(&client->handle);
ffffffffea80c58c:	97fff78d 	bl	ffffffffea80a3c0 <handle_notify>
ffffffffea80c590:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea80c594:	17ffffd1 	b	ffffffffea80c4d8 <ipc_port_accept+0x130>
	ASSERT(chan->peer == NULL);
ffffffffea80c598:	f9401000 	ldr	x0, [x0, #32]
ffffffffea80c59c:	b5000540 	cbnz	x0, ffffffffea80c644 <ipc_port_accept+0x29c>
	if (item->prev == 0 && item->next == 0)
ffffffffea80c5a0:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80c5a4:	b4000380 	cbz	x0, ffffffffea80c614 <ipc_port_accept+0x26c>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80c5a8:	f0000044 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80c5ac:	f0000042 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80c5b0:	b0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80c5b4:	9112e084 	add	x4, x4, #0x4b8
ffffffffea80c5b8:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80c5bc:	91146042 	add	x2, x2, #0x518
ffffffffea80c5c0:	9135a021 	add	x1, x1, #0xd68
ffffffffea80c5c4:	aa1703e0 	mov	x0, x23
ffffffffea80c5c8:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80c5cc:	940015b3 	bl	ffffffffea811c98 <_panic>
	ASSERT(chan->peer == NULL);
ffffffffea80c5d0:	f8580280 	ldur	x0, [x20, #-128]
ffffffffea80c5d4:	b5000380 	cbnz	x0, ffffffffea80c644 <ipc_port_accept+0x29c>
ffffffffea80c5d8:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80c5dc:	b5fffe60 	cbnz	x0, ffffffffea80c5a8 <ipc_port_accept+0x200>
ffffffffea80c5e0:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80c5e4:	b5fffe20 	cbnz	x0, ffffffffea80c5a8 <ipc_port_accept+0x200>
	if (chan->path) {
ffffffffea80c5e8:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80c5ec:	b4000040 	cbz	x0, ffffffffea80c5f4 <ipc_port_accept+0x24c>
		free((void *)chan->path);
ffffffffea80c5f0:	94001b4e 	bl	ffffffffea813328 <free>
	if (chan->msg_queue) {
ffffffffea80c5f4:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80c5f8:	b4000060 	cbz	x0, ffffffffea80c604 <ipc_port_accept+0x25c>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80c5fc:	9400014f 	bl	ffffffffea80cb38 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80c600:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80c604:	aa1303e0 	mov	x0, x19
ffffffffea80c608:	94001b48 	bl	ffffffffea813328 <free>
ffffffffea80c60c:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80c610:	17ffff81 	b	ffffffffea80c414 <ipc_port_accept+0x6c>
ffffffffea80c614:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80c618:	b5fffc80 	cbnz	x0, ffffffffea80c5a8 <ipc_port_accept+0x200>
	if (chan->path) {
ffffffffea80c61c:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80c620:	b4000040 	cbz	x0, ffffffffea80c628 <ipc_port_accept+0x280>
		free((void *)chan->path);
ffffffffea80c624:	94001b41 	bl	ffffffffea813328 <free>
	if (chan->msg_queue) {
ffffffffea80c628:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80c62c:	b4000060 	cbz	x0, ffffffffea80c638 <ipc_port_accept+0x290>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80c630:	94000142 	bl	ffffffffea80cb38 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80c634:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80c638:	aa1303e0 	mov	x0, x19
ffffffffea80c63c:	94001b3b 	bl	ffffffffea813328 <free>
ffffffffea80c640:	17ffff9c 	b	ffffffffea80c4b0 <ipc_port_accept+0x108>
	ASSERT(chan->peer == NULL);
ffffffffea80c644:	f0000044 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80c648:	f0000042 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80c64c:	b0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80c650:	91128084 	add	x4, x4, #0x4a0
ffffffffea80c654:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80c658:	91146042 	add	x2, x2, #0x518
ffffffffea80c65c:	9135a021 	add	x1, x1, #0xd68
ffffffffea80c660:	aa1703e0 	mov	x0, x23
ffffffffea80c664:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80c668:	9400158c 	bl	ffffffffea811c98 <_panic>
ffffffffea80c66c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80c670 <sys_accept>:

long __SYSCALL sys_accept(uint32_t handle_id, user_addr_t user_uuid)
{
ffffffffea80c670:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80c674:	910003fd 	mov	x29, sp
ffffffffea80c678:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80c67c:	2a0003f3 	mov	w19, w0
ffffffffea80c680:	f90013f5 	str	x21, [sp, #32]
ffffffffea80c684:	2a0103f5 	mov	w21, w1
	uctx_t *ctx = current_uctx();
ffffffffea80c688:	97fff896 	bl	ffffffffea80a8e0 <current_uctx>
	handle_t *phandle = NULL;
	handle_t *chandle = NULL;
ffffffffea80c68c:	a903ffbf 	stp	xzr, xzr, [x29, #56]
	uctx_t *ctx = current_uctx();
ffffffffea80c690:	aa0003f4 	mov	x20, x0
	int ret;
	handle_id_t new_id;
	const uuid_t *peer_uuid_ptr;

	ret = uctx_handle_get(ctx, handle_id, &phandle);
ffffffffea80c694:	9100e3a2 	add	x2, x29, #0x38
ffffffffea80c698:	2a1303e1 	mov	w1, w19
ffffffffea80c69c:	97fff917 	bl	ffffffffea80aaf8 <uctx_handle_get>
	if (ret != NO_ERROR) {
ffffffffea80c6a0:	340000c0 	cbz	w0, ffffffffea80c6b8 <sys_accept+0x48>
		return (long) ret;
ffffffffea80c6a4:	93407c00 	sxtw	x0, w0
err_install:
	handle_close(chandle);
err_accept:
	handle_decref(phandle);
	return (long) ret;
}
ffffffffea80c6a8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c6ac:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80c6b0:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80c6b4:	d65f03c0 	ret
	ret = ipc_port_accept(phandle, &chandle, &peer_uuid_ptr);
ffffffffea80c6b8:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c6bc:	910123a2 	add	x2, x29, #0x48
ffffffffea80c6c0:	910103a1 	add	x1, x29, #0x40
ffffffffea80c6c4:	97ffff39 	bl	ffffffffea80c3a8 <ipc_port_accept>
ffffffffea80c6c8:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c6cc:	35000260 	cbnz	w0, ffffffffea80c718 <sys_accept+0xa8>
	ret = uctx_handle_install(ctx, chandle, &new_id);
ffffffffea80c6d0:	f94023a1 	ldr	x1, [x29, #64]
ffffffffea80c6d4:	9100d3a2 	add	x2, x29, #0x34
ffffffffea80c6d8:	aa1403e0 	mov	x0, x20
ffffffffea80c6dc:	97fff8d5 	bl	ffffffffea80aa30 <uctx_handle_install>
ffffffffea80c6e0:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c6e4:	35000160 	cbnz	w0, ffffffffea80c710 <sys_accept+0xa0>
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea80c6e8:	f94027a1 	ldr	x1, [x29, #72]
ffffffffea80c6ec:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80c6f0:	2a1503e0 	mov	w0, w21
ffffffffea80c6f4:	94001c89 	bl	ffffffffea813918 <arch_copy_to_user>
ffffffffea80c6f8:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c6fc:	340001c0 	cbz	w0, ffffffffea80c734 <sys_accept+0xc4>
	uctx_handle_remove(ctx, new_id, &chandle);
ffffffffea80c700:	b94037a1 	ldr	w1, [x29, #52]
ffffffffea80c704:	910103a2 	add	x2, x29, #0x40
ffffffffea80c708:	aa1403e0 	mov	x0, x20
ffffffffea80c70c:	97fff911 	bl	ffffffffea80ab50 <uctx_handle_remove>
	handle_close(chandle);
ffffffffea80c710:	f94023a0 	ldr	x0, [x29, #64]
ffffffffea80c714:	97fff6e7 	bl	ffffffffea80a2b0 <handle_close>
	handle_decref(phandle);
ffffffffea80c718:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c71c:	97fff6bd 	bl	ffffffffea80a210 <handle_decref>
}
ffffffffea80c720:	f94013f5 	ldr	x21, [sp, #32]
	return (long) ret;
ffffffffea80c724:	93407e60 	sxtw	x0, w19
}
ffffffffea80c728:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c72c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80c730:	d65f03c0 	ret
	handle_decref(phandle);
ffffffffea80c734:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c738:	97fff6b6 	bl	ffffffffea80a210 <handle_decref>
	return (long) new_id;
ffffffffea80c73c:	b94037a0 	ldr	w0, [x29, #52]
ffffffffea80c740:	17ffffda 	b	ffffffffea80c6a8 <sys_accept+0x38>
ffffffffea80c744:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80c748 <msg_get_filled_locked>:
	if (list->next != list) {
ffffffffea80c748:	f9400c01 	ldr	x1, [x0, #24]
 */
static void msg_get_filled_locked(ipc_msg_queue_t *mq)
{
	msg_item_t *item;

	item = list_peek_head_type(&mq->filled_list, msg_item_t, node);
ffffffffea80c74c:	91004002 	add	x2, x0, #0x10
ffffffffea80c750:	f100003f 	cmp	x1, #0x0
ffffffffea80c754:	fa411044 	ccmp	x2, x1, #0x4, ne  // ne = any
ffffffffea80c758:	540001e0 	b.eq	ffffffffea80c794 <msg_get_filled_locked+0x4c>  // b.none
	item->next->prev = item->prev;
ffffffffea80c75c:	a9401026 	ldp	x6, x4, [x1]
	item->prev = list->prev;
ffffffffea80c760:	aa0003e3 	mov	x3, x0
	DEBUG_ASSERT(item);

	list_delete(&item->node);
	list_add_tail(&mq->read_list, &item->node);
	item->state = MSG_ITEM_STATE_READ;
ffffffffea80c764:	52800045 	mov	w5, #0x2                   	// #2
	item->next->prev = item->prev;
ffffffffea80c768:	f9000086 	str	x6, [x4]
	item->prev->next = item->next;
ffffffffea80c76c:	f9400026 	ldr	x6, [x1]
ffffffffea80c770:	f90004c4 	str	x4, [x6, #8]
	item->prev = item->next = 0;
ffffffffea80c774:	f900003f 	str	xzr, [x1]
	item->prev = list->prev;
ffffffffea80c778:	f8420c64 	ldr	x4, [x3, #32]!
	item->next = list;
ffffffffea80c77c:	a9000c24 	stp	x4, x3, [x1]
	list->prev->next = item;
ffffffffea80c780:	f9401002 	ldr	x2, [x0, #32]
ffffffffea80c784:	f9000441 	str	x1, [x2, #8]
	list->prev = item;
ffffffffea80c788:	f9001001 	str	x1, [x0, #32]
ffffffffea80c78c:	381d1025 	sturb	w5, [x1, #-47]
}
ffffffffea80c790:	d65f03c0 	ret
	item->next->prev = item->prev;
ffffffffea80c794:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80c798:	f9401c00 	ldr	x0, [x0, #56]
ffffffffea80c79c:	d4207d00 	brk	#0x3e8

ffffffffea80c7a0 <check_channel_connected_locked>:
	if (unlikely(!chandle)) {
ffffffffea80c7a0:	b4000300 	cbz	x0, ffffffffea80c800 <check_channel_connected_locked+0x60>
{
ffffffffea80c7a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80c7a8:	910003fd 	mov	x29, sp
ffffffffea80c7ac:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80c7b0:	aa0003f3 	mov	x19, x0
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80c7b4:	97fffca9 	bl	ffffffffea80ba58 <ipc_is_channel>
ffffffffea80c7b8:	72001c1f 	tst	w0, #0xff
ffffffffea80c7bc:	54000100 	b.eq	ffffffffea80c7dc <check_channel_connected_locked+0x3c>  // b.none
	if (likely(chan->state == IPC_CHAN_STATE_CONNECTED)) {
ffffffffea80c7c0:	b85e0261 	ldur	w1, [x19, #-32]
		return NO_ERROR;
ffffffffea80c7c4:	52800000 	mov	w0, #0x0                   	// #0
	if (likely(chan->state == IPC_CHAN_STATE_CONNECTED)) {
ffffffffea80c7c8:	71000c3f 	cmp	w1, #0x3
ffffffffea80c7cc:	54000101 	b.ne	ffffffffea80c7ec <check_channel_connected_locked+0x4c>  // b.any
}
ffffffffea80c7d0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80c7d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80c7d8:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80c7dc:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80c7e0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80c7e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80c7e8:	d65f03c0 	ret
		return ERR_NOT_READY;
ffffffffea80c7ec:	7100103f 	cmp	w1, #0x4
ffffffffea80c7f0:	128001c0 	mov	w0, #0xfffffff1            	// #-15
ffffffffea80c7f4:	12800041 	mov	w1, #0xfffffffd            	// #-3
ffffffffea80c7f8:	1a810000 	csel	w0, w0, w1, eq  // eq = none
ffffffffea80c7fc:	17fffff5 	b	ffffffffea80c7d0 <check_channel_connected_locked+0x30>
		return ERR_INVALID_ARGS;
ffffffffea80c800:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80c804:	d65f03c0 	ret

ffffffffea80c808 <msg_write_locked>:
{
ffffffffea80c808:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80c80c:	910003fd 	mov	x29, sp
	ipc_msg_queue_t *mq = chan->peer->msg_queue;
ffffffffea80c810:	f9401002 	ldr	x2, [x0, #32]
{
ffffffffea80c814:	a90153f3 	stp	x19, x20, [sp, #16]
	ipc_msg_queue_t *mq = chan->peer->msg_queue;
ffffffffea80c818:	f9405854 	ldr	x20, [x2, #176]
	if (list->next != list) {
ffffffffea80c81c:	f9400693 	ldr	x19, [x20, #8]
	item = list_peek_head_type(&mq->free_list, msg_item_t, node);
ffffffffea80c820:	f100027f 	cmp	x19, #0x0
ffffffffea80c824:	fa531284 	ccmp	x20, x19, #0x4, ne  // ne = any
ffffffffea80c828:	54000780 	b.eq	ffffffffea80c918 <msg_write_locked+0x110>  // b.none
ffffffffea80c82c:	f90013b5 	str	x21, [x29, #32]
	if (item == NULL) {
ffffffffea80c830:	f100c27f 	cmp	x19, #0x30
	item = list_peek_head_type(&mq->free_list, msg_item_t, node);
ffffffffea80c834:	d100c275 	sub	x21, x19, #0x30
	if (item == NULL) {
ffffffffea80c838:	540006c0 	b.eq	ffffffffea80c910 <msg_write_locked+0x108>  // b.none
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80c83c:	b9400023 	ldr	w3, [x1]
ffffffffea80c840:	aa0103e2 	mov	x2, x1
	return mq->buf + item->id * mq->item_sz;
ffffffffea80c844:	f9402284 	ldr	x4, [x20, #64]
	item->len = 0;
ffffffffea80c848:	f81f827f 	stur	xzr, [x19, #-8]
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80c84c:	7100047f 	cmp	w3, #0x1
	return mq->buf + item->id * mq->item_sz;
ffffffffea80c850:	385d0260 	ldurb	w0, [x19, #-48]
	uint8_t *buf = msg_queue_get_buf(mq, item);
ffffffffea80c854:	f9401e81 	ldr	x1, [x20, #56]
	item->num_handles = 0;
ffffffffea80c858:	b81d427f 	stur	wzr, [x19, #-44]
	return mq->buf + item->id * mq->item_sz;
ffffffffea80c85c:	d503201f 	nop
ffffffffea80c860:	9b011000 	madd	x0, x0, x1, x4
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80c864:	54000380 	b.eq	ffffffffea80c8d4 <msg_write_locked+0xcc>  // b.none
	} else if (msg->type == IPC_MSG_BUFFER_USER) {
ffffffffea80c868:	35000623 	cbnz	w3, ffffffffea80c92c <msg_write_locked+0x124>
		if (msg->user.num_handles) {
ffffffffea80c86c:	b9401043 	ldr	w3, [x2, #16]
ffffffffea80c870:	350004a3 	cbnz	w3, ffffffffea80c904 <msg_write_locked+0xfc>
		ret = user_iovec_to_membuf(buf, mq->item_sz,
ffffffffea80c874:	29410843 	ldp	w3, w2, [x2, #8]
ffffffffea80c878:	94000326 	bl	ffffffffea80d510 <user_iovec_to_membuf>
ffffffffea80c87c:	2a0003e2 	mov	w2, w0
	if (ret < 0) {
ffffffffea80c880:	b7f80380 	tbnz	x0, #63, ffffffffea80c8f0 <msg_write_locked+0xe8>
	item->next->prev = item->prev;
ffffffffea80c884:	a9430ea5 	ldp	x5, x3, [x21, #48]
	item->len = (size_t) ret;
ffffffffea80c888:	f81f8260 	stur	x0, [x19, #-8]
	item->prev = list->prev;
ffffffffea80c88c:	aa1403e1 	mov	x1, x20
	list_delete(&item->node);
ffffffffea80c890:	9100c2a0 	add	x0, x21, #0x30
	item->state = MSG_ITEM_STATE_FILLED;
ffffffffea80c894:	52800024 	mov	w4, #0x1                   	// #1
	item->next->prev = item->prev;
ffffffffea80c898:	f9000065 	str	x5, [x3]
	item->prev->next = item->next;
ffffffffea80c89c:	f9401aa5 	ldr	x5, [x21, #48]
ffffffffea80c8a0:	f90004a3 	str	x3, [x5, #8]
	item->prev = item->next = 0;
ffffffffea80c8a4:	f9001abf 	str	xzr, [x21, #48]
	item->prev = list->prev;
ffffffffea80c8a8:	f8410c23 	ldr	x3, [x1, #16]!
	item->next = list;
ffffffffea80c8ac:	a90306a3 	stp	x3, x1, [x21, #48]
	list->prev->next = item;
ffffffffea80c8b0:	f9400a81 	ldr	x1, [x20, #16]
ffffffffea80c8b4:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea80c8b8:	f9000a80 	str	x0, [x20, #16]
ffffffffea80c8bc:	381d1264 	sturb	w4, [x19, #-47]
	return item->len;
ffffffffea80c8c0:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80c8c4:	2a0203e0 	mov	w0, w2
ffffffffea80c8c8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c8cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80c8d0:	d65f03c0 	ret
		if (msg->kern.num_handles) {
ffffffffea80c8d4:	b9401843 	ldr	w3, [x2, #24]
ffffffffea80c8d8:	35000163 	cbnz	w3, ffffffffea80c904 <msg_write_locked+0xfc>
		ret = kern_iovec_to_membuf(buf, mq->item_sz,
ffffffffea80c8dc:	b9400843 	ldr	w3, [x2, #8]
ffffffffea80c8e0:	f9400842 	ldr	x2, [x2, #16]
ffffffffea80c8e4:	94000285 	bl	ffffffffea80d2f8 <kern_iovec_to_membuf>
ffffffffea80c8e8:	2a0003e2 	mov	w2, w0
	if (ret < 0) {
ffffffffea80c8ec:	b6fffcc0 	tbz	x0, #63, ffffffffea80c884 <msg_write_locked+0x7c>
ffffffffea80c8f0:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80c8f4:	2a0203e0 	mov	w0, w2
ffffffffea80c8f8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c8fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80c900:	d65f03c0 	ret
			return ERR_NOT_SUPPORTED;
ffffffffea80c904:	128002e2 	mov	w2, #0xffffffe8            	// #-24
ffffffffea80c908:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c90c:	17ffffee 	b	ffffffffea80c8c4 <msg_write_locked+0xbc>
ffffffffea80c910:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c914:	d503201f 	nop
		chan->aux_state |= IPC_CHAN_AUX_STATE_SEND_BLOCKED;
ffffffffea80c918:	b9403801 	ldr	w1, [x0, #56]
		return ERR_NOT_ENOUGH_BUFFER;
ffffffffea80c91c:	12800102 	mov	w2, #0xfffffff7            	// #-9
		chan->aux_state |= IPC_CHAN_AUX_STATE_SEND_BLOCKED;
ffffffffea80c920:	32000021 	orr	w1, w1, #0x1
ffffffffea80c924:	b9003801 	str	w1, [x0, #56]
		return ERR_NOT_ENOUGH_BUFFER;
ffffffffea80c928:	17ffffe7 	b	ffffffffea80c8c4 <msg_write_locked+0xbc>
		return ERR_INVALID_ARGS;
ffffffffea80c92c:	128000e2 	mov	w2, #0xfffffff8            	// #-8
ffffffffea80c930:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c934:	17ffffe4 	b	ffffffffea80c8c4 <msg_write_locked+0xbc>

ffffffffea80c938 <msg_read_locked>:
	if (id < mq->num_items) {
ffffffffea80c938:	b9403004 	ldr	w4, [x0, #48]
ffffffffea80c93c:	6b04003f 	cmp	w1, w4
ffffffffea80c940:	54000702 	b.cs	ffffffffea80ca20 <msg_read_locked+0xe8>  // b.hs, b.nlast
{
ffffffffea80c944:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80c948:	910003fd 	mov	x29, sp
ffffffffea80c94c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80c950:	2a0103f3 	mov	w19, w1
ffffffffea80c954:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80c958:	aa0003f4 	mov	x20, x0
ffffffffea80c95c:	2a0203f6 	mov	w22, w2
ffffffffea80c960:	aa0303f5 	mov	x21, x3
		platform_arch_speculation_barrier();
ffffffffea80c964:	97ffd633 	bl	ffffffffea802230 <platform_arch_speculation_barrier>
		return &mq->items[id];
ffffffffea80c968:	2a1303e1 	mov	w1, w19
ffffffffea80c96c:	8b011a80 	add	x0, x20, x1, lsl #6
ffffffffea80c970:	d37ae421 	lsl	x1, x1, #6
ffffffffea80c974:	91012021 	add	x1, x1, #0x48
	if (item->state != MSG_ITEM_STATE_READ) {
ffffffffea80c978:	39412402 	ldrb	w2, [x0, #73]
ffffffffea80c97c:	7100085f 	cmp	w2, #0x2
ffffffffea80c980:	54000421 	b.ne	ffffffffea80ca04 <msg_read_locked+0xcc>  // b.any
	if (item->num_handles) {
ffffffffea80c984:	b9404c02 	ldr	w2, [x0, #76]
ffffffffea80c988:	35000482 	cbnz	w2, ffffffffea80ca18 <msg_read_locked+0xe0>
	if (offset > item->len) {
ffffffffea80c98c:	f9403803 	ldr	x3, [x0, #112]
ffffffffea80c990:	2a1603e0 	mov	w0, w22
ffffffffea80c994:	eb03001f 	cmp	x0, x3
ffffffffea80c998:	54000368 	b.hi	ffffffffea80ca04 <msg_read_locked+0xcc>  // b.pmore
	const uint8_t *buf = msg_queue_get_buf(mq, item) + offset;
ffffffffea80c99c:	a9438a85 	ldp	x5, x2, [x20, #56]
	size_t bytes_left = item->len - offset;
ffffffffea80c9a0:	cb000063 	sub	x3, x3, x0
	return mq->buf + item->id * mq->item_sz;
ffffffffea80c9a4:	38616a81 	ldrb	w1, [x20, x1]
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80c9a8:	b94002a4 	ldr	w4, [x21]
ffffffffea80c9ac:	7100049f 	cmp	w4, #0x1
	const uint8_t *buf = msg_queue_get_buf(mq, item) + offset;
ffffffffea80c9b0:	9b050020 	madd	x0, x1, x5, x0
ffffffffea80c9b4:	8b000042 	add	x2, x2, x0
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80c9b8:	54000140 	b.eq	ffffffffea80c9e0 <msg_read_locked+0xa8>  // b.none
	} else if (msg->type == IPC_MSG_BUFFER_USER) {
ffffffffea80c9bc:	35000244 	cbnz	w4, ffffffffea80ca04 <msg_read_locked+0xcc>
		if (msg->user.num_handles) {
ffffffffea80c9c0:	b94012a0 	ldr	w0, [x21, #16]
ffffffffea80c9c4:	350002a0 	cbnz	w0, ffffffffea80ca18 <msg_read_locked+0xe0>
		return membuf_to_user_iovec(msg->user.iov, msg->user.num_iov,
ffffffffea80c9c8:	294102a1 	ldp	w1, w0, [x21, #8]
ffffffffea80c9cc:	94000291 	bl	ffffffffea80d410 <membuf_to_user_iovec>
}
ffffffffea80c9d0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c9d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80c9d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80c9dc:	d65f03c0 	ret
		if (msg->kern.num_handles) {
ffffffffea80c9e0:	b9401aa0 	ldr	w0, [x21, #24]
ffffffffea80c9e4:	350001a0 	cbnz	w0, ffffffffea80ca18 <msg_read_locked+0xe0>
		return membuf_to_kern_iovec((const iovec_kern_t *)msg->kern.iov,
ffffffffea80c9e8:	b9400aa1 	ldr	w1, [x21, #8]
ffffffffea80c9ec:	f9400aa0 	ldr	x0, [x21, #16]
ffffffffea80c9f0:	940001fc 	bl	ffffffffea80d1e0 <membuf_to_kern_iovec>
}
ffffffffea80c9f4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c9f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80c9fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ca00:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80ca04:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80ca08:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ca0c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ca10:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ca14:	d65f03c0 	ret
		return ERR_NOT_SUPPORTED;
ffffffffea80ca18:	128002e0 	mov	w0, #0xffffffe8            	// #-24
ffffffffea80ca1c:	17ffffed 	b	ffffffffea80c9d0 <msg_read_locked+0x98>
		return ERR_INVALID_ARGS;
ffffffffea80ca20:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80ca24:	d65f03c0 	ret

ffffffffea80ca28 <ipc_msg_queue_create>:
{
ffffffffea80ca28:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80ca2c:	910003fd 	mov	x29, sp
ffffffffea80ca30:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea80ca34:	2a0003f7 	mov	w23, w0
ffffffffea80ca38:	aa0103f6 	mov	x22, x1
ffffffffea80ca3c:	f9000ff4 	str	x20, [sp, #24]
	tmp_mq = calloc(1, (sizeof(ipc_msg_queue_t) +
ffffffffea80ca40:	d37a7ee1 	ubfiz	x1, x23, #6, #32
ffffffffea80ca44:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80ca48:	91012021 	add	x1, x1, #0x48
{
ffffffffea80ca4c:	aa0203f4 	mov	x20, x2
	tmp_mq = calloc(1, (sizeof(ipc_msg_queue_t) +
ffffffffea80ca50:	94001a26 	bl	ffffffffea8132e8 <calloc>
	if (!tmp_mq) {
ffffffffea80ca54:	b4000560 	cbz	x0, ffffffffea80cb00 <ipc_msg_queue_create+0xd8>
ffffffffea80ca58:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80ca5c:	aa0003f3 	mov	x19, x0
	tmp_mq->buf = malloc(num_items * item_sz);
ffffffffea80ca60:	9b167ee0 	mul	x0, x23, x22
ffffffffea80ca64:	94001a1b 	bl	ffffffffea8132d0 <malloc>
ffffffffea80ca68:	f9002260 	str	x0, [x19, #64]
	if (!tmp_mq->buf) {
ffffffffea80ca6c:	b4000540 	cbz	x0, ffffffffea80cb14 <ipc_msg_queue_create+0xec>
ffffffffea80ca70:	f90013b5 	str	x21, [x29, #32]
	list_initialize(&tmp_mq->filled_list);
ffffffffea80ca74:	91004261 	add	x1, x19, #0x10
	list_initialize(&tmp_mq->read_list);
ffffffffea80ca78:	91008260 	add	x0, x19, #0x20
	list->prev = list->next = list;
ffffffffea80ca7c:	a9004e73 	stp	x19, x19, [x19]
ffffffffea80ca80:	a9010661 	stp	x1, x1, [x19, #16]
ffffffffea80ca84:	aa1703f5 	mov	x21, x23
ffffffffea80ca88:	a9020260 	stp	x0, x0, [x19, #32]
	tmp_mq->num_items = num_items;
ffffffffea80ca8c:	b9003277 	str	w23, [x19, #48]
	tmp_mq->item_sz = item_sz;
ffffffffea80ca90:	f9001e76 	str	x22, [x19, #56]
	for (uint i = 0; i < num_items; i++) {
ffffffffea80ca94:	34000277 	cbz	w23, ffffffffea80cae0 <ipc_msg_queue_create+0xb8>
ffffffffea80ca98:	9101e260 	add	x0, x19, #0x78
ffffffffea80ca9c:	aa1303e2 	mov	x2, x19
ffffffffea80caa0:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea80caa4:	14000002 	b	ffffffffea80caac <ipc_msg_queue_create+0x84>
ffffffffea80caa8:	2a0403e3 	mov	w3, w4
		tmp_mq->items[i].id = i;
ffffffffea80caac:	381d0003 	sturb	w3, [x0, #-48]
	for (uint i = 0; i < num_items; i++) {
ffffffffea80cab0:	11000464 	add	w4, w3, #0x1
	item->next = list;
ffffffffea80cab4:	a9004c02 	stp	x2, x19, [x0]
ffffffffea80cab8:	6b0402bf 	cmp	w21, w4
	list->prev->next = item;
ffffffffea80cabc:	f9000440 	str	x0, [x2, #8]
ffffffffea80cac0:	aa0003e2 	mov	x2, x0
ffffffffea80cac4:	91010000 	add	x0, x0, #0x40
ffffffffea80cac8:	54ffff01 	b.ne	ffffffffea80caa8 <ipc_msg_queue_create+0x80>  // b.any
ffffffffea80cacc:	d37a7c60 	ubfiz	x0, x3, #6, #32
ffffffffea80cad0:	9101e000 	add	x0, x0, #0x78
ffffffffea80cad4:	8b000260 	add	x0, x19, x0
ffffffffea80cad8:	f9000260 	str	x0, [x19]
ffffffffea80cadc:	d503201f 	nop
	return 0;
ffffffffea80cae0:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80cae4:	52800000 	mov	w0, #0x0                   	// #0
	*mq = tmp_mq;
ffffffffea80cae8:	f9000293 	str	x19, [x20]
	return 0;
ffffffffea80caec:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea80caf0:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80caf4:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80caf8:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80cafc:	d65f03c0 	ret
		dprintf(CRITICAL, "cannot allocate memory for message queue\n");
ffffffffea80cb00:	f0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80cb04:	9116a000 	add	x0, x0, #0x5a8
ffffffffea80cb08:	940013e6 	bl	ffffffffea811aa0 <_dprintf>
		return ERR_NO_MEMORY;
ffffffffea80cb0c:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea80cb10:	17fffff8 	b	ffffffffea80caf0 <ipc_msg_queue_create+0xc8>
		dprintf(CRITICAL,
ffffffffea80cb14:	f0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80cb18:	91176000 	add	x0, x0, #0x5d8
ffffffffea80cb1c:	940013e1 	bl	ffffffffea811aa0 <_dprintf>
	free(tmp_mq);
ffffffffea80cb20:	aa1303e0 	mov	x0, x19
ffffffffea80cb24:	94001a01 	bl	ffffffffea813328 <free>
	return ret;
ffffffffea80cb28:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea80cb2c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80cb30:	17fffff0 	b	ffffffffea80caf0 <ipc_msg_queue_create+0xc8>
ffffffffea80cb34:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80cb38 <ipc_msg_queue_destroy>:
{
ffffffffea80cb38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80cb3c:	910003fd 	mov	x29, sp
ffffffffea80cb40:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80cb44:	aa0003f3 	mov	x19, x0
	free(mq->buf);
ffffffffea80cb48:	f9402000 	ldr	x0, [x0, #64]
ffffffffea80cb4c:	940019f7 	bl	ffffffffea813328 <free>
	free(mq);
ffffffffea80cb50:	aa1303e0 	mov	x0, x19
}
ffffffffea80cb54:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cb58:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(mq);
ffffffffea80cb5c:	140019f3 	b	ffffffffea813328 <free>

ffffffffea80cb60 <ipc_msg_queue_is_empty>:
	return list_is_empty(&mq->filled_list);
ffffffffea80cb60:	91004001 	add	x1, x0, #0x10
	return (list->next == list) ? true : false;
ffffffffea80cb64:	f9400c00 	ldr	x0, [x0, #24]
ffffffffea80cb68:	eb01001f 	cmp	x0, x1
}
ffffffffea80cb6c:	1a9f17e0 	cset	w0, eq  // eq = none
ffffffffea80cb70:	d65f03c0 	ret
ffffffffea80cb74:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80cb78 <sys_send_msg>:
	return NO_ERROR;
}


long __SYSCALL sys_send_msg(uint32_t handle_id, user_addr_t user_msg)
{
ffffffffea80cb78:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	return arch_copy_from_user(kdest, usrc, len);
ffffffffea80cb7c:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80cb80:	910003fd 	mov	x29, sp
ffffffffea80cb84:	a90153f3 	stp	x19, x20, [sp, #16]
	handle_t  *chandle;
	msg_desc_t tmp_msg;
	int ret;

	/* copy message descriptor from user space */
	tmp_msg.type = IPC_MSG_BUFFER_USER;
ffffffffea80cb88:	910183b4 	add	x20, x29, #0x60
{
ffffffffea80cb8c:	2a0003f3 	mov	w19, w0
	tmp_msg.type = IPC_MSG_BUFFER_USER;
ffffffffea80cb90:	b81d8e9f 	str	wzr, [x20, #-40]!
ffffffffea80cb94:	91002280 	add	x0, x20, #0x8
ffffffffea80cb98:	94001b68 	bl	ffffffffea813938 <arch_copy_from_user>
	ret = copy_from_user(&tmp_msg.user, user_msg, sizeof(ipc_msg_user_t));
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80cb9c:	350004a0 	cbnz	w0, ffffffffea80cc30 <sys_send_msg+0xb8>
		return (long) ret;
	}
	/* grab handle */
	ret = uctx_handle_get(current_uctx(), handle_id, &chandle);
ffffffffea80cba0:	97fff750 	bl	ffffffffea80a8e0 <current_uctx>
ffffffffea80cba4:	9100c3a2 	add	x2, x29, #0x30
ffffffffea80cba8:	2a1303e1 	mov	w1, w19
ffffffffea80cbac:	97fff7d3 	bl	ffffffffea80aaf8 <uctx_handle_get>
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80cbb0:	35000400 	cbnz	w0, ffffffffea80cc30 <sys_send_msg+0xb8>
ffffffffea80cbb4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80cbb8:	f90013b5 	str	x21, [x29, #32]
ffffffffea80cbbc:	b0000075 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea80cbc0:	9136e2a0 	add	x0, x21, #0xdb8
ffffffffea80cbc4:	97ffe37d 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
		return (long) ret;
	}
	mutex_acquire(&ipc_lock);
	/* check if it is  avalid channel to call send_msg */
	ret = check_channel_connected_locked(chandle);
ffffffffea80cbc8:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80cbcc:	97fffef5 	bl	ffffffffea80c7a0 <check_channel_connected_locked>
ffffffffea80cbd0:	2a0003f3 	mov	w19, w0
	if (likely(ret == NO_ERROR)) {
ffffffffea80cbd4:	35000120 	cbnz	w0, ffffffffea80cbf8 <sys_send_msg+0x80>
ffffffffea80cbd8:	f90017b6 	str	x22, [x29, #40]
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		/* do write message to target channel  */
		ret = msg_write_locked(chan, &tmp_msg);
ffffffffea80cbdc:	aa1403e1 	mov	x1, x20
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
ffffffffea80cbe0:	f9401bb6 	ldr	x22, [x29, #48]
		ret = msg_write_locked(chan, &tmp_msg);
ffffffffea80cbe4:	d10142c0 	sub	x0, x22, #0x50
ffffffffea80cbe8:	97ffff08 	bl	ffffffffea80c808 <msg_write_locked>
ffffffffea80cbec:	2a0003f3 	mov	w19, w0
		if (ret >= 0) {
ffffffffea80cbf0:	36f80160 	tbz	w0, #31, ffffffffea80cc1c <sys_send_msg+0xa4>
ffffffffea80cbf4:	f94017b6 	ldr	x22, [x29, #40]
			/* and notify target */
			handle_notify(&chan->peer->handle);
		}
	}
	mutex_release(&ipc_lock);
ffffffffea80cbf8:	9136e2a0 	add	x0, x21, #0xdb8
ffffffffea80cbfc:	97ffe39b 	bl	ffffffffea805a68 <mutex_release>
	handle_decref(chandle);
ffffffffea80cc00:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80cc04:	97fff583 	bl	ffffffffea80a210 <handle_decref>
	return (long) ret;
ffffffffea80cc08:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80cc0c:	93407e60 	sxtw	x0, w19
}
ffffffffea80cc10:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80cc14:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80cc18:	d65f03c0 	ret
			handle_notify(&chan->peer->handle);
ffffffffea80cc1c:	f85d02c0 	ldur	x0, [x22, #-48]
ffffffffea80cc20:	91014000 	add	x0, x0, #0x50
ffffffffea80cc24:	97fff5e7 	bl	ffffffffea80a3c0 <handle_notify>
ffffffffea80cc28:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80cc2c:	17fffff3 	b	ffffffffea80cbf8 <sys_send_msg+0x80>
}
ffffffffea80cc30:	a94153f3 	ldp	x19, x20, [sp, #16]
		return (long) ret;
ffffffffea80cc34:	93407c00 	sxtw	x0, w0
}
ffffffffea80cc38:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80cc3c:	d65f03c0 	ret

ffffffffea80cc40 <ipc_send_msg>:

int ipc_send_msg(handle_t *chandle, ipc_msg_kern_t *msg)
{
ffffffffea80cc40:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80cc44:	910003fd 	mov	x29, sp
ffffffffea80cc48:	f90013f5 	str	x21, [sp, #32]
	int ret;
	msg_desc_t tmp_msg;

	if (!msg) {
ffffffffea80cc4c:	b4000461 	cbz	x1, ffffffffea80ccd8 <ipc_send_msg+0x98>
ffffffffea80cc50:	a90153b3 	stp	x19, x20, [x29, #16]
		return ERR_INVALID_ARGS;
	}
	tmp_msg.type = IPC_MSG_BUFFER_KERNEL;
ffffffffea80cc54:	910183b4 	add	x20, x29, #0x60
ffffffffea80cc58:	f90017b6 	str	x22, [x29, #40]
ffffffffea80cc5c:	aa0003f3 	mov	x19, x0
ffffffffea80cc60:	52800020 	mov	w0, #0x1                   	// #1
	memcpy(&tmp_msg.kern, msg, sizeof(ipc_msg_kern_t));
ffffffffea80cc64:	d2800402 	mov	x2, #0x20                  	// #32
	tmp_msg.type = IPC_MSG_BUFFER_KERNEL;
ffffffffea80cc68:	b81d8e80 	str	w0, [x20, #-40]!
ffffffffea80cc6c:	b0000076 	adrp	x22, ffffffffea819000 <_mem_phys_base>
	memcpy(&tmp_msg.kern, msg, sizeof(ipc_msg_kern_t));
ffffffffea80cc70:	91002280 	add	x0, x20, #0x8
ffffffffea80cc74:	940019af 	bl	ffffffffea813330 <memcpy>
ffffffffea80cc78:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80cc7c:	9136e2c0 	add	x0, x22, #0xdb8
ffffffffea80cc80:	97ffe34e 	bl	ffffffffea8059b8 <mutex_acquire_timeout>

	mutex_acquire(&ipc_lock);
	ret = check_channel_connected_locked(chandle);
ffffffffea80cc84:	aa1303e0 	mov	x0, x19
ffffffffea80cc88:	97fffec6 	bl	ffffffffea80c7a0 <check_channel_connected_locked>
ffffffffea80cc8c:	2a0003f5 	mov	w21, w0
	if (likely(ret == NO_ERROR)) {
ffffffffea80cc90:	350000c0 	cbnz	w0, ffffffffea80cca8 <ipc_send_msg+0x68>
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		ret = msg_write_locked(chan, &tmp_msg);
ffffffffea80cc94:	aa1403e1 	mov	x1, x20
ffffffffea80cc98:	d1014260 	sub	x0, x19, #0x50
ffffffffea80cc9c:	97fffedb 	bl	ffffffffea80c808 <msg_write_locked>
ffffffffea80cca0:	2a0003f5 	mov	w21, w0
		if (ret >= 0) {
ffffffffea80cca4:	36f80120 	tbz	w0, #31, ffffffffea80ccc8 <ipc_send_msg+0x88>
			handle_notify(&chan->peer->handle);
		}
	}
	mutex_release(&ipc_lock);
ffffffffea80cca8:	9136e2c0 	add	x0, x22, #0xdb8
ffffffffea80ccac:	97ffe36f 	bl	ffffffffea805a68 <mutex_release>
	return ret;
ffffffffea80ccb0:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80ccb4:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea80ccb8:	2a1503e0 	mov	w0, w21
ffffffffea80ccbc:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ccc0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80ccc4:	d65f03c0 	ret
			handle_notify(&chan->peer->handle);
ffffffffea80ccc8:	f85d0260 	ldur	x0, [x19, #-48]
ffffffffea80cccc:	91014000 	add	x0, x0, #0x50
ffffffffea80ccd0:	97fff5bc 	bl	ffffffffea80a3c0 <handle_notify>
ffffffffea80ccd4:	17fffff5 	b	ffffffffea80cca8 <ipc_send_msg+0x68>
		return ERR_INVALID_ARGS;
ffffffffea80ccd8:	128000f5 	mov	w21, #0xfffffff8            	// #-8
ffffffffea80ccdc:	17fffff7 	b	ffffffffea80ccb8 <ipc_send_msg+0x78>

ffffffffea80cce0 <sys_get_msg>:

long __SYSCALL sys_get_msg(uint32_t handle_id, user_addr_t user_msg_info)
{
ffffffffea80cce0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80cce4:	910003fd 	mov	x29, sp
ffffffffea80cce8:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80ccec:	2a0003f3 	mov	w19, w0
ffffffffea80ccf0:	f90013f5 	str	x21, [sp, #32]
ffffffffea80ccf4:	2a0103f5 	mov	w21, w1
	handle_t *chandle;
	ipc_msg_info_t msg_info;
	int ret;

	/* grab handle */
	ret = uctx_handle_get(current_uctx(), handle_id, &chandle);
ffffffffea80ccf8:	97fff6fa 	bl	ffffffffea80a8e0 <current_uctx>
ffffffffea80ccfc:	2a1303e1 	mov	w1, w19
ffffffffea80cd00:	9100c3a2 	add	x2, x29, #0x30
ffffffffea80cd04:	97fff77d 	bl	ffffffffea80aaf8 <uctx_handle_get>
	if (ret != NO_ERROR) {
		return (long) ret;
ffffffffea80cd08:	93407c13 	sxtw	x19, w0
	if (ret != NO_ERROR) {
ffffffffea80cd0c:	340000c0 	cbz	w0, ffffffffea80cd24 <sys_get_msg+0x44>
		}
	}
	mutex_release(&ipc_lock);
	handle_decref(chandle);
	return (long) ret;
}
ffffffffea80cd10:	aa1303e0 	mov	x0, x19
ffffffffea80cd14:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cd18:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80cd1c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80cd20:	d65f03c0 	ret
ffffffffea80cd24:	f90017b6 	str	x22, [x29, #40]
ffffffffea80cd28:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80cd2c:	b0000076 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea80cd30:	9136e2c0 	add	x0, x22, #0xdb8
ffffffffea80cd34:	97ffe321 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	ret = check_channel_locked(chandle);
ffffffffea80cd38:	f9401ba0 	ldr	x0, [x29, #48]
	if (unlikely(!chandle)) {
ffffffffea80cd3c:	b4000520 	cbz	x0, ffffffffea80cde0 <sys_get_msg+0x100>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80cd40:	97fffb46 	bl	ffffffffea80ba58 <ipc_is_channel>
ffffffffea80cd44:	72001c1f 	tst	w0, #0xff
ffffffffea80cd48:	540004c0 	b.eq	ffffffffea80cde0 <sys_get_msg+0x100>  // b.none
ffffffffea80cd4c:	f9000fb4 	str	x20, [x29, #24]
	item = list_peek_head_type(&mq->filled_list, msg_item_t, node);
ffffffffea80cd50:	92800073 	mov	x19, #0xfffffffffffffffc    	// #-4
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
ffffffffea80cd54:	f9401bb4 	ldr	x20, [x29, #48]
ffffffffea80cd58:	d1014294 	sub	x20, x20, #0x50
		ret = msg_peek_next_filled_locked(chan->msg_queue, &msg_info);
ffffffffea80cd5c:	f9405a80 	ldr	x0, [x20, #176]
	item = list_peek_head_type(&mq->filled_list, msg_item_t, node);
ffffffffea80cd60:	91004001 	add	x1, x0, #0x10
	if (list->next != list) {
ffffffffea80cd64:	f9400c03 	ldr	x3, [x0, #24]
ffffffffea80cd68:	f100007f 	cmp	x3, #0x0
ffffffffea80cd6c:	fa431024 	ccmp	x1, x3, #0x4, ne  // ne = any
ffffffffea80cd70:	54000181 	b.ne	ffffffffea80cda0 <sys_get_msg+0xc0>  // b.any
ffffffffea80cd74:	f9400fb4 	ldr	x20, [x29, #24]
	mutex_release(&ipc_lock);
ffffffffea80cd78:	9136e2c0 	add	x0, x22, #0xdb8
ffffffffea80cd7c:	97ffe33b 	bl	ffffffffea805a68 <mutex_release>
	handle_decref(chandle);
ffffffffea80cd80:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80cd84:	97fff523 	bl	ffffffffea80a210 <handle_decref>
ffffffffea80cd88:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea80cd8c:	aa1303e0 	mov	x0, x19
ffffffffea80cd90:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cd94:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80cd98:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80cd9c:	d65f03c0 	ret
	if (!item) {
ffffffffea80cda0:	f100c07f 	cmp	x3, #0x30
ffffffffea80cda4:	54fffe80 	b.eq	ffffffffea80cd74 <sys_get_msg+0x94>  // b.none
	info->len = item->len;
ffffffffea80cda8:	f85f8060 	ldur	x0, [x3, #-8]
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea80cdac:	d2800102 	mov	x2, #0x8                   	// #8
ffffffffea80cdb0:	b9003ba0 	str	w0, [x29, #56]
ffffffffea80cdb4:	9100e3a1 	add	x1, x29, #0x38
ffffffffea80cdb8:	2a1503e0 	mov	w0, w21
	info->id  = item->id;
ffffffffea80cdbc:	385d0063 	ldurb	w3, [x3, #-48]
ffffffffea80cdc0:	b9003fa3 	str	w3, [x29, #60]
ffffffffea80cdc4:	94001ad5 	bl	ffffffffea813918 <arch_copy_to_user>
			if (likely(ret == NO_ERROR)) {
ffffffffea80cdc8:	35000100 	cbnz	w0, ffffffffea80cde8 <sys_get_msg+0x108>
				msg_get_filled_locked(chan->msg_queue);
ffffffffea80cdcc:	f9405a80 	ldr	x0, [x20, #176]
ffffffffea80cdd0:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea80cdd4:	97fffe5d 	bl	ffffffffea80c748 <msg_get_filled_locked>
ffffffffea80cdd8:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80cddc:	17ffffe7 	b	ffffffffea80cd78 <sys_get_msg+0x98>
	if (!item) {
ffffffffea80cde0:	928000f3 	mov	x19, #0xfffffffffffffff8    	// #-8
ffffffffea80cde4:	17ffffe5 	b	ffffffffea80cd78 <sys_get_msg+0x98>
ffffffffea80cde8:	93407c13 	sxtw	x19, w0
ffffffffea80cdec:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80cdf0:	17ffffe2 	b	ffffffffea80cd78 <sys_get_msg+0x98>
ffffffffea80cdf4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80cdf8 <ipc_get_msg>:

int ipc_get_msg(handle_t *chandle, ipc_msg_info_t *msg_info)
{
ffffffffea80cdf8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80cdfc:	910003fd 	mov	x29, sp
ffffffffea80ce00:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80ce04:	aa0003f3 	mov	x19, x0
ffffffffea80ce08:	f90013f5 	str	x21, [sp, #32]
ffffffffea80ce0c:	b0000074 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea80ce10:	aa0103f5 	mov	x21, x1
ffffffffea80ce14:	9136e280 	add	x0, x20, #0xdb8
ffffffffea80ce18:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80ce1c:	97ffe2e7 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	if (unlikely(!chandle)) {
ffffffffea80ce20:	b4000453 	cbz	x19, ffffffffea80cea8 <ipc_get_msg+0xb0>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80ce24:	aa1303e0 	mov	x0, x19
ffffffffea80ce28:	97fffb0c 	bl	ffffffffea80ba58 <ipc_is_channel>
ffffffffea80ce2c:	72001c1f 	tst	w0, #0xff
ffffffffea80ce30:	540003c0 	b.eq	ffffffffea80cea8 <ipc_get_msg+0xb0>  // b.none
	/* check if channel handle */
	ret = check_channel_locked(chandle);
	if (likely(ret == NO_ERROR)) {
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		/* peek next filled message */
		ret  = msg_peek_next_filled_locked(chan->msg_queue, msg_info);
ffffffffea80ce34:	f9403260 	ldr	x0, [x19, #96]
		return ERR_NO_MSG;
ffffffffea80ce38:	12800073 	mov	w19, #0xfffffffc            	// #-4
	item = list_peek_head_type(&mq->filled_list, msg_item_t, node);
ffffffffea80ce3c:	91004002 	add	x2, x0, #0x10
ffffffffea80ce40:	f9400c01 	ldr	x1, [x0, #24]
ffffffffea80ce44:	f100003f 	cmp	x1, #0x0
ffffffffea80ce48:	fa411044 	ccmp	x2, x1, #0x4, ne  // ne = any
ffffffffea80ce4c:	54000101 	b.ne	ffffffffea80ce6c <ipc_get_msg+0x74>  // b.any
		if (likely(ret == NO_ERROR)) {
			/* and make it readable */
			msg_get_filled_locked(chan->msg_queue);
		}
	}
	mutex_release(&ipc_lock);
ffffffffea80ce50:	9136e280 	add	x0, x20, #0xdb8
ffffffffea80ce54:	97ffe305 	bl	ffffffffea805a68 <mutex_release>
	return ret;
}
ffffffffea80ce58:	2a1303e0 	mov	w0, w19
ffffffffea80ce5c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ce60:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ce64:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ce68:	d65f03c0 	ret
	if (!item) {
ffffffffea80ce6c:	f100c03f 	cmp	x1, #0x30
ffffffffea80ce70:	54ffff00 	b.eq	ffffffffea80ce50 <ipc_get_msg+0x58>  // b.none
	info->len = item->len;
ffffffffea80ce74:	f85f8022 	ldur	x2, [x1, #-8]
	return NO_ERROR;
ffffffffea80ce78:	52800013 	mov	w19, #0x0                   	// #0
	info->len = item->len;
ffffffffea80ce7c:	b90002a2 	str	w2, [x21]
	info->id  = item->id;
ffffffffea80ce80:	385d0021 	ldurb	w1, [x1, #-48]
ffffffffea80ce84:	b90006a1 	str	w1, [x21, #4]
			msg_get_filled_locked(chan->msg_queue);
ffffffffea80ce88:	97fffe30 	bl	ffffffffea80c748 <msg_get_filled_locked>
	mutex_release(&ipc_lock);
ffffffffea80ce8c:	9136e280 	add	x0, x20, #0xdb8
ffffffffea80ce90:	97ffe2f6 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea80ce94:	2a1303e0 	mov	w0, w19
ffffffffea80ce98:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ce9c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80cea0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cea4:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80cea8:	128000f3 	mov	w19, #0xfffffff8            	// #-8
	mutex_release(&ipc_lock);
ffffffffea80ceac:	9136e280 	add	x0, x20, #0xdb8
ffffffffea80ceb0:	97ffe2ee 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea80ceb4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ceb8:	2a1303e0 	mov	w0, w19
ffffffffea80cebc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80cec0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cec4:	d65f03c0 	ret

ffffffffea80cec8 <ipc_put_msg>:

	return (long) ret;
}

int ipc_put_msg(handle_t *chandle, uint32_t msg_id)
{
ffffffffea80cec8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80cecc:	910003fd 	mov	x29, sp
ffffffffea80ced0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80ced4:	2a0103f3 	mov	w19, w1
ffffffffea80ced8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80cedc:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80cee0:	aa0003f6 	mov	x22, x0
ffffffffea80cee4:	b0000075 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea80cee8:	9136e2a0 	add	x0, x21, #0xdb8
ffffffffea80ceec:	97ffe2b3 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	if (unlikely(!chandle)) {
ffffffffea80cef0:	b4000776 	cbz	x22, ffffffffea80cfdc <ipc_put_msg+0x114>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80cef4:	aa1603e0 	mov	x0, x22
ffffffffea80cef8:	97fffad8 	bl	ffffffffea80ba58 <ipc_is_channel>
ffffffffea80cefc:	72001c1f 	tst	w0, #0xff
ffffffffea80cf00:	540006e0 	b.eq	ffffffffea80cfdc <ipc_put_msg+0x114>  // b.none
ffffffffea80cf04:	f9000fb4 	str	x20, [x29, #24]
	ipc_msg_queue_t *mq = chan->msg_queue;
ffffffffea80cf08:	f94032d4 	ldr	x20, [x22, #96]
	if (id < mq->num_items) {
ffffffffea80cf0c:	b9403280 	ldr	w0, [x20, #48]
ffffffffea80cf10:	6b00027f 	cmp	w19, w0
ffffffffea80cf14:	54000622 	b.cs	ffffffffea80cfd8 <ipc_put_msg+0x110>  // b.hs, b.nlast
		platform_arch_speculation_barrier();
ffffffffea80cf18:	97ffd4c6 	bl	ffffffffea802230 <platform_arch_speculation_barrier>
ffffffffea80cf1c:	91000660 	add	x0, x19, #0x1
ffffffffea80cf20:	8b131a93 	add	x19, x20, x19, lsl #6
ffffffffea80cf24:	d37ae400 	lsl	x0, x0, #6
	if (!item || item->state != MSG_ITEM_STATE_READ) {
ffffffffea80cf28:	39412662 	ldrb	w2, [x19, #73]
		return &mq->items[id];
ffffffffea80cf2c:	91002001 	add	x1, x0, #0x8
ffffffffea80cf30:	8b010281 	add	x1, x20, x1
	if (!item || item->state != MSG_ITEM_STATE_READ) {
ffffffffea80cf34:	7100085f 	cmp	w2, #0x2
ffffffffea80cf38:	54000501 	b.ne	ffffffffea80cfd8 <ipc_put_msg+0x110>  // b.any
	item->next->prev = item->prev;
ffffffffea80cf3c:	a9430c24 	ldp	x4, x3, [x1, #48]
	list_delete(&item->node);
ffffffffea80cf40:	9100e000 	add	x0, x0, #0x38
	ipc_chan_t *peer = chan->peer;
ffffffffea80cf44:	f85d02c2 	ldur	x2, [x22, #-48]
	list_delete(&item->node);
ffffffffea80cf48:	8b000280 	add	x0, x20, x0
	return NO_ERROR;
ffffffffea80cf4c:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea80cf50:	f9000064 	str	x4, [x3]
	item->prev->next = item->next;
ffffffffea80cf54:	f9401824 	ldr	x4, [x1, #48]
ffffffffea80cf58:	f9000483 	str	x3, [x4, #8]
	item->prev = item->next = 0;
ffffffffea80cf5c:	f9001c3f 	str	xzr, [x1, #56]
	item->next = list->next;
ffffffffea80cf60:	f9400683 	ldr	x3, [x20, #8]
ffffffffea80cf64:	a9030c34 	stp	x20, x3, [x1, #48]
	list->next->prev = item;
ffffffffea80cf68:	f9400681 	ldr	x1, [x20, #8]
ffffffffea80cf6c:	f9000020 	str	x0, [x1]
	list->next = item;
ffffffffea80cf70:	f9000680 	str	x0, [x20, #8]
	item->state = MSG_ITEM_STATE_FREE;
ffffffffea80cf74:	3901267f 	strb	wzr, [x19, #73]
	if (peer && (peer->aux_state & IPC_CHAN_AUX_STATE_SEND_BLOCKED)) {
ffffffffea80cf78:	b4000062 	cbz	x2, ffffffffea80cf84 <ipc_put_msg+0xbc>
ffffffffea80cf7c:	b9403840 	ldr	w0, [x2, #56]
ffffffffea80cf80:	37000120 	tbnz	w0, #0, ffffffffea80cfa4 <ipc_put_msg+0xdc>
ffffffffea80cf84:	f9400fb4 	ldr	x20, [x29, #24]
	if (likely(ret == NO_ERROR)) {
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		/* retire message */
		ret = msg_put_read_locked(chan, msg_id);
	}
	mutex_release(&ipc_lock);
ffffffffea80cf88:	9136e2a0 	add	x0, x21, #0xdb8
ffffffffea80cf8c:	97ffe2b7 	bl	ffffffffea805a68 <mutex_release>
	return ret;
}
ffffffffea80cf90:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cf94:	2a1603e0 	mov	w0, w22
ffffffffea80cf98:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80cf9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cfa0:	d65f03c0 	ret
		peer->aux_state &= ~IPC_CHAN_AUX_STATE_SEND_BLOCKED;
ffffffffea80cfa4:	121f7801 	and	w1, w0, #0xfffffffe
		handle_notify(&peer->handle);
ffffffffea80cfa8:	91014040 	add	x0, x2, #0x50
		peer->aux_state |=  IPC_CHAN_AUX_STATE_SEND_UNBLOCKED;
ffffffffea80cfac:	321f0021 	orr	w1, w1, #0x2
ffffffffea80cfb0:	b9003841 	str	w1, [x2, #56]
		handle_notify(&peer->handle);
ffffffffea80cfb4:	97fff503 	bl	ffffffffea80a3c0 <handle_notify>
ffffffffea80cfb8:	f9400fb4 	ldr	x20, [x29, #24]
	mutex_release(&ipc_lock);
ffffffffea80cfbc:	9136e2a0 	add	x0, x21, #0xdb8
ffffffffea80cfc0:	97ffe2aa 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea80cfc4:	2a1603e0 	mov	w0, w22
ffffffffea80cfc8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cfcc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80cfd0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cfd4:	d65f03c0 	ret
ffffffffea80cfd8:	f9400fb4 	ldr	x20, [x29, #24]
		return ERR_INVALID_ARGS;
ffffffffea80cfdc:	128000f6 	mov	w22, #0xfffffff8            	// #-8
	mutex_release(&ipc_lock);
ffffffffea80cfe0:	9136e2a0 	add	x0, x21, #0xdb8
ffffffffea80cfe4:	97ffe2a1 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea80cfe8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cfec:	2a1603e0 	mov	w0, w22
ffffffffea80cff0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80cff4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cff8:	d65f03c0 	ret
ffffffffea80cffc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d000 <sys_put_msg>:
{
ffffffffea80d000:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80d004:	910003fd 	mov	x29, sp
ffffffffea80d008:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d00c:	2a0003f3 	mov	w19, w0
ffffffffea80d010:	2a0103f4 	mov	w20, w1
	int ret = uctx_handle_get(current_uctx(), handle_id, &chandle);
ffffffffea80d014:	97fff633 	bl	ffffffffea80a8e0 <current_uctx>
ffffffffea80d018:	9100a3a2 	add	x2, x29, #0x28
ffffffffea80d01c:	2a1303e1 	mov	w1, w19
ffffffffea80d020:	97fff6b6 	bl	ffffffffea80aaf8 <uctx_handle_get>
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80d024:	35000160 	cbnz	w0, ffffffffea80d050 <sys_put_msg+0x50>
	ret = ipc_put_msg(chandle, msg_id);
ffffffffea80d028:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80d02c:	2a1403e1 	mov	w1, w20
ffffffffea80d030:	97ffffa6 	bl	ffffffffea80cec8 <ipc_put_msg>
ffffffffea80d034:	2a0003f3 	mov	w19, w0
	handle_decref(chandle);
ffffffffea80d038:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80d03c:	97fff475 	bl	ffffffffea80a210 <handle_decref>
	return (long) ret;
ffffffffea80d040:	93407e60 	sxtw	x0, w19
}
ffffffffea80d044:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d048:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80d04c:	d65f03c0 	ret
ffffffffea80d050:	a94153f3 	ldp	x19, x20, [sp, #16]
		return (long) ret;
ffffffffea80d054:	93407c00 	sxtw	x0, w0
}
ffffffffea80d058:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80d05c:	d65f03c0 	ret

ffffffffea80d060 <sys_read_msg>:


long __SYSCALL sys_read_msg(uint32_t handle_id, uint32_t msg_id, uint32_t offset,
                            user_addr_t user_msg)
{
ffffffffea80d060:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80d064:	910003fd 	mov	x29, sp
ffffffffea80d068:	a90153f3 	stp	x19, x20, [sp, #16]
	handle_t  *chandle;
	msg_desc_t tmp_msg;
	int ret;

	/* get msg descriptor form user space */
	tmp_msg.type = IPC_MSG_BUFFER_USER;
ffffffffea80d06c:	910183b3 	add	x19, x29, #0x60
{
ffffffffea80d070:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80d074:	2a0003f4 	mov	w20, w0
ffffffffea80d078:	2a0103f5 	mov	w21, w1
ffffffffea80d07c:	2a0203f6 	mov	w22, w2
	tmp_msg.type = IPC_MSG_BUFFER_USER;
ffffffffea80d080:	b81d8e7f 	str	wzr, [x19, #-40]!
	return arch_copy_from_user(kdest, usrc, len);
ffffffffea80d084:	2a0303e1 	mov	w1, w3
ffffffffea80d088:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80d08c:	91002260 	add	x0, x19, #0x8
ffffffffea80d090:	94001a2a 	bl	ffffffffea813938 <arch_copy_from_user>
	ret = copy_from_user(&tmp_msg.user, user_msg, sizeof(ipc_msg_user_t));
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80d094:	350003e0 	cbnz	w0, ffffffffea80d110 <sys_read_msg+0xb0>
		return (long) ret;
	}
	/* grab handle */
	ret = uctx_handle_get(current_uctx(), handle_id, &chandle);
ffffffffea80d098:	97fff612 	bl	ffffffffea80a8e0 <current_uctx>
ffffffffea80d09c:	9100c3a2 	add	x2, x29, #0x30
ffffffffea80d0a0:	2a1403e1 	mov	w1, w20
ffffffffea80d0a4:	97fff695 	bl	ffffffffea80aaf8 <uctx_handle_get>
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80d0a8:	35000340 	cbnz	w0, ffffffffea80d110 <sys_read_msg+0xb0>
ffffffffea80d0ac:	90000074 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea80d0b0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80d0b4:	9136e280 	add	x0, x20, #0xdb8
ffffffffea80d0b8:	97ffe240 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
		return (long) ret;
	}
	mutex_acquire(&ipc_lock);
	/* check if channel handle is a valid one */
	ret = check_channel_locked (chandle);
ffffffffea80d0bc:	f9401ba0 	ldr	x0, [x29, #48]
	if (unlikely(!chandle)) {
ffffffffea80d0c0:	b4000340 	cbz	x0, ffffffffea80d128 <sys_read_msg+0xc8>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80d0c4:	97fffa65 	bl	ffffffffea80ba58 <ipc_is_channel>
ffffffffea80d0c8:	72001c1f 	tst	w0, #0xff
ffffffffea80d0cc:	540002e0 	b.eq	ffffffffea80d128 <sys_read_msg+0xc8>  // b.none
	if (ret == NO_ERROR) {
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		/* read message content */
		ret = msg_read_locked(chan->msg_queue, msg_id,
ffffffffea80d0d0:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80d0d4:	aa1303e3 	mov	x3, x19
ffffffffea80d0d8:	2a1603e2 	mov	w2, w22
ffffffffea80d0dc:	2a1503e1 	mov	w1, w21
ffffffffea80d0e0:	f9403000 	ldr	x0, [x0, #96]
ffffffffea80d0e4:	97fffe15 	bl	ffffffffea80c938 <msg_read_locked>
ffffffffea80d0e8:	93407c13 	sxtw	x19, w0
		                      offset, &tmp_msg);
	}
	mutex_release(&ipc_lock);
ffffffffea80d0ec:	9136e280 	add	x0, x20, #0xdb8
ffffffffea80d0f0:	97ffe25e 	bl	ffffffffea805a68 <mutex_release>
	handle_decref(chandle);
ffffffffea80d0f4:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80d0f8:	97fff446 	bl	ffffffffea80a210 <handle_decref>

	return (long) ret;
}
ffffffffea80d0fc:	aa1303e0 	mov	x0, x19
ffffffffea80d100:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d104:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d108:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80d10c:	d65f03c0 	ret
		return (long) ret;
ffffffffea80d110:	93407c13 	sxtw	x19, w0
}
ffffffffea80d114:	aa1303e0 	mov	x0, x19
ffffffffea80d118:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d11c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d120:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80d124:	d65f03c0 	ret
{
ffffffffea80d128:	928000f3 	mov	x19, #0xfffffffffffffff8    	// #-8
ffffffffea80d12c:	17fffff0 	b	ffffffffea80d0ec <sys_read_msg+0x8c>

ffffffffea80d130 <ipc_read_msg>:

int ipc_read_msg(handle_t *chandle, uint32_t msg_id, uint32_t offset,
                 ipc_msg_kern_t *msg)
{
ffffffffea80d130:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80d134:	910003fd 	mov	x29, sp
ffffffffea80d138:	f9000bf3 	str	x19, [sp, #16]
	int ret;
	msg_desc_t tmp_msg;

	if (!msg) {
ffffffffea80d13c:	b40004c3 	cbz	x3, ffffffffea80d1d4 <ipc_read_msg+0xa4>
ffffffffea80d140:	a901d7b4 	stp	x20, x21, [x29, #24]
		return ERR_INVALID_ARGS;
	}
	tmp_msg.type = IPC_MSG_BUFFER_KERNEL;
ffffffffea80d144:	9101c3b4 	add	x20, x29, #0x70
ffffffffea80d148:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea80d14c:	aa0003f3 	mov	x19, x0
ffffffffea80d150:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80d154:	2a0203f6 	mov	w22, w2
ffffffffea80d158:	b81d8e80 	str	w0, [x20, #-40]!
	memcpy(&tmp_msg.kern, msg, sizeof(ipc_msg_kern_t));
ffffffffea80d15c:	d2800402 	mov	x2, #0x20                  	// #32
ffffffffea80d160:	2a0103f5 	mov	w21, w1
ffffffffea80d164:	aa0303e1 	mov	x1, x3
ffffffffea80d168:	91002280 	add	x0, x20, #0x8
ffffffffea80d16c:	94001871 	bl	ffffffffea813330 <memcpy>
ffffffffea80d170:	90000077 	adrp	x23, ffffffffea819000 <_mem_phys_base>
ffffffffea80d174:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80d178:	9136e2e0 	add	x0, x23, #0xdb8
ffffffffea80d17c:	97ffe20f 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	if (unlikely(!chandle)) {
ffffffffea80d180:	b4000273 	cbz	x19, ffffffffea80d1cc <ipc_read_msg+0x9c>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80d184:	aa1303e0 	mov	x0, x19
ffffffffea80d188:	97fffa34 	bl	ffffffffea80ba58 <ipc_is_channel>
ffffffffea80d18c:	72001c1f 	tst	w0, #0xff
ffffffffea80d190:	540001e0 	b.eq	ffffffffea80d1cc <ipc_read_msg+0x9c>  // b.none

	mutex_acquire(&ipc_lock);
	ret = check_channel_locked (chandle);
	if (ret == NO_ERROR) {
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		ret = msg_read_locked(chan->msg_queue, msg_id,
ffffffffea80d194:	f9403260 	ldr	x0, [x19, #96]
ffffffffea80d198:	aa1403e3 	mov	x3, x20
ffffffffea80d19c:	2a1603e2 	mov	w2, w22
ffffffffea80d1a0:	2a1503e1 	mov	w1, w21
ffffffffea80d1a4:	97fffde5 	bl	ffffffffea80c938 <msg_read_locked>
ffffffffea80d1a8:	2a0003f3 	mov	w19, w0
		                      offset, &tmp_msg);
	}
	mutex_release(&ipc_lock);
ffffffffea80d1ac:	9136e2e0 	add	x0, x23, #0xdb8
ffffffffea80d1b0:	97ffe22e 	bl	ffffffffea805a68 <mutex_release>
	return ret;
ffffffffea80d1b4:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea80d1b8:	a942dfb6 	ldp	x22, x23, [x29, #40]
}
ffffffffea80d1bc:	2a1303e0 	mov	w0, w19
ffffffffea80d1c0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80d1c4:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80d1c8:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80d1cc:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea80d1d0:	17fffff7 	b	ffffffffea80d1ac <ipc_read_msg+0x7c>
		return ERR_INVALID_ARGS;
ffffffffea80d1d4:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea80d1d8:	17fffff9 	b	ffffffffea80d1bc <ipc_read_msg+0x8c>
ffffffffea80d1dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d1e0 <membuf_to_kern_iovec>:
ssize_t membuf_to_kern_iovec(const iovec_kern_t *iov, uint iov_cnt,
                             const uint8_t *buf, size_t len)
{
	size_t copied = 0;

	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d1e0:	7100003f 	cmp	w1, #0x0
ffffffffea80d1e4:	fa401864 	ccmp	x3, #0x0, #0x4, ne  // ne = any
ffffffffea80d1e8:	54000820 	b.eq	ffffffffea80d2ec <membuf_to_kern_iovec+0x10c>  // b.none
{
ffffffffea80d1ec:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
		return 0;
	}

	if (unlikely(iov == NULL || buf == NULL)) {
ffffffffea80d1f0:	f100001f 	cmp	x0, #0x0
ffffffffea80d1f4:	fa401844 	ccmp	x2, #0x0, #0x4, ne  // ne = any
{
ffffffffea80d1f8:	910003fd 	mov	x29, sp
ffffffffea80d1fc:	f9000ff4 	str	x20, [sp, #24]
ffffffffea80d200:	aa0003f4 	mov	x20, x0
ffffffffea80d204:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80d208:	aa0203f7 	mov	x23, x2
	if (unlikely(iov == NULL || buf == NULL)) {
ffffffffea80d20c:	54000400 	b.eq	ffffffffea80d28c <membuf_to_kern_iovec+0xac>  // b.none
ffffffffea80d210:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80d214:	51000436 	sub	w22, w1, #0x1
ffffffffea80d218:	910006d6 	add	x22, x22, #0x1
ffffffffea80d21c:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80d220:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80d224:	aa0303f5 	mov	x21, x3
ffffffffea80d228:	8b161016 	add	x22, x0, x22, lsl #4
	size_t copied = 0;
ffffffffea80d22c:	d2800018 	mov	x24, #0x0                   	// #0
ffffffffea80d230:	1400000d 	b	ffffffffea80d264 <membuf_to_kern_iovec+0x84>

		size_t to_copy = len;
		if (to_copy > iov->len) {
			to_copy = iov->len;
		}
		if (unlikely(to_copy == 0)) {
ffffffffea80d234:	b4000133 	cbz	x19, ffffffffea80d258 <membuf_to_kern_iovec+0x78>
			continue;
		}
		if (unlikely(iov->base == NULL)) {
ffffffffea80d238:	f9400283 	ldr	x3, [x20]
			return (ssize_t) ERR_INVALID_ARGS;
		}
		memcpy(iov->base, buf, to_copy);

		copied += to_copy;
ffffffffea80d23c:	8b130318 	add	x24, x24, x19
		buf    += to_copy;
ffffffffea80d240:	8b1302f7 	add	x23, x23, x19
		memcpy(iov->base, buf, to_copy);
ffffffffea80d244:	aa0303e0 	mov	x0, x3
		if (unlikely(iov->base == NULL)) {
ffffffffea80d248:	b40001c3 	cbz	x3, ffffffffea80d280 <membuf_to_kern_iovec+0xa0>
		memcpy(iov->base, buf, to_copy);
ffffffffea80d24c:	94001839 	bl	ffffffffea813330 <memcpy>
		len    -= to_copy;

		if (len == 0) {
ffffffffea80d250:	eb1302b5 	subs	x21, x21, x19
ffffffffea80d254:	54000260 	b.eq	ffffffffea80d2a0 <membuf_to_kern_iovec+0xc0>  // b.none
	for (uint i = 0; i < iov_cnt; i++, iov++) {
ffffffffea80d258:	91004294 	add	x20, x20, #0x10
ffffffffea80d25c:	eb16029f 	cmp	x20, x22
ffffffffea80d260:	54000200 	b.eq	ffffffffea80d2a0 <membuf_to_kern_iovec+0xc0>  // b.none
		if (to_copy > iov->len) {
ffffffffea80d264:	f9400693 	ldr	x19, [x20, #8]
		memcpy(iov->base, buf, to_copy);
ffffffffea80d268:	aa1703e1 	mov	x1, x23
ffffffffea80d26c:	aa1303e2 	mov	x2, x19
		if (to_copy > iov->len) {
ffffffffea80d270:	eb15027f 	cmp	x19, x21
ffffffffea80d274:	54fffe03 	b.cc	ffffffffea80d234 <membuf_to_kern_iovec+0x54>  // b.lo, b.ul, b.last
		if (unlikely(iov->base == NULL)) {
ffffffffea80d278:	f9400280 	ldr	x0, [x20]
ffffffffea80d27c:	b5000220 	cbnz	x0, ffffffffea80d2c0 <membuf_to_kern_iovec+0xe0>
ffffffffea80d280:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d284:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d288:	f9401fb8 	ldr	x24, [x29, #56]
		return (ssize_t) ERR_INVALID_ARGS;
ffffffffea80d28c:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
			break;
		}
	}

	return  (ssize_t) copied;
}
ffffffffea80d290:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d294:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d298:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d29c:	d65f03c0 	ret
ffffffffea80d2a0:	aa1803e0 	mov	x0, x24
	return  (ssize_t) copied;
ffffffffea80d2a4:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d2a8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d2ac:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea80d2b0:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d2b4:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d2b8:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d2bc:	d65f03c0 	ret
		memcpy(iov->base, buf, to_copy);
ffffffffea80d2c0:	aa1503e2 	mov	x2, x21
ffffffffea80d2c4:	aa1703e1 	mov	x1, x23
ffffffffea80d2c8:	9400181a 	bl	ffffffffea813330 <memcpy>
ffffffffea80d2cc:	f9400bb3 	ldr	x19, [x29, #16]
		copied += to_copy;
ffffffffea80d2d0:	8b1802a0 	add	x0, x21, x24
}
ffffffffea80d2d4:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d2d8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d2dc:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80d2e0:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d2e4:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d2e8:	d65f03c0 	ret
		return 0;
ffffffffea80d2ec:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80d2f0:	d65f03c0 	ret
ffffffffea80d2f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d2f8 <kern_iovec_to_membuf>:
ssize_t kern_iovec_to_membuf(uint8_t *buf, size_t len,
                             const iovec_kern_t *iov, uint iov_cnt)
{
	size_t copied = 0;

	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d2f8:	7100007f 	cmp	w3, #0x0
ffffffffea80d2fc:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
ffffffffea80d300:	54000820 	b.eq	ffffffffea80d404 <kern_iovec_to_membuf+0x10c>  // b.none
{
ffffffffea80d304:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
		return 0;
	}
	if (unlikely(buf == NULL || iov == NULL)) {
ffffffffea80d308:	f100001f 	cmp	x0, #0x0
ffffffffea80d30c:	fa401844 	ccmp	x2, #0x0, #0x4, ne  // ne = any
{
ffffffffea80d310:	910003fd 	mov	x29, sp
ffffffffea80d314:	f9000ff4 	str	x20, [sp, #24]
ffffffffea80d318:	aa0203f4 	mov	x20, x2
ffffffffea80d31c:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80d320:	aa0003f7 	mov	x23, x0
	if (unlikely(buf == NULL || iov == NULL)) {
ffffffffea80d324:	54000400 	b.eq	ffffffffea80d3a4 <kern_iovec_to_membuf+0xac>  // b.none
ffffffffea80d328:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80d32c:	51000476 	sub	w22, w3, #0x1
ffffffffea80d330:	910006d6 	add	x22, x22, #0x1
ffffffffea80d334:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80d338:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80d33c:	aa0103f5 	mov	x21, x1
ffffffffea80d340:	8b161056 	add	x22, x2, x22, lsl #4
	size_t copied = 0;
ffffffffea80d344:	d2800018 	mov	x24, #0x0                   	// #0
ffffffffea80d348:	1400000d 	b	ffffffffea80d37c <kern_iovec_to_membuf+0x84>

		size_t to_copy = len;
		if (to_copy > iov->len) {
			to_copy = iov->len;
		}
		if (unlikely(to_copy == 0)) {
ffffffffea80d34c:	b4000133 	cbz	x19, ffffffffea80d370 <kern_iovec_to_membuf+0x78>
			continue;
		}
		if (unlikely(iov->base == NULL)) {
ffffffffea80d350:	f9400283 	ldr	x3, [x20]
			return (ssize_t) ERR_INVALID_ARGS;
		}
		memcpy (buf, iov->base, to_copy);

		copied += to_copy;
ffffffffea80d354:	8b130318 	add	x24, x24, x19
		buf    += to_copy;
ffffffffea80d358:	8b1302f7 	add	x23, x23, x19
		memcpy (buf, iov->base, to_copy);
ffffffffea80d35c:	aa0303e1 	mov	x1, x3
		if (unlikely(iov->base == NULL)) {
ffffffffea80d360:	b40001c3 	cbz	x3, ffffffffea80d398 <kern_iovec_to_membuf+0xa0>
		memcpy (buf, iov->base, to_copy);
ffffffffea80d364:	940017f3 	bl	ffffffffea813330 <memcpy>
		len    -= to_copy;

		if (len == 0) {
ffffffffea80d368:	eb1302b5 	subs	x21, x21, x19
ffffffffea80d36c:	54000260 	b.eq	ffffffffea80d3b8 <kern_iovec_to_membuf+0xc0>  // b.none
	for (uint i = 0; i < iov_cnt; i++, iov++) {
ffffffffea80d370:	91004294 	add	x20, x20, #0x10
ffffffffea80d374:	eb16029f 	cmp	x20, x22
ffffffffea80d378:	54000200 	b.eq	ffffffffea80d3b8 <kern_iovec_to_membuf+0xc0>  // b.none
		if (to_copy > iov->len) {
ffffffffea80d37c:	f9400693 	ldr	x19, [x20, #8]
		memcpy (buf, iov->base, to_copy);
ffffffffea80d380:	aa1703e0 	mov	x0, x23
ffffffffea80d384:	aa1303e2 	mov	x2, x19
		if (to_copy > iov->len) {
ffffffffea80d388:	eb15027f 	cmp	x19, x21
ffffffffea80d38c:	54fffe03 	b.cc	ffffffffea80d34c <kern_iovec_to_membuf+0x54>  // b.lo, b.ul, b.last
		if (unlikely(iov->base == NULL)) {
ffffffffea80d390:	f9400281 	ldr	x1, [x20]
ffffffffea80d394:	b5000221 	cbnz	x1, ffffffffea80d3d8 <kern_iovec_to_membuf+0xe0>
ffffffffea80d398:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d39c:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d3a0:	f9401fb8 	ldr	x24, [x29, #56]
		return (ssize_t) ERR_INVALID_ARGS;
ffffffffea80d3a4:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
			break;
		}
	}

	return (ssize_t) copied;
}
ffffffffea80d3a8:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d3ac:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d3b0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d3b4:	d65f03c0 	ret
ffffffffea80d3b8:	aa1803e0 	mov	x0, x24
	return (ssize_t) copied;
ffffffffea80d3bc:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d3c0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d3c4:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea80d3c8:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d3cc:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d3d0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d3d4:	d65f03c0 	ret
		memcpy (buf, iov->base, to_copy);
ffffffffea80d3d8:	aa1503e2 	mov	x2, x21
ffffffffea80d3dc:	aa1703e0 	mov	x0, x23
ffffffffea80d3e0:	940017d4 	bl	ffffffffea813330 <memcpy>
ffffffffea80d3e4:	f9400bb3 	ldr	x19, [x29, #16]
		copied += to_copy;
ffffffffea80d3e8:	8b1802a0 	add	x0, x21, x24
}
ffffffffea80d3ec:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d3f0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d3f4:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80d3f8:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d3fc:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d400:	d65f03c0 	ret
		return 0;
ffffffffea80d404:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80d408:	d65f03c0 	ret
ffffffffea80d40c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d410 <membuf_to_user_iovec>:
{
	status_t ret;
	size_t copied = 0;
	iovec_user_t uiov;

	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d410:	7100003f 	cmp	w1, #0x0
ffffffffea80d414:	fa401864 	ccmp	x3, #0x0, #0x4, ne  // ne = any
ffffffffea80d418:	54000680 	b.eq	ffffffffea80d4e8 <membuf_to_user_iovec+0xd8>  // b.none
{
ffffffffea80d41c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80d420:	910003fd 	mov	x29, sp
ffffffffea80d424:	f90017f6 	str	x22, [sp, #40]
ffffffffea80d428:	aa0203f6 	mov	x22, x2
		return 0;
	}
	if (unlikely(buf == NULL)) {
ffffffffea80d42c:	b40006e2 	cbz	x2, ffffffffea80d508 <membuf_to_user_iovec+0xf8>
ffffffffea80d430:	51000421 	sub	w1, w1, #0x1
ffffffffea80d434:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80d438:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80d43c:	aa0303f4 	mov	x20, x3
ffffffffea80d440:	2a0003f8 	mov	w24, w0
ffffffffea80d444:	91000437 	add	x23, x1, #0x1
ffffffffea80d448:	f90013b5 	str	x21, [x29, #32]
ffffffffea80d44c:	d2800015 	mov	x21, #0x0                   	// #0
ffffffffea80d450:	f90023b9 	str	x25, [x29, #64]
	size_t copied = 0;
ffffffffea80d454:	d2800019 	mov	x25, #0x0                   	// #0
ffffffffea80d458:	0b150f01 	add	w1, w24, w21, lsl #3
ffffffffea80d45c:	d2800102 	mov	x2, #0x8                   	// #8
ffffffffea80d460:	910006b5 	add	x21, x21, #0x1
ffffffffea80d464:	910163a0 	add	x0, x29, #0x58
ffffffffea80d468:	94001934 	bl	ffffffffea813938 <arch_copy_from_user>

		/* copy user iovec from user space into local buffer */
		ret = copy_from_user(&uiov,
		                     iov_uaddr + i * sizeof(iovec_user_t),
		                     sizeof(iovec_user_t));
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d46c:	350002e0 	cbnz	w0, ffffffffea80d4c8 <membuf_to_user_iovec+0xb8>
			return (ssize_t) ret;
		}

		size_t to_copy = len;
		if (to_copy > uiov.len) {
ffffffffea80d470:	294b4fa0 	ldp	w0, w19, [x29, #88]
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea80d474:	aa1603e1 	mov	x1, x22
ffffffffea80d478:	eb13029f 	cmp	x20, x19
ffffffffea80d47c:	54000209 	b.ls	ffffffffea80d4bc <membuf_to_user_iovec+0xac>  // b.plast
ffffffffea80d480:	aa1303e2 	mov	x2, x19
		/* copy data to user space */
		ret = copy_to_user(uiov.base, buf, to_copy);
		if (unlikely(ret != NO_ERROR)) {
			return (ssize_t) ret;
		}
		copied += to_copy;
ffffffffea80d484:	8b130339 	add	x25, x25, x19
		buf    += to_copy;
ffffffffea80d488:	8b1302d6 	add	x22, x22, x19
ffffffffea80d48c:	94001923 	bl	ffffffffea813918 <arch_copy_to_user>
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d490:	350001c0 	cbnz	w0, ffffffffea80d4c8 <membuf_to_user_iovec+0xb8>
		len    -= to_copy;

		if (len == 0) {
ffffffffea80d494:	eb130294 	subs	x20, x20, x19
ffffffffea80d498:	54000060 	b.eq	ffffffffea80d4a4 <membuf_to_user_iovec+0x94>  // b.none
	for (uint i = 0; i < iov_cnt; i++) {
ffffffffea80d49c:	eb1702bf 	cmp	x21, x23
ffffffffea80d4a0:	54fffdc1 	b.ne	ffffffffea80d458 <membuf_to_user_iovec+0x48>  // b.any
ffffffffea80d4a4:	aa1903e0 	mov	x0, x25
			break;;
		}
	}

	return  (ssize_t) copied;
ffffffffea80d4a8:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d4ac:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d4b0:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d4b4:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80d4b8:	14000009 	b	ffffffffea80d4dc <membuf_to_user_iovec+0xcc>
ffffffffea80d4bc:	aa1403e2 	mov	x2, x20
ffffffffea80d4c0:	94001916 	bl	ffffffffea813918 <arch_copy_to_user>
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d4c4:	34000160 	cbz	w0, ffffffffea80d4f0 <membuf_to_user_iovec+0xe0>
			return (ssize_t) ret;
ffffffffea80d4c8:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d4cc:	93407c00 	sxtw	x0, w0
ffffffffea80d4d0:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d4d4:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d4d8:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea80d4dc:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80d4e0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80d4e4:	d65f03c0 	ret
		return 0;
ffffffffea80d4e8:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80d4ec:	d65f03c0 	ret
		copied += to_copy;
ffffffffea80d4f0:	8b190280 	add	x0, x20, x25
ffffffffea80d4f4:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d4f8:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d4fc:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d500:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80d504:	17fffff6 	b	ffffffffea80d4dc <membuf_to_user_iovec+0xcc>
		return (ssize_t) ERR_INVALID_ARGS;
ffffffffea80d508:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80d50c:	17fffff4 	b	ffffffffea80d4dc <membuf_to_user_iovec+0xcc>

ffffffffea80d510 <user_iovec_to_membuf>:
{
	status_t ret;
	size_t copied = 0;
	iovec_user_t uiov;

	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d510:	7100007f 	cmp	w3, #0x0
ffffffffea80d514:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
ffffffffea80d518:	54000680 	b.eq	ffffffffea80d5e8 <user_iovec_to_membuf+0xd8>  // b.none
{
ffffffffea80d51c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80d520:	910003fd 	mov	x29, sp
ffffffffea80d524:	f90017f6 	str	x22, [sp, #40]
ffffffffea80d528:	aa0003f6 	mov	x22, x0
		return 0;
	}
	if (unlikely(buf == NULL)) {
ffffffffea80d52c:	b40006e0 	cbz	x0, ffffffffea80d608 <user_iovec_to_membuf+0xf8>
ffffffffea80d530:	51000463 	sub	w3, w3, #0x1
ffffffffea80d534:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80d538:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80d53c:	aa0103f4 	mov	x20, x1
ffffffffea80d540:	2a0203f8 	mov	w24, w2
ffffffffea80d544:	91000477 	add	x23, x3, #0x1
ffffffffea80d548:	f90013b5 	str	x21, [x29, #32]
ffffffffea80d54c:	d2800015 	mov	x21, #0x0                   	// #0
ffffffffea80d550:	f90023b9 	str	x25, [x29, #64]
	size_t copied = 0;
ffffffffea80d554:	d2800019 	mov	x25, #0x0                   	// #0
	return arch_copy_from_user(kdest, usrc, len);
ffffffffea80d558:	0b150f01 	add	w1, w24, w21, lsl #3
ffffffffea80d55c:	d2800102 	mov	x2, #0x8                   	// #8
ffffffffea80d560:	910006b5 	add	x21, x21, #0x1
ffffffffea80d564:	910163a0 	add	x0, x29, #0x58
ffffffffea80d568:	940018f4 	bl	ffffffffea813938 <arch_copy_from_user>

		/* copy user iovec from user space into local buffer */
		ret = copy_from_user(&uiov,
		                     iov_uaddr + i * sizeof(iovec_user_t),
		                     sizeof(iovec_user_t));
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d56c:	350002e0 	cbnz	w0, ffffffffea80d5c8 <user_iovec_to_membuf+0xb8>
			return (ssize_t) ret;
		}
		size_t to_copy = len;
		if (to_copy > uiov.len) {
ffffffffea80d570:	294b4fa1 	ldp	w1, w19, [x29, #88]
ffffffffea80d574:	aa1603e0 	mov	x0, x22
ffffffffea80d578:	eb13029f 	cmp	x20, x19
ffffffffea80d57c:	54000209 	b.ls	ffffffffea80d5bc <user_iovec_to_membuf+0xac>  // b.plast
ffffffffea80d580:	aa1303e2 	mov	x2, x19
		ret = copy_from_user(buf, uiov.base, to_copy);
		if (unlikely(ret != NO_ERROR)) {
			return (ssize_t) ret;
		}

		copied += to_copy;
ffffffffea80d584:	8b130339 	add	x25, x25, x19
		buf    += to_copy;
ffffffffea80d588:	8b1302d6 	add	x22, x22, x19
ffffffffea80d58c:	940018eb 	bl	ffffffffea813938 <arch_copy_from_user>
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d590:	350001c0 	cbnz	w0, ffffffffea80d5c8 <user_iovec_to_membuf+0xb8>
		len    -= to_copy;
		if (len == 0) {
ffffffffea80d594:	eb130294 	subs	x20, x20, x19
ffffffffea80d598:	54000060 	b.eq	ffffffffea80d5a4 <user_iovec_to_membuf+0x94>  // b.none
	for (uint i = 0; i < iov_cnt; i++) {
ffffffffea80d59c:	eb1702bf 	cmp	x21, x23
ffffffffea80d5a0:	54fffdc1 	b.ne	ffffffffea80d558 <user_iovec_to_membuf+0x48>  // b.any
ffffffffea80d5a4:	aa1903e0 	mov	x0, x25
			break;;
		}
	}

	return (ssize_t) copied;
ffffffffea80d5a8:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d5ac:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d5b0:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d5b4:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80d5b8:	14000009 	b	ffffffffea80d5dc <user_iovec_to_membuf+0xcc>
ffffffffea80d5bc:	aa1403e2 	mov	x2, x20
ffffffffea80d5c0:	940018de 	bl	ffffffffea813938 <arch_copy_from_user>
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d5c4:	34000160 	cbz	w0, ffffffffea80d5f0 <user_iovec_to_membuf+0xe0>
			return (ssize_t) ret;
ffffffffea80d5c8:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d5cc:	93407c00 	sxtw	x0, w0
ffffffffea80d5d0:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d5d4:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d5d8:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea80d5dc:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80d5e0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80d5e4:	d65f03c0 	ret
		return 0;
ffffffffea80d5e8:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80d5ec:	d65f03c0 	ret
		copied += to_copy;
ffffffffea80d5f0:	8b190280 	add	x0, x20, x25
ffffffffea80d5f4:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d5f8:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d5fc:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d600:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80d604:	17fffff6 	b	ffffffffea80d5dc <user_iovec_to_membuf+0xcc>
		return (ssize_t) ERR_INVALID_ARGS;
ffffffffea80d608:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80d60c:	17fffff4 	b	ffffffffea80d5dc <user_iovec_to_membuf+0xcc>

ffffffffea80d610 <vqueue_init>:

int vqueue_init(struct vqueue *vq, uint32_t id,
		paddr_t paddr, uint num, ulong align,
		void *priv, vqueue_cb_t notify_cb, vqueue_cb_t kick_cb,
		uint32_t guest)
{
ffffffffea80d610:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
}

static inline unsigned vring_size(unsigned int num, unsigned long align)
{
	return ((sizeof(struct vring_desc) * num + sizeof(__u16) * (3 + num)
		 + align - 1) & ~(align - 1))
ffffffffea80d614:	51000488 	sub	w8, w4, #0x1
ffffffffea80d618:	910003fd 	mov	x29, sp
ffffffffea80d61c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d620:	2a0303f4 	mov	w20, w3
	return ((sizeof(struct vring_desc) * num + sizeof(__u16) * (3 + num)
ffffffffea80d624:	11000c63 	add	w3, w3, #0x3
ffffffffea80d628:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80d62c:	8b344c63 	add	x3, x3, w20, uxtw #3
ffffffffea80d630:	aa0403f5 	mov	x21, x4
		 + align - 1) & ~(align - 1))
ffffffffea80d634:	4b0403e4 	neg	w4, w4
ffffffffea80d638:	a90573fb 	stp	x27, x28, [sp, #80]
ffffffffea80d63c:	0b030503 	add	w3, w8, w3, lsl #1
ffffffffea80d640:	aa0203fc 	mov	x28, x2
ffffffffea80d644:	0a040063 	and	w3, w3, w4

	DEBUG_ASSERT(vq);

	vq->vring_sz = vring_size(num, align);
	roundedup_vring_sz = ROUNDUP(vq->vring_sz, PAGE_SIZE);
	ret = trusty_hyp_check_guest_pa_valid(paddr, roundedup_vring_sz, guest);
ffffffffea80d648:	b94083a2 	ldr	w2, [x29, #128]
		+ sizeof(__u16) * 3 + sizeof(struct vring_used_elem) * num;
ffffffffea80d64c:	0b140c63 	add	w3, w3, w20, lsl #3
{
ffffffffea80d650:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80d654:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea80d658:	2a0103f7 	mov	w23, w1
	vq->vring_sz = vring_size(num, align);
ffffffffea80d65c:	11001861 	add	w1, w3, #0x6
ffffffffea80d660:	f9001801 	str	x1, [x0, #48]
	roundedup_vring_sz = ROUNDUP(vq->vring_sz, PAGE_SIZE);
ffffffffea80d664:	913ffc21 	add	x1, x1, #0xfff
{
ffffffffea80d668:	aa0003f6 	mov	x22, x0
	roundedup_vring_sz = ROUNDUP(vq->vring_sz, PAGE_SIZE);
ffffffffea80d66c:	9274cc33 	and	x19, x1, #0xfffffffffffff000
{
ffffffffea80d670:	aa0503f8 	mov	x24, x5
ffffffffea80d674:	aa0603f9 	mov	x25, x6
ffffffffea80d678:	aa0703fa 	mov	x26, x7
	ret = trusty_hyp_check_guest_pa_valid(paddr, roundedup_vring_sz, guest);
ffffffffea80d67c:	aa1303e1 	mov	x1, x19
ffffffffea80d680:	aa1c03e0 	mov	x0, x28
	void   *vptr = NULL;
ffffffffea80d684:	f9003fbf 	str	xzr, [x29, #120]
	ret = trusty_hyp_check_guest_pa_valid(paddr, roundedup_vring_sz, guest);
ffffffffea80d688:	97ffd454 	bl	ffffffffea8027d8 <trusty_hyp_check_guest_pa_valid>
	if (ret != NO_ERROR) {
ffffffffea80d68c:	35000320 	cbnz	w0, ffffffffea80d6f0 <vqueue_init+0xe0>
ffffffffea80d690:	2a1403e8 	mov	w8, w20
		TRACEF("%s: check_guest_pa_valid failed, error = %d",
			__func__, ret);
		return ret;
	}

	ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80d694:	d0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80d698:	f90037a8 	str	x8, [x29, #104]
ffffffffea80d69c:	b0000280 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
ffffffffea80d6a0:	52800607 	mov	w7, #0x30                  	// #48
ffffffffea80d6a4:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80d6a8:	aa1c03e5 	mov	x5, x28
ffffffffea80d6ac:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea80d6b0:	9101e3a3 	add	x3, x29, #0x78
ffffffffea80d6b4:	aa1303e2 	mov	x2, x19
ffffffffea80d6b8:	911bc021 	add	x1, x1, #0x6f0
ffffffffea80d6bc:	91034000 	add	x0, x0, #0xd0
ffffffffea80d6c0:	94000f36 	bl	ffffffffea811398 <vmm_alloc_physical>
ffffffffea80d6c4:	2a0003fb 	mov	w27, w0
	                         roundedup_vring_sz,
	                         &vptr,  PAGE_SIZE_SHIFT,
	                         paddr, 0,
	                         ARCH_MMU_FLAG_NS | ARCH_MMU_FLAG_PERM_NO_EXECUTE |
	                         ARCH_MMU_FLAG_CACHED);
	if (ret != NO_ERROR) {
ffffffffea80d6c8:	f94037a8 	ldr	x8, [x29, #104]
ffffffffea80d6cc:	34000360 	cbz	w0, ffffffffea80d738 <vqueue_init+0x128>
	vq->vring_addr = (vaddr_t)vptr;

	event_init(&vq->avail_event, false, 0);

	return NO_ERROR;
}
ffffffffea80d6d0:	2a1b03e0 	mov	w0, w27
ffffffffea80d6d4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d6d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d6dc:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80d6e0:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80d6e4:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea80d6e8:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80d6ec:	d65f03c0 	ret
		TRACEF("%s: check_guest_pa_valid failed, error = %d",
ffffffffea80d6f0:	d0000045 	adrp	x5, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80d6f4:	2a0003fb 	mov	w27, w0
ffffffffea80d6f8:	2a0003e4 	mov	w4, w0
ffffffffea80d6fc:	528007c2 	mov	w2, #0x3e                  	// #62
ffffffffea80d700:	911ae0a0 	add	x0, x5, #0x6b8
ffffffffea80d704:	d0000043 	adrp	x3, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80d708:	d0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80d70c:	9118e063 	add	x3, x3, #0x638
ffffffffea80d710:	91186021 	add	x1, x1, #0x618
ffffffffea80d714:	940016c7 	bl	ffffffffea813230 <_printf>
}
ffffffffea80d718:	2a1b03e0 	mov	w0, w27
ffffffffea80d71c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d720:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d724:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80d728:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80d72c:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea80d730:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80d734:	d65f03c0 	ret
	vring_init(&vq->vring, num, vptr, align);
ffffffffea80d738:	f9403fa1 	ldr	x1, [x29, #120]
	vr->used = (void *)(((unsigned long)&vr->avail->ring[num] + sizeof(__u16)
ffffffffea80d73c:	91000900 	add	x0, x8, #0x2
		+ align-1) & ~(align - 1));
ffffffffea80d740:	910006a4 	add	x4, x21, #0x1
ffffffffea80d744:	cb1503f5 	neg	x21, x21
	vq->id = id;
ffffffffea80d748:	b90002d7 	str	w23, [x22]
	event_init(&vq->avail_event, false, 0);
ffffffffea80d74c:	52800002 	mov	w2, #0x0                   	// #0
	vr->avail = p + num*sizeof(struct vring_desc);
ffffffffea80d750:	8b081028 	add	x8, x1, x8, lsl #4
	vr->num = num;
ffffffffea80d754:	b9000ad4 	str	w20, [x22, #8]
	vr->used = (void *)(((unsigned long)&vr->avail->ring[num] + sizeof(__u16)
ffffffffea80d758:	8b000500 	add	x0, x8, x0, lsl #1
	vr->avail = p + num*sizeof(struct vring_desc);
ffffffffea80d75c:	a90122c1 	stp	x1, x8, [x22, #16]
		+ align-1) & ~(align - 1));
ffffffffea80d760:	8b040000 	add	x0, x0, x4
	vq->kick_cb = kick_cb;
ffffffffea80d764:	a907ead9 	stp	x25, x26, [x22, #120]
ffffffffea80d768:	8a150015 	and	x21, x0, x21
	vq->vring_addr = (vaddr_t)vptr;
ffffffffea80d76c:	a90206d5 	stp	x21, x1, [x22, #32]
	vq->priv = priv;
ffffffffea80d770:	f90046d8 	str	x24, [x22, #136]
	event_init(&vq->avail_event, false, 0);
ffffffffea80d774:	910122c0 	add	x0, x22, #0x48
ffffffffea80d778:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80d77c:	97ffdfd5 	bl	ffffffffea8056d0 <event_init>
}
ffffffffea80d780:	2a1b03e0 	mov	w0, w27
ffffffffea80d784:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d788:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d78c:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80d790:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80d794:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea80d798:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80d79c:	d65f03c0 	ret

ffffffffea80d7a0 <vqueue_destroy>:

void vqueue_destroy(struct vqueue *vq)
{
ffffffffea80d7a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80d7a4:	910003fd 	mov	x29, sp
ffffffffea80d7a8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d7ac:	aa0003f3 	mov	x19, x0
	vaddr_t vring_addr;
	spin_lock_saved_state_t state;

	DEBUG_ASSERT(vq);

	spin_lock_save(&vq->slock, &state, VQ_LOCK_FLAGS);
ffffffffea80d7b0:	9100e014 	add	x20, x0, #0x38
{
ffffffffea80d7b4:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80d7b8:	d53b4220 	mrs	x0, daif
ffffffffea80d7bc:	37380220 	tbnz	w0, #7, ffffffffea80d800 <vqueue_destroy+0x60>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80d7c0:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80d7c4:	aa1403e0 	mov	x0, x20
ffffffffea80d7c8:	97ffd434 	bl	ffffffffea802898 <arch_spin_lock>
	vring_addr = vq->vring_addr;
ffffffffea80d7cc:	f9401675 	ldr	x21, [x19, #40]
    arch_spin_unlock(lock);
ffffffffea80d7d0:	aa1403e0 	mov	x0, x20
	vq->vring_addr = (vaddr_t)NULL;
	vq->vring_sz = 0;
ffffffffea80d7d4:	a902fe7f 	stp	xzr, xzr, [x19, #40]
	vq->last_avail_idx = 0;
ffffffffea80d7d8:	7900827f 	strh	wzr, [x19, #64]
ffffffffea80d7dc:	97ffd437 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80d7e0:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&vq->slock, state, VQ_LOCK_FLAGS);

	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80d7e4:	aa1503e1 	mov	x1, x21
}
ffffffffea80d7e8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80d7ec:	a94153f3 	ldp	x19, x20, [sp, #16]
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80d7f0:	b0000280 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
}
ffffffffea80d7f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80d7f8:	91034000 	add	x0, x0, #0xd0
ffffffffea80d7fc:	14000f49 	b	ffffffffea811520 <vmm_free_region>
    arch_spin_lock(lock);
ffffffffea80d800:	aa1403e0 	mov	x0, x20
ffffffffea80d804:	97ffd425 	bl	ffffffffea802898 <arch_spin_lock>
	vring_addr = vq->vring_addr;
ffffffffea80d808:	f9401675 	ldr	x21, [x19, #40]
    arch_spin_unlock(lock);
ffffffffea80d80c:	aa1403e0 	mov	x0, x20
	vq->vring_sz = 0;
ffffffffea80d810:	a902fe7f 	stp	xzr, xzr, [x19, #40]
	vq->last_avail_idx = 0;
ffffffffea80d814:	7900827f 	strh	wzr, [x19, #64]
ffffffffea80d818:	97ffd428 	bl	ffffffffea8028b8 <arch_spin_unlock>
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80d81c:	aa1503e1 	mov	x1, x21
}
ffffffffea80d820:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80d824:	a94153f3 	ldp	x19, x20, [sp, #16]
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80d828:	b0000280 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
}
ffffffffea80d82c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80d830:	91034000 	add	x0, x0, #0xd0
ffffffffea80d834:	14000f3b 	b	ffffffffea811520 <vmm_free_region>

ffffffffea80d838 <vqueue_signal_avail>:

void vqueue_signal_avail(struct vqueue *vq)
{
ffffffffea80d838:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80d83c:	910003fd 	mov	x29, sp
ffffffffea80d840:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d844:	aa0003f3 	mov	x19, x0
	spin_lock_saved_state_t state;

	spin_lock_save(&vq->slock, &state, VQ_LOCK_FLAGS);
ffffffffea80d848:	9100e014 	add	x20, x0, #0x38
{
ffffffffea80d84c:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80d850:	d53b4220 	mrs	x0, daif
ffffffffea80d854:	91012275 	add	x21, x19, #0x48
ffffffffea80d858:	37380280 	tbnz	w0, #7, ffffffffea80d8a8 <vqueue_signal_avail+0x70>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80d85c:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80d860:	aa1403e0 	mov	x0, x20
ffffffffea80d864:	97ffd40d 	bl	ffffffffea802898 <arch_spin_lock>
	if (vq->vring_addr) {
ffffffffea80d868:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80d86c:	b4000440 	cbz	x0, ffffffffea80d8f4 <vqueue_signal_avail+0xbc>
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80d870:	f9401263 	ldr	x3, [x19, #32]
	}
	event_signal(&vq->avail_event, false);
ffffffffea80d874:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80d878:	aa1503e0 	mov	x0, x21
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80d87c:	79400062 	ldrh	w2, [x3]
ffffffffea80d880:	32000042 	orr	w2, w2, #0x1
ffffffffea80d884:	79000062 	strh	w2, [x3]
	event_signal(&vq->avail_event, false);
ffffffffea80d888:	97ffdfec 	bl	ffffffffea805838 <event_signal>
    arch_spin_unlock(lock);
ffffffffea80d88c:	aa1403e0 	mov	x0, x20
ffffffffea80d890:	97ffd40a 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80d894:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&vq->slock, state, VQ_LOCK_FLAGS);
}
ffffffffea80d898:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d89c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80d8a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80d8a4:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea80d8a8:	aa1403e0 	mov	x0, x20
ffffffffea80d8ac:	97ffd3fb 	bl	ffffffffea802898 <arch_spin_lock>
	if (vq->vring_addr) {
ffffffffea80d8b0:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80d8b4:	b5000120 	cbnz	x0, ffffffffea80d8d8 <vqueue_signal_avail+0xa0>
	event_signal(&vq->avail_event, false);
ffffffffea80d8b8:	aa1503e0 	mov	x0, x21
ffffffffea80d8bc:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80d8c0:	97ffdfde 	bl	ffffffffea805838 <event_signal>
}
ffffffffea80d8c4:	f94013f5 	ldr	x21, [sp, #32]
    arch_spin_unlock(lock);
ffffffffea80d8c8:	aa1403e0 	mov	x0, x20
ffffffffea80d8cc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d8d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80d8d4:	17ffd3f9 	b	ffffffffea8028b8 <arch_spin_unlock>
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80d8d8:	f9401263 	ldr	x3, [x19, #32]
	event_signal(&vq->avail_event, false);
ffffffffea80d8dc:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80d8e0:	aa1503e0 	mov	x0, x21
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80d8e4:	79400062 	ldrh	w2, [x3]
ffffffffea80d8e8:	32000042 	orr	w2, w2, #0x1
ffffffffea80d8ec:	79000062 	strh	w2, [x3]
ffffffffea80d8f0:	17fffff4 	b	ffffffffea80d8c0 <vqueue_signal_avail+0x88>
	event_signal(&vq->avail_event, false);
ffffffffea80d8f4:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80d8f8:	aa1503e0 	mov	x0, x21
ffffffffea80d8fc:	97ffdfcf 	bl	ffffffffea805838 <event_signal>
ffffffffea80d900:	aa1403e0 	mov	x0, x20
ffffffffea80d904:	97ffd3ed 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea80d908:	17ffffe3 	b	ffffffffea80d894 <vqueue_signal_avail+0x5c>
ffffffffea80d90c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d910 <vqueue_get_avail_buf>:

	return NO_ERROR;
}

int vqueue_get_avail_buf(struct vqueue *vq, struct vqueue_buf *iovbuf)
{
ffffffffea80d910:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80d914:	910003fd 	mov	x29, sp
ffffffffea80d918:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d91c:	aa0103f4 	mov	x20, x1
ffffffffea80d920:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80d924:	aa0003f5 	mov	x21, x0
ffffffffea80d928:	f9001bf7 	str	x23, [sp, #48]
	spin_lock_saved_state_t state;

	spin_lock_save(&vq->slock, &state, VQ_LOCK_FLAGS);
ffffffffea80d92c:	9100e016 	add	x22, x0, #0x38
ffffffffea80d930:	aa1e03f7 	mov	x23, x30
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80d934:	d53b4220 	mrs	x0, daif
ffffffffea80d938:	37380100 	tbnz	w0, #7, ffffffffea80d958 <vqueue_get_avail_buf+0x48>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80d93c:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80d940:	aa1603e0 	mov	x0, x22
ffffffffea80d944:	97ffd3d5 	bl	ffffffffea802898 <arch_spin_lock>
	if (!vq->vring_addr) {
ffffffffea80d948:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80d94c:	b4000de0 	cbz	x0, ffffffffea80db08 <vqueue_get_avail_buf+0x1f8>
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea80d950:	52800033 	mov	w19, #0x1                   	// #1
ffffffffea80d954:	14000006 	b	ffffffffea80d96c <vqueue_get_avail_buf+0x5c>
ffffffffea80d958:	aa1603e0 	mov	x0, x22
ffffffffea80d95c:	97ffd3cf 	bl	ffffffffea802898 <arch_spin_lock>
ffffffffea80d960:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80d964:	b4000e00 	cbz	x0, ffffffffea80db24 <vqueue_get_avail_buf+0x214>
    spin_lock_saved_state_t state = 0;
ffffffffea80d968:	52800013 	mov	w19, #0x0                   	// #0
	uint16_t avail_cnt = vq->vring.avail->idx - vq->last_avail_idx;
ffffffffea80d96c:	f9400ea1 	ldr	x1, [x21, #24]
ffffffffea80d970:	794082a3 	ldrh	w3, [x21, #64]
	if (unlikely(avail_cnt > (uint16_t) vq->vring.num)) {
ffffffffea80d974:	794012a0 	ldrh	w0, [x21, #8]
	uint16_t avail_cnt = vq->vring.avail->idx - vq->last_avail_idx;
ffffffffea80d978:	79400424 	ldrh	w4, [x1, #2]
ffffffffea80d97c:	4b030081 	sub	w1, w4, w3
	if (unlikely(avail_cnt > (uint16_t) vq->vring.num)) {
ffffffffea80d980:	6b21201f 	cmp	w0, w1, uxth
ffffffffea80d984:	54000aa3 	b.cc	ffffffffea80dad8 <vqueue_get_avail_buf+0x1c8>  // b.lo, b.ul, b.last
	if (vq->last_avail_idx == vq->vring.avail->idx) {
ffffffffea80d988:	6b03009f 	cmp	w4, w3
ffffffffea80d98c:	54000780 	b.eq	ffffffffea80da7c <vqueue_get_avail_buf+0x16c>  // b.none
	smp_rmb();
ffffffffea80d990:	d50339bf 	dmb	ishld
	next_idx = vq->vring.avail->ring[vq->last_avail_idx % vq->vring.num];
ffffffffea80d994:	794082a1 	ldrh	w1, [x21, #64]
ffffffffea80d998:	b9400aa4 	ldr	w4, [x21, #8]
ffffffffea80d99c:	f9400ea3 	ldr	x3, [x21, #24]
	vq->last_avail_idx++;
ffffffffea80d9a0:	11000422 	add	w2, w1, #0x1
	next_idx = vq->vring.avail->ring[vq->last_avail_idx % vq->vring.num];
ffffffffea80d9a4:	1ac40820 	udiv	w0, w1, w4
ffffffffea80d9a8:	1b048400 	msub	w0, w0, w4, w1
ffffffffea80d9ac:	8b000460 	add	x0, x3, x0, lsl #1
ffffffffea80d9b0:	79400803 	ldrh	w3, [x0, #4]
	vq->last_avail_idx++;
ffffffffea80d9b4:	790082a2 	strh	w2, [x21, #64]
	if (unlikely(next_idx >= vq->vring.num)) {
ffffffffea80d9b8:	6b03009f 	cmp	w4, w3
ffffffffea80d9bc:	540009a9 	b.ls	ffffffffea80daf0 <vqueue_get_avail_buf+0x1e0>  // b.plast
		desc = &vq->vring.desc[next_idx];
ffffffffea80d9c0:	f9400aa9 	ldr	x9, [x21, #16]
			iovlist = &iovbuf->out_iovs;
ffffffffea80d9c4:	9100a28c 	add	x12, x20, #0x28
	iovbuf->head = next_idx;
ffffffffea80d9c8:	79000283 	strh	w3, [x20]
			iovlist = &iovbuf->out_iovs;
ffffffffea80d9cc:	91002294 	add	x20, x20, #0x8
	iovbuf->in_iovs.used = 0;
ffffffffea80d9d0:	b900069f 	str	wzr, [x20, #4]
	iovbuf->in_iovs.len  = 0;
ffffffffea80d9d4:	f900069f 	str	xzr, [x20, #8]
	iovbuf->out_iovs.used = 0;
ffffffffea80d9d8:	b900269f 	str	wzr, [x20, #36]
	iovbuf->out_iovs.len  = 0;
ffffffffea80d9dc:	f900169f 	str	xzr, [x20, #40]
		desc = &vq->vring.desc[next_idx];
ffffffffea80d9e0:	d37c3c63 	ubfiz	x3, x3, #4, #16
ffffffffea80d9e4:	8b030125 	add	x5, x9, x3
		if (desc->flags & VRING_DESC_F_WRITE) {
ffffffffea80d9e8:	794018a7 	ldrh	w7, [x5, #12]
			iovlist = &iovbuf->out_iovs;
ffffffffea80d9ec:	f27f00ff 	tst	x7, #0x2
ffffffffea80d9f0:	9a8c0280 	csel	x0, x20, x12, eq  // eq = none
		if (iovlist->used < iovlist->cnt) {
ffffffffea80d9f4:	29400801 	ldp	w1, w2, [x0]
ffffffffea80d9f8:	6b01005f 	cmp	w2, w1
ffffffffea80d9fc:	54000382 	b.cs	ffffffffea80da6c <vqueue_get_avail_buf+0x15c>  // b.hs, b.nlast
			iovlist->iovs[iovlist->used].len = desc->len;
ffffffffea80da00:	a941180a 	ldp	x10, x6, [x0, #16]
ffffffffea80da04:	2a0203e8 	mov	w8, w2
ffffffffea80da08:	b94008a1 	ldr	w1, [x5, #8]
			iovlist->used++;
ffffffffea80da0c:	11000442 	add	w2, w2, #0x1
			iovlist->phys[iovlist->used] = (paddr_t) desc->addr;
ffffffffea80da10:	f863692b 	ldr	x11, [x9, x3]
			iovlist->iovs[iovlist->used].len = desc->len;
ffffffffea80da14:	8b0810c6 	add	x6, x6, x8, lsl #4
		next_idx = desc->next;
ffffffffea80da18:	79401ca3 	ldrh	w3, [x5, #14]
			iovlist->iovs[iovlist->used].len = desc->len;
ffffffffea80da1c:	f90004c1 	str	x1, [x6, #8]
			iovlist->phys[iovlist->used] = (paddr_t) desc->addr;
ffffffffea80da20:	f828794b 	str	x11, [x10, x8, lsl #3]
			iovlist->used++;
ffffffffea80da24:	b9000402 	str	w2, [x0, #4]
			iovlist->len += desc->len;
ffffffffea80da28:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80da2c:	8b010042 	add	x2, x2, x1
ffffffffea80da30:	f9000402 	str	x2, [x0, #8]
	} while (desc->flags & VRING_DESC_F_NEXT);
ffffffffea80da34:	36000207 	tbz	w7, #0, ffffffffea80da74 <vqueue_get_avail_buf+0x164>
		if (unlikely(next_idx >= vq->vring.num)) {
ffffffffea80da38:	6b03009f 	cmp	w4, w3
ffffffffea80da3c:	54fffd28 	b.hi	ffffffffea80d9e0 <vqueue_get_avail_buf+0xd0>  // b.pmore
			return ERR_NOT_VALID;
ffffffffea80da40:	128000d4 	mov	w20, #0xfffffff9            	// #-7
    arch_spin_unlock(lock);
ffffffffea80da44:	aa1603e0 	mov	x0, x22
ffffffffea80da48:	97ffd39c 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea80da4c:	34000053 	cbz	w19, ffffffffea80da54 <vqueue_get_avail_buf+0x144>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80da50:	d50342ff 	msr	daifclr, #0x2
	int ret = _vqueue_get_avail_buf_locked(vq, iovbuf);
	spin_unlock_restore(&vq->slock, state, VQ_LOCK_FLAGS);
	return ret;
}
ffffffffea80da54:	2a1403e0 	mov	w0, w20
ffffffffea80da58:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80da5c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80da60:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80da64:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80da68:	d65f03c0 	ret
			return ERR_TOO_BIG;
ffffffffea80da6c:	12800314 	mov	w20, #0xffffffe7            	// #-25
ffffffffea80da70:	17fffff5 	b	ffffffffea80da44 <vqueue_get_avail_buf+0x134>
	return NO_ERROR;
ffffffffea80da74:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea80da78:	17fffff3 	b	ffffffffea80da44 <vqueue_get_avail_buf+0x134>
ffffffffea80da7c:	f9001fb8 	str	x24, [x29, #56]
		event_unsignal(&vq->avail_event);
ffffffffea80da80:	910122b8 	add	x24, x21, #0x48
ffffffffea80da84:	aa1803e0 	mov	x0, x24
ffffffffea80da88:	97ffdfac 	bl	ffffffffea805938 <event_unsignal>
		vq->vring.used->flags &= ~VRING_USED_F_NO_NOTIFY;
ffffffffea80da8c:	f94012a1 	ldr	x1, [x21, #32]
ffffffffea80da90:	79400020 	ldrh	w0, [x1]
ffffffffea80da94:	121f7800 	and	w0, w0, #0xfffffffe
ffffffffea80da98:	79000020 	strh	w0, [x1]
		smp_mb();
ffffffffea80da9c:	d5033bbf 	dmb	ish
		if (vq->last_avail_idx == vq->vring.avail->idx) {
ffffffffea80daa0:	f9400ea0 	ldr	x0, [x21, #24]
ffffffffea80daa4:	794082a1 	ldrh	w1, [x21, #64]
ffffffffea80daa8:	79400400 	ldrh	w0, [x0, #2]
ffffffffea80daac:	6b00003f 	cmp	w1, w0
ffffffffea80dab0:	54000340 	b.eq	ffffffffea80db18 <vqueue_get_avail_buf+0x208>  // b.none
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80dab4:	f94012a3 	ldr	x3, [x21, #32]
		event_signal(&vq->avail_event, false);
ffffffffea80dab8:	aa1803e0 	mov	x0, x24
ffffffffea80dabc:	52800001 	mov	w1, #0x0                   	// #0
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80dac0:	79400062 	ldrh	w2, [x3]
ffffffffea80dac4:	32000042 	orr	w2, w2, #0x1
ffffffffea80dac8:	79000062 	strh	w2, [x3]
		event_signal(&vq->avail_event, false);
ffffffffea80dacc:	97ffdf5b 	bl	ffffffffea805838 <event_signal>
ffffffffea80dad0:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80dad4:	17ffffaf 	b	ffffffffea80d990 <vqueue_get_avail_buf+0x80>
		panic("vq %p: new avail idx out of range (old %u new %u)\n",
ffffffffea80dad8:	d0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80dadc:	aa1503e2 	mov	x2, x21
ffffffffea80dae0:	91196021 	add	x1, x1, #0x658
ffffffffea80dae4:	aa1703e0 	mov	x0, x23
ffffffffea80dae8:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80daec:	9400106b 	bl	ffffffffea811c98 <_panic>
		panic("vq %p: head out of range %u (max %u)\n",
ffffffffea80daf0:	d0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80daf4:	aa1503e2 	mov	x2, x21
ffffffffea80daf8:	911a4021 	add	x1, x1, #0x690
ffffffffea80dafc:	aa1703e0 	mov	x0, x23
ffffffffea80db00:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80db04:	94001065 	bl	ffffffffea811c98 <_panic>
ffffffffea80db08:	aa1603e0 	mov	x0, x22
		return ERR_CHANNEL_CLOSED;
ffffffffea80db0c:	128001d4 	mov	w20, #0xfffffff1            	// #-15
ffffffffea80db10:	97ffd36a 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea80db14:	17ffffcf 	b	ffffffffea80da50 <vqueue_get_avail_buf+0x140>
			return ERR_NOT_ENOUGH_BUFFER;
ffffffffea80db18:	12800114 	mov	w20, #0xfffffff7            	// #-9
ffffffffea80db1c:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80db20:	17ffffc9 	b	ffffffffea80da44 <vqueue_get_avail_buf+0x134>
ffffffffea80db24:	aa1603e0 	mov	x0, x22
		return ERR_CHANNEL_CLOSED;
ffffffffea80db28:	128001d4 	mov	w20, #0xfffffff1            	// #-15
ffffffffea80db2c:	97ffd363 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea80db30:	17ffffc9 	b	ffffffffea80da54 <vqueue_get_avail_buf+0x144>
ffffffffea80db34:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80db38 <vqueue_map_iovs>:

int vqueue_map_iovs(struct vqueue_iovs *vqiovs, u_int flags, uint32_t guest)
{
ffffffffea80db38:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80db3c:	910003fd 	mov	x29, sp
	DEBUG_ASSERT(vqiovs);
	DEBUG_ASSERT(vqiovs->phys);
	DEBUG_ASSERT(vqiovs->iovs);
	DEBUG_ASSERT(vqiovs->used <= vqiovs->cnt);

	for (i = 0; i < vqiovs->used; i++) {
ffffffffea80db40:	b9400403 	ldr	w3, [x0, #4]
{
ffffffffea80db44:	f9002ffc 	str	x28, [sp, #88]
	for (i = 0; i < vqiovs->used; i++) {
ffffffffea80db48:	34000883 	cbz	w3, ffffffffea80dc58 <vqueue_map_iovs+0x120>
ffffffffea80db4c:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80db50:	aa0003f4 	mov	x20, x0
ffffffffea80db54:	a9025bb5 	stp	x21, x22, [x29, #32]
			TRACEF("%s: check_guest_pa_valid failed, error = %d",
				__func__, ret);
			return ret;
		}
        vqiovs->iovs[i].base = NULL;
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80db58:	b0000295 	adrp	x21, ffffffffea85e000 <rb_data+0x18>
ffffffffea80db5c:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80db60:	2a0203f6 	mov	w22, w2
ffffffffea80db64:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea80db68:	d0000058 	adrp	x24, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80db6c:	2a0103f7 	mov	w23, w1
ffffffffea80db70:	911bc318 	add	x24, x24, #0x6f0
ffffffffea80db74:	910342b5 	add	x21, x21, #0xd0
	for (i = 0; i < vqiovs->used; i++) {
ffffffffea80db78:	5280001a 	mov	w26, #0x0                   	// #0
ffffffffea80db7c:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80db80:	14000011 	b	ffffffffea80dbc4 <vqueue_map_iovs+0x8c>
        vqiovs->iovs[i].base = NULL;
ffffffffea80db84:	a9410682 	ldp	x2, x1, [x20, #16]
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80db88:	2a1703e7 	mov	w7, w23
ffffffffea80db8c:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80db90:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea80db94:	8b1b0023 	add	x3, x1, x27
ffffffffea80db98:	f8797845 	ldr	x5, [x2, x25, lsl #3]
ffffffffea80db9c:	aa1303e2 	mov	x2, x19
        vqiovs->iovs[i].base = NULL;
ffffffffea80dba0:	f83b683f 	str	xzr, [x1, x27]
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80dba4:	aa1803e1 	mov	x1, x24
ffffffffea80dba8:	94000dfc 	bl	ffffffffea811398 <vmm_alloc_physical>
ffffffffea80dbac:	2a0003fc 	mov	w28, w0
		                         roundedup_iovs_sz,
		                         &vqiovs->iovs[i].base, PAGE_SIZE_SHIFT,
		                         vqiovs->phys[i], 0, flags);
		if (ret) {
ffffffffea80dbb0:	350005e0 	cbnz	w0, ffffffffea80dc6c <vqueue_map_iovs+0x134>
	for (i = 0; i < vqiovs->used; i++) {
ffffffffea80dbb4:	b9400680 	ldr	w0, [x20, #4]
ffffffffea80dbb8:	1100075a 	add	w26, w26, #0x1
ffffffffea80dbbc:	6b1a001f 	cmp	w0, w26
ffffffffea80dbc0:	54000429 	b.ls	ffffffffea80dc44 <vqueue_map_iovs+0x10c>  // b.plast
		roundedup_iovs_sz = ROUNDUP(vqiovs->iovs[i].len, PAGE_SIZE);
ffffffffea80dbc4:	a9410e80 	ldp	x0, x3, [x20, #16]
ffffffffea80dbc8:	2a1a03f9 	mov	w25, w26
		ret = trusty_hyp_check_guest_pa_valid(vqiovs->phys[i],
ffffffffea80dbcc:	2a1603e2 	mov	w2, w22
		roundedup_iovs_sz = ROUNDUP(vqiovs->iovs[i].len, PAGE_SIZE);
ffffffffea80dbd0:	d37cef3b 	lsl	x27, x25, #4
ffffffffea80dbd4:	8b1b0063 	add	x3, x3, x27
		ret = trusty_hyp_check_guest_pa_valid(vqiovs->phys[i],
ffffffffea80dbd8:	f8797800 	ldr	x0, [x0, x25, lsl #3]
		roundedup_iovs_sz = ROUNDUP(vqiovs->iovs[i].len, PAGE_SIZE);
ffffffffea80dbdc:	f9400473 	ldr	x19, [x3, #8]
ffffffffea80dbe0:	913ffe73 	add	x19, x19, #0xfff
ffffffffea80dbe4:	9274ce73 	and	x19, x19, #0xfffffffffffff000
		ret = trusty_hyp_check_guest_pa_valid(vqiovs->phys[i],
ffffffffea80dbe8:	aa1303e1 	mov	x1, x19
ffffffffea80dbec:	97ffd2fb 	bl	ffffffffea8027d8 <trusty_hyp_check_guest_pa_valid>
ffffffffea80dbf0:	aa0003e4 	mov	x4, x0
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80dbf4:	aa1503e0 	mov	x0, x21
		ret = trusty_hyp_check_guest_pa_valid(vqiovs->phys[i],
ffffffffea80dbf8:	2a0403fc 	mov	w28, w4
		if (ret != NO_ERROR) {
ffffffffea80dbfc:	34fffc44 	cbz	w4, ffffffffea80db84 <vqueue_map_iovs+0x4c>
			TRACEF("%s: check_guest_pa_valid failed, error = %d",
ffffffffea80dc00:	d0000043 	adrp	x3, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80dc04:	d0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80dc08:	d0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80dc0c:	91192063 	add	x3, x3, #0x648
ffffffffea80dc10:	52801e42 	mov	w2, #0xf2                  	// #242
ffffffffea80dc14:	9118a021 	add	x1, x1, #0x628
ffffffffea80dc18:	911ae000 	add	x0, x0, #0x6b8
ffffffffea80dc1c:	94001585 	bl	ffffffffea813230 <_printf>
		vmm_free_region(vmm_get_kernel_aspace(),
		                (vaddr_t)vqiovs->iovs[i].base);
		vqiovs->iovs[i].base = NULL;
	}
	return ret;
}
ffffffffea80dc20:	2a1c03e0 	mov	w0, w28
ffffffffea80dc24:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea80dc28:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80dc2c:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80dc30:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80dc34:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80dc38:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea80dc3c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80dc40:	d65f03c0 	ret
ffffffffea80dc44:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80dc48:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80dc4c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80dc50:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80dc54:	f9402bbb 	ldr	x27, [x29, #80]
	return NO_ERROR;
ffffffffea80dc58:	5280001c 	mov	w28, #0x0                   	// #0
}
ffffffffea80dc5c:	2a1c03e0 	mov	w0, w28
ffffffffea80dc60:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea80dc64:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80dc68:	d65f03c0 	ret
	while (i--) {
ffffffffea80dc6c:	51000753 	sub	w19, w26, #0x1
ffffffffea80dc70:	34fffd9a 	cbz	w26, ffffffffea80dc20 <vqueue_map_iovs+0xe8>
ffffffffea80dc74:	f9400e80 	ldr	x0, [x20, #24]
ffffffffea80dc78:	d37c7e73 	ubfiz	x19, x19, #4, #32
ffffffffea80dc7c:	d503201f 	nop
		vmm_free_region(vmm_get_kernel_aspace(),
ffffffffea80dc80:	f8736801 	ldr	x1, [x0, x19]
ffffffffea80dc84:	aa1503e0 	mov	x0, x21
ffffffffea80dc88:	94000e26 	bl	ffffffffea811520 <vmm_free_region>
		vqiovs->iovs[i].base = NULL;
ffffffffea80dc8c:	f9400e80 	ldr	x0, [x20, #24]
ffffffffea80dc90:	f833681f 	str	xzr, [x0, x19]
ffffffffea80dc94:	d1004273 	sub	x19, x19, #0x10
	while (i--) {
ffffffffea80dc98:	b100427f 	cmn	x19, #0x10
ffffffffea80dc9c:	54ffff21 	b.ne	ffffffffea80dc80 <vqueue_map_iovs+0x148>  // b.any
ffffffffea80dca0:	17ffffe0 	b	ffffffffea80dc20 <vqueue_map_iovs+0xe8>
ffffffffea80dca4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80dca8 <vqueue_unmap_iovs>:
	DEBUG_ASSERT(vqiovs);
	DEBUG_ASSERT(vqiovs->phys);
	DEBUG_ASSERT(vqiovs->iovs);
	DEBUG_ASSERT(vqiovs->used <= vqiovs->cnt);

	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80dca8:	b9400401 	ldr	w1, [x0, #4]
ffffffffea80dcac:	34000321 	cbz	w1, ffffffffea80dd10 <vqueue_unmap_iovs+0x68>
{
ffffffffea80dcb0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80dcb4:	910003fd 	mov	x29, sp
ffffffffea80dcb8:	f9400c01 	ldr	x1, [x0, #24]
ffffffffea80dcbc:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80dcc0:	b0000296 	adrp	x22, ffffffffea85e000 <rb_data+0x18>
ffffffffea80dcc4:	aa0003f5 	mov	x21, x0
		/* base is expected to be set */
		DEBUG_ASSERT(vqiovs->iovs[i].base);
		vmm_free_region(vmm_get_kernel_aspace(),
ffffffffea80dcc8:	910342d6 	add	x22, x22, #0xd0
{
ffffffffea80dccc:	a90153f3 	stp	x19, x20, [sp, #16]
	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80dcd0:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea80dcd4:	d503201f 	nop
		                (vaddr_t)vqiovs->iovs[i].base);
ffffffffea80dcd8:	d37c7e74 	ubfiz	x20, x19, #4, #32
		vmm_free_region(vmm_get_kernel_aspace(),
ffffffffea80dcdc:	aa1603e0 	mov	x0, x22
	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80dce0:	11000673 	add	w19, w19, #0x1
		vmm_free_region(vmm_get_kernel_aspace(),
ffffffffea80dce4:	f8746821 	ldr	x1, [x1, x20]
ffffffffea80dce8:	94000e0e 	bl	ffffffffea811520 <vmm_free_region>
		vqiovs->iovs[i].base = NULL;
ffffffffea80dcec:	f9400ea1 	ldr	x1, [x21, #24]
	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80dcf0:	b94006a0 	ldr	w0, [x21, #4]
		vqiovs->iovs[i].base = NULL;
ffffffffea80dcf4:	f834683f 	str	xzr, [x1, x20]
	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80dcf8:	6b13001f 	cmp	w0, w19
ffffffffea80dcfc:	54fffee8 	b.hi	ffffffffea80dcd8 <vqueue_unmap_iovs+0x30>  // b.pmore
	}
}
ffffffffea80dd00:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80dd04:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80dd08:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80dd0c:	d65f03c0 	ret
ffffffffea80dd10:	d65f03c0 	ret
ffffffffea80dd14:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80dd18 <vqueue_add_buf>:
	vq->vring.used->idx++;
	return NO_ERROR;
}

int vqueue_add_buf(struct vqueue *vq, struct vqueue_buf *buf, uint32_t len)
{
ffffffffea80dd18:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80dd1c:	910003fd 	mov	x29, sp
ffffffffea80dd20:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80dd24:	aa0003f3 	mov	x19, x0
ffffffffea80dd28:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80dd2c:	aa0103f4 	mov	x20, x1
ffffffffea80dd30:	2a0203f6 	mov	w22, w2
	spin_lock_saved_state_t state;

	spin_lock_save(&vq->slock, &state, VQ_LOCK_FLAGS);
ffffffffea80dd34:	9100e015 	add	x21, x0, #0x38
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80dd38:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80dd3c:	37380180 	tbnz	w0, #7, ffffffffea80dd6c <vqueue_add_buf+0x54>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80dd40:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80dd44:	aa1503e0 	mov	x0, x21
ffffffffea80dd48:	97ffd2d4 	bl	ffffffffea802898 <arch_spin_lock>
	if (!vq->vring_addr) {
ffffffffea80dd4c:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80dd50:	b4000580 	cbz	x0, ffffffffea80de00 <vqueue_add_buf+0xe8>
	if (buf->head >= vq->vring.num) {
ffffffffea80dd54:	79400285 	ldrh	w5, [x20]
ffffffffea80dd58:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea80dd5c:	6b05003f 	cmp	w1, w5
ffffffffea80dd60:	54000589 	b.ls	ffffffffea80de10 <vqueue_add_buf+0xf8>  // b.plast
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea80dd64:	52800034 	mov	w20, #0x1                   	// #1
ffffffffea80dd68:	1400000a 	b	ffffffffea80dd90 <vqueue_add_buf+0x78>
ffffffffea80dd6c:	aa1503e0 	mov	x0, x21
ffffffffea80dd70:	97ffd2ca 	bl	ffffffffea802898 <arch_spin_lock>
	if (!vq->vring_addr) {
ffffffffea80dd74:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80dd78:	b4000340 	cbz	x0, ffffffffea80dde0 <vqueue_add_buf+0xc8>
	if (buf->head >= vq->vring.num) {
ffffffffea80dd7c:	79400285 	ldrh	w5, [x20]
ffffffffea80dd80:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea80dd84:	6b05003f 	cmp	w1, w5
ffffffffea80dd88:	54000349 	b.ls	ffffffffea80ddf0 <vqueue_add_buf+0xd8>  // b.plast
    spin_lock_saved_state_t state = 0;
ffffffffea80dd8c:	52800014 	mov	w20, #0x0                   	// #0
	used = &vq->vring.used->ring[vq->vring.used->idx % vq->vring.num];
ffffffffea80dd90:	f9401263 	ldr	x3, [x19, #32]
ffffffffea80dd94:	79400464 	ldrh	w4, [x3, #2]
ffffffffea80dd98:	1ac10880 	udiv	w0, w4, w1
ffffffffea80dd9c:	1b019000 	msub	w0, w0, w1, w4
ffffffffea80dda0:	8b000c60 	add	x0, x3, x0, lsl #3
	used->len = len;
ffffffffea80dda4:	2900d805 	stp	w5, w22, [x0, #4]
	smp_wmb();
ffffffffea80dda8:	d5033abf 	dmb	ishst
	vq->vring.used->idx++;
ffffffffea80ddac:	f9401262 	ldr	x2, [x19, #32]
    arch_spin_unlock(lock);
ffffffffea80ddb0:	aa1503e0 	mov	x0, x21
ffffffffea80ddb4:	79400441 	ldrh	w1, [x2, #2]
ffffffffea80ddb8:	11000421 	add	w1, w1, #0x1
ffffffffea80ddbc:	79000441 	strh	w1, [x2, #2]
ffffffffea80ddc0:	97ffd2be 	bl	ffffffffea8028b8 <arch_spin_unlock>
	return NO_ERROR;
ffffffffea80ddc4:	52800000 	mov	w0, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea80ddc8:	34000054 	cbz	w20, ffffffffea80ddd0 <vqueue_add_buf+0xb8>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80ddcc:	d50342ff 	msr	daifclr, #0x2
	int ret = _vqueue_add_buf_locked(vq, buf, len);
	spin_unlock_restore(&vq->slock, state, VQ_LOCK_FLAGS);
	return ret;
}
ffffffffea80ddd0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ddd4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ddd8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80dddc:	d65f03c0 	ret
ffffffffea80dde0:	aa1503e0 	mov	x0, x21
ffffffffea80dde4:	97ffd2b5 	bl	ffffffffea8028b8 <arch_spin_unlock>
		return ERR_CHANNEL_CLOSED;
ffffffffea80dde8:	128001c0 	mov	w0, #0xfffffff1            	// #-15
ffffffffea80ddec:	17fffff9 	b	ffffffffea80ddd0 <vqueue_add_buf+0xb8>
ffffffffea80ddf0:	aa1503e0 	mov	x0, x21
ffffffffea80ddf4:	97ffd2b1 	bl	ffffffffea8028b8 <arch_spin_unlock>
		return ERR_NOT_VALID;
ffffffffea80ddf8:	128000c0 	mov	w0, #0xfffffff9            	// #-7
ffffffffea80ddfc:	17fffff5 	b	ffffffffea80ddd0 <vqueue_add_buf+0xb8>
ffffffffea80de00:	aa1503e0 	mov	x0, x21
ffffffffea80de04:	97ffd2ad 	bl	ffffffffea8028b8 <arch_spin_unlock>
		return ERR_CHANNEL_CLOSED;
ffffffffea80de08:	128001c0 	mov	w0, #0xfffffff1            	// #-15
ffffffffea80de0c:	17fffff0 	b	ffffffffea80ddcc <vqueue_add_buf+0xb4>
ffffffffea80de10:	aa1503e0 	mov	x0, x21
ffffffffea80de14:	97ffd2a9 	bl	ffffffffea8028b8 <arch_spin_unlock>
		return ERR_NOT_VALID;
ffffffffea80de18:	128000c0 	mov	w0, #0xfffffff9            	// #-7
ffffffffea80de1c:	17ffffec 	b	ffffffffea80ddcc <vqueue_add_buf+0xb4>

ffffffffea80de20 <trusty_sm_init>:
	.stdcall_handler = trusty_sm_stdcall,
	.nopcall_handler = trusty_sm_nopcall
};

static void trusty_sm_init(uint level)
{
ffffffffea80de20:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	int err;

	dprintf(INFO, "Initializing Trusted OS SMC handler\n");
ffffffffea80de24:	d0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80de28:	911fc000 	add	x0, x0, #0x7f0
{
ffffffffea80de2c:	910003fd 	mov	x29, sp
	dprintf(INFO, "Initializing Trusted OS SMC handler\n");
ffffffffea80de30:	94000f1c 	bl	ffffffffea811aa0 <_dprintf>

	err = sm_register_entity(SMC_ENTITY_TRUSTED_OS, &trusty_sm_entity);
ffffffffea80de34:	90000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea80de38:	52800640 	mov	w0, #0x32                  	// #50
ffffffffea80de3c:	9138c021 	add	x1, x1, #0xe30
ffffffffea80de40:	97ffeb18 	bl	ffffffffea808aa0 <sm_register_entity>
	if (err) {
ffffffffea80de44:	35000060 	cbnz	w0, ffffffffea80de50 <trusty_sm_init+0x30>
		TRACEF("WARNING: Cannot register SMC entity! (%d)\n", err);
	}
}
ffffffffea80de48:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80de4c:	d65f03c0 	ret
ffffffffea80de50:	a8c17bfd 	ldp	x29, x30, [sp], #16
		TRACEF("WARNING: Cannot register SMC entity! (%d)\n", err);
ffffffffea80de54:	d0000044 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80de58:	2a0003e3 	mov	w3, w0
ffffffffea80de5c:	d0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80de60:	52802442 	mov	w2, #0x122                 	// #290
ffffffffea80de64:	911ec021 	add	x1, x1, #0x7b0
ffffffffea80de68:	91206080 	add	x0, x4, #0x818
ffffffffea80de6c:	140014f1 	b	ffffffffea813230 <_printf>

ffffffffea80de70 <get_ns_mem_buf>:
{
ffffffffea80de70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80de74:	910003fd 	mov	x29, sp
ffffffffea80de78:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80de7c:	aa0303f3 	mov	x19, x3
	status_t rc = smc32_decode_mem_buf_info(args, ppa, psz, pflags);
ffffffffea80de80:	97ffeb6e 	bl	ffffffffea808c38 <smc32_decode_mem_buf_info>
	if (rc != NO_ERROR) {
ffffffffea80de84:	35000100 	cbnz	w0, ffffffffea80dea4 <get_ns_mem_buf+0x34>
	uint mem_type = *pflags & ARCH_MMU_FLAG_CACHE_MASK;
ffffffffea80de88:	b9400260 	ldr	w0, [x19]
ffffffffea80de8c:	12000401 	and	w1, w0, #0x3
	if (mem_type != ARCH_MMU_FLAG_CACHED &&
ffffffffea80de90:	7100043f 	cmp	w1, #0x1
ffffffffea80de94:	540000e8 	b.hi	ffffffffea80deb0 <get_ns_mem_buf+0x40>  // b.pmore
		return ERR_INVALID_ARGS;
ffffffffea80de98:	721e041f 	tst	w0, #0xc
ffffffffea80de9c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80dea0:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
}
ffffffffea80dea4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80dea8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80deac:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80deb0:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80deb4:	17fffffc 	b	ffffffffea80dea4 <get_ns_mem_buf+0x34>

ffffffffea80deb8 <trusty_sm_nopcall>:
{
ffffffffea80deb8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80debc:	aa0003e1 	mov	x1, x0
ffffffffea80dec0:	910003fd 	mov	x29, sp
	uint32_t guest = args->params[SMC_ARGS_GUESTID];
ffffffffea80dec4:	b9401c02 	ldr	w2, [x0, #28]
	if (((int32_t)guest != HV_GUEST_ID) &&
ffffffffea80dec8:	51004040 	sub	w0, w2, #0x10
ffffffffea80decc:	3100481f 	cmn	w0, #0x12
ffffffffea80ded0:	540003c9 	b.ls	ffffffffea80df48 <trusty_sm_nopcall+0x90>  // b.plast
	switch (args->params[0]) {
ffffffffea80ded4:	b9400420 	ldr	w0, [x1, #4]
ffffffffea80ded8:	52800323 	mov	w3, #0x19                  	// #25
ffffffffea80dedc:	72a64003 	movk	w3, #0x3200, lsl #16
ffffffffea80dee0:	6b03001f 	cmp	w0, w3
ffffffffea80dee4:	540002a0 	b.eq	ffffffffea80df38 <trusty_sm_nopcall+0x80>  // b.none
ffffffffea80dee8:	52800342 	mov	w2, #0x1a                  	// #26
ffffffffea80deec:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80def0:	6b02001f 	cmp	w0, w2
ffffffffea80def4:	540000e0 	b.eq	ffffffffea80df10 <trusty_sm_nopcall+0x58>  // b.none
ffffffffea80def8:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80defc:	d0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80df00:	911be000 	add	x0, x0, #0x6f8
ffffffffea80df04:	f8617800 	ldr	x0, [x0, x1, lsl #3]
}
ffffffffea80df08:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80df0c:	d65f03c0 	ret
		res = arm_gic_sim_irq_handler(args->params[1]);
ffffffffea80df10:	b9400820 	ldr	w0, [x1, #8]
ffffffffea80df14:	97ffdbe9 	bl	ffffffffea804eb8 <arm_gic_sim_irq_handler>
ffffffffea80df18:	93407c00 	sxtw	x0, w0
	if (err >= 0) {
ffffffffea80df1c:	b6ffff60 	tbz	x0, #63, ffffffffea80df08 <trusty_sm_nopcall+0x50>
ffffffffea80df20:	91006001 	add	x1, x0, #0x18
ffffffffea80df24:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea80df28:	f100403f 	cmp	x1, #0x10
ffffffffea80df2c:	54fffe89 	b.ls	ffffffffea80defc <trusty_sm_nopcall+0x44>  // b.plast
}
ffffffffea80df30:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80df34:	d65f03c0 	ret
		res = virtio_kick_vq(args->params[1], args->params[2], guest);
ffffffffea80df38:	29410420 	ldp	w0, w1, [x1, #8]
ffffffffea80df3c:	9400029d 	bl	ffffffffea80e9b0 <virtio_kick_vq>
ffffffffea80df40:	93407c00 	sxtw	x0, w0
		break;
ffffffffea80df44:	17fffff6 	b	ffffffffea80df1c <trusty_sm_nopcall+0x64>
		TRACEF("%s: Error. Unexpected guestID %u\n",
ffffffffea80df48:	2a0203e4 	mov	w4, w2
ffffffffea80df4c:	d0000043 	adrp	x3, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80df50:	d0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80df54:	d0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80df58:	911f6063 	add	x3, x3, #0x7d8
ffffffffea80df5c:	52801fe2 	mov	w2, #0xff                  	// #255
ffffffffea80df60:	911e6021 	add	x1, x1, #0x798
ffffffffea80df64:	91214000 	add	x0, x0, #0x850
ffffffffea80df68:	940014b2 	bl	ffffffffea813230 <_printf>
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80df6c:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80df70:	17ffffe6 	b	ffffffffea80df08 <trusty_sm_nopcall+0x50>
ffffffffea80df74:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80df78 <lock_bl_data_interface>:
}
ffffffffea80df78:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80df7c:	d65f03c0 	ret

ffffffffea80df80 <handle_bl_data_interface>:
}
ffffffffea80df80:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80df84:	d65f03c0 	ret

ffffffffea80df88 <set_root_of_trust_params>:
}
ffffffffea80df88:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80df8c:	d65f03c0 	ret

ffffffffea80df90 <trusty_sm_stdcall>:
{
ffffffffea80df90:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80df94:	910003fd 	mov	x29, sp
ffffffffea80df98:	f9000bf3 	str	x19, [sp, #16]
	uint32_t guest = args->params[SMC_ARGS_GUESTID];
ffffffffea80df9c:	b9401c13 	ldr	w19, [x0, #28]
	 if (((int32_t)guest != HV_GUEST_ID) &&
ffffffffea80dfa0:	51004261 	sub	w1, w19, #0x10
ffffffffea80dfa4:	3100483f 	cmn	w1, #0x12
ffffffffea80dfa8:	54001229 	b.ls	ffffffffea80e1ec <trusty_sm_stdcall+0x25c>  // b.plast
	switch (args->smc_nr) {
ffffffffea80dfac:	b9400001 	ldr	w1, [x0]
ffffffffea80dfb0:	528003c2 	mov	w2, #0x1e                  	// #30
ffffffffea80dfb4:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80dfb8:	aa0003e3 	mov	x3, x0
ffffffffea80dfbc:	6b02003f 	cmp	w1, w2
ffffffffea80dfc0:	54000e20 	b.eq	ffffffffea80e184 <trusty_sm_stdcall+0x1f4>  // b.none
ffffffffea80dfc4:	540002a8 	b.hi	ffffffffea80e018 <trusty_sm_stdcall+0x88>  // b.pmore
ffffffffea80dfc8:	528002c2 	mov	w2, #0x16                  	// #22
ffffffffea80dfcc:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80dfd0:	6b02003f 	cmp	w1, w2
ffffffffea80dfd4:	54000c00 	b.eq	ffffffffea80e154 <trusty_sm_stdcall+0x1c4>  // b.none
ffffffffea80dfd8:	54000549 	b.ls	ffffffffea80e080 <trusty_sm_stdcall+0xf0>  // b.plast
ffffffffea80dfdc:	528002e0 	mov	w0, #0x17                  	// #23
ffffffffea80dfe0:	72a64000 	movk	w0, #0x3200, lsl #16
ffffffffea80dfe4:	6b00003f 	cmp	w1, w0
ffffffffea80dfe8:	54000e20 	b.eq	ffffffffea80e1ac <trusty_sm_stdcall+0x21c>  // b.none
ffffffffea80dfec:	11000400 	add	w0, w0, #0x1
ffffffffea80dff0:	6b00003f 	cmp	w1, w0
ffffffffea80dff4:	54000961 	b.ne	ffffffffea80e120 <trusty_sm_stdcall+0x190>  // b.any
		res = virtio_kick_vq(args->params[0], args->params[1], guest);
ffffffffea80dff8:	29408460 	ldp	w0, w1, [x3, #4]
ffffffffea80dffc:	2a1303e2 	mov	w2, w19
ffffffffea80e000:	9400026c 	bl	ffffffffea80e9b0 <virtio_kick_vq>
ffffffffea80e004:	93407c00 	sxtw	x0, w0
	if (err >= 0) {
ffffffffea80e008:	b7f80280 	tbnz	x0, #63, ffffffffea80e058 <trusty_sm_stdcall+0xc8>
}
ffffffffea80e00c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80e010:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e014:	d65f03c0 	ret
	switch (args->smc_nr) {
ffffffffea80e018:	529fffa2 	mov	w2, #0xfffd                	// #65533
ffffffffea80e01c:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80e020:	6b02003f 	cmp	w1, w2
ffffffffea80e024:	54000ce0 	b.eq	ffffffffea80e1c0 <trusty_sm_stdcall+0x230>  // b.none
ffffffffea80e028:	54000529 	b.ls	ffffffffea80e0cc <trusty_sm_stdcall+0x13c>  // b.plast
ffffffffea80e02c:	529fffc0 	mov	w0, #0xfffe                	// #65534
ffffffffea80e030:	72a64000 	movk	w0, #0x3200, lsl #16
ffffffffea80e034:	6b00003f 	cmp	w1, w0
ffffffffea80e038:	540006c0 	b.eq	ffffffffea80e110 <trusty_sm_stdcall+0x180>  // b.none
ffffffffea80e03c:	12b9bfe0 	mov	w0, #0x3200ffff            	// #838926335
ffffffffea80e040:	6b00003f 	cmp	w1, w0
ffffffffea80e044:	540006e1 	b.ne	ffffffffea80e120 <trusty_sm_stdcall+0x190>  // b.any
		res = set_root_of_trust_params((paddr_t)args->params[0],
ffffffffea80e048:	29408460 	ldp	w0, w1, [x3, #4]
ffffffffea80e04c:	97ffffcf 	bl	ffffffffea80df88 <set_root_of_trust_params>
	if (err >= 0) {
ffffffffea80e050:	b6fffde0 	tbz	x0, #63, ffffffffea80e00c <trusty_sm_stdcall+0x7c>
ffffffffea80e054:	d503201f 	nop
ffffffffea80e058:	91006001 	add	x1, x0, #0x18
ffffffffea80e05c:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea80e060:	f100403f 	cmp	x1, #0x10
ffffffffea80e064:	54fffd48 	b.hi	ffffffffea80e00c <trusty_sm_stdcall+0x7c>  // b.pmore
ffffffffea80e068:	b0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e06c:	911be000 	add	x0, x0, #0x6f8
}
ffffffffea80e070:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80e074:	f8617800 	ldr	x0, [x0, x1, lsl #3]
ffffffffea80e078:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e07c:	d65f03c0 	ret
	switch (args->smc_nr) {
ffffffffea80e080:	52800282 	mov	w2, #0x14                  	// #20
ffffffffea80e084:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80e088:	6b02003f 	cmp	w1, w2
ffffffffea80e08c:	540004e0 	b.eq	ffffffffea80e128 <trusty_sm_stdcall+0x198>  // b.none
ffffffffea80e090:	11000442 	add	w2, w2, #0x1
ffffffffea80e094:	6b02003f 	cmp	w1, w2
ffffffffea80e098:	54000441 	b.ne	ffffffffea80e120 <trusty_sm_stdcall+0x190>  // b.any
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80e09c:	910093a3 	add	x3, x29, #0x24
ffffffffea80e0a0:	910083a2 	add	x2, x29, #0x20
ffffffffea80e0a4:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80e0a8:	97ffff72 	bl	ffffffffea80de70 <get_ns_mem_buf>
ffffffffea80e0ac:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR) {
ffffffffea80e0b0:	b5fffac0 	cbnz	x0, ffffffffea80e008 <trusty_sm_stdcall+0x78>
			res = virtio_start(ns_pa, ns_sz, ns_mmu_flags, guest);
ffffffffea80e0b4:	29440ba1 	ldp	w1, w2, [x29, #32]
ffffffffea80e0b8:	2a1303e3 	mov	w3, w19
ffffffffea80e0bc:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80e0c0:	9400017c 	bl	ffffffffea80e6b0 <virtio_start>
ffffffffea80e0c4:	93407c00 	sxtw	x0, w0
ffffffffea80e0c8:	17ffffd0 	b	ffffffffea80e008 <trusty_sm_stdcall+0x78>
	switch (args->smc_nr) {
ffffffffea80e0cc:	528003e2 	mov	w2, #0x1f                  	// #31
ffffffffea80e0d0:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80e0d4:	6b02003f 	cmp	w1, w2
ffffffffea80e0d8:	54000780 	b.eq	ffffffffea80e1c8 <trusty_sm_stdcall+0x238>  // b.none
ffffffffea80e0dc:	11000442 	add	w2, w2, #0x1
ffffffffea80e0e0:	6b02003f 	cmp	w1, w2
ffffffffea80e0e4:	540001e1 	b.ne	ffffffffea80e120 <trusty_sm_stdcall+0x190>  // b.any
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80e0e8:	910093a3 	add	x3, x29, #0x24
ffffffffea80e0ec:	910083a2 	add	x2, x29, #0x20
ffffffffea80e0f0:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80e0f4:	97ffff5f 	bl	ffffffffea80de70 <get_ns_mem_buf>
ffffffffea80e0f8:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR)
ffffffffea80e0fc:	b5fff860 	cbnz	x0, ffffffffea80e008 <trusty_sm_stdcall+0x78>
			res = ql_tipc_handle_cmd(ns_pa, ns_sz);
ffffffffea80e100:	b94023a1 	ldr	w1, [x29, #32]
ffffffffea80e104:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80e108:	94000788 	bl	ffffffffea80ff28 <ql_tipc_handle_cmd>
ffffffffea80e10c:	17ffffbf 	b	ffffffffea80e008 <trusty_sm_stdcall+0x78>
		res = handle_bl_data_interface((long)args->params[0],
ffffffffea80e110:	29408460 	ldp	w0, w1, [x3, #4]
ffffffffea80e114:	b9400c62 	ldr	w2, [x3, #12]
ffffffffea80e118:	97ffff9a 	bl	ffffffffea80df80 <handle_bl_data_interface>
		break;
ffffffffea80e11c:	17ffffbb 	b	ffffffffea80e008 <trusty_sm_stdcall+0x78>
	switch (args->smc_nr) {
ffffffffea80e120:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80e124:	17ffffd1 	b	ffffffffea80e068 <trusty_sm_stdcall+0xd8>
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80e128:	910093a3 	add	x3, x29, #0x24
ffffffffea80e12c:	910083a2 	add	x2, x29, #0x20
ffffffffea80e130:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80e134:	97ffff4f 	bl	ffffffffea80de70 <get_ns_mem_buf>
ffffffffea80e138:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR) {
ffffffffea80e13c:	b5fff660 	cbnz	x0, ffffffffea80e008 <trusty_sm_stdcall+0x78>
			res = virtio_get_description(ns_pa, ns_sz,
ffffffffea80e140:	29440ba1 	ldp	w1, w2, [x29, #32]
ffffffffea80e144:	2a1303e3 	mov	w3, w19
ffffffffea80e148:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80e14c:	940000d5 	bl	ffffffffea80e4a0 <virtio_get_description>
ffffffffea80e150:	17ffffae 	b	ffffffffea80e008 <trusty_sm_stdcall+0x78>
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80e154:	910093a3 	add	x3, x29, #0x24
ffffffffea80e158:	910083a2 	add	x2, x29, #0x20
ffffffffea80e15c:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80e160:	97ffff44 	bl	ffffffffea80de70 <get_ns_mem_buf>
ffffffffea80e164:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR) {
ffffffffea80e168:	b5fff500 	cbnz	x0, ffffffffea80e008 <trusty_sm_stdcall+0x78>
			res = virtio_stop(ns_pa, ns_sz, ns_mmu_flags, guest);
ffffffffea80e16c:	29440ba1 	ldp	w1, w2, [x29, #32]
ffffffffea80e170:	2a1303e3 	mov	w3, w19
ffffffffea80e174:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80e178:	940001b2 	bl	ffffffffea80e840 <virtio_stop>
ffffffffea80e17c:	93407c00 	sxtw	x0, w0
ffffffffea80e180:	17ffffa2 	b	ffffffffea80e008 <trusty_sm_stdcall+0x78>
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80e184:	910093a3 	add	x3, x29, #0x24
ffffffffea80e188:	910083a2 	add	x2, x29, #0x20
ffffffffea80e18c:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80e190:	97ffff38 	bl	ffffffffea80de70 <get_ns_mem_buf>
ffffffffea80e194:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR)
ffffffffea80e198:	b5fff380 	cbnz	x0, ffffffffea80e008 <trusty_sm_stdcall+0x78>
			res = ql_tipc_create_device(ns_pa, ns_sz, ns_mmu_flags);
ffffffffea80e19c:	29440ba1 	ldp	w1, w2, [x29, #32]
ffffffffea80e1a0:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80e1a4:	940006bd 	bl	ffffffffea80fc98 <ql_tipc_create_device>
ffffffffea80e1a8:	17ffff98 	b	ffffffffea80e008 <trusty_sm_stdcall+0x78>
		res = virtio_device_reset(args->params[0], guest);
ffffffffea80e1ac:	b9400460 	ldr	w0, [x3, #4]
ffffffffea80e1b0:	2a1303e1 	mov	w1, w19
ffffffffea80e1b4:	940001d3 	bl	ffffffffea80e900 <virtio_device_reset>
ffffffffea80e1b8:	93407c00 	sxtw	x0, w0
		break;
ffffffffea80e1bc:	17ffff93 	b	ffffffffea80e008 <trusty_sm_stdcall+0x78>
		res = lock_bl_data_interface();
ffffffffea80e1c0:	97ffff6e 	bl	ffffffffea80df78 <lock_bl_data_interface>
		break;
ffffffffea80e1c4:	17ffff91 	b	ffffffffea80e008 <trusty_sm_stdcall+0x78>
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80e1c8:	910093a3 	add	x3, x29, #0x24
ffffffffea80e1cc:	910083a2 	add	x2, x29, #0x20
ffffffffea80e1d0:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80e1d4:	97ffff27 	bl	ffffffffea80de70 <get_ns_mem_buf>
ffffffffea80e1d8:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR)
ffffffffea80e1dc:	b5fff160 	cbnz	x0, ffffffffea80e008 <trusty_sm_stdcall+0x78>
			res = ql_tipc_shutdown_device(ns_pa);
ffffffffea80e1e0:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80e1e4:	9400070b 	bl	ffffffffea80fe10 <ql_tipc_shutdown_device>
ffffffffea80e1e8:	17ffff88 	b	ffffffffea80e008 <trusty_sm_stdcall+0x78>
		TRACEF("%s: Error. Unexpected guestID %u\n",
ffffffffea80e1ec:	b0000043 	adrp	x3, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e1f0:	b0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e1f4:	b0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e1f8:	2a1303e4 	mov	w4, w19
ffffffffea80e1fc:	911f0063 	add	x3, x3, #0x7c0
ffffffffea80e200:	52801322 	mov	w2, #0x99                  	// #153
ffffffffea80e204:	911e0021 	add	x1, x1, #0x780
ffffffffea80e208:	91214000 	add	x0, x0, #0x850
ffffffffea80e20c:	94001409 	bl	ffffffffea813230 <_printf>
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80e210:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80e214:	17ffff7e 	b	ffffffffea80e00c <trusty_sm_stdcall+0x7c>

ffffffffea80e218 <smc_hv_init>:
}
ffffffffea80e218:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80e21c:	d65f03c0 	ret

ffffffffea80e220 <map_descr>:
	.addl_guests_virtio_bus = NULL,
};

static status_t map_descr(ns_paddr_t buf_pa, void **buf_va, ns_size_t sz,
                          uint buf_mmu_flags, uint32_t guest_id)
{
ffffffffea80e220:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80e224:	910003fd 	mov	x29, sp
ffffffffea80e228:	f9001bf7 	str	x23, [sp, #48]
	status_t ret;
	size_t roundedup_sz;

	if (!buf_pa) {
ffffffffea80e22c:	b4000640 	cbz	x0, ffffffffea80e2f4 <map_descr+0xd4>
ffffffffea80e230:	f9000fb4 	str	x20, [x29, #24]
		LTRACEF("invalid descr addr 0x%llx\n", buf_pa);
		return ERR_INVALID_ARGS;
	}

	if (buf_pa & (PAGE_SIZE-1)) {
ffffffffea80e234:	f2402c1f 	tst	x0, #0xfff
ffffffffea80e238:	aa0003f4 	mov	x20, x0
ffffffffea80e23c:	54000561 	b.ne	ffffffffea80e2e8 <map_descr+0xc8>  // b.any
ffffffffea80e240:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80e244:	2a0203f3 	mov	w19, w2
		LTRACEF("unsuported addr range 0x%llx\n", buf_pa);
		return ERR_INVALID_ARGS;
	}
#endif

	roundedup_sz = ROUNDUP(sz, PAGE_SIZE);
ffffffffea80e248:	913ffe73 	add	x19, x19, #0xfff
ffffffffea80e24c:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80e250:	9274ce73 	and	x19, x19, #0xfffffffffffff000
ffffffffea80e254:	2a0303f5 	mov	w21, w3
ffffffffea80e258:	aa0103f6 	mov	x22, x1
ffffffffea80e25c:	2a0403e2 	mov	w2, w4
	ret = trusty_hyp_check_guest_pa_valid(buf_pa, roundedup_sz, guest_id);
ffffffffea80e260:	aa1303e1 	mov	x1, x19
ffffffffea80e264:	97ffd15d 	bl	ffffffffea8027d8 <trusty_hyp_check_guest_pa_valid>
ffffffffea80e268:	2a0003f7 	mov	w23, w0
	if (ret != NO_ERROR) {
ffffffffea80e26c:	35000200 	cbnz	w0, ffffffffea80e2ac <map_descr+0x8c>
			__func__, ret);
		return ret;
	}

	/* map resource table into our address space */
	return  vmm_alloc_physical(vmm_get_kernel_aspace(), "virtio",
ffffffffea80e270:	2a1503e7 	mov	w7, w21
ffffffffea80e274:	aa1403e5 	mov	x5, x20
ffffffffea80e278:	aa1603e3 	mov	x3, x22
ffffffffea80e27c:	aa1303e2 	mov	x2, x19
ffffffffea80e280:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80e284:	b0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e288:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80e28c:	90000280 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
	                           roundedup_sz,
	                           buf_va, PAGE_SIZE_SHIFT,
	                           (paddr_t) buf_pa, 0, buf_mmu_flags);
}
ffffffffea80e290:	f9401bf7 	ldr	x23, [sp, #48]
	return  vmm_alloc_physical(vmm_get_kernel_aspace(), "virtio",
ffffffffea80e294:	52800006 	mov	w6, #0x0                   	// #0
}
ffffffffea80e298:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return  vmm_alloc_physical(vmm_get_kernel_aspace(), "virtio",
ffffffffea80e29c:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea80e2a0:	91252021 	add	x1, x1, #0x948
ffffffffea80e2a4:	91034000 	add	x0, x0, #0xd0
ffffffffea80e2a8:	14000c3c 	b	ffffffffea811398 <vmm_alloc_physical>
		TRACEF("%s: check_guest_pa_valid failed, error = %d",
ffffffffea80e2ac:	b0000045 	adrp	x5, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e2b0:	2a0003e4 	mov	w4, w0
ffffffffea80e2b4:	b0000043 	adrp	x3, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e2b8:	b0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e2bc:	91230063 	add	x3, x3, #0x8c0
ffffffffea80e2c0:	52800e42 	mov	w2, #0x72                  	// #114
ffffffffea80e2c4:	91220021 	add	x1, x1, #0x880
ffffffffea80e2c8:	911ae0a0 	add	x0, x5, #0x6b8
ffffffffea80e2cc:	940013d9 	bl	ffffffffea813230 <_printf>
		return ret;
ffffffffea80e2d0:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80e2d4:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea80e2d8:	2a1703e0 	mov	w0, w23
ffffffffea80e2dc:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80e2e0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80e2e4:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80e2e8:	128000f7 	mov	w23, #0xfffffff8            	// #-8
ffffffffea80e2ec:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80e2f0:	17fffffa 	b	ffffffffea80e2d8 <map_descr+0xb8>
ffffffffea80e2f4:	128000f7 	mov	w23, #0xfffffff8            	// #-8
ffffffffea80e2f8:	17fffff8 	b	ffffffffea80e2d8 <map_descr+0xb8>
ffffffffea80e2fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e300 <get_guest_virtio_bus.constprop.2>:
	if (vb == NULL) {
		TRACEF("%s: Bad pointer. vb is NULL\n", __func__);
		return ERR_INVALID_ARGS;
	}

	if (guest_id > 0) {
ffffffffea80e300:	34000321 	cbz	w1, ffffffffea80e364 <get_guest_virtio_bus.constprop.2+0x64>
static status_t get_guest_virtio_bus(struct trusty_virtio_bus **vb,
ffffffffea80e304:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80e308:	910003fd 	mov	x29, sp
ffffffffea80e30c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80e310:	aa0003f4 	mov	x20, x0
		if (guest_id >= guests_vbus_context.num_guests) {
ffffffffea80e314:	f0000040 	adrp	x0, ffffffffea819000 <_mem_phys_base>
static status_t get_guest_virtio_bus(struct trusty_virtio_bus **vb,
ffffffffea80e318:	f90013f5 	str	x21, [sp, #32]
ffffffffea80e31c:	2a0103f3 	mov	w19, w1
		if (guest_id >= guests_vbus_context.num_guests) {
ffffffffea80e320:	91392015 	add	x21, x0, #0xe48
ffffffffea80e324:	b94e4805 	ldr	w5, [x0, #3656]
ffffffffea80e328:	6b05003f 	cmp	w1, w5
ffffffffea80e32c:	540002a2 	b.cs	ffffffffea80e380 <get_guest_virtio_bus.constprop.2+0x80>  // b.hs, b.nlast
				__func__, guest_id, guests_vbus_context.num_guests);
			return ERR_INVALID_ARGS;
		}

		/* Barrier against speculating addl_guests_virtio_bus[guest_id - 1] */
		platform_arch_speculation_barrier();
ffffffffea80e330:	97ffcfc0 	bl	ffffffffea802230 <platform_arch_speculation_barrier>

		if (guests_vbus_context.addl_guests_virtio_bus == NULL) {
ffffffffea80e334:	f9401aa4 	ldr	x4, [x21, #48]
ffffffffea80e338:	b40003a4 	cbz	x4, ffffffffea80e3ac <get_guest_virtio_bus.constprop.2+0xac>
			TRACEF("%s: addl_guests_virtio_bus init failed\n",
				 __func__);
			return ERR_NOT_READY;
		}

		*vb = guests_vbus_context.addl_guests_virtio_bus + (guest_id - 1);
ffffffffea80e33c:	51000661 	sub	w1, w19, #0x1
ffffffffea80e340:	52800513 	mov	w19, #0x28                  	// #40
	} else {
		*vb = &guests_vbus_context.guest0_virtio_bus;
	}

	return NO_ERROR;
ffffffffea80e344:	52800002 	mov	w2, #0x0                   	// #0
		*vb = guests_vbus_context.addl_guests_virtio_bus + (guest_id - 1);
ffffffffea80e348:	9bb31021 	umaddl	x1, w1, w19, x4
ffffffffea80e34c:	f9000281 	str	x1, [x20]
}
ffffffffea80e350:	2a0203e0 	mov	w0, w2
ffffffffea80e354:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80e358:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e35c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e360:	d65f03c0 	ret
		*vb = &guests_vbus_context.guest0_virtio_bus;
ffffffffea80e364:	f0000041 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea80e368:	91392021 	add	x1, x1, #0xe48
ffffffffea80e36c:	91002021 	add	x1, x1, #0x8
	return NO_ERROR;
ffffffffea80e370:	52800002 	mov	w2, #0x0                   	// #0
		*vb = &guests_vbus_context.guest0_virtio_bus;
ffffffffea80e374:	f9000001 	str	x1, [x0]
}
ffffffffea80e378:	2a0203e0 	mov	w0, w2
ffffffffea80e37c:	d65f03c0 	ret
			TRACEF("%s: Bad input, guest %d regd_guests %d\n",
ffffffffea80e380:	528014c2 	mov	w2, #0xa6                  	// #166
ffffffffea80e384:	b0000043 	adrp	x3, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e388:	b0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e38c:	b0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e390:	2a1303e4 	mov	w4, w19
ffffffffea80e394:	91234063 	add	x3, x3, #0x8d0
ffffffffea80e398:	91224021 	add	x1, x1, #0x890
ffffffffea80e39c:	9123a000 	add	x0, x0, #0x8e8
ffffffffea80e3a0:	940013a4 	bl	ffffffffea813230 <_printf>
			return ERR_INVALID_ARGS;
ffffffffea80e3a4:	128000e2 	mov	w2, #0xfffffff8            	// #-8
ffffffffea80e3a8:	17ffffea 	b	ffffffffea80e350 <get_guest_virtio_bus.constprop.2+0x50>
			TRACEF("%s: addl_guests_virtio_bus init failed\n",
ffffffffea80e3ac:	528015e2 	mov	w2, #0xaf                  	// #175
ffffffffea80e3b0:	b0000043 	adrp	x3, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e3b4:	b0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e3b8:	b0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e3bc:	91234063 	add	x3, x3, #0x8d0
ffffffffea80e3c0:	91224021 	add	x1, x1, #0x890
ffffffffea80e3c4:	91246000 	add	x0, x0, #0x918
ffffffffea80e3c8:	9400139a 	bl	ffffffffea813230 <_printf>
ffffffffea80e3cc:	12800042 	mov	w2, #0xfffffffd            	// #-3
ffffffffea80e3d0:	17ffffe0 	b	ffffffffea80e350 <get_guest_virtio_bus.constprop.2+0x50>
ffffffffea80e3d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e3d8 <virtio_register_device>:

/*
 *     Register virtio device
 */
status_t virtio_register_device(struct vdev *vd, uint32_t guest_id)
{
ffffffffea80e3d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	status_t ret = ERR_BAD_STATE;
	struct trusty_virtio_bus *vb = NULL;

	guests_vbus_context.num_guests++;
ffffffffea80e3dc:	f0000043 	adrp	x3, ffffffffea819000 <_mem_phys_base>
{
ffffffffea80e3e0:	910003fd 	mov	x29, sp
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e3e4:	9100c3a2 	add	x2, x29, #0x30
{
ffffffffea80e3e8:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80e3ec:	aa0003f3 	mov	x19, x0
	guests_vbus_context.num_guests++;
ffffffffea80e3f0:	b94e4860 	ldr	w0, [x3, #3656]
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e3f4:	f81f8c5f 	str	xzr, [x2, #-8]!
	guests_vbus_context.num_guests++;
ffffffffea80e3f8:	11000400 	add	w0, w0, #0x1
ffffffffea80e3fc:	b90e4860 	str	w0, [x3, #3656]

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e400:	aa0203e0 	mov	x0, x2
ffffffffea80e404:	97ffffbf 	bl	ffffffffea80e300 <get_guest_virtio_bus.constprop.2>
ffffffffea80e408:	35000420 	cbnz	w0, ffffffffea80e48c <virtio_register_device+0xb4>
		return ERR_INVALID_ARGS;
	}

	if (vb->state == VIRTIO_BUS_STATE_UNINITIALIZED) {
ffffffffea80e40c:	f94017a1 	ldr	x1, [x29, #40]
ffffffffea80e410:	b9401022 	ldr	w2, [x1, #16]
ffffffffea80e414:	35000402 	cbnz	w2, ffffffffea80e494 <virtio_register_device+0xbc>
	if (!vd) {
ffffffffea80e418:	b40003b3 	cbz	x19, ffffffffea80e48c <virtio_register_device+0xb4>
	if (!vd->ops) {
ffffffffea80e41c:	f9401262 	ldr	x2, [x19, #32]
ffffffffea80e420:	b4000362 	cbz	x2, ffffffffea80e48c <virtio_register_device+0xb4>
	if (!ops->descr_sz || !ops->get_descr ||
ffffffffea80e424:	f9400043 	ldr	x3, [x2]
ffffffffea80e428:	b4000323 	cbz	x3, ffffffffea80e48c <virtio_register_device+0xb4>
ffffffffea80e42c:	f9400443 	ldr	x3, [x2, #8]
ffffffffea80e430:	b40002e3 	cbz	x3, ffffffffea80e48c <virtio_register_device+0xb4>
ffffffffea80e434:	f9400843 	ldr	x3, [x2, #16]
ffffffffea80e438:	b40002a3 	cbz	x3, ffffffffea80e48c <virtio_register_device+0xb4>
	    !ops->probe || !ops->reset || !ops->kick_vqueue) {
ffffffffea80e43c:	f9400c43 	ldr	x3, [x2, #24]
ffffffffea80e440:	b4000263 	cbz	x3, ffffffffea80e48c <virtio_register_device+0xb4>
ffffffffea80e444:	f9401042 	ldr	x2, [x2, #32]
ffffffffea80e448:	b4000222 	cbz	x2, ffffffffea80e48c <virtio_register_device+0xb4>
		ret = validate_vdev(vd);
		if (ret == NO_ERROR) {
			vb->vdev_cnt++;
			vd->devid = vb->next_dev_id++;
ffffffffea80e44c:	29401423 	ldp	w3, w5, [x1]
	item->prev = list->prev;
ffffffffea80e450:	aa0103e2 	mov	x2, x1
			list_add_tail(&vb->vdev_list, &vd->node);
ffffffffea80e454:	91004264 	add	x4, x19, #0x10
			vb->vdev_cnt++;
ffffffffea80e458:	11000463 	add	w3, w3, #0x1
			vd->devid = vb->next_dev_id++;
ffffffffea80e45c:	110004a6 	add	w6, w5, #0x1
			vb->vdev_cnt++;
ffffffffea80e460:	b9000023 	str	w3, [x1]
ffffffffea80e464:	f8418c43 	ldr	x3, [x2, #24]!
			vd->devid = vb->next_dev_id++;
ffffffffea80e468:	b9000426 	str	w6, [x1, #4]
	item->next = list;
ffffffffea80e46c:	a9010a63 	stp	x3, x2, [x19, #16]
ffffffffea80e470:	b9000665 	str	w5, [x19, #4]
	list->prev->next = item;
ffffffffea80e474:	f9400c22 	ldr	x2, [x1, #24]
ffffffffea80e478:	f9000444 	str	x4, [x2, #8]
	list->prev = item;
ffffffffea80e47c:	f9000c24 	str	x4, [x1, #24]
		}
	}
	return ret;
}
ffffffffea80e480:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80e484:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e488:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80e48c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80e490:	17fffffc 	b	ffffffffea80e480 <virtio_register_device+0xa8>
	status_t ret = ERR_BAD_STATE;
ffffffffea80e494:	128003c0 	mov	w0, #0xffffffe1            	// #-31
ffffffffea80e498:	17fffffa 	b	ffffffffea80e480 <virtio_register_device+0xa8>
ffffffffea80e49c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e4a0 <virtio_get_description>:
/*
 * Retrieve device description to be shared with NS side
 */
ssize_t virtio_get_description(ns_paddr_t buf_pa, ns_size_t buf_sz,
                               uint buf_mmu_flags, uint32_t guest_id)
{
ffffffffea80e4a0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80e4a4:	910003fd 	mov	x29, sp
	status_t ret;
	struct vdev *vd;
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e4a8:	910183a4 	add	x4, x29, #0x60
{
ffffffffea80e4ac:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea80e4b0:	a903e7f8 	stp	x24, x25, [sp, #56]
ffffffffea80e4b4:	2a0103f7 	mov	w23, w1
ffffffffea80e4b8:	aa0003f8 	mov	x24, x0
ffffffffea80e4bc:	2a0303f6 	mov	w22, w3
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e4c0:	f81f0c9f 	str	xzr, [x4, #-16]!
{
ffffffffea80e4c4:	2a0203f9 	mov	w25, w2

	LTRACEF("descr_buf: %u bytes @ 0x%llx\n", buf_sz, buf_pa);

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e4c8:	2a0303e1 	mov	w1, w3
ffffffffea80e4cc:	aa0403e0 	mov	x0, x4
ffffffffea80e4d0:	97ffff8c 	bl	ffffffffea80e300 <get_guest_virtio_bus.constprop.2>
ffffffffea80e4d4:	35000e40 	cbnz	w0, ffffffffea80e69c <virtio_get_description+0x1fc>
ffffffffea80e4d8:	f90013b5 	str	x21, [x29, #32]
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e4dc:	910183b5 	add	x21, x29, #0x60
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e4e0:	2a1603e1 	mov	w1, w22
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e4e4:	f81f8ebf 	str	xzr, [x21, #-8]!
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e4e8:	aa1503e0 	mov	x0, x21
ffffffffea80e4ec:	97ffff85 	bl	ffffffffea80e300 <get_guest_virtio_bus.constprop.2>
ffffffffea80e4f0:	35000bc0 	cbnz	w0, ffffffffea80e668 <virtio_get_description+0x1c8>
	if (vb->state == VIRTIO_BUS_STATE_UNINITIALIZED) {
ffffffffea80e4f4:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea80e4f8:	b9401020 	ldr	w0, [x1, #16]
ffffffffea80e4fc:	35000360 	cbnz	w0, ffffffffea80e568 <virtio_get_description+0xc8>
ffffffffea80e500:	a90153b3 	stp	x19, x20, [x29, #16]
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e504:	91006020 	add	x0, x1, #0x18
		uint32_t offset = sizeof(struct resource_table) +
ffffffffea80e508:	b9400034 	ldr	w20, [x1]
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e50c:	f9401022 	ldr	x2, [x1, #32]
		uint32_t offset = sizeof(struct resource_table) +
ffffffffea80e510:	11001294 	add	w20, w20, #0x4
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e514:	d1004053 	sub	x19, x2, #0x10
ffffffffea80e518:	eb02001f 	cmp	x0, x2
		uint32_t offset = sizeof(struct resource_table) +
ffffffffea80e51c:	531e7694 	lsl	w20, w20, #2
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e520:	540001c0 	b.eq	ffffffffea80e558 <virtio_get_description+0xb8>  // b.none
ffffffffea80e524:	d503201f 	nop
			offset += vd->ops->descr_sz(vd);
ffffffffea80e528:	f9401261 	ldr	x1, [x19, #32]
ffffffffea80e52c:	aa1303e0 	mov	x0, x19
ffffffffea80e530:	f9400021 	ldr	x1, [x1]
			vd->descr_offset = offset;
ffffffffea80e534:	b9000a74 	str	w20, [x19, #8]
			offset += vd->ops->descr_sz(vd);
ffffffffea80e538:	d63f0020 	blr	x1
ffffffffea80e53c:	0b000294 	add	w20, w20, w0
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e540:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea80e544:	f9400e62 	ldr	x2, [x19, #24]
ffffffffea80e548:	91006020 	add	x0, x1, #0x18
ffffffffea80e54c:	d1004053 	sub	x19, x2, #0x10
ffffffffea80e550:	eb00005f 	cmp	x2, x0
ffffffffea80e554:	54fffea1 	b.ne	ffffffffea80e528 <virtio_get_description+0x88>  // b.any
		vb->descr_size = offset;
ffffffffea80e558:	f9000434 	str	x20, [x1, #8]
		vb->state = VIRTIO_BUS_STATE_IDLE;
ffffffffea80e55c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80e560:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80e564:	b9001020 	str	w0, [x1, #16]
	if (ret != NO_ERROR) {
		TRACEF("failed (%d) finalize_vdev_registery\n", ret);
		return ret;
	}

	if ((size_t)buf_sz < vb->descr_size) {
ffffffffea80e568:	f9402ba0 	ldr	x0, [x29, #80]
ffffffffea80e56c:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80e570:	eb37405f 	cmp	x2, w23, uxtw
ffffffffea80e574:	54000988 	b.hi	ffffffffea80e6a4 <virtio_get_description+0x204>  // b.pmore
		return ERR_NOT_ENOUGH_BUFFER;
	}

	/* map in NS memory */
	void *va = NULL;
	ret = map_descr(buf_pa, &va, vb->descr_size, buf_mmu_flags, guest_id);
ffffffffea80e578:	2a1603e4 	mov	w4, w22
ffffffffea80e57c:	2a1903e3 	mov	w3, w25
ffffffffea80e580:	aa1503e1 	mov	x1, x21
ffffffffea80e584:	aa1803e0 	mov	x0, x24
	void *va = NULL;
ffffffffea80e588:	f9002fbf 	str	xzr, [x29, #88]
	ret = map_descr(buf_pa, &va, vb->descr_size, buf_mmu_flags, guest_id);
ffffffffea80e58c:	97ffff25 	bl	ffffffffea80e220 <map_descr>
	if (ret != NO_ERROR) {
ffffffffea80e590:	340000e0 	cbz	w0, ffffffffea80e5ac <virtio_get_description+0x10c>
		LTRACEF("failed (%d) to map in descriptor buffer\n",
			(int)ret);
		return ret;
ffffffffea80e594:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80e598:	93407c00 	sxtw	x0, w0
	}

	unmap_descr(buf_pa, va, vb->descr_size);

	return vb->descr_size;
}
ffffffffea80e59c:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80e5a0:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea80e5a4:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80e5a8:	d65f03c0 	ret
	memset(va, 0, vb->descr_size);
ffffffffea80e5ac:	a94503a2 	ldp	x2, x0, [x29, #80]
ffffffffea80e5b0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80e5b4:	f9400442 	ldr	x2, [x2, #8]
ffffffffea80e5b8:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80e5bc:	94001419 	bl	ffffffffea813620 <memset>
	trusty_virtio_descr_t *descr = (trusty_virtio_descr_t *)va;
ffffffffea80e5c0:	a94557a0 	ldp	x0, x21, [x29, #80]
	descr->ver = VIRTIO_FW_RSC_VER;
ffffffffea80e5c4:	52800023 	mov	w3, #0x1                   	// #1
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e5c8:	91006001 	add	x1, x0, #0x18
	descr->num = vb->vdev_cnt;
ffffffffea80e5cc:	b9400002 	ldr	w2, [x0]
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e5d0:	f9401000 	ldr	x0, [x0, #32]
	descr->num = vb->vdev_cnt;
ffffffffea80e5d4:	29000aa3 	stp	w3, w2, [x21]
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e5d8:	d1004013 	sub	x19, x0, #0x10
ffffffffea80e5dc:	eb01001f 	cmp	x0, x1
ffffffffea80e5e0:	540002c0 	b.eq	ffffffffea80e638 <virtio_get_description+0x198>  // b.none
	uint32_t vdev_idx = 0;
ffffffffea80e5e4:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80e5e8:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80e5ec:	d503201f 	nop
		vd->ops->get_descr(vd, (uint8_t *)descr + vd->descr_offset);
ffffffffea80e5f0:	f9401262 	ldr	x2, [x19, #32]
		descr->offset[vdev_idx++] = vd->descr_offset;
ffffffffea80e5f4:	8b204aa3 	add	x3, x21, w0, uxtw #2
ffffffffea80e5f8:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea80e5fc:	11000414 	add	w20, w0, #0x1
		vd->ops->get_descr(vd, (uint8_t *)descr + vd->descr_offset);
ffffffffea80e600:	aa1303e0 	mov	x0, x19
ffffffffea80e604:	f9400442 	ldr	x2, [x2, #8]
		descr->offset[vdev_idx++] = vd->descr_offset;
ffffffffea80e608:	b9001061 	str	w1, [x3, #16]
		vd->ops->get_descr(vd, (uint8_t *)descr + vd->descr_offset);
ffffffffea80e60c:	8b2142a1 	add	x1, x21, w1, uxtw
ffffffffea80e610:	d63f0040 	blr	x2
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e614:	f9402ba1 	ldr	x1, [x29, #80]
		descr->offset[vdev_idx++] = vd->descr_offset;
ffffffffea80e618:	2a1403e0 	mov	w0, w20
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e61c:	f9400e62 	ldr	x2, [x19, #24]
ffffffffea80e620:	91006021 	add	x1, x1, #0x18
ffffffffea80e624:	d1004053 	sub	x19, x2, #0x10
ffffffffea80e628:	eb01005f 	cmp	x2, x1
ffffffffea80e62c:	54fffe21 	b.ne	ffffffffea80e5f0 <virtio_get_description+0x150>  // b.any
ffffffffea80e630:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80e634:	f9402fb5 	ldr	x21, [x29, #88]
	return vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)va);
ffffffffea80e638:	aa1503e1 	mov	x1, x21
ffffffffea80e63c:	90000280 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
ffffffffea80e640:	91034000 	add	x0, x0, #0xd0
ffffffffea80e644:	94000bb7 	bl	ffffffffea811520 <vmm_free_region>
	return vb->descr_size;
ffffffffea80e648:	f9402ba0 	ldr	x0, [x29, #80]
ffffffffea80e64c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80e650:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80e654:	f9400400 	ldr	x0, [x0, #8]
}
ffffffffea80e658:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80e65c:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea80e660:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80e664:	d65f03c0 	ret
		TRACEF("failed (%d) finalize_vdev_registery\n", ret);
ffffffffea80e668:	128000e3 	mov	w3, #0xfffffff8            	// #-8
ffffffffea80e66c:	528020c2 	mov	w2, #0x106                 	// #262
ffffffffea80e670:	b0000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e674:	b0000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80e678:	9122a021 	add	x1, x1, #0x8a8
ffffffffea80e67c:	91254000 	add	x0, x0, #0x950
ffffffffea80e680:	940012ec 	bl	ffffffffea813230 <_printf>
		return ret;
ffffffffea80e684:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80e688:	a942dff6 	ldp	x22, x23, [sp, #40]
		return ret;
ffffffffea80e68c:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
}
ffffffffea80e690:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea80e694:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80e698:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80e69c:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80e6a0:	17ffffbf 	b	ffffffffea80e59c <virtio_get_description+0xfc>
		return ERR_NOT_ENOUGH_BUFFER;
ffffffffea80e6a4:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
ffffffffea80e6a8:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80e6ac:	17ffffbc 	b	ffffffffea80e59c <virtio_get_description+0xfc>

ffffffffea80e6b0 <virtio_start>:
/*
 * Called by NS side to finalize device initialization
 */
status_t virtio_start(ns_paddr_t ns_descr_pa, ns_size_t descr_sz,
                      uint descr_mmu_flags, uint32_t guest_id)
{
ffffffffea80e6b0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80e6b4:	910003fd 	mov	x29, sp
	status_t ret;
	int oldstate;
	void *descr_va;
	void *ns_descr_va = NULL;
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e6b8:	910143a4 	add	x4, x29, #0x50
{
ffffffffea80e6bc:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80e6c0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80e6c4:	2a0103f3 	mov	w19, w1
ffffffffea80e6c8:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80e6cc:	aa0003f6 	mov	x22, x0
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e6d0:	f81f8c9f 	str	xzr, [x4, #-8]!
{
ffffffffea80e6d4:	2a0303f5 	mov	w21, w3

	LTRACEF("%u bytes @ 0x%llx\n", descr_sz, ns_descr_pa);

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e6d8:	2a0303e1 	mov	w1, w3
	void *ns_descr_va = NULL;
ffffffffea80e6dc:	f90023bf 	str	xzr, [x29, #64]
{
ffffffffea80e6e0:	2a0203f7 	mov	w23, w2
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e6e4:	aa0403e0 	mov	x0, x4
ffffffffea80e6e8:	97ffff06 	bl	ffffffffea80e300 <get_guest_virtio_bus.constprop.2>
ffffffffea80e6ec:	35000a60 	cbnz	w0, ffffffffea80e838 <virtio_start+0x188>
    __atomic_compare_exchange_n(ptr, &oldval, newval, false,
ffffffffea80e6f0:	f94027a1 	ldr	x1, [x29, #72]
ffffffffea80e6f4:	52800042 	mov	w2, #0x2                   	// #2
ffffffffea80e6f8:	91004021 	add	x1, x1, #0x10
ffffffffea80e6fc:	885f7c20 	ldxr	w0, [x1]
ffffffffea80e700:	7100041f 	cmp	w0, #0x1
ffffffffea80e704:	54000061 	b.ne	ffffffffea80e710 <virtio_start+0x60>  // b.any
ffffffffea80e708:	88037c22 	stxr	w3, w2, [x1]
ffffffffea80e70c:	35ffff83 	cbnz	w3, ffffffffea80e6fc <virtio_start+0x4c>

	oldstate = atomic_cmpxchg(&vb->state,
				  VIRTIO_BUS_STATE_IDLE,
				  VIRTIO_BUS_STATE_ACTIVATING);

	if (oldstate != VIRTIO_BUS_STATE_IDLE) {
ffffffffea80e710:	7100041f 	cmp	w0, #0x1
ffffffffea80e714:	540008e1 	b.ne	ffffffffea80e830 <virtio_start+0x180>  // b.any
		/* bus should be in initializing state */
		LTRACEF("unexpected state state (%d)\n", oldstate);
		return ERR_BAD_STATE;
	}

	if ((size_t)descr_sz != vb->descr_size) {
ffffffffea80e718:	f94027a0 	ldr	x0, [x29, #72]
		LTRACEF("unexpected descriptor size (%zd vs. %zd)\n",
			(size_t)descr_sz, vb->descr_size);
		ret = ERR_INVALID_ARGS;
ffffffffea80e71c:	128000f4 	mov	w20, #0xfffffff8            	// #-8
	if ((size_t)descr_sz != vb->descr_size) {
ffffffffea80e720:	f9400401 	ldr	x1, [x0, #8]
ffffffffea80e724:	eb01027f 	cmp	x19, x1
ffffffffea80e728:	54000120 	b.eq	ffffffffea80e74c <virtio_start+0x9c>  // b.none

err_map_in:
	free(descr_va);
err_alloc_descr:
err_bad_params:
	vb->state = oldstate;
ffffffffea80e72c:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea80e730:	b9001001 	str	w1, [x0, #16]
	return ret;
}
ffffffffea80e734:	2a1403e0 	mov	w0, w20
ffffffffea80e738:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80e73c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e740:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80e744:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80e748:	d65f03c0 	ret
ffffffffea80e74c:	f9001fb8 	str	x24, [x29, #56]
	descr_va = malloc(descr_sz);
ffffffffea80e750:	aa1303e0 	mov	x0, x19
ffffffffea80e754:	940012df 	bl	ffffffffea8132d0 <malloc>
ffffffffea80e758:	aa0003f8 	mov	x24, x0
	if (!descr_va) {
ffffffffea80e75c:	b4000580 	cbz	x0, ffffffffea80e80c <virtio_start+0x15c>
	ret = map_descr(ns_descr_pa, &ns_descr_va, vb->descr_size, descr_mmu_flags, guest_id);
ffffffffea80e760:	f94027a2 	ldr	x2, [x29, #72]
ffffffffea80e764:	2a1503e4 	mov	w4, w21
ffffffffea80e768:	2a1703e3 	mov	w3, w23
ffffffffea80e76c:	910103a1 	add	x1, x29, #0x40
ffffffffea80e770:	aa1603e0 	mov	x0, x22
ffffffffea80e774:	b9400842 	ldr	w2, [x2, #8]
ffffffffea80e778:	97fffeaa 	bl	ffffffffea80e220 <map_descr>
ffffffffea80e77c:	2a0003f4 	mov	w20, w0
	if (ret != NO_ERROR) {
ffffffffea80e780:	350004e0 	cbnz	w0, ffffffffea80e81c <virtio_start+0x16c>
	memcpy(descr_va, ns_descr_va, descr_sz);
ffffffffea80e784:	f94023a1 	ldr	x1, [x29, #64]
ffffffffea80e788:	aa1303e2 	mov	x2, x19
ffffffffea80e78c:	aa1803e0 	mov	x0, x24
ffffffffea80e790:	940012e8 	bl	ffffffffea813330 <memcpy>
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e794:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80e798:	91006001 	add	x1, x0, #0x18
ffffffffea80e79c:	f9401000 	ldr	x0, [x0, #32]
ffffffffea80e7a0:	d1004013 	sub	x19, x0, #0x10
ffffffffea80e7a4:	eb00003f 	cmp	x1, x0
ffffffffea80e7a8:	540001c0 	b.eq	ffffffffea80e7e0 <virtio_start+0x130>  // b.none
ffffffffea80e7ac:	d503201f 	nop
		vd->ops->probe(vd, (void*)((uint8_t*)descr_va + vd->descr_offset));
ffffffffea80e7b0:	f9401262 	ldr	x2, [x19, #32]
ffffffffea80e7b4:	aa1303e0 	mov	x0, x19
ffffffffea80e7b8:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea80e7bc:	f9400842 	ldr	x2, [x2, #16]
ffffffffea80e7c0:	8b010301 	add	x1, x24, x1
ffffffffea80e7c4:	d63f0040 	blr	x2
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e7c8:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80e7cc:	f9400e61 	ldr	x1, [x19, #24]
ffffffffea80e7d0:	91006000 	add	x0, x0, #0x18
ffffffffea80e7d4:	d1004033 	sub	x19, x1, #0x10
ffffffffea80e7d8:	eb00003f 	cmp	x1, x0
ffffffffea80e7dc:	54fffea1 	b.ne	ffffffffea80e7b0 <virtio_start+0x100>  // b.any
	return vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)va);
ffffffffea80e7e0:	f94023a1 	ldr	x1, [x29, #64]
ffffffffea80e7e4:	90000280 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
ffffffffea80e7e8:	91034000 	add	x0, x0, #0xd0
ffffffffea80e7ec:	94000b4d 	bl	ffffffffea811520 <vmm_free_region>
	free(descr_va);
ffffffffea80e7f0:	aa1803e0 	mov	x0, x24
ffffffffea80e7f4:	940012cd 	bl	ffffffffea813328 <free>
	vb->state = VIRTIO_BUS_STATE_ACTIVE;
ffffffffea80e7f8:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80e7fc:	52800061 	mov	w1, #0x3                   	// #3
	return NO_ERROR;
ffffffffea80e800:	f9401fb8 	ldr	x24, [x29, #56]
	vb->state = VIRTIO_BUS_STATE_ACTIVE;
ffffffffea80e804:	b9001001 	str	w1, [x0, #16]
	return NO_ERROR;
ffffffffea80e808:	17ffffcb 	b	ffffffffea80e734 <virtio_start+0x84>
		ret = ERR_NO_MEMORY;
ffffffffea80e80c:	12800094 	mov	w20, #0xfffffffb            	// #-5
ffffffffea80e810:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80e814:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80e818:	17ffffc5 	b	ffffffffea80e72c <virtio_start+0x7c>
	free(descr_va);
ffffffffea80e81c:	aa1803e0 	mov	x0, x24
ffffffffea80e820:	940012c2 	bl	ffffffffea813328 <free>
ffffffffea80e824:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80e828:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80e82c:	17ffffc0 	b	ffffffffea80e72c <virtio_start+0x7c>
		return ERR_BAD_STATE;
ffffffffea80e830:	128003d4 	mov	w20, #0xffffffe1            	// #-31
ffffffffea80e834:	17ffffc0 	b	ffffffffea80e734 <virtio_start+0x84>
		return ERR_INVALID_ARGS;
ffffffffea80e838:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80e83c:	17ffffbe 	b	ffffffffea80e734 <virtio_start+0x84>

ffffffffea80e840 <virtio_stop>:

status_t virtio_stop(ns_paddr_t descr_pa, ns_size_t descr_sz,
		     uint descr_mmu_flags, uint32_t guest_id)
{
ffffffffea80e840:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	struct vdev *vd;
	struct trusty_virtio_bus *vb = NULL;

	LTRACEF("%u bytes @ 0x%llx\n", descr_sz, descr_pa);

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e844:	2a0303e1 	mov	w1, w3
{
ffffffffea80e848:	910003fd 	mov	x29, sp
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e84c:	9100c3a0 	add	x0, x29, #0x30
{
ffffffffea80e850:	f9000ff4 	str	x20, [sp, #24]
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e854:	f81f8c1f 	str	xzr, [x0, #-8]!
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e858:	97fffeaa 	bl	ffffffffea80e300 <get_guest_virtio_bus.constprop.2>
ffffffffea80e85c:	350004c0 	cbnz	w0, ffffffffea80e8f4 <virtio_stop+0xb4>
ffffffffea80e860:	2a0003f4 	mov	w20, w0
ffffffffea80e864:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80e868:	52800082 	mov	w2, #0x4                   	// #4
ffffffffea80e86c:	91004000 	add	x0, x0, #0x10
ffffffffea80e870:	885f7c01 	ldxr	w1, [x0]
ffffffffea80e874:	71000c3f 	cmp	w1, #0x3
ffffffffea80e878:	54000061 	b.ne	ffffffffea80e884 <virtio_stop+0x44>  // b.any
ffffffffea80e87c:	88037c02 	stxr	w3, w2, [x0]
ffffffffea80e880:	35ffff83 	cbnz	w3, ffffffffea80e870 <virtio_stop+0x30>

	oldstate = atomic_cmpxchg(&vb->state,
				  VIRTIO_BUS_STATE_ACTIVE,
				  VIRTIO_BUS_STATE_DEACTIVATING);

	if (oldstate != VIRTIO_BUS_STATE_ACTIVE) {
ffffffffea80e884:	71000c3f 	cmp	w1, #0x3
ffffffffea80e888:	54000321 	b.ne	ffffffffea80e8ec <virtio_stop+0xac>  // b.any
		return ERR_BAD_STATE;
	}
	/* reset all devices */
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e88c:	f94017a1 	ldr	x1, [x29, #40]
ffffffffea80e890:	91006022 	add	x2, x1, #0x18
ffffffffea80e894:	f9401020 	ldr	x0, [x1, #32]
ffffffffea80e898:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80e89c:	eb02001f 	cmp	x0, x2
ffffffffea80e8a0:	d1004013 	sub	x19, x0, #0x10
ffffffffea80e8a4:	54000160 	b.eq	ffffffffea80e8d0 <virtio_stop+0x90>  // b.none
		vd->ops->reset(vd);
ffffffffea80e8a8:	f9401261 	ldr	x1, [x19, #32]
ffffffffea80e8ac:	aa1303e0 	mov	x0, x19
ffffffffea80e8b0:	f9400c21 	ldr	x1, [x1, #24]
ffffffffea80e8b4:	d63f0020 	blr	x1
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e8b8:	f94017a1 	ldr	x1, [x29, #40]
ffffffffea80e8bc:	f9400e60 	ldr	x0, [x19, #24]
ffffffffea80e8c0:	91006022 	add	x2, x1, #0x18
ffffffffea80e8c4:	d1004013 	sub	x19, x0, #0x10
ffffffffea80e8c8:	eb02001f 	cmp	x0, x2
ffffffffea80e8cc:	54fffee1 	b.ne	ffffffffea80e8a8 <virtio_stop+0x68>  // b.any
	}

	vb->state = VIRTIO_BUS_STATE_IDLE;
ffffffffea80e8d0:	52800020 	mov	w0, #0x1                   	// #1

	return NO_ERROR;
ffffffffea80e8d4:	f9400bb3 	ldr	x19, [x29, #16]
	vb->state = VIRTIO_BUS_STATE_IDLE;
ffffffffea80e8d8:	b9001020 	str	w0, [x1, #16]
}
ffffffffea80e8dc:	2a1403e0 	mov	w0, w20
ffffffffea80e8e0:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80e8e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e8e8:	d65f03c0 	ret
		return ERR_BAD_STATE;
ffffffffea80e8ec:	128003d4 	mov	w20, #0xffffffe1            	// #-31
ffffffffea80e8f0:	17fffffb 	b	ffffffffea80e8dc <virtio_stop+0x9c>
		return ERR_INVALID_ARGS;
ffffffffea80e8f4:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80e8f8:	17fffff9 	b	ffffffffea80e8dc <virtio_stop+0x9c>
ffffffffea80e8fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e900 <virtio_device_reset>:

/*
 *  Reset virtio device with specified device id
 */
status_t virtio_device_reset(uint devid, uint32_t guest_id)
{
ffffffffea80e900:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80e904:	910003fd 	mov	x29, sp
	struct vdev *vd;
	status_t ret = ERR_NOT_FOUND;
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e908:	9100c3a2 	add	x2, x29, #0x30
{
ffffffffea80e90c:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80e910:	2a0003f3 	mov	w19, w0
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e914:	f81f8c5f 	str	xzr, [x2, #-8]!

	LTRACEF("dev=%d\n", devid);

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e918:	aa0203e0 	mov	x0, x2
ffffffffea80e91c:	97fffe79 	bl	ffffffffea80e300 <get_guest_virtio_bus.constprop.2>
ffffffffea80e920:	35000420 	cbnz	w0, ffffffffea80e9a4 <virtio_device_reset+0xa4>
		return ERR_INVALID_ARGS;
	}

	if (vb->state != VIRTIO_BUS_STATE_ACTIVE) {
ffffffffea80e924:	f94017a2 	ldr	x2, [x29, #40]
ffffffffea80e928:	b9401040 	ldr	w0, [x2, #16]
ffffffffea80e92c:	71000c1f 	cmp	w0, #0x3
ffffffffea80e930:	54000361 	b.ne	ffffffffea80e99c <virtio_device_reset+0x9c>  // b.any
		return ERR_BAD_STATE;
	}

	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e934:	f9401041 	ldr	x1, [x2, #32]
ffffffffea80e938:	91006042 	add	x2, x2, #0x18
ffffffffea80e93c:	d1004020 	sub	x0, x1, #0x10
ffffffffea80e940:	eb01005f 	cmp	x2, x1
ffffffffea80e944:	54000180 	b.eq	ffffffffea80e974 <virtio_device_reset+0x74>  // b.none
		if (vd->devid == devid) {
ffffffffea80e948:	b85f4021 	ldur	w1, [x1, #-12]
ffffffffea80e94c:	6b01027f 	cmp	w19, w1
ffffffffea80e950:	540000a1 	b.ne	ffffffffea80e964 <virtio_device_reset+0x64>  // b.any
ffffffffea80e954:	1400000c 	b	ffffffffea80e984 <virtio_device_reset+0x84>
ffffffffea80e958:	b85f4021 	ldur	w1, [x1, #-12]
ffffffffea80e95c:	6b13003f 	cmp	w1, w19
ffffffffea80e960:	54000120 	b.eq	ffffffffea80e984 <virtio_device_reset+0x84>  // b.none
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e964:	f9400c01 	ldr	x1, [x0, #24]
ffffffffea80e968:	eb01005f 	cmp	x2, x1
ffffffffea80e96c:	d1004020 	sub	x0, x1, #0x10
ffffffffea80e970:	54ffff41 	b.ne	ffffffffea80e958 <virtio_device_reset+0x58>  // b.any
	status_t ret = ERR_NOT_FOUND;
ffffffffea80e974:	12800020 	mov	w0, #0xfffffffe            	// #-2
			ret = vd->ops->reset(vd);
			break;
		}
	}
	return ret;
}
ffffffffea80e978:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80e97c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e980:	d65f03c0 	ret
			ret = vd->ops->reset(vd);
ffffffffea80e984:	f9401001 	ldr	x1, [x0, #32]
ffffffffea80e988:	f9400c21 	ldr	x1, [x1, #24]
ffffffffea80e98c:	d63f0020 	blr	x1
}
ffffffffea80e990:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80e994:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e998:	d65f03c0 	ret
		return ERR_BAD_STATE;
ffffffffea80e99c:	128003c0 	mov	w0, #0xffffffe1            	// #-31
ffffffffea80e9a0:	17fffff6 	b	ffffffffea80e978 <virtio_device_reset+0x78>
		return ERR_INVALID_ARGS;
ffffffffea80e9a4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80e9a8:	17fffff4 	b	ffffffffea80e978 <virtio_device_reset+0x78>
ffffffffea80e9ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e9b0 <virtio_kick_vq>:

/*
 *  Kick vq for virtio device with specified device id
 */
status_t virtio_kick_vq(uint devid, uint vqid, uint32_t guest_id)
{
ffffffffea80e9b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80e9b4:	910003fd 	mov	x29, sp
	struct vdev *vd;
	status_t ret = ERR_NOT_FOUND;
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e9b8:	9100c3a3 	add	x3, x29, #0x30
{
ffffffffea80e9bc:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80e9c0:	2a0003f3 	mov	w19, w0
ffffffffea80e9c4:	2a0103f4 	mov	w20, w1

#if WITH_CHATTY_LTRACE
	LTRACEF("dev=%d\n", devid);
#endif

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e9c8:	2a0203e1 	mov	w1, w2
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e9cc:	f81f8c7f 	str	xzr, [x3, #-8]!
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e9d0:	aa0303e0 	mov	x0, x3
ffffffffea80e9d4:	97fffe4b 	bl	ffffffffea80e300 <get_guest_virtio_bus.constprop.2>
ffffffffea80e9d8:	35000440 	cbnz	w0, ffffffffea80ea60 <virtio_kick_vq+0xb0>
		return ERR_INVALID_ARGS;
	}

	if (vb->state != VIRTIO_BUS_STATE_ACTIVE) {
ffffffffea80e9dc:	f94017a2 	ldr	x2, [x29, #40]
ffffffffea80e9e0:	b9401040 	ldr	w0, [x2, #16]
ffffffffea80e9e4:	71000c1f 	cmp	w0, #0x3
ffffffffea80e9e8:	54000381 	b.ne	ffffffffea80ea58 <virtio_kick_vq+0xa8>  // b.any
		return ERR_BAD_STATE;
	}
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e9ec:	f9401041 	ldr	x1, [x2, #32]
ffffffffea80e9f0:	91006042 	add	x2, x2, #0x18
ffffffffea80e9f4:	d1004020 	sub	x0, x1, #0x10
ffffffffea80e9f8:	eb01005f 	cmp	x2, x1
ffffffffea80e9fc:	54000180 	b.eq	ffffffffea80ea2c <virtio_kick_vq+0x7c>  // b.none
		if (vd->devid == devid) {
ffffffffea80ea00:	b85f4021 	ldur	w1, [x1, #-12]
ffffffffea80ea04:	6b01027f 	cmp	w19, w1
ffffffffea80ea08:	540000a1 	b.ne	ffffffffea80ea1c <virtio_kick_vq+0x6c>  // b.any
ffffffffea80ea0c:	1400000c 	b	ffffffffea80ea3c <virtio_kick_vq+0x8c>
ffffffffea80ea10:	b85f4021 	ldur	w1, [x1, #-12]
ffffffffea80ea14:	6b13003f 	cmp	w1, w19
ffffffffea80ea18:	54000120 	b.eq	ffffffffea80ea3c <virtio_kick_vq+0x8c>  // b.none
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80ea1c:	f9400c01 	ldr	x1, [x0, #24]
ffffffffea80ea20:	eb01005f 	cmp	x2, x1
ffffffffea80ea24:	d1004020 	sub	x0, x1, #0x10
ffffffffea80ea28:	54ffff41 	b.ne	ffffffffea80ea10 <virtio_kick_vq+0x60>  // b.any
	status_t ret = ERR_NOT_FOUND;
ffffffffea80ea2c:	12800020 	mov	w0, #0xfffffffe            	// #-2
			ret = vd->ops->kick_vqueue(vd, vqid);
			break;
		}
	}
	return ret;
}
ffffffffea80ea30:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ea34:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ea38:	d65f03c0 	ret
			ret = vd->ops->kick_vqueue(vd, vqid);
ffffffffea80ea3c:	f9401002 	ldr	x2, [x0, #32]
ffffffffea80ea40:	2a1403e1 	mov	w1, w20
ffffffffea80ea44:	f9401042 	ldr	x2, [x2, #32]
ffffffffea80ea48:	d63f0040 	blr	x2
}
ffffffffea80ea4c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ea50:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ea54:	d65f03c0 	ret
		return ERR_BAD_STATE;
ffffffffea80ea58:	128003c0 	mov	w0, #0xffffffe1            	// #-31
ffffffffea80ea5c:	17fffff5 	b	ffffffffea80ea30 <virtio_kick_vq+0x80>
		return ERR_INVALID_ARGS;
ffffffffea80ea60:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80ea64:	17fffff3 	b	ffffffffea80ea30 <virtio_kick_vq+0x80>

ffffffffea80ea68 <tipc_descr_size>:

static size_t tipc_descr_size(struct vdev *vd)
{
	struct tipc_dev *dev = vdev_to_dev(vd);
	return dev->descr_size;
}
ffffffffea80ea68:	f9402000 	ldr	x0, [x0, #64]
ffffffffea80ea6c:	d65f03c0 	ret

ffffffffea80ea70 <tipc_tx_vq_notify_cb>:
{
ffffffffea80ea70:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80ea74:	910003fd 	mov	x29, sp
	vqueue_signal_avail(vq);
ffffffffea80ea78:	97fffb70 	bl	ffffffffea80d838 <vqueue_signal_avail>
}
ffffffffea80ea7c:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80ea80:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80ea84:	d65f03c0 	ret

ffffffffea80ea88 <_send_buf>:
	uint8_t  *data;
	size_t    len;
};

static int _send_buf(uint8_t *dst, size_t sz, void *ctx)
{
ffffffffea80ea88:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80ea8c:	910003fd 	mov	x29, sp
	DEBUG_ASSERT(dst);
	DEBUG_ASSERT(buf);
	DEBUG_ASSERT(buf->data);
	DEBUG_ASSERT(sz <= buf->len);

	memcpy (dst, buf->data,  sz);
ffffffffea80ea90:	f9400043 	ldr	x3, [x2]
ffffffffea80ea94:	aa0103e2 	mov	x2, x1
{
ffffffffea80ea98:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80ea9c:	aa0103f3 	mov	x19, x1
	memcpy (dst, buf->data,  sz);
ffffffffea80eaa0:	aa0303e1 	mov	x1, x3
ffffffffea80eaa4:	94001223 	bl	ffffffffea813330 <memcpy>

	return (int) sz;
}
ffffffffea80eaa8:	2a1303e0 	mov	w0, w19
ffffffffea80eaac:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80eab0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80eab4:	d65f03c0 	ret

ffffffffea80eab8 <tipc_get_vdev_descr>:
{
ffffffffea80eab8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80eabc:	910003fd 	mov	x29, sp
ffffffffea80eac0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80eac4:	aa0003f3 	mov	x19, x0
ffffffffea80eac8:	aa0103f4 	mov	x20, x1
	memcpy(vdev_descr, dev->descr_ptr, dev->descr_size);
ffffffffea80eacc:	aa0103e0 	mov	x0, x1
ffffffffea80ead0:	a9438a61 	ldp	x1, x2, [x19, #56]
ffffffffea80ead4:	94001217 	bl	ffffffffea813330 <memcpy>
	vdev_descr->vdev.notifyid = vd->devid;
ffffffffea80ead8:	b9400660 	ldr	w0, [x19, #4]
ffffffffea80eadc:	b9000a80 	str	w0, [x20, #8]
}
ffffffffea80eae0:	f9402260 	ldr	x0, [x19, #64]
ffffffffea80eae4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80eae8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80eaec:	d65f03c0 	ret

ffffffffea80eaf0 <tx_data_cb>:
{
ffffffffea80eaf0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	ipc_msg_kern_t dst_kern_msg = {
ffffffffea80eaf4:	52800024 	mov	w4, #0x1                   	// #1
{
ffffffffea80eaf8:	910003fd 	mov	x29, sp
ffffffffea80eafc:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80eb00:	aa0203f3 	mov	x19, x2
	rc = ipc_read_msg(cb_ctx->chan, cb_ctx->msg_inf.id, 0,
ffffffffea80eb04:	9100c3a3 	add	x3, x29, #0x30
ffffffffea80eb08:	52800002 	mov	w2, #0x0                   	// #0
	iovec_kern_t dst_iov = { buf, buf_len };
ffffffffea80eb0c:	a90207a0 	stp	x0, x1, [x29, #32]
	rc = ipc_read_msg(cb_ctx->chan, cb_ctx->msg_inf.id, 0,
ffffffffea80eb10:	b9400e61 	ldr	w1, [x19, #12]
ffffffffea80eb14:	f9400260 	ldr	x0, [x19]
	ipc_msg_kern_t dst_kern_msg = {
ffffffffea80eb18:	b90033a4 	str	w4, [x29, #48]
ffffffffea80eb1c:	910083a4 	add	x4, x29, #0x20
ffffffffea80eb20:	f9001fa4 	str	x4, [x29, #56]
ffffffffea80eb24:	b90043bf 	str	wzr, [x29, #64]
ffffffffea80eb28:	f90027bf 	str	xzr, [x29, #72]
	rc = ipc_read_msg(cb_ctx->chan, cb_ctx->msg_inf.id, 0,
ffffffffea80eb2c:	97fff981 	bl	ffffffffea80d130 <ipc_read_msg>
	ipc_put_msg(cb_ctx->chan, cb_ctx->msg_inf.id);
ffffffffea80eb30:	b9400e61 	ldr	w1, [x19, #12]
	rc = ipc_read_msg(cb_ctx->chan, cb_ctx->msg_inf.id, 0,
ffffffffea80eb34:	2a0003f4 	mov	w20, w0
	ipc_put_msg(cb_ctx->chan, cb_ctx->msg_inf.id);
ffffffffea80eb38:	f9400260 	ldr	x0, [x19]
ffffffffea80eb3c:	97fff8e3 	bl	ffffffffea80cec8 <ipc_put_msg>
}
ffffffffea80eb40:	2a1403e0 	mov	w0, w20
ffffffffea80eb44:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80eb48:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80eb4c:	d65f03c0 	ret

ffffffffea80eb50 <tipc_vdev_kick_vq>:
	if (vqid == vqueue_id(&dev->vqs[TIPC_VQ_TX])) {
ffffffffea80eb50:	b9404802 	ldr	w2, [x0, #72]
ffffffffea80eb54:	6b02003f 	cmp	w1, w2
ffffffffea80eb58:	54000120 	b.eq	ffffffffea80eb7c <tipc_vdev_kick_vq+0x2c>  // b.none
	if (vqid == vqueue_id(&dev->vqs[TIPC_VQ_RX])) {
ffffffffea80eb5c:	b940d802 	ldr	w2, [x0, #216]
ffffffffea80eb60:	6b02003f 	cmp	w1, w2
ffffffffea80eb64:	54000161 	b.ne	ffffffffea80eb90 <tipc_vdev_kick_vq+0x40>  // b.any
		return vqueue_notify(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80eb68:	91036000 	add	x0, x0, #0xd8
	return vq->id;
}

static inline int vqueue_notify(struct vqueue *vq)
{
	if (vq->notify_cb){
ffffffffea80eb6c:	f9403c02 	ldr	x2, [x0, #120]
ffffffffea80eb70:	b40000c2 	cbz	x2, ffffffffea80eb88 <tipc_vdev_kick_vq+0x38>
		return vq->notify_cb(vq, vq->priv);
ffffffffea80eb74:	f9404401 	ldr	x1, [x0, #136]
ffffffffea80eb78:	d61f0040 	br	x2
		return vqueue_notify(&dev->vqs[TIPC_VQ_TX]);
ffffffffea80eb7c:	91012000 	add	x0, x0, #0x48
	if (vq->notify_cb){
ffffffffea80eb80:	f9403c02 	ldr	x2, [x0, #120]
ffffffffea80eb84:	b5ffff82 	cbnz	x2, ffffffffea80eb74 <tipc_vdev_kick_vq+0x24>
	}
	return 0;
ffffffffea80eb88:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea80eb8c:	d65f03c0 	ret
	return ERR_NOT_FOUND;
ffffffffea80eb90:	12800020 	mov	w0, #0xfffffffe            	// #-2
}
ffffffffea80eb94:	d65f03c0 	ret

ffffffffea80eb98 <tipc_send_data.constprop.3>:
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80eb98:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
ffffffffea80eb9c:	910003fd 	mov	x29, sp
ffffffffea80eba0:	a90153f3 	stp	x19, x20, [sp, #16]
	struct vqueue *vq = &dev->vqs[TIPC_VQ_TX];
ffffffffea80eba4:	91012013 	add	x19, x0, #0x48
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80eba8:	a9025bf5 	stp	x21, x22, [sp, #32]
		event_wait(&vq->avail_event);
ffffffffea80ebac:	91024014 	add	x20, x0, #0x90
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80ebb0:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80ebb4:	aa0003f6 	mov	x22, x0
ffffffffea80ebb8:	a9046bf9 	stp	x25, x26, [sp, #64]
		if (dev->tx_stop) {
ffffffffea80ebbc:	91400415 	add	x21, x0, #0x1, lsl #12
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80ebc0:	f9002bfb 	str	x27, [sp, #80]
ffffffffea80ebc4:	2a0103fa 	mov	w26, w1
ffffffffea80ebc8:	2a0203f9 	mov	w25, w2
	memset(&buf, 0, sizeof(buf));
ffffffffea80ebcc:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80ebd0:	d2800902 	mov	x2, #0x48                  	// #72
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80ebd4:	aa0303f8 	mov	x24, x3
ffffffffea80ebd8:	12003cb7 	and	w23, w5, #0xffff
	memset(&buf, 0, sizeof(buf));
ffffffffea80ebdc:	9101e3a0 	add	x0, x29, #0x78
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80ebe0:	aa0403fb 	mov	x27, x4
	memset(&buf, 0, sizeof(buf));
ffffffffea80ebe4:	9400128f 	bl	ffffffffea813620 <memset>
	buf.out_iovs.cnt  = MAX_TX_IOVS;
ffffffffea80ebe8:	52800022 	mov	w2, #0x1                   	// #1
	buf.out_iovs.phys = out_phys;
ffffffffea80ebec:	910183a1 	add	x1, x29, #0x60
	buf.out_iovs.iovs = out_iovs;
ffffffffea80ebf0:	9101a3a0 	add	x0, x29, #0x68
	buf.out_iovs.cnt  = MAX_TX_IOVS;
ffffffffea80ebf4:	b900a3a2 	str	w2, [x29, #160]
	buf.out_iovs.iovs = out_iovs;
ffffffffea80ebf8:	a90b03a1 	stp	x1, x0, [x29, #176]
ffffffffea80ebfc:	14000006 	b	ffffffffea80ec14 <tipc_send_data.constprop.3+0x7c>
		if (ret != ERR_NOT_ENOUGH_BUFFER || !wait) {
ffffffffea80ec00:	3100245f 	cmn	w2, #0x9
ffffffffea80ec04:	540003a1 	b.ne	ffffffffea80ec78 <tipc_send_data.constprop.3+0xe0>  // b.any
ffffffffea80ec08:	97ffdae8 	bl	ffffffffea8057a8 <event_wait_timeout>
		if (dev->tx_stop) {
ffffffffea80ec0c:	394942a0 	ldrb	w0, [x21, #592]
ffffffffea80ec10:	35000440 	cbnz	w0, ffffffffea80ec98 <tipc_send_data.constprop.3+0x100>
		ret = vqueue_get_avail_buf(vq, &buf);
ffffffffea80ec14:	9101e3a1 	add	x1, x29, #0x78
ffffffffea80ec18:	aa1303e0 	mov	x0, x19
ffffffffea80ec1c:	97fffb3d 	bl	ffffffffea80d910 <vqueue_get_avail_buf>
ffffffffea80ec20:	2a0003e2 	mov	w2, w0
ffffffffea80ec24:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80ec28:	aa1403e0 	mov	x0, x20
		if (ret == NO_ERROR) {
ffffffffea80ec2c:	35fffea2 	cbnz	w2, ffffffffea80ec00 <tipc_send_data.constprop.3+0x68>
	if (buf.out_iovs.used == 0) {
ffffffffea80ec30:	b940a7a0 	ldr	w0, [x29, #164]
ffffffffea80ec34:	12800102 	mov	w2, #0xfffffff7            	// #-9
ffffffffea80ec38:	34000180 	cbz	w0, ffffffffea80ec68 <tipc_send_data.constprop.3+0xd0>
	if (sizeof(struct tipc_hdr) > buf.out_iovs.iovs[0].len) {
ffffffffea80ec3c:	f9405fa0 	ldr	x0, [x29, #184]
ffffffffea80ec40:	f9400400 	ldr	x0, [x0, #8]
ffffffffea80ec44:	f1003c1f 	cmp	x0, #0xf
ffffffffea80ec48:	54000109 	b.ls	ffffffffea80ec68 <tipc_send_data.constprop.3+0xd0>  // b.plast
	ret = vqueue_map_iovs(&buf.out_iovs, map_flags, dev->guest);
ffffffffea80ec4c:	b9402ac2 	ldr	w2, [x22, #40]
ffffffffea80ec50:	910283b5 	add	x21, x29, #0xa0
ffffffffea80ec54:	52800601 	mov	w1, #0x30                  	// #48
ffffffffea80ec58:	aa1503e0 	mov	x0, x21
ffffffffea80ec5c:	97fffbb7 	bl	ffffffffea80db38 <vqueue_map_iovs>
ffffffffea80ec60:	2a0003e2 	mov	w2, w0
	if (ret == NO_ERROR) {
ffffffffea80ec64:	340002c0 	cbz	w0, ffffffffea80ecbc <tipc_send_data.constprop.3+0x124>
	ret = vqueue_add_buf(vq, &buf, ret);
ffffffffea80ec68:	9101e3a1 	add	x1, x29, #0x78
ffffffffea80ec6c:	aa1303e0 	mov	x0, x19
ffffffffea80ec70:	97fffc2a 	bl	ffffffffea80dd18 <vqueue_add_buf>
ffffffffea80ec74:	2a0003e2 	mov	w2, w0
}
ffffffffea80ec78:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ec7c:	2a0203e0 	mov	w0, w2
ffffffffea80ec80:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ec84:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80ec88:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80ec8c:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea80ec90:	a8cc7bfd 	ldp	x29, x30, [sp], #192
ffffffffea80ec94:	d65f03c0 	ret
ffffffffea80ec98:	a94153f3 	ldp	x19, x20, [sp, #16]
			return ERR_CHANNEL_CLOSED;
ffffffffea80ec9c:	128001c2 	mov	w2, #0xfffffff1            	// #-15
}
ffffffffea80eca0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80eca4:	2a0203e0 	mov	w0, w2
ffffffffea80eca8:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80ecac:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80ecb0:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea80ecb4:	a8cc7bfd 	ldp	x29, x30, [sp], #192
ffffffffea80ecb8:	d65f03c0 	ret
		struct tipc_hdr *hdr = buf.out_iovs.iovs[0].base;
ffffffffea80ecbc:	f9405fa1 	ldr	x1, [x29, #184]
	sizeof(struct tipc_hdr) + data_len;
ffffffffea80ecc0:	92403ee4 	and	x4, x23, #0xffff
	size_t ttl_len =
ffffffffea80ecc4:	91004085 	add	x5, x4, #0x10
		ret = cb(hdr->data, data_len, cb_ctx);
ffffffffea80ecc8:	aa1b03e2 	mov	x2, x27
		if (ttl_len > buf.out_iovs.iovs[0].len) {
ffffffffea80eccc:	a9400c20 	ldp	x0, x3, [x1]
		hdr->dst = remote;
ffffffffea80ecd0:	2900641a 	stp	w26, w25, [x0]
		hdr->reserved = 0;
ffffffffea80ecd4:	b900081f 	str	wzr, [x0, #8]
ffffffffea80ecd8:	eb0300bf 	cmp	x5, x3
ffffffffea80ecdc:	51004063 	sub	w3, w3, #0x10
		hdr->len = data_len;
ffffffffea80ece0:	79001817 	strh	w23, [x0, #12]
ffffffffea80ece4:	92403c61 	and	x1, x3, #0xffff
		hdr->flags = 0;
ffffffffea80ece8:	79001c1f 	strh	wzr, [x0, #14]
		ret = cb(hdr->data, data_len, cb_ctx);
ffffffffea80ecec:	9a848021 	csel	x1, x1, x4, hi  // hi = pmore
ffffffffea80ecf0:	91004000 	add	x0, x0, #0x10
ffffffffea80ecf4:	d63f0300 	blr	x24
			ret += sizeof(struct tipc_hdr);
ffffffffea80ecf8:	7100001f 	cmp	w0, #0x0
		ret = cb(hdr->data, data_len, cb_ctx);
ffffffffea80ecfc:	2a0003f4 	mov	w20, w0
			ret += sizeof(struct tipc_hdr);
ffffffffea80ed00:	11004000 	add	w0, w0, #0x10
ffffffffea80ed04:	1a94a014 	csel	w20, w0, w20, ge  // ge = tcont
		vqueue_unmap_iovs(&buf.out_iovs);
ffffffffea80ed08:	aa1503e0 	mov	x0, x21
ffffffffea80ed0c:	97fffbe7 	bl	ffffffffea80dca8 <vqueue_unmap_iovs>
ffffffffea80ed10:	2a1403e2 	mov	w2, w20
ffffffffea80ed14:	17ffffd5 	b	ffffffffea80ec68 <tipc_send_data.constprop.3+0xd0>

ffffffffea80ed18 <tipc_vdev_probe>:
{
ffffffffea80ed18:	d102c3ff 	sub	sp, sp, #0xb0
ffffffffea80ed1c:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea80ed20:	910043fd 	add	x29, sp, #0x10
	if (dev->vd.state != VDEV_STATE_RESET) {
ffffffffea80ed24:	b9400002 	ldr	w2, [x0]
{
ffffffffea80ed28:	f90027f8 	str	x24, [sp, #72]
	if (dev->vd.state != VDEV_STATE_RESET) {
ffffffffea80ed2c:	35000f22 	cbnz	w2, ffffffffea80ef10 <tipc_vdev_probe+0x1f8>
	if (vdev_descr->hdr.type != RSC_VDEV) {
ffffffffea80ed30:	b9400022 	ldr	w2, [x1]
ffffffffea80ed34:	71000c5f 	cmp	w2, #0x3
ffffffffea80ed38:	54000e01 	b.ne	ffffffffea80eef8 <tipc_vdev_probe+0x1e0>  // b.any
	if (vdev_descr->vdev.id != VIRTIO_ID_TIPC) {
ffffffffea80ed3c:	b9400422 	ldr	w2, [x1, #4]
ffffffffea80ed40:	7100345f 	cmp	w2, #0xd
ffffffffea80ed44:	54000da1 	b.ne	ffffffffea80eef8 <tipc_vdev_probe+0x1e0>  // b.any
	if (vdev_descr->vdev.num_of_vrings != TIPC_VQ_NUM) {
ffffffffea80ed48:	39406422 	ldrb	w2, [x1, #25]
ffffffffea80ed4c:	7100085f 	cmp	w2, #0x2
ffffffffea80ed50:	54000d41 	b.ne	ffffffffea80eef8 <tipc_vdev_probe+0x1e0>  // b.any
	if (vdev_descr->vdev.status != (VIRTIO_CONFIG_S_ACKNOWLEDGE |
ffffffffea80ed54:	39406022 	ldrb	w2, [x1, #24]
ffffffffea80ed58:	71001c5f 	cmp	w2, #0x7
ffffffffea80ed5c:	54000ce1 	b.ne	ffffffffea80eef8 <tipc_vdev_probe+0x1e0>  // b.any
ffffffffea80ed60:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea80ed64:	9101201a 	add	x26, x0, #0x48
ffffffffea80ed68:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80ed6c:	90000006 	adrp	x6, ffffffffea80e000 <trusty_sm_stdcall+0x70>
ffffffffea80ed70:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80ed74:	aa0103f9 	mov	x25, x1
ffffffffea80ed78:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80ed7c:	aa0003f4 	mov	x20, x0
ffffffffea80ed80:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80ed84:	91007033 	add	x19, x1, #0x1c
ffffffffea80ed88:	b000005b 	adrp	x27, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80ed8c:	aa1a03f6 	mov	x22, x26
ffffffffea80ed90:	9129c0c6 	add	x6, x6, #0xa70
	for (vring_cnt = 0; vring_cnt < dscr->vdev.num_of_vrings; vring_cnt++) {
ffffffffea80ed94:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea80ed98:	9127e37b 	add	x27, x27, #0x9f8
	if (vdev_descr->vdev.status != (VIRTIO_CONFIG_S_ACKNOWLEDGE |
ffffffffea80ed9c:	d2800017 	mov	x23, #0x0                   	// #0
ffffffffea80eda0:	14000009 	b	ffffffffea80edc4 <tipc_vdev_probe+0xac>
	for (vring_cnt = 0; vring_cnt < dscr->vdev.num_of_vrings; vring_cnt++) {
ffffffffea80eda4:	39406720 	ldrb	w0, [x25, #25]
ffffffffea80eda8:	110006b5 	add	w21, w21, #0x1
ffffffffea80edac:	910022f7 	add	x23, x23, #0x8
ffffffffea80edb0:	91005273 	add	x19, x19, #0x14
ffffffffea80edb4:	910242d6 	add	x22, x22, #0x90
ffffffffea80edb8:	6b0002bf 	cmp	w21, w0
ffffffffea80edbc:	540003e2 	b.cs	ffffffffea80ee38 <tipc_vdev_probe+0x120>  // b.hs, b.nlast
ffffffffea80edc0:	f87b6ae6 	ldr	x6, [x23, x27]
		ret = vqueue_init(&dev->vqs[vring_cnt],
ffffffffea80edc4:	29401260 	ldp	w0, w4, [x19]
ffffffffea80edc8:	d2800007 	mov	x7, #0x0                   	// #0
ffffffffea80edcc:	29410663 	ldp	w3, w1, [x19, #8]
		uint64_t pa64 = ((uint64_t)vring->reserved << 32) | vring->da;
ffffffffea80edd0:	b9401262 	ldr	w2, [x19, #16]
		ret = vqueue_init(&dev->vqs[vring_cnt],
ffffffffea80edd4:	b9402a85 	ldr	w5, [x20, #40]
ffffffffea80edd8:	b90003e5 	str	w5, [sp]
ffffffffea80eddc:	aa1403e5 	mov	x5, x20
ffffffffea80ede0:	aa028002 	orr	x2, x0, x2, lsl #32
ffffffffea80ede4:	aa1603e0 	mov	x0, x22
ffffffffea80ede8:	97fffa0a 	bl	ffffffffea80d610 <vqueue_init>
ffffffffea80edec:	2a0003f8 	mov	w24, w0
		if (ret) {
ffffffffea80edf0:	34fffda0 	cbz	w0, ffffffffea80eda4 <tipc_vdev_probe+0x8c>
ffffffffea80edf4:	d1012294 	sub	x20, x20, #0x48
	while (vring_cnt--) {
ffffffffea80edf8:	340000d5 	cbz	w21, ffffffffea80ee10 <tipc_vdev_probe+0xf8>
		vqueue_destroy(&dev->vqs[vring_cnt]);
ffffffffea80edfc:	aa1a03e0 	mov	x0, x26
ffffffffea80ee00:	d102435a 	sub	x26, x26, #0x90
ffffffffea80ee04:	97fffa67 	bl	ffffffffea80d7a0 <vqueue_destroy>
	while (vring_cnt--) {
ffffffffea80ee08:	eb1a029f 	cmp	x20, x26
ffffffffea80ee0c:	54ffff81 	b.ne	ffffffffea80edfc <tipc_vdev_probe+0xe4>  // b.any
ffffffffea80ee10:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80ee14:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80ee18:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80ee1c:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80ee20:	f9402bbb 	ldr	x27, [x29, #80]
}
ffffffffea80ee24:	2a1803e0 	mov	w0, w24
ffffffffea80ee28:	f94027f8 	ldr	x24, [sp, #72]
ffffffffea80ee2c:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea80ee30:	9102c3ff 	add	sp, sp, #0xb0
ffffffffea80ee34:	d65f03c0 	ret
	snprintf(tname, sizeof(tname), "tipc-dev%d-rx", dev->vd.devid);
ffffffffea80ee38:	b9400683 	ldr	w3, [x20, #4]
ffffffffea80ee3c:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea80ee40:	b0000042 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80ee44:	910203a0 	add	x0, x29, #0x80
ffffffffea80ee48:	912bc042 	add	x2, x2, #0xaf0
ffffffffea80ee4c:	940010db 	bl	ffffffffea8131b8 <snprintf>
		thread_create(tname, tipc_rx_thread_func, dev,
ffffffffea80ee50:	90000001 	adrp	x1, ffffffffea80e000 <trusty_sm_stdcall+0x70>
ffffffffea80ee54:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea80ee58:	52800203 	mov	w3, #0x10                  	// #16
ffffffffea80ee5c:	aa1403e2 	mov	x2, x20
ffffffffea80ee60:	913c6021 	add	x1, x1, #0xf18
ffffffffea80ee64:	910203a0 	add	x0, x29, #0x80
ffffffffea80ee68:	97ffdcec 	bl	ffffffffea806218 <thread_create>
	dev->rx_thread =
ffffffffea80ee6c:	f9092280 	str	x0, [x20, #4672]
	if (dev->rx_thread) {
ffffffffea80ee70:	b4000040 	cbz	x0, ffffffffea80ee78 <tipc_vdev_probe+0x160>
		thread_resume(dev->rx_thread);
ffffffffea80ee74:	97ffdd49 	bl	ffffffffea806398 <thread_resume>
	snprintf(tname, sizeof(tname), "tipc-dev%d-tx", dev->vd.devid);
ffffffffea80ee78:	b9400683 	ldr	w3, [x20, #4]
ffffffffea80ee7c:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea80ee80:	b0000042 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80ee84:	910203a0 	add	x0, x29, #0x80
ffffffffea80ee88:	912c0042 	add	x2, x2, #0xb00
ffffffffea80ee8c:	940010cb 	bl	ffffffffea8131b8 <snprintf>
		thread_create(tname, tipc_tx_thread_func, dev,
ffffffffea80ee90:	b0000001 	adrp	x1, ffffffffea80f000 <tipc_rx_thread_func+0xe8>
ffffffffea80ee94:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea80ee98:	52800203 	mov	w3, #0x10                  	// #16
ffffffffea80ee9c:	aa1403e2 	mov	x2, x20
ffffffffea80eea0:	911b0021 	add	x1, x1, #0x6c0
ffffffffea80eea4:	910203a0 	add	x0, x29, #0x80
ffffffffea80eea8:	97ffdcdc 	bl	ffffffffea806218 <thread_create>
	dev->tx_thread =
ffffffffea80eeac:	f9092680 	str	x0, [x20, #4680]
	if (dev->tx_thread) {
ffffffffea80eeb0:	b4000040 	cbz	x0, ffffffffea80eeb8 <tipc_vdev_probe+0x1a0>
		thread_resume(dev->tx_thread);
ffffffffea80eeb4:	97ffdd39 	bl	ffffffffea806398 <thread_resume>
	msg.hdr.type = TIPC_CTRL_MSGTYPE_GO_ONLINE;
ffffffffea80eeb8:	910283a0 	add	x0, x29, #0xa0
ffffffffea80eebc:	d2800033 	mov	x19, #0x1                   	// #1

static int
tipc_send_buf(struct tipc_dev *dev, uint32_t local, uint32_t remote,
              void *data, uint16_t data_len, bool wait)
{
	struct buf_ctx ctx = {data, data_len};
ffffffffea80eec0:	d2800105 	mov	x5, #0x8                   	// #8

	return tipc_send_data(dev, local, remote,
ffffffffea80eec4:	528006a2 	mov	w2, #0x35                  	// #53
ffffffffea80eec8:	90000003 	adrp	x3, ffffffffea80e000 <trusty_sm_stdcall+0x70>
ffffffffea80eecc:	9101c3a4 	add	x4, x29, #0x70
	msg.hdr.type = TIPC_CTRL_MSGTYPE_GO_ONLINE;
ffffffffea80eed0:	f81c8c13 	str	x19, [x0, #-56]!
	return tipc_send_data(dev, local, remote,
ffffffffea80eed4:	912a2063 	add	x3, x3, #0xa88
ffffffffea80eed8:	2a0203e1 	mov	w1, w2
	struct buf_ctx ctx = {data, data_len};
ffffffffea80eedc:	a90717a0 	stp	x0, x5, [x29, #112]
	return tipc_send_data(dev, local, remote,
ffffffffea80eee0:	aa1403e0 	mov	x0, x20
ffffffffea80eee4:	97ffff2d 	bl	ffffffffea80eb98 <tipc_send_data.constprop.3>
ffffffffea80eee8:	2a0003f8 	mov	w24, w0
	if (ret == NO_ERROR) {
ffffffffea80eeec:	35fff920 	cbnz	w0, ffffffffea80ee10 <tipc_vdev_probe+0xf8>
		dev->vd.state = VDEV_STATE_ACTIVE;
ffffffffea80eef0:	b9000293 	str	w19, [x20]
ffffffffea80eef4:	17ffffc7 	b	ffffffffea80ee10 <tipc_vdev_probe+0xf8>
	if (vdev_descr->vdev.status != (VIRTIO_CONFIG_S_ACKNOWLEDGE |
ffffffffea80eef8:	128000f8 	mov	w24, #0xfffffff8            	// #-8
}
ffffffffea80eefc:	2a1803e0 	mov	w0, w24
ffffffffea80ef00:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea80ef04:	f94027f8 	ldr	x24, [sp, #72]
ffffffffea80ef08:	9102c3ff 	add	sp, sp, #0xb0
ffffffffea80ef0c:	d65f03c0 	ret
		return ERR_BAD_STATE;
ffffffffea80ef10:	128003d8 	mov	w24, #0xffffffe1            	// #-31
ffffffffea80ef14:	17ffffc4 	b	ffffffffea80ee24 <tipc_vdev_probe+0x10c>

ffffffffea80ef18 <tipc_rx_thread_func>:
{
ffffffffea80ef18:	d10883ff 	sub	sp, sp, #0x220
	mutex_acquire(&dev->ept_lock);
ffffffffea80ef1c:	d2824106 	mov	x6, #0x1208                	// #4616
	memset(&buf, 0, sizeof(buf));
ffffffffea80ef20:	d2800902 	mov	x2, #0x48                  	// #72
ffffffffea80ef24:	52800001 	mov	w1, #0x0                   	// #0
{
ffffffffea80ef28:	a9007bfd 	stp	x29, x30, [sp]
ffffffffea80ef2c:	910003fd 	mov	x29, sp
ffffffffea80ef30:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80ef34:	aa0003f5 	mov	x21, x0
ffffffffea80ef38:	a90153f3 	stp	x19, x20, [sp, #16]
	memset(&buf, 0, sizeof(buf));
ffffffffea80ef3c:	910363a0 	add	x0, x29, #0xd8
{
ffffffffea80ef40:	a90363f7 	stp	x23, x24, [sp, #48]
	struct vqueue *vq = &dev->vqs[TIPC_VQ_RX];
ffffffffea80ef44:	910362b4 	add	x20, x21, #0xd8
{
ffffffffea80ef48:	a9046bf9 	stp	x25, x26, [sp, #64]
	mutex_acquire(&dev->ept_lock);
ffffffffea80ef4c:	8b0602b8 	add	x24, x21, x6
ffffffffea80ef50:	aa1e03f9 	mov	x25, x30
{
ffffffffea80ef54:	f9002bfb 	str	x27, [sp, #80]
ffffffffea80ef58:	914006b6 	add	x22, x21, #0x1, lsl #12
	memset(&buf, 0, sizeof(buf));
ffffffffea80ef5c:	940011b1 	bl	ffffffffea813620 <memset>
		event_wait(&vq->avail_event);
ffffffffea80ef60:	910482b7 	add	x23, x21, #0x120
	buf.in_iovs.cnt  = MAX_RX_IOVS;
ffffffffea80ef64:	52800022 	mov	w2, #0x1                   	// #1
	buf.in_iovs.phys = in_phys;
ffffffffea80ef68:	9101e3a1 	add	x1, x29, #0x78
	buf.in_iovs.iovs = in_iovs;
ffffffffea80ef6c:	910223a0 	add	x0, x29, #0x88
	buf.in_iovs.cnt  = MAX_RX_IOVS;
ffffffffea80ef70:	b900e3a2 	str	w2, [x29, #224]
	buf.in_iovs.iovs = in_iovs;
ffffffffea80ef74:	a90f03a1 	stp	x1, x0, [x29, #240]
	while(!dev->rx_stop) {
ffffffffea80ef78:	394946c0 	ldrb	w0, [x22, #593]
ffffffffea80ef7c:	350007c0 	cbnz	w0, ffffffffea80f074 <tipc_rx_thread_func+0x15c>
ffffffffea80ef80:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80ef84:	aa1703e0 	mov	x0, x23
ffffffffea80ef88:	97ffda08 	bl	ffffffffea8057a8 <event_wait_timeout>
		ret = vqueue_get_avail_buf(vq, &buf);
ffffffffea80ef8c:	910363a1 	add	x1, x29, #0xd8
ffffffffea80ef90:	aa1403e0 	mov	x0, x20
ffffffffea80ef94:	97fffa5f 	bl	ffffffffea80d910 <vqueue_get_avail_buf>
		if (ret == ERR_CHANNEL_CLOSED) {
ffffffffea80ef98:	31003c1f 	cmn	w0, #0xf
ffffffffea80ef9c:	540006c0 	b.eq	ffffffffea80f074 <tipc_rx_thread_func+0x15c>  // b.none
		if (ret == ERR_NOT_ENOUGH_BUFFER) {
ffffffffea80efa0:	3100241f 	cmn	w0, #0x9
ffffffffea80efa4:	54fffea0 	b.eq	ffffffffea80ef78 <tipc_rx_thread_func+0x60>  // b.none
ffffffffea80efa8:	2a0003f3 	mov	w19, w0
		if (likely(ret == NO_ERROR)) {
ffffffffea80efac:	350002e0 	cbnz	w0, ffffffffea80f008 <tipc_rx_thread_func+0xf0>
	if (buf->in_iovs.used == 0) {
ffffffffea80efb0:	b940e7a0 	ldr	w0, [x29, #228]
ffffffffea80efb4:	340012c0 	cbz	w0, ffffffffea80f20c <tipc_rx_thread_func+0x2f4>
	int ret = vqueue_map_iovs(&buf->in_iovs, map_flags, dev->guest);
ffffffffea80efb8:	b9402aa2 	ldr	w2, [x21, #40]
ffffffffea80efbc:	52800701 	mov	w1, #0x38                  	// #56
ffffffffea80efc0:	910383a0 	add	x0, x29, #0xe0
ffffffffea80efc4:	97fffadd 	bl	ffffffffea80db38 <vqueue_map_iovs>
	if (ret) {
ffffffffea80efc8:	350003a0 	cbnz	w0, ffffffffea80f03c <tipc_rx_thread_func+0x124>
	if (buf->in_iovs.iovs[0].len < sizeof(struct tipc_hdr)) {
ffffffffea80efcc:	f9407fa1 	ldr	x1, [x29, #248]
ffffffffea80efd0:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea80efd4:	f9400420 	ldr	x0, [x1, #8]
ffffffffea80efd8:	f1003c1f 	cmp	x0, #0xf
ffffffffea80efdc:	54000129 	b.ls	ffffffffea80f000 <tipc_rx_thread_func+0xe8>  // b.plast
	ns_hdr  = buf->in_iovs.iovs[0].base;
ffffffffea80efe0:	f9400021 	ldr	x1, [x1]
	ns_data_len = ns_hdr->len;
ffffffffea80efe4:	79401822 	ldrh	w2, [x1, #12]
	src_addr = ns_hdr->src;
ffffffffea80efe8:	b940003b 	ldr	w27, [x1]
	dst_addr = ns_hdr->dst;
ffffffffea80efec:	b940043a 	ldr	w26, [x1, #4]
	ns_data_len = ns_hdr->len;
ffffffffea80eff0:	92403c42 	and	x2, x2, #0xffff
	if (ns_data_len + sizeof(struct tipc_hdr) != buf->in_iovs.iovs[0].len) {
ffffffffea80eff4:	91004043 	add	x3, x2, #0x10
ffffffffea80eff8:	eb03001f 	cmp	x0, x3
ffffffffea80effc:	540004e0 	b.eq	ffffffffea80f098 <tipc_rx_thread_func+0x180>  // b.none
	vqueue_unmap_iovs(&buf->in_iovs);
ffffffffea80f000:	910383a0 	add	x0, x29, #0xe0
ffffffffea80f004:	97fffb29 	bl	ffffffffea80dca8 <vqueue_unmap_iovs>
		ret = vqueue_add_buf(vq, &buf, ret);
ffffffffea80f008:	2a1303e2 	mov	w2, w19
ffffffffea80f00c:	910363a1 	add	x1, x29, #0xd8
ffffffffea80f010:	aa1403e0 	mov	x0, x20
ffffffffea80f014:	97fffb41 	bl	ffffffffea80dd18 <vqueue_add_buf>
		if (ret == ERR_CHANNEL_CLOSED) {
ffffffffea80f018:	31003c1f 	cmn	w0, #0xf
ffffffffea80f01c:	540002c0 	b.eq	ffffffffea80f074 <tipc_rx_thread_func+0x15c>  // b.none
		if (ret != NO_ERROR) {
ffffffffea80f020:	34fffac0 	cbz	w0, ffffffffea80ef78 <tipc_rx_thread_func+0x60>
			panic("Unable (%d) to return buffer to vqueue\n", ret);
ffffffffea80f024:	90000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80f028:	2a0003e2 	mov	w2, w0
ffffffffea80f02c:	91294021 	add	x1, x1, #0xa50
ffffffffea80f030:	aa1903e0 	mov	x0, x25
ffffffffea80f034:	f9002fbc 	str	x28, [x29, #88]
ffffffffea80f038:	94000b18 	bl	ffffffffea811c98 <_panic>
		TRACEF("failed to map iovs %d\n", ret);
ffffffffea80f03c:	2a0003e3 	mov	w3, w0
ffffffffea80f040:	90000044 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80f044:	2a0303f3 	mov	w19, w3
ffffffffea80f048:	52803e62 	mov	w2, #0x1f3                 	// #499
ffffffffea80f04c:	91282080 	add	x0, x4, #0xa08
ffffffffea80f050:	90000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80f054:	91264021 	add	x1, x1, #0x990
ffffffffea80f058:	94001076 	bl	ffffffffea813230 <_printf>
		ret = vqueue_add_buf(vq, &buf, ret);
ffffffffea80f05c:	2a1303e2 	mov	w2, w19
ffffffffea80f060:	910363a1 	add	x1, x29, #0xd8
ffffffffea80f064:	aa1403e0 	mov	x0, x20
ffffffffea80f068:	97fffb2c 	bl	ffffffffea80dd18 <vqueue_add_buf>
		if (ret == ERR_CHANNEL_CLOSED) {
ffffffffea80f06c:	31003c1f 	cmn	w0, #0xf
ffffffffea80f070:	54fffd81 	b.ne	ffffffffea80f020 <tipc_rx_thread_func+0x108>  // b.any
}
ffffffffea80f074:	a9407bfd 	ldp	x29, x30, [sp]
ffffffffea80f078:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80f07c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80f080:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80f084:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80f088:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80f08c:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea80f090:	910883ff 	add	sp, sp, #0x220
ffffffffea80f094:	d65f03c0 	ret
	if (dst_addr == TIPC_CTRL_ADDR) {
ffffffffea80f098:	7100d75f 	cmp	w26, #0x35
ffffffffea80f09c:	54000480 	b.eq	ffffffffea80f12c <tipc_rx_thread_func+0x214>  // b.none
	ipc_msg_kern_t msg = {
ffffffffea80f0a0:	910493a0 	add	x0, x29, #0x124
	ns_data = buf->in_iovs.iovs[0].base + sizeof(struct tipc_hdr);
ffffffffea80f0a4:	91004021 	add	x1, x1, #0x10
	return (uint)(addr - TIPC_ADDR_BASE);
ffffffffea80f0a8:	510fa35a 	sub	w26, w26, #0x3e8
		.iov		= (iovec_kern_t []) {
ffffffffea80f0ac:	a90a8ba1 	stp	x1, x2, [x29, #168]
ffffffffea80f0b0:	12800001 	mov	w1, #0xffffffff            	// #-1
	ipc_msg_kern_t msg = {
ffffffffea80f0b4:	a9007c1f 	stp	xzr, xzr, [x0]
ffffffffea80f0b8:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80f0bc:	b90123a0 	str	w0, [x29, #288]
ffffffffea80f0c0:	9102a3a0 	add	x0, x29, #0xa8
ffffffffea80f0c4:	f90097a0 	str	x0, [x29, #296]
ffffffffea80f0c8:	910843a0 	add	x0, x29, #0x210
ffffffffea80f0cc:	f812401f 	stur	xzr, [x0, #-220]
ffffffffea80f0d0:	aa1803e0 	mov	x0, x24
ffffffffea80f0d4:	b9013fbf 	str	wzr, [x29, #316]
ffffffffea80f0d8:	97ffda38 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80f0dc:	7103ff5f 	cmp	w26, #0xff
ffffffffea80f0e0:	54001448 	b.hi	ffffffffea80f368 <tipc_rx_thread_func+0x450>  // b.pmore
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80f0e4:	2a1a03e0 	mov	w0, w26
ffffffffea80f0e8:	d346fc01 	lsr	x1, x0, #6
ffffffffea80f0ec:	8b010ea1 	add	x1, x21, x1, lsl #3
ffffffffea80f0f0:	f948b421 	ldr	x1, [x1, #4456]
ffffffffea80f0f4:	9ada243a 	lsr	x26, x1, x26
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80f0f8:	3600139a 	tbz	w26, #0, ffffffffea80f368 <tipc_rx_thread_func+0x450>
ffffffffea80f0fc:	8b0012a0 	add	x0, x21, x0, lsl #4
	if (ept && ept->remote == remote) {
ffffffffea80f100:	b9416801 	ldr	w1, [x0, #360]
ffffffffea80f104:	6b01037f 	cmp	w27, w1
ffffffffea80f108:	54001301 	b.ne	ffffffffea80f368 <tipc_rx_thread_func+0x450>  // b.any
		if (ept->chan){
ffffffffea80f10c:	f940b800 	ldr	x0, [x0, #368]
ffffffffea80f110:	b40012c0 	cbz	x0, ffffffffea80f368 <tipc_rx_thread_func+0x450>
			ret = ipc_send_msg(ept->chan, &msg);
ffffffffea80f114:	910483a1 	add	x1, x29, #0x120
ffffffffea80f118:	97fff6ca 	bl	ffffffffea80cc40 <ipc_send_msg>
ffffffffea80f11c:	2a0003f3 	mov	w19, w0
	mutex_release(&dev->ept_lock);
ffffffffea80f120:	aa1803e0 	mov	x0, x24
ffffffffea80f124:	97ffda51 	bl	ffffffffea805a68 <mutex_release>
ffffffffea80f128:	17ffffb6 	b	ffffffffea80f000 <tipc_rx_thread_func+0xe8>
	if (msg_len < sizeof(struct tipc_ctrl_msg_hdr)) {
ffffffffea80f12c:	f1001c5f 	cmp	x2, #0x7
ffffffffea80f130:	54000b09 	b.ls	ffffffffea80f290 <tipc_rx_thread_func+0x378>  // b.plast
	msg_type = ns_msg_hdr->type;
ffffffffea80f134:	b940103a 	ldr	w26, [x1, #16]
	msg_body_len = ns_msg_hdr->body_len;
ffffffffea80f138:	b9401433 	ldr	w19, [x1, #20]
ffffffffea80f13c:	2a1303f3 	mov	w19, w19
	if (sizeof(struct tipc_ctrl_msg_hdr) + msg_body_len != msg_len) {
ffffffffea80f140:	91002260 	add	x0, x19, #0x8
ffffffffea80f144:	eb00005f 	cmp	x2, x0
ffffffffea80f148:	54000a41 	b.ne	ffffffffea80f290 <tipc_rx_thread_func+0x378>  // b.any
	switch (msg_type) {
ffffffffea80f14c:	71000f5f 	cmp	w26, #0x3
ffffffffea80f150:	54000620 	b.eq	ffffffffea80f214 <tipc_rx_thread_func+0x2fc>  // b.none
ffffffffea80f154:	7100175f 	cmp	w26, #0x5
ffffffffea80f158:	540009c1 	b.ne	ffffffffea80f290 <tipc_rx_thread_func+0x378>  // b.any
		if (msg_body_len != sizeof(struct tipc_disc_req_body)) {
ffffffffea80f15c:	f100127f 	cmp	x19, #0x4
ffffffffea80f160:	54000981 	b.ne	ffffffffea80f290 <tipc_rx_thread_func+0x378>  // b.any
ffffffffea80f164:	d2822d02 	mov	x2, #0x1168                	// #4456
	uint32_t target = ns_req->target;
ffffffffea80f168:	b9401833 	ldr	w19, [x1, #24]
ffffffffea80f16c:	aa1803e0 	mov	x0, x24
ffffffffea80f170:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f174:	8b0202ba 	add	x26, x21, x2
ffffffffea80f178:	97ffda10 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	return (uint)(addr - TIPC_ADDR_BASE);
ffffffffea80f17c:	510fa261 	sub	w1, w19, #0x3e8
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80f180:	7103fc3f 	cmp	w1, #0xff
ffffffffea80f184:	540008a9 	b.ls	ffffffffea80f298 <tipc_rx_thread_func+0x380>  // b.plast
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80f188:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80f18c:	14000004 	b	ffffffffea80f19c <tipc_rx_thread_func+0x284>
ffffffffea80f190:	91000400 	add	x0, x0, #0x1
		for (uint slot  = 0; slot < countof(dev->epts); slot++) {
ffffffffea80f194:	f104001f 	cmp	x0, #0x100
ffffffffea80f198:	54000320 	b.eq	ffffffffea80f1fc <tipc_rx_thread_func+0x2e4>  // b.none
ffffffffea80f19c:	d346fc01 	lsr	x1, x0, #6
ffffffffea80f1a0:	f8617b41 	ldr	x1, [x26, x1, lsl #3]
ffffffffea80f1a4:	9ac02421 	lsr	x1, x1, x0
			if (bitmap_test(dev->inuse, slot)) {
ffffffffea80f1a8:	3607ff41 	tbz	w1, #0, ffffffffea80f190 <tipc_rx_thread_func+0x278>
				if (dev->epts[slot].remote == remote) {
ffffffffea80f1ac:	8b0012a1 	add	x1, x21, x0, lsl #4
ffffffffea80f1b0:	b9416821 	ldr	w1, [x1, #360]
ffffffffea80f1b4:	6b01037f 	cmp	w27, w1
ffffffffea80f1b8:	54fffec1 	b.ne	ffffffffea80f190 <tipc_rx_thread_func+0x278>  // b.any
					ept = &dev->epts[slot];
ffffffffea80f1bc:	8b0012a0 	add	x0, x21, x0, lsl #4
ffffffffea80f1c0:	9105a013 	add	x19, x0, #0x168
		handle_t *chan = ept->chan;
ffffffffea80f1c4:	f940067b 	ldr	x27, [x19, #8]
		if (chan) {
ffffffffea80f1c8:	b400011b 	cbz	x27, ffffffffea80f1e8 <tipc_rx_thread_func+0x2d0>
			handle_list_del(&dev->handle_list, chan);
ffffffffea80f1cc:	aa1b03e1 	mov	x1, x27
ffffffffea80f1d0:	d2823700 	mov	x0, #0x11b8                	// #4536
ffffffffea80f1d4:	8b0002a0 	add	x0, x21, x0
ffffffffea80f1d8:	97ffecd2 	bl	ffffffffea80a520 <handle_list_del>
	handle->cookie = cookie;
ffffffffea80f1dc:	f9001b7f 	str	xzr, [x27, #48]
			handle_close(chan);
ffffffffea80f1e0:	aa1b03e0 	mov	x0, x27
ffffffffea80f1e4:	97ffec33 	bl	ffffffffea80a2b0 <handle_close>
	return slot_to_addr(ept - dev->epts);
ffffffffea80f1e8:	9105a2a0 	add	x0, x21, #0x168
ffffffffea80f1ec:	cb000260 	sub	x0, x19, x0
ffffffffea80f1f0:	9344fc00 	asr	x0, x0, #4
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80f1f4:	7103fc1f 	cmp	w0, #0xff
ffffffffea80f1f8:	540009a9 	b.ls	ffffffffea80f32c <tipc_rx_thread_func+0x414>  // b.plast
	mutex_release(&dev->ept_lock);
ffffffffea80f1fc:	aa1803e0 	mov	x0, x24
ffffffffea80f200:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea80f204:	97ffda19 	bl	ffffffffea805a68 <mutex_release>
ffffffffea80f208:	17ffff7e 	b	ffffffffea80f000 <tipc_rx_thread_func+0xe8>
	if (buf->in_iovs.used == 0) {
ffffffffea80f20c:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea80f210:	17ffff7e 	b	ffffffffea80f008 <tipc_rx_thread_func+0xf0>
		if (msg_body_len != sizeof(struct tipc_conn_req_body)) {
ffffffffea80f214:	f104027f 	cmp	x19, #0x100
ffffffffea80f218:	540003c1 	b.ne	ffffffffea80f290 <tipc_rx_thread_func+0x378>  // b.any
	strncpy(req.name, (const char *)ns_req->name, sizeof(req.name));
ffffffffea80f21c:	aa1303e2 	mov	x2, x19
ffffffffea80f220:	91006021 	add	x1, x1, #0x18
ffffffffea80f224:	f9002fbc 	str	x28, [x29, #88]
ffffffffea80f228:	910483a0 	add	x0, x29, #0x120
	handle_t *chan = NULL;
ffffffffea80f22c:	f90043bf 	str	xzr, [x29, #128]
	strncpy(req.name, (const char *)ns_req->name, sizeof(req.name));
ffffffffea80f230:	94001168 	bl	ffffffffea8137d0 <strncpy>
	err = ipc_port_connect_async(dev->guest, dev->uuid, req.name, sizeof(req.name),
ffffffffea80f234:	b9402aa0 	ldr	w0, [x21, #40]
ffffffffea80f238:	910203a5 	add	x5, x29, #0x80
ffffffffea80f23c:	f9401aa1 	ldr	x1, [x21, #48]
ffffffffea80f240:	52800004 	mov	w4, #0x0                   	// #0
ffffffffea80f244:	aa1303e3 	mov	x3, x19
ffffffffea80f248:	910483a2 	add	x2, x29, #0x120
ffffffffea80f24c:	97fff355 	bl	ffffffffea80bfa0 <ipc_port_connect_async>
ffffffffea80f250:	2a0003fc 	mov	w28, w0
	if (err == NO_ERROR) {
ffffffffea80f254:	340008e0 	cbz	w0, ffffffffea80f370 <tipc_rx_thread_func+0x458>
	if (chan) {
ffffffffea80f258:	f94043a1 	ldr	x1, [x29, #128]
	return NULL;
ffffffffea80f25c:	d2800000 	mov	x0, #0x0                   	// #0
	if (chan) {
ffffffffea80f260:	b4000381 	cbz	x1, ffffffffea80f2d0 <tipc_rx_thread_func+0x3b8>
ffffffffea80f264:	f9001820 	str	x0, [x1, #48]
		handle_list_add(&dev->handle_list, chan);
ffffffffea80f268:	d2823703 	mov	x3, #0x11b8                	// #4536
ffffffffea80f26c:	8b0302a0 	add	x0, x21, x3
		event_signal(&dev->have_handles, false);
ffffffffea80f270:	52800013 	mov	w19, #0x0                   	// #0
		handle_list_add(&dev->handle_list, chan);
ffffffffea80f274:	97ffec81 	bl	ffffffffea80a478 <handle_list_add>
		event_signal(&dev->have_handles, false);
ffffffffea80f278:	d2823104 	mov	x4, #0x1188                	// #4488
ffffffffea80f27c:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80f280:	8b0402a0 	add	x0, x21, x4
ffffffffea80f284:	97ffd96d 	bl	ffffffffea805838 <event_signal>
ffffffffea80f288:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea80f28c:	17ffff5d 	b	ffffffffea80f000 <tipc_rx_thread_func+0xe8>
		if (msg_body_len != sizeof(struct tipc_disc_req_body)) {
ffffffffea80f290:	128000d3 	mov	w19, #0xfffffff9            	// #-7
ffffffffea80f294:	17ffff5b 	b	ffffffffea80f000 <tipc_rx_thread_func+0xe8>
ffffffffea80f298:	2a0103e0 	mov	w0, w1
ffffffffea80f29c:	d346fc02 	lsr	x2, x0, #6
ffffffffea80f2a0:	f8627b42 	ldr	x2, [x26, x2, lsl #3]
ffffffffea80f2a4:	9ac12441 	lsr	x1, x2, x1
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80f2a8:	3607f701 	tbz	w1, #0, ffffffffea80f188 <tipc_rx_thread_func+0x270>
	if (!ept || ept->remote != remote) {
ffffffffea80f2ac:	91005800 	add	x0, x0, #0x16
ffffffffea80f2b0:	d37cec00 	lsl	x0, x0, #4
ffffffffea80f2b4:	8b0002a1 	add	x1, x21, x0
ffffffffea80f2b8:	b9400821 	ldr	w1, [x1, #8]
ffffffffea80f2bc:	6b01037f 	cmp	w27, w1
ffffffffea80f2c0:	54fff641 	b.ne	ffffffffea80f188 <tipc_rx_thread_func+0x270>  // b.any
			return &dev->epts[slot];
ffffffffea80f2c4:	91002000 	add	x0, x0, #0x8
ffffffffea80f2c8:	8b0002b3 	add	x19, x21, x0
ffffffffea80f2cc:	17ffffbe 	b	ffffffffea80f1c4 <tipc_rx_thread_func+0x2ac>
	return NULL;
ffffffffea80f2d0:	5280001a 	mov	w26, #0x0                   	// #0
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f2d4:	d2800080 	mov	x0, #0x4                   	// #4
	return tipc_send_data(dev, local, remote,
ffffffffea80f2d8:	f0ffffe3 	adrp	x3, ffffffffea80e000 <trusty_sm_stdcall+0x70>
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f2dc:	f2c00280 	movk	x0, #0x14, lsl #32
	return tipc_send_data(dev, local, remote,
ffffffffea80f2e0:	912a2063 	add	x3, x3, #0xa88
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f2e4:	f9005fa0 	str	x0, [x29, #184]
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f2e8:	9102e3a0 	add	x0, x29, #0xb8
ffffffffea80f2ec:	d2800385 	mov	x5, #0x1c                  	// #28
	return tipc_send_data(dev, local, remote,
ffffffffea80f2f0:	528006a2 	mov	w2, #0x35                  	// #53
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f2f4:	f9004fa0 	str	x0, [x29, #152]
	return tipc_send_data(dev, local, remote,
ffffffffea80f2f8:	910263a4 	add	x4, x29, #0x98
ffffffffea80f2fc:	2a0203e1 	mov	w1, w2
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f300:	f90053a5 	str	x5, [x29, #160]
	msg.body.status = status;
ffffffffea80f304:	291873bb 	stp	w27, w28, [x29, #192]
	return tipc_send_data(dev, local, remote,
ffffffffea80f308:	aa1503e0 	mov	x0, x21
	msg.body.remote = local;
ffffffffea80f30c:	b900cbba 	str	w26, [x29, #200]
	if (err) {
ffffffffea80f310:	52800013 	mov	w19, #0x0                   	// #0
	msg.body.max_msg_size = msg_sz;
ffffffffea80f314:	f80cc3bf 	stur	xzr, [x29, #204]
	return tipc_send_data(dev, local, remote,
ffffffffea80f318:	97fffe20 	bl	ffffffffea80eb98 <tipc_send_data.constprop.3>
ffffffffea80f31c:	2a0003e3 	mov	w3, w0
	if (err) {
ffffffffea80f320:	350007c0 	cbnz	w0, ffffffffea80f418 <tipc_rx_thread_func+0x500>
ffffffffea80f324:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea80f328:	17ffff36 	b	ffffffffea80f000 <tipc_rx_thread_func+0xe8>
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80f32c:	93437c01 	sbfx	x1, x0, #3, #29
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f330:	52800022 	mov	w2, #0x1                   	// #1
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea80f334:	927ee821 	and	x1, x1, #0x1ffffffffffffffc
ffffffffea80f338:	1ac02042 	lsl	w2, w2, w0
ffffffffea80f33c:	8b01035a 	add	x26, x26, x1
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80f340:	2a2203e1 	mvn	w1, w2
ffffffffea80f344:	885f7f42 	ldxr	w2, [x26]
ffffffffea80f348:	0a010042 	and	w2, w2, w1
ffffffffea80f34c:	88037f42 	stxr	w3, w2, [x26]
ffffffffea80f350:	35ffffa3 	cbnz	w3, ffffffffea80f344 <tipc_rx_thread_func+0x42c>
ffffffffea80f354:	d37c7c00 	ubfiz	x0, x0, #4, #32
ffffffffea80f358:	8b0002a0 	add	x0, x21, x0
		dev->epts[slot].remote = 0;
ffffffffea80f35c:	b901681f 	str	wzr, [x0, #360]
		dev->epts[slot].chan = NULL;
ffffffffea80f360:	f900b81f 	str	xzr, [x0, #368]
ffffffffea80f364:	17ffffa6 	b	ffffffffea80f1fc <tipc_rx_thread_func+0x2e4>
		if (ept->chan){
ffffffffea80f368:	12800033 	mov	w19, #0xfffffffe            	// #-2
ffffffffea80f36c:	17ffff6d 	b	ffffffffea80f120 <tipc_rx_thread_func+0x208>
ffffffffea80f370:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f374:	aa1803e0 	mov	x0, x24
ffffffffea80f378:	97ffd990 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
		if (bitmap[i] == ~0UL)
ffffffffea80f37c:	f948b6a0 	ldr	x0, [x21, #4456]
	int slot = bitmap_ffz(dev->inuse, TIPC_ADDR_MAX_NUM);
ffffffffea80f380:	d2822d05 	mov	x5, #0x1168                	// #4456
ffffffffea80f384:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea80f388:	8b0502a4 	add	x4, x21, x5
ffffffffea80f38c:	b100041f 	cmn	x0, #0x1
		local = alloc_local_addr(dev, remote, chan);
ffffffffea80f390:	f94043a5 	ldr	x5, [x29, #128]
ffffffffea80f394:	54000540 	b.eq	ffffffffea80f43c <tipc_rx_thread_func+0x524>  // b.none
	return __builtin_ffsl(~x) - 1;
ffffffffea80f398:	aa2003e1 	mvn	x1, x0
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f39c:	52800023 	mov	w3, #0x1                   	// #1
	return __builtin_ffsl(~x) - 1;
ffffffffea80f3a0:	dac00020 	rbit	x0, x1
ffffffffea80f3a4:	f100003f 	cmp	x1, #0x0
ffffffffea80f3a8:	dac01000 	clz	x0, x0
    return __atomic_fetch_or(ptr, val, __ATOMIC_RELAXED);
ffffffffea80f3ac:	f90037a4 	str	x4, [x29, #104]
ffffffffea80f3b0:	5a9f1000 	csinv	w0, w0, wzr, ne  // ne = any
		bit = i * BITMAP_BITS_PER_WORD + _ffz(bitmap[i]);
ffffffffea80f3b4:	0b020013 	add	w19, w0, w2
ffffffffea80f3b8:	aa1303fa 	mov	x26, x19
	return atomic_or(&((int*)bitmap)[BITMAP_INT(bit)], mask) & mask ? 1 : 0;
ffffffffea80f3bc:	d345fe60 	lsr	x0, x19, #5
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f3c0:	1ad32061 	lsl	w1, w3, w19
ffffffffea80f3c4:	8b000880 	add	x0, x4, x0, lsl #2
ffffffffea80f3c8:	885f7c02 	ldxr	w2, [x0]
ffffffffea80f3cc:	2a010042 	orr	w2, w2, w1
ffffffffea80f3d0:	88037c02 	stxr	w3, w2, [x0]
ffffffffea80f3d4:	35ffffa3 	cbnz	w3, ffffffffea80f3c8 <tipc_rx_thread_func+0x4b0>
ffffffffea80f3d8:	8b1312a1 	add	x1, x21, x19, lsl #4
		mutex_release(&dev->ept_lock);
ffffffffea80f3dc:	aa1803e0 	mov	x0, x24
		dev->epts[slot].remote = remote;
ffffffffea80f3e0:	b901683b 	str	w27, [x1, #360]
		dev->epts[slot].chan = chan;
ffffffffea80f3e4:	f900b825 	str	x5, [x1, #368]
		mutex_release(&dev->ept_lock);
ffffffffea80f3e8:	97ffd9a0 	bl	ffffffffea805a68 <mutex_release>
	if (chan) {
ffffffffea80f3ec:	f94043a1 	ldr	x1, [x29, #128]
ffffffffea80f3f0:	f94037a4 	ldr	x4, [x29, #104]
ffffffffea80f3f4:	b40003c1 	cbz	x1, ffffffffea80f46c <tipc_rx_thread_func+0x554>
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80f3f8:	d346fe62 	lsr	x2, x19, #6
			return &dev->epts[slot];
ffffffffea80f3fc:	8b1312a0 	add	x0, x21, x19, lsl #4
ffffffffea80f400:	9105a000 	add	x0, x0, #0x168
ffffffffea80f404:	f8627882 	ldr	x2, [x4, x2, lsl #3]
ffffffffea80f408:	9ada245a 	lsr	x26, x2, x26
ffffffffea80f40c:	f240035f 	tst	x26, #0x1
ffffffffea80f410:	9a9f1000 	csel	x0, x0, xzr, ne  // ne = any
ffffffffea80f414:	17ffff94 	b	ffffffffea80f264 <tipc_rx_thread_func+0x34c>
		TRACEF("failed (%d) to send response\n", err);
ffffffffea80f418:	90000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80f41c:	90000040 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80f420:	52802982 	mov	w2, #0x14c                 	// #332
ffffffffea80f424:	91260021 	add	x1, x1, #0x980
ffffffffea80f428:	9128a000 	add	x0, x0, #0xa28
ffffffffea80f42c:	2a0303f3 	mov	w19, w3
ffffffffea80f430:	94000f80 	bl	ffffffffea813230 <_printf>
ffffffffea80f434:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea80f438:	17fffef2 	b	ffffffffea80f000 <tipc_rx_thread_func+0xe8>
		if (bitmap[i] == ~0UL)
ffffffffea80f43c:	f948baa0 	ldr	x0, [x21, #4464]
	for (i = 0; i < BITMAP_NUM_WORDS(numbits); i++) {
ffffffffea80f440:	52800022 	mov	w2, #0x1                   	// #1
		if (bitmap[i] == ~0UL)
ffffffffea80f444:	b100041f 	cmn	x0, #0x1
ffffffffea80f448:	54000060 	b.eq	ffffffffea80f454 <tipc_rx_thread_func+0x53c>  // b.none
ffffffffea80f44c:	531a6442 	lsl	w2, w2, #6
ffffffffea80f450:	17ffffd2 	b	ffffffffea80f398 <tipc_rx_thread_func+0x480>
ffffffffea80f454:	f948bea0 	ldr	x0, [x21, #4472]
ffffffffea80f458:	b100041f 	cmn	x0, #0x1
ffffffffea80f45c:	540000c0 	b.eq	ffffffffea80f474 <tipc_rx_thread_func+0x55c>  // b.none
	for (i = 0; i < BITMAP_NUM_WORDS(numbits); i++) {
ffffffffea80f460:	52800042 	mov	w2, #0x2                   	// #2
ffffffffea80f464:	531a6442 	lsl	w2, w2, #6
ffffffffea80f468:	17ffffcc 	b	ffffffffea80f398 <tipc_rx_thread_func+0x480>
	return (uint32_t) (slot + TIPC_ADDR_BASE);
ffffffffea80f46c:	110fa35a 	add	w26, w26, #0x3e8
ffffffffea80f470:	17ffff99 	b	ffffffffea80f2d4 <tipc_rx_thread_func+0x3bc>
		if (bitmap[i] == ~0UL)
ffffffffea80f474:	f948c2a0 	ldr	x0, [x21, #4480]
ffffffffea80f478:	b100041f 	cmn	x0, #0x1
ffffffffea80f47c:	54000080 	b.eq	ffffffffea80f48c <tipc_rx_thread_func+0x574>  // b.none
	for (i = 0; i < BITMAP_NUM_WORDS(numbits); i++) {
ffffffffea80f480:	2a1a03e2 	mov	w2, w26
ffffffffea80f484:	531a6442 	lsl	w2, w2, #6
ffffffffea80f488:	17ffffc4 	b	ffffffffea80f398 <tipc_rx_thread_func+0x480>
			handle_close(chan);
ffffffffea80f48c:	aa0503e0 	mov	x0, x5
ffffffffea80f490:	97ffeb88 	bl	ffffffffea80a2b0 <handle_close>
		mutex_release(&dev->ept_lock);
ffffffffea80f494:	aa1803e0 	mov	x0, x24
			chan = NULL;
ffffffffea80f498:	f90043bf 	str	xzr, [x29, #128]
		mutex_release(&dev->ept_lock);
ffffffffea80f49c:	97ffd973 	bl	ffffffffea805a68 <mutex_release>
	if (chan) {
ffffffffea80f4a0:	f94043a1 	ldr	x1, [x29, #128]
ffffffffea80f4a4:	b4fff161 	cbz	x1, ffffffffea80f2d0 <tipc_rx_thread_func+0x3b8>
	return NULL;
ffffffffea80f4a8:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80f4ac:	17ffff6e 	b	ffffffffea80f264 <tipc_rx_thread_func+0x34c>

ffffffffea80f4b0 <tipc_rx_vq_notify_cb>:
ffffffffea80f4b0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80f4b4:	910003fd 	mov	x29, sp
ffffffffea80f4b8:	97fff8e0 	bl	ffffffffea80d838 <vqueue_signal_avail>
ffffffffea80f4bc:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80f4c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80f4c4:	d65f03c0 	ret

ffffffffea80f4c8 <tipc_vdev_reset>:
	if (dev->vd.state == VDEV_STATE_RESET) {
ffffffffea80f4c8:	b9400001 	ldr	w1, [x0]
ffffffffea80f4cc:	35000061 	cbnz	w1, ffffffffea80f4d8 <tipc_vdev_reset+0x10>
}
ffffffffea80f4d0:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80f4d4:	d65f03c0 	ret
{
ffffffffea80f4d8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80f4dc:	910003fd 	mov	x29, sp
ffffffffea80f4e0:	f90023f9 	str	x25, [sp, #64]
	dev->rx_stop = true;
ffffffffea80f4e4:	91400419 	add	x25, x0, #0x1, lsl #12
{
ffffffffea80f4e8:	f9000ff4 	str	x20, [sp, #24]
	dev->rx_stop = true;
ffffffffea80f4ec:	52800034 	mov	w20, #0x1                   	// #1
{
ffffffffea80f4f0:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80f4f4:	aa0003f7 	mov	x23, x0
ffffffffea80f4f8:	f9002bfb 	str	x27, [sp, #80]
	vqueue_signal_avail(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80f4fc:	9103601b 	add	x27, x0, #0xd8
	dev->rx_stop = true;
ffffffffea80f500:	39094734 	strb	w20, [x25, #593]
	vqueue_signal_avail(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80f504:	aa1b03e0 	mov	x0, x27
ffffffffea80f508:	f90037be 	str	x30, [x29, #104]
ffffffffea80f50c:	97fff8cb 	bl	ffffffffea80d838 <vqueue_signal_avail>
	rc = thread_join(dev->rx_thread, NULL, 1000);
ffffffffea80f510:	f94922e0 	ldr	x0, [x23, #4672]
ffffffffea80f514:	52807d02 	mov	w2, #0x3e8                 	// #1000
ffffffffea80f518:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80f51c:	97ffdd3b 	bl	ffffffffea806a08 <thread_join>
ffffffffea80f520:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80f524:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80f528:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80f52c:	f90027ba 	str	x26, [x29, #72]
ffffffffea80f530:	f9002fbc 	str	x28, [x29, #88]
	if (rc != NO_ERROR) {
ffffffffea80f534:	35000b00 	cbnz	w0, ffffffffea80f694 <tipc_vdev_reset+0x1cc>
	dev->rx_thread = NULL;
ffffffffea80f538:	f90922ff 	str	xzr, [x23, #4672]
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80f53c:	d2823702 	mov	x2, #0x11b8                	// #4536
	mutex_acquire(&dev->ept_lock);
ffffffffea80f540:	d2824103 	mov	x3, #0x1208                	// #4616
	dev->tx_stop = true;
ffffffffea80f544:	39094334 	strb	w20, [x25, #592]
	dev->rx_stop = false;
ffffffffea80f548:	3909473f 	strb	wzr, [x25, #593]
	ept = dev->epts;
ffffffffea80f54c:	9105a2f5 	add	x21, x23, #0x168
ffffffffea80f550:	d2822d01 	mov	x1, #0x1168                	// #4456
	mutex_acquire(&dev->ept_lock);
ffffffffea80f554:	8b0302fc 	add	x28, x23, x3
ffffffffea80f558:	8b0102fa 	add	x26, x23, x1
	ept = dev->epts;
ffffffffea80f55c:	aa1503f3 	mov	x19, x21
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80f560:	8b0202f6 	add	x22, x23, x2
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f564:	52800038 	mov	w24, #0x1                   	// #1
ffffffffea80f568:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f56c:	aa1c03e0 	mov	x0, x28
	ept = dev->epts;
ffffffffea80f570:	d2800014 	mov	x20, #0x0                   	// #0
ffffffffea80f574:	97ffd911 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
ffffffffea80f578:	14000005 	b	ffffffffea80f58c <tipc_vdev_reset+0xc4>
	for (uint slot  = 0; slot < countof(dev->epts); slot++, ept++) {
ffffffffea80f57c:	91004273 	add	x19, x19, #0x10
ffffffffea80f580:	91000694 	add	x20, x20, #0x1
ffffffffea80f584:	eb1a027f 	cmp	x19, x26
ffffffffea80f588:	54000440 	b.eq	ffffffffea80f610 <tipc_vdev_reset+0x148>  // b.none
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80f58c:	d346fe80 	lsr	x0, x20, #6
ffffffffea80f590:	f8607b40 	ldr	x0, [x26, x0, lsl #3]
ffffffffea80f594:	9ad42400 	lsr	x0, x0, x20
		if (!bitmap_test(dev->inuse, slot)) {
ffffffffea80f598:	3607ff20 	tbz	w0, #0, ffffffffea80f57c <tipc_vdev_reset+0xb4>
		if (!ept->chan) {
ffffffffea80f59c:	f9400661 	ldr	x1, [x19, #8]
ffffffffea80f5a0:	b4fffee1 	cbz	x1, ffffffffea80f57c <tipc_vdev_reset+0xb4>
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80f5a4:	aa1603e0 	mov	x0, x22
ffffffffea80f5a8:	97ffebde 	bl	ffffffffea80a520 <handle_list_del>
		handle_set_cookie(ept->chan, NULL);
ffffffffea80f5ac:	f9400661 	ldr	x1, [x19, #8]
		handle_close(ept->chan);
ffffffffea80f5b0:	aa0103e0 	mov	x0, x1
ffffffffea80f5b4:	f900183f 	str	xzr, [x1, #48]
ffffffffea80f5b8:	97ffeb3e 	bl	ffffffffea80a2b0 <handle_close>
	return slot_to_addr(ept - dev->epts);
ffffffffea80f5bc:	cb150260 	sub	x0, x19, x21
ffffffffea80f5c0:	9344fc00 	asr	x0, x0, #4
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80f5c4:	7103fc1f 	cmp	w0, #0xff
ffffffffea80f5c8:	54fffda8 	b.hi	ffffffffea80f57c <tipc_vdev_reset+0xb4>  // b.pmore
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80f5cc:	93437c01 	sbfx	x1, x0, #3, #29
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f5d0:	1ac02303 	lsl	w3, w24, w0
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea80f5d4:	927ee821 	and	x1, x1, #0x1ffffffffffffffc
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80f5d8:	2a2303e3 	mvn	w3, w3
ffffffffea80f5dc:	8b010341 	add	x1, x26, x1
ffffffffea80f5e0:	885f7c22 	ldxr	w2, [x1]
ffffffffea80f5e4:	0a030042 	and	w2, w2, w3
ffffffffea80f5e8:	88047c22 	stxr	w4, w2, [x1]
ffffffffea80f5ec:	35ffffa4 	cbnz	w4, ffffffffea80f5e0 <tipc_vdev_reset+0x118>
ffffffffea80f5f0:	d37c7c00 	ubfiz	x0, x0, #4, #32
	for (uint slot  = 0; slot < countof(dev->epts); slot++, ept++) {
ffffffffea80f5f4:	91004273 	add	x19, x19, #0x10
ffffffffea80f5f8:	8b0002e0 	add	x0, x23, x0
ffffffffea80f5fc:	91000694 	add	x20, x20, #0x1
ffffffffea80f600:	eb1a027f 	cmp	x19, x26
		dev->epts[slot].remote = 0;
ffffffffea80f604:	b901681f 	str	wzr, [x0, #360]
		dev->epts[slot].chan = NULL;
ffffffffea80f608:	f900b81f 	str	xzr, [x0, #368]
	for (uint slot  = 0; slot < countof(dev->epts); slot++, ept++) {
ffffffffea80f60c:	54fffc01 	b.ne	ffffffffea80f58c <tipc_vdev_reset+0xc4>  // b.any
	mutex_release(&dev->ept_lock);
ffffffffea80f610:	aa1c03e0 	mov	x0, x28
ffffffffea80f614:	97ffd915 	bl	ffffffffea805a68 <mutex_release>
	event_signal(&dev->have_handles, false);
ffffffffea80f618:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80f61c:	d2823100 	mov	x0, #0x1188                	// #4488
	vqueue_signal_avail(&dev->vqs[TIPC_VQ_TX]);
ffffffffea80f620:	910122f3 	add	x19, x23, #0x48
	event_signal(&dev->have_handles, false);
ffffffffea80f624:	8b0002e0 	add	x0, x23, x0
ffffffffea80f628:	97ffd884 	bl	ffffffffea805838 <event_signal>
	vqueue_signal_avail(&dev->vqs[TIPC_VQ_TX]);
ffffffffea80f62c:	aa1303e0 	mov	x0, x19
ffffffffea80f630:	97fff882 	bl	ffffffffea80d838 <vqueue_signal_avail>
	rc = thread_join(dev->tx_thread, NULL, 1000);
ffffffffea80f634:	f94926e0 	ldr	x0, [x23, #4680]
ffffffffea80f638:	52807d02 	mov	w2, #0x3e8                 	// #1000
ffffffffea80f63c:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80f640:	97ffdcf2 	bl	ffffffffea806a08 <thread_join>
	if (rc != NO_ERROR) {
ffffffffea80f644:	35000320 	cbnz	w0, ffffffffea80f6a8 <tipc_vdev_reset+0x1e0>
	dev->tx_thread = NULL;
ffffffffea80f648:	f90926ff 	str	xzr, [x23, #4680]
	vqueue_destroy(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80f64c:	aa1b03e0 	mov	x0, x27
	dev->tx_stop = false;
ffffffffea80f650:	3909433f 	strb	wzr, [x25, #592]
	vqueue_destroy(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80f654:	97fff853 	bl	ffffffffea80d7a0 <vqueue_destroy>
	vqueue_destroy(&dev->vqs[TIPC_VQ_TX]);
ffffffffea80f658:	aa1303e0 	mov	x0, x19
ffffffffea80f65c:	97fff851 	bl	ffffffffea80d7a0 <vqueue_destroy>
}
ffffffffea80f660:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80f664:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80f668:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80f66c:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80f670:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea80f674:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea80f678:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80f67c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80f680:	f9402bfb 	ldr	x27, [sp, #80]
	dev->vd.state = VDEV_STATE_RESET;
ffffffffea80f684:	b90002ff 	str	wzr, [x23]
}
ffffffffea80f688:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80f68c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80f690:	d65f03c0 	ret
		panic("unable to shutdown rx thread: %d\n", rc);
ffffffffea80f694:	2a0003e2 	mov	w2, w0
ffffffffea80f698:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea80f69c:	90000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80f6a0:	912c4021 	add	x1, x1, #0xb10
ffffffffea80f6a4:	9400097d 	bl	ffffffffea811c98 <_panic>
		panic("unable to shutdown tx thread: %d\n", rc);
ffffffffea80f6a8:	2a0003e2 	mov	w2, w0
ffffffffea80f6ac:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea80f6b0:	90000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80f6b4:	912ce021 	add	x1, x1, #0xb38
ffffffffea80f6b8:	94000978 	bl	ffffffffea811c98 <_panic>
ffffffffea80f6bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80f6c0 <tipc_tx_thread_func>:
{
ffffffffea80f6c0:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
ffffffffea80f6c4:	910003fd 	mov	x29, sp
ffffffffea80f6c8:	f9002ffc 	str	x28, [sp, #88]
	while (!dev->tx_stop) {
ffffffffea80f6cc:	9140041c 	add	x28, x0, #0x1, lsl #12
ffffffffea80f6d0:	39494381 	ldrb	w1, [x28, #592]
ffffffffea80f6d4:	35001361 	cbnz	w1, ffffffffea80f940 <tipc_tx_thread_func+0x280>
ffffffffea80f6d8:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80f6dc:	aa0003f4 	mov	x20, x0
ffffffffea80f6e0:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80f6e4:	d2823707 	mov	x7, #0x11b8                	// #4536
ffffffffea80f6e8:	a9046bb9 	stp	x25, x26, [x29, #64]
		ret = tipc_send_data(dev, local, remote,
ffffffffea80f6ec:	f0fffff8 	adrp	x24, ffffffffea80e000 <trusty_sm_stdcall+0x70>
ffffffffea80f6f0:	8b070299 	add	x25, x20, x7
ffffffffea80f6f4:	912bc318 	add	x24, x24, #0xaf0
ffffffffea80f6f8:	d2823106 	mov	x6, #0x1188                	// #4488
ffffffffea80f6fc:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80f700:	8b060000 	add	x0, x0, x6
ffffffffea80f704:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80f708:	a90603be 	stp	x30, x0, [x29, #96]
ffffffffea80f70c:	d503201f 	nop
ffffffffea80f710:	f94037a0 	ldr	x0, [x29, #104]
	msg.hdr.type = TIPC_CTRL_MSGTYPE_DISC_REQ;
ffffffffea80f714:	d28000bb 	mov	x27, #0x5                   	// #5
ffffffffea80f718:	f2c0009b 	movk	x27, #0x4, lsl #32
ffffffffea80f71c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f720:	97ffd822 	bl	ffffffffea8057a8 <event_wait_timeout>
ffffffffea80f724:	14000005 	b	ffffffffea80f738 <tipc_tx_thread_func+0x78>
		} else if (chan_event & IPC_HANDLE_POLL_MSG) {
ffffffffea80f728:	37180620 	tbnz	w0, #3, ffffffffea80f7ec <tipc_tx_thread_func+0x12c>
		} else if (chan_event & IPC_HANDLE_POLL_HUP) {
ffffffffea80f72c:	37100b60 	tbnz	w0, #2, ffffffffea80f898 <tipc_tx_thread_func+0x1d8>
		handle_decref(chan);
ffffffffea80f730:	aa1303e0 	mov	x0, x19
ffffffffea80f734:	97ffeab7 	bl	ffffffffea80a210 <handle_decref>
		ret = handle_list_wait(&dev->handle_list, &chan,
ffffffffea80f738:	12800003 	mov	w3, #0xffffffff            	// #-1
ffffffffea80f73c:	9101d3a2 	add	x2, x29, #0x74
ffffffffea80f740:	9101e3a1 	add	x1, x29, #0x78
ffffffffea80f744:	aa1903e0 	mov	x0, x25
ffffffffea80f748:	97ffeb88 	bl	ffffffffea80a568 <handle_list_wait>
		if (ret == ERR_NOT_FOUND) {
ffffffffea80f74c:	3100081f 	cmn	w0, #0x2
ffffffffea80f750:	54000ea0 	b.eq	ffffffffea80f924 <tipc_tx_thread_func+0x264>  // b.none
		if (ret < 0) {
ffffffffea80f754:	37f813a0 	tbnz	w0, #31, ffffffffea80f9c8 <tipc_tx_thread_func+0x308>
		if (chan_event & IPC_HANDLE_POLL_READY) {
ffffffffea80f758:	b94077a0 	ldr	w0, [x29, #116]
ffffffffea80f75c:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea80f760:	3607fe40 	tbz	w0, #0, ffffffffea80f728 <tipc_tx_thread_func+0x68>
	mutex_acquire(&dev->ept_lock);
ffffffffea80f764:	d2824105 	mov	x5, #0x1208                	// #4616
ffffffffea80f768:	8b050295 	add	x21, x20, x5
ffffffffea80f76c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f770:	aa1503e0 	mov	x0, x21
ffffffffea80f774:	97ffd891 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	return handle->cookie;
ffffffffea80f778:	f9401a73 	ldr	x19, [x19, #48]
	if (ept) {
ffffffffea80f77c:	b4000793 	cbz	x19, ffffffffea80f86c <tipc_tx_thread_func+0x1ac>
		remote = ept->remote;
ffffffffea80f780:	b9400276 	ldr	w22, [x19]
	mutex_release(&dev->ept_lock);
ffffffffea80f784:	aa1503e0 	mov	x0, x21
ffffffffea80f788:	97ffd8b8 	bl	ffffffffea805a68 <mutex_release>
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f78c:	910243b5 	add	x21, x29, #0x90
	return slot_to_addr(ept - dev->epts);
ffffffffea80f790:	9105a280 	add	x0, x20, #0x168
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f794:	d2800081 	mov	x1, #0x4                   	// #4
	return slot_to_addr(ept - dev->epts);
ffffffffea80f798:	cb000260 	sub	x0, x19, x0
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f79c:	f2c00281 	movk	x1, #0x14, lsl #32
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f7a0:	d2800385 	mov	x5, #0x1c                  	// #28
	return tipc_send_data(dev, local, remote,
ffffffffea80f7a4:	528006a2 	mov	w2, #0x35                  	// #53
	return slot_to_addr(ept - dev->epts);
ffffffffea80f7a8:	9344fc00 	asr	x0, x0, #4
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f7ac:	a90817b5 	stp	x21, x5, [x29, #128]
	return (uint32_t) (slot + TIPC_ADDR_BASE);
ffffffffea80f7b0:	110fa000 	add	w0, w0, #0x3e8
	msg.body.remote = local;
ffffffffea80f7b4:	b900a3a0 	str	w0, [x29, #160]
	msg.body.max_msg_size = msg_sz;
ffffffffea80f7b8:	d2820000 	mov	x0, #0x1000                	// #4096
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f7bc:	f9004ba1 	str	x1, [x29, #144]
	msg.body.max_msg_size = msg_sz;
ffffffffea80f7c0:	f2c00020 	movk	x0, #0x1, lsl #32
	return tipc_send_data(dev, local, remote,
ffffffffea80f7c4:	f0ffffe3 	adrp	x3, ffffffffea80e000 <trusty_sm_stdcall+0x70>
ffffffffea80f7c8:	910203a4 	add	x4, x29, #0x80
	msg.body.status = status;
ffffffffea80f7cc:	29137fb6 	stp	w22, wzr, [x29, #152]
	msg.body.max_msg_size = msg_sz;
ffffffffea80f7d0:	f80a43a0 	stur	x0, [x29, #164]
	return tipc_send_data(dev, local, remote,
ffffffffea80f7d4:	912a2063 	add	x3, x3, #0xa88
ffffffffea80f7d8:	2a0203e1 	mov	w1, w2
ffffffffea80f7dc:	aa1403e0 	mov	x0, x20
ffffffffea80f7e0:	97fffcee 	bl	ffffffffea80eb98 <tipc_send_data.constprop.3>
ffffffffea80f7e4:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea80f7e8:	17ffffd2 	b	ffffffffea80f730 <tipc_tx_thread_func+0x70>
	mutex_acquire(&dev->ept_lock);
ffffffffea80f7ec:	d2824104 	mov	x4, #0x1208                	// #4616
ffffffffea80f7f0:	8b040295 	add	x21, x20, x4
ffffffffea80f7f4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f7f8:	aa1503e0 	mov	x0, x21
	data_cb_ctx_t cb_ctx = { .chan = chan };
ffffffffea80f7fc:	a9097fb3 	stp	x19, xzr, [x29, #144]
ffffffffea80f800:	97ffd86e 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
ffffffffea80f804:	f9401a60 	ldr	x0, [x19, #48]
	if (!ept) {
ffffffffea80f808:	b4000320 	cbz	x0, ffffffffea80f86c <tipc_tx_thread_func+0x1ac>
			TRACEF("tipc_send_data failed (%d)\n", ret);
ffffffffea80f80c:	9000005a 	adrp	x26, ffffffffea817000 <__func__.2428+0x420>
	remote = ept->remote;
ffffffffea80f810:	b9400017 	ldr	w23, [x0]
			TRACEF("tipc_send_data failed (%d)\n", ret);
ffffffffea80f814:	9126835a 	add	x26, x26, #0x9a0
	mutex_release(&dev->ept_lock);
ffffffffea80f818:	aa1503e0 	mov	x0, x21
ffffffffea80f81c:	910243b5 	add	x21, x29, #0x90
ffffffffea80f820:	97ffd892 	bl	ffffffffea805a68 <mutex_release>
		ret = ipc_get_msg(chan, &cb_ctx.msg_inf);
ffffffffea80f824:	910022b6 	add	x22, x21, #0x8
ffffffffea80f828:	1400000a 	b	ffffffffea80f850 <tipc_tx_thread_func+0x190>
		if (ret != NO_ERROR) {
ffffffffea80f82c:	35000c00 	cbnz	w0, ffffffffea80f9ac <tipc_tx_thread_func+0x2ec>
		ret = tipc_send_data(dev, local, remote,
ffffffffea80f830:	794133a5 	ldrh	w5, [x29, #152]
ffffffffea80f834:	aa1503e4 	mov	x4, x21
ffffffffea80f838:	aa1803e3 	mov	x3, x24
ffffffffea80f83c:	2a1703e2 	mov	w2, w23
ffffffffea80f840:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80f844:	aa1403e0 	mov	x0, x20
ffffffffea80f848:	97fffcd4 	bl	ffffffffea80eb98 <tipc_send_data.constprop.3>
		if (ret != NO_ERROR) {
ffffffffea80f84c:	35000180 	cbnz	w0, ffffffffea80f87c <tipc_tx_thread_func+0x1bc>
		ret = ipc_get_msg(chan, &cb_ctx.msg_inf);
ffffffffea80f850:	aa1603e1 	mov	x1, x22
ffffffffea80f854:	aa1303e0 	mov	x0, x19
ffffffffea80f858:	97fff568 	bl	ffffffffea80cdf8 <ipc_get_msg>
		if (ret == ERR_NO_MSG) {
ffffffffea80f85c:	3100101f 	cmn	w0, #0x4
ffffffffea80f860:	54fffe61 	b.ne	ffffffffea80f82c <tipc_tx_thread_func+0x16c>  // b.any
ffffffffea80f864:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea80f868:	17ffffb2 	b	ffffffffea80f730 <tipc_tx_thread_func+0x70>
		mutex_release(&dev->ept_lock);
ffffffffea80f86c:	aa1503e0 	mov	x0, x21
ffffffffea80f870:	97ffd87e 	bl	ffffffffea805a68 <mutex_release>
ffffffffea80f874:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea80f878:	17ffffae 	b	ffffffffea80f730 <tipc_tx_thread_func+0x70>
			TRACEF("tipc_send_data failed (%d)\n", ret);
ffffffffea80f87c:	90000044 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80f880:	2a0003e3 	mov	w3, w0
ffffffffea80f884:	528051c2 	mov	w2, #0x28e                 	// #654
ffffffffea80f888:	aa1a03e1 	mov	x1, x26
ffffffffea80f88c:	912b2080 	add	x0, x4, #0xac8
ffffffffea80f890:	94000e68 	bl	ffffffffea813230 <_printf>
ffffffffea80f894:	17ffffe4 	b	ffffffffea80f824 <tipc_tx_thread_func+0x164>
	mutex_acquire(&dev->ept_lock);
ffffffffea80f898:	d2824103 	mov	x3, #0x1208                	// #4616
ffffffffea80f89c:	8b030296 	add	x22, x20, x3
ffffffffea80f8a0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f8a4:	aa1603e0 	mov	x0, x22
ffffffffea80f8a8:	97ffd844 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
ffffffffea80f8ac:	f9401a62 	ldr	x2, [x19, #48]
	if (ept) {
ffffffffea80f8b0:	b4000502 	cbz	x2, ffffffffea80f950 <tipc_tx_thread_func+0x290>
		handle_list_del(&dev->handle_list, chan);
ffffffffea80f8b4:	aa1303e1 	mov	x1, x19
	return slot_to_addr(ept - dev->epts);
ffffffffea80f8b8:	9105a295 	add	x21, x20, #0x168
ffffffffea80f8bc:	cb150055 	sub	x21, x2, x21
		handle_list_del(&dev->handle_list, chan);
ffffffffea80f8c0:	aa1903e0 	mov	x0, x25
		remote = ept->remote;
ffffffffea80f8c4:	b9400057 	ldr	w23, [x2]
		handle_list_del(&dev->handle_list, chan);
ffffffffea80f8c8:	97ffeb16 	bl	ffffffffea80a520 <handle_list_del>
	handle->cookie = cookie;
ffffffffea80f8cc:	f9001a7f 	str	xzr, [x19, #48]
	return slot_to_addr(ept - dev->epts);
ffffffffea80f8d0:	9344feb5 	asr	x21, x21, #4
		handle_close(chan);
ffffffffea80f8d4:	aa1303e0 	mov	x0, x19
ffffffffea80f8d8:	97ffea76 	bl	ffffffffea80a2b0 <handle_close>
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80f8dc:	7103febf 	cmp	w21, #0xff
ffffffffea80f8e0:	54000409 	b.ls	ffffffffea80f960 <tipc_tx_thread_func+0x2a0>  // b.plast
	mutex_release(&dev->ept_lock);
ffffffffea80f8e4:	aa1603e0 	mov	x0, x22
ffffffffea80f8e8:	97ffd860 	bl	ffffffffea805a68 <mutex_release>
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f8ec:	910203a0 	add	x0, x29, #0x80
ffffffffea80f8f0:	d2800185 	mov	x5, #0xc                   	// #12
	return tipc_send_data(dev, local, remote,
ffffffffea80f8f4:	f0ffffe3 	adrp	x3, ffffffffea80e000 <trusty_sm_stdcall+0x70>
ffffffffea80f8f8:	910243a4 	add	x4, x29, #0x90
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f8fc:	a90917a0 	stp	x0, x5, [x29, #144]
	return tipc_send_data(dev, local, remote,
ffffffffea80f900:	912a2063 	add	x3, x3, #0xa88
ffffffffea80f904:	528006a2 	mov	w2, #0x35                  	// #53
ffffffffea80f908:	110fa2a1 	add	w1, w21, #0x3e8
	msg.hdr.type = TIPC_CTRL_MSGTYPE_DISC_REQ;
ffffffffea80f90c:	f90043bb 	str	x27, [x29, #128]
	return tipc_send_data(dev, local, remote,
ffffffffea80f910:	aa1403e0 	mov	x0, x20
	msg.body.target = remote;
ffffffffea80f914:	b9008bb7 	str	w23, [x29, #136]
	return tipc_send_data(dev, local, remote,
ffffffffea80f918:	97fffca0 	bl	ffffffffea80eb98 <tipc_send_data.constprop.3>
ffffffffea80f91c:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea80f920:	17ffff84 	b	ffffffffea80f730 <tipc_tx_thread_func+0x70>
	while (!dev->tx_stop) {
ffffffffea80f924:	39494380 	ldrb	w0, [x28, #592]
ffffffffea80f928:	34ffef40 	cbz	w0, ffffffffea80f710 <tipc_tx_thread_func+0x50>
ffffffffea80f92c:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80f930:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80f934:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80f938:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80f93c:	f9402bbb 	ldr	x27, [x29, #80]
}
ffffffffea80f940:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea80f944:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80f948:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea80f94c:	d65f03c0 	ret
	mutex_release(&dev->ept_lock);
ffffffffea80f950:	aa1603e0 	mov	x0, x22
ffffffffea80f954:	97ffd845 	bl	ffffffffea805a68 <mutex_release>
ffffffffea80f958:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea80f95c:	17ffff75 	b	ffffffffea80f730 <tipc_tx_thread_func+0x70>
ffffffffea80f960:	93437ea0 	sbfx	x0, x21, #3, #29
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f964:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea80f968:	927ee800 	and	x0, x0, #0x1ffffffffffffffc
ffffffffea80f96c:	1ad52021 	lsl	w1, w1, w21
ffffffffea80f970:	8b000280 	add	x0, x20, x0
ffffffffea80f974:	d2822d02 	mov	x2, #0x1168                	// #4456
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80f978:	2a2103e1 	mvn	w1, w1
ffffffffea80f97c:	8b020000 	add	x0, x0, x2
ffffffffea80f980:	885f7c02 	ldxr	w2, [x0]
ffffffffea80f984:	0a010042 	and	w2, w2, w1
ffffffffea80f988:	88037c02 	stxr	w3, w2, [x0]
ffffffffea80f98c:	35ffffa3 	cbnz	w3, ffffffffea80f980 <tipc_tx_thread_func+0x2c0>
ffffffffea80f990:	d37c7ea1 	ubfiz	x1, x21, #4, #32
ffffffffea80f994:	aa1603e0 	mov	x0, x22
ffffffffea80f998:	8b010281 	add	x1, x20, x1
		dev->epts[slot].remote = 0;
ffffffffea80f99c:	b901683f 	str	wzr, [x1, #360]
		dev->epts[slot].chan = NULL;
ffffffffea80f9a0:	f900b83f 	str	xzr, [x1, #368]
	mutex_release(&dev->ept_lock);
ffffffffea80f9a4:	97ffd831 	bl	ffffffffea805a68 <mutex_release>
ffffffffea80f9a8:	17ffffd1 	b	ffffffffea80f8ec <tipc_tx_thread_func+0x22c>
			panic ("%s: failed (%d) to get message\n",
ffffffffea80f9ac:	2a0003e3 	mov	w3, w0
ffffffffea80f9b0:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80f9b4:	90000042 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80f9b8:	90000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80f9bc:	9126c042 	add	x2, x2, #0x9b0
ffffffffea80f9c0:	912aa021 	add	x1, x1, #0xaa8
ffffffffea80f9c4:	940008b5 	bl	ffffffffea811c98 <_panic>
			panic("%s: couldn't wait for handle events (%d)\n",
ffffffffea80f9c8:	2a0003e3 	mov	w3, w0
ffffffffea80f9cc:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80f9d0:	90000042 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80f9d4:	90000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80f9d8:	91270042 	add	x2, x2, #0x9c0
ffffffffea80f9dc:	9129e021 	add	x1, x1, #0xa78
ffffffffea80f9e0:	940008ae 	bl	ffffffffea811c98 <_panic>
ffffffffea80f9e4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80f9e8 <create_tipc_device>:
};

status_t create_tipc_device(const struct tipc_vdev_descr *descr, size_t size,
                            const uuid_t *uuid, uint32_t guest,
                            struct tipc_dev **dev_ptr)
{
ffffffffea80f9e8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80f9ec:	910003fd 	mov	x29, sp
ffffffffea80f9f0:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea80f9f4:	2a0303f4 	mov	w20, w3
ffffffffea80f9f8:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea80f9fc:	aa0403f5 	mov	x21, x4
ffffffffea80fa00:	f9001ff8 	str	x24, [sp, #56]
ffffffffea80fa04:	aa0003f7 	mov	x23, x0
ffffffffea80fa08:	aa0103f6 	mov	x22, x1

	DEBUG_ASSERT(uuid);
	DEBUG_ASSERT(descr);
	DEBUG_ASSERT(size);

	dev = calloc(1, sizeof(*dev));
ffffffffea80fa0c:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80fa10:	d2824b01 	mov	x1, #0x1258                	// #4696
{
ffffffffea80fa14:	aa0203f8 	mov	x24, x2
	dev = calloc(1, sizeof(*dev));
ffffffffea80fa18:	94000e34 	bl	ffffffffea8132e8 <calloc>
	if (!dev) {
ffffffffea80fa1c:	b4000640 	cbz	x0, ffffffffea80fae4 <create_tipc_device+0xfc>
ffffffffea80fa20:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80fa24:	aa0003f3 	mov	x19, x0
		return ERR_NO_MEMORY;
	}
	mutex_init(&dev->ept_lock);
ffffffffea80fa28:	d2824100 	mov	x0, #0x1208                	// #4616
ffffffffea80fa2c:	8b000260 	add	x0, x19, x0
ffffffffea80fa30:	97ffd7d6 	bl	ffffffffea805988 <mutex_init>
	dev->vd.ops = &_tipc_dev_ops;
	dev->uuid = uuid;
	dev->guest = guest;
	dev->descr_ptr = descr;
	dev->descr_size = size;
	handle_list_init(&dev->handle_list);
ffffffffea80fa34:	d2823701 	mov	x1, #0x11b8                	// #4536
ffffffffea80fa38:	8b010260 	add	x0, x19, x1
	dev->vd.ops = &_tipc_dev_ops;
ffffffffea80fa3c:	90000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80fa40:	91274021 	add	x1, x1, #0x9d0
ffffffffea80fa44:	f9001261 	str	x1, [x19, #32]
	dev->guest = guest;
ffffffffea80fa48:	b9002a74 	str	w20, [x19, #40]
	dev->descr_ptr = descr;
ffffffffea80fa4c:	a9035e78 	stp	x24, x23, [x19, #48]
	dev->descr_size = size;
ffffffffea80fa50:	f9002276 	str	x22, [x19, #64]
	handle_list_init(&dev->handle_list);
ffffffffea80fa54:	97ffea7b 	bl	ffffffffea80a440 <handle_list_init>
	event_init(&dev->have_handles, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea80fa58:	d2823103 	mov	x3, #0x1188                	// #4488
ffffffffea80fa5c:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80fa60:	8b030260 	add	x0, x19, x3
ffffffffea80fa64:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80fa68:	97ffd71a 	bl	ffffffffea8056d0 <event_init>

	ret = virtio_register_device(&dev->vd, guest);
ffffffffea80fa6c:	2a1403e1 	mov	w1, w20
ffffffffea80fa70:	aa1303e0 	mov	x0, x19
ffffffffea80fa74:	97fffa59 	bl	ffffffffea80e3d8 <virtio_register_device>
ffffffffea80fa78:	2a0003f4 	mov	w20, w0
	if (ret != NO_ERROR) {
ffffffffea80fa7c:	35000140 	cbnz	w0, ffffffffea80faa4 <create_tipc_device+0xbc>
		goto err_register;
	}
	if (dev_ptr) {
ffffffffea80fa80:	b4000255 	cbz	x21, ffffffffea80fac8 <create_tipc_device+0xe0>
		*dev_ptr = dev;
ffffffffea80fa84:	f90002b3 	str	x19, [x21]
ffffffffea80fa88:	f9400bb3 	ldr	x19, [x29, #16]
	return NO_ERROR;

err_register:
	free(dev);
	return ret;
}
ffffffffea80fa8c:	2a1403e0 	mov	w0, w20
ffffffffea80fa90:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea80fa94:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80fa98:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80fa9c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80faa0:	d65f03c0 	ret
	free(dev);
ffffffffea80faa4:	aa1303e0 	mov	x0, x19
ffffffffea80faa8:	94000e20 	bl	ffffffffea813328 <free>
}
ffffffffea80faac:	2a1403e0 	mov	w0, w20
	return ret;
ffffffffea80fab0:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea80fab4:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80fab8:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80fabc:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea80fac0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80fac4:	d65f03c0 	ret
ffffffffea80fac8:	2a1403e0 	mov	w0, w20
ffffffffea80facc:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80fad0:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80fad4:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80fad8:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea80fadc:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80fae0:	d65f03c0 	ret
		return ERR_NO_MEMORY;
ffffffffea80fae4:	12800094 	mov	w20, #0xfffffffb            	// #-5
ffffffffea80fae8:	17ffffe9 	b	ffffffffea80fa8c <create_tipc_device+0xa4>
ffffffffea80faec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80faf0 <dev_connect>:
	return err;
}

static int dev_connect(struct ql_tipc_dev *dev, void *ns_payload,
                       size_t ns_payload_len)
{
ffffffffea80faf0:	a9ab7bfd 	stp	x29, x30, [sp, #-336]!
	struct {
		struct tipc_connect_req hdr;
		uint8_t body[TIPC_MAX_SRV_NAME_LEN + 1];
	} req;

	if (ns_payload_len <= sizeof(req.hdr))
ffffffffea80faf4:	f100405f 	cmp	x2, #0x10
{
ffffffffea80faf8:	910003fd 	mov	x29, sp
ffffffffea80fafc:	a901d7f4 	stp	x20, x21, [sp, #24]
	struct tipc_cmd_hdr *ns_hdr = dev->ns_va;
ffffffffea80fb00:	f9403815 	ldr	x21, [x0, #112]
	handle_t *chan = NULL;
ffffffffea80fb04:	f9001bbf 	str	xzr, [x29, #48]
	if (ns_payload_len <= sizeof(req.hdr))
ffffffffea80fb08:	54000b89 	b.ls	ffffffffea80fc78 <dev_connect+0x188>  // b.plast
		return set_status(dev, opcode, ERR_INVALID_ARGS, 0);

	if (ns_payload_len >= sizeof(req))
ffffffffea80fb0c:	f1045c5f 	cmp	x2, #0x117
ffffffffea80fb10:	54000b48 	b.hi	ffffffffea80fc78 <dev_connect+0x188>  // b.pmore
ffffffffea80fb14:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80fb18:	aa0003f3 	mov	x19, x0
		return set_status(dev, opcode, ERR_INVALID_ARGS, 0);

	/* copy out and zero terminate */
	memcpy(&req, ns_payload, ns_payload_len);
	req.body[ns_payload_len - sizeof(req.hdr)] = 0;
ffffffffea80fb1c:	d1004054 	sub	x20, x2, #0x10
	memcpy(&req, ns_payload, ns_payload_len);
ffffffffea80fb20:	9100e3a0 	add	x0, x29, #0x38
ffffffffea80fb24:	94000e03 	bl	ffffffffea813330 <memcpy>

	/* open ipc channel */
	rc = ipc_port_connect_async(dev->guest, dev->uuid, (const char *)req.body,
ffffffffea80fb28:	b9407a60 	ldr	w0, [x19, #120]
	req.body[ns_payload_len - sizeof(req.hdr)] = 0;
ffffffffea80fb2c:	910123a7 	add	x7, x29, #0x48
	rc = ipc_port_connect_async(dev->guest, dev->uuid, (const char *)req.body,
ffffffffea80fb30:	f9404261 	ldr	x1, [x19, #128]
ffffffffea80fb34:	aa1403e3 	mov	x3, x20
ffffffffea80fb38:	9100c3a5 	add	x5, x29, #0x30
ffffffffea80fb3c:	52800004 	mov	w4, #0x0                   	// #0
	req.body[ns_payload_len - sizeof(req.hdr)] = 0;
ffffffffea80fb40:	383468ff 	strb	wzr, [x7, x20]
	rc = ipc_port_connect_async(dev->guest, dev->uuid, (const char *)req.body,
ffffffffea80fb44:	aa0703e2 	mov	x2, x7
ffffffffea80fb48:	97fff116 	bl	ffffffffea80bfa0 <ipc_port_connect_async>
ffffffffea80fb4c:	2a0003f4 	mov	w20, w0
				    ns_payload_len - sizeof(req.hdr), 0, &chan);
	if (rc != NO_ERROR) {
ffffffffea80fb50:	340001a0 	cbz	w0, ffffffffea80fb84 <dev_connect+0x94>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80fb54:	531f7c01 	lsr	w1, w0, #31
		LTRACEF("failed to open ipc channel: %d\n", rc);
		return set_status(dev, opcode, rc, 0);
ffffffffea80fb58:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80fb5c:	128fffc2 	mov	w2, #0xffff8001            	// #-32767
ffffffffea80fb60:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80fb64:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea80fb68:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea80fb6c:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, rc, 0);
ffffffffea80fb70:	f9400bb3 	ldr	x19, [x29, #16]
	handle_set_cookie(chan, ept_lookup(dev, local));
	handle_list_add(&dev->handle_list, chan);
	ns_hdr->handle = local;

	return set_status(dev, opcode, 0, 0);
}
ffffffffea80fb74:	2a1403e0 	mov	w0, w20
ffffffffea80fb78:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80fb7c:	a8d57bfd 	ldp	x29, x30, [sp], #336
ffffffffea80fb80:	d65f03c0 	ret
		if (bitmap[i] == ~0UL)
ffffffffea80fb84:	f9404661 	ldr	x1, [x19, #136]
	int slot = bitmap_ffz(dev->inuse, QL_TIPC_ADDR_MAX_NUM);
ffffffffea80fb88:	91022263 	add	x3, x19, #0x88
	local = alloc_local_addr(dev, chan, req.hdr.cookie);
ffffffffea80fb8c:	a9431ba0 	ldp	x0, x6, [x29, #48]
ffffffffea80fb90:	b100043f 	cmn	x1, #0x1
ffffffffea80fb94:	540005a0 	b.eq	ffffffffea80fc48 <dev_connect+0x158>  // b.none
	return __builtin_ffsl(~x) - 1;
ffffffffea80fb98:	aa2103e2 	mvn	x2, x1
ffffffffea80fb9c:	f90017b6 	str	x22, [x29, #40]
ffffffffea80fba0:	dac00041 	rbit	x1, x2
ffffffffea80fba4:	f100005f 	cmp	x2, #0x0
ffffffffea80fba8:	dac01021 	clz	x1, x1
ffffffffea80fbac:	9a8107e1 	csinc	x1, xzr, x1, eq  // eq = none
ffffffffea80fbb0:	51000424 	sub	w4, w1, #0x1
		if (bit < numbits)
ffffffffea80fbb4:	71007c9f 	cmp	w4, #0x1f
ffffffffea80fbb8:	5400046c 	b.gt	ffffffffea80fc44 <dev_connect+0x154>
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80fbbc:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80fbc0:	1ac42042 	lsl	w2, w2, w4
    return __atomic_fetch_or(ptr, val, __ATOMIC_RELAXED);
ffffffffea80fbc4:	885f7c65 	ldxr	w5, [x3]
ffffffffea80fbc8:	2a0200a5 	orr	w5, w5, w2
ffffffffea80fbcc:	88077c65 	stxr	w7, w5, [x3]
ffffffffea80fbd0:	35ffffa7 	cbnz	w7, ffffffffea80fbc4 <dev_connect+0xd4>
ffffffffea80fbd4:	8b21d263 	add	x3, x19, w1, sxtw #4
	return NULL;
ffffffffea80fbd8:	d37c7c82 	ubfiz	x2, x4, #4, #32
	handle_set_cookie(chan, ept_lookup(dev, local));
ffffffffea80fbdc:	f9401ba5 	ldr	x5, [x29, #48]
	return NULL;
ffffffffea80fbe0:	91024042 	add	x2, x2, #0x90
ffffffffea80fbe4:	8b020262 	add	x2, x19, x2
	return (uint32_t) (slot + QL_TIPC_ADDR_BASE);
ffffffffea80fbe8:	11007c36 	add	w22, w1, #0x1f
		dev->epts[slot].cookie = cookie;
ffffffffea80fbec:	a9081860 	stp	x0, x6, [x3, #128]
	handle_list_add(&dev->handle_list, chan);
ffffffffea80fbf0:	aa0503e1 	mov	x1, x5
ffffffffea80fbf4:	91004260 	add	x0, x19, #0x10
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80fbf8:	f9404663 	ldr	x3, [x19, #136]
ffffffffea80fbfc:	9ac42463 	lsr	x3, x3, x4
	return NULL;
ffffffffea80fc00:	f240007f 	tst	x3, #0x1
ffffffffea80fc04:	9a9f1042 	csel	x2, x2, xzr, ne  // ne = any
ffffffffea80fc08:	f90018a2 	str	x2, [x5, #48]
	handle_list_add(&dev->handle_list, chan);
ffffffffea80fc0c:	97ffea1b 	bl	ffffffffea80a478 <handle_list_add>
	return set_status(dev, opcode, 0, 0);
ffffffffea80fc10:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80fc14:	128fffc1 	mov	w1, #0xffff8001            	// #-32767
	ns_hdr->handle = local;
ffffffffea80fc18:	b9000ab6 	str	w22, [x21, #8]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80fc1c:	79000001 	strh	w1, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80fc20:	b900041f 	str	wzr, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea80fc24:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea80fc28:	d5033abf 	dmb	ishst
ffffffffea80fc2c:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea80fc30:	2a1403e0 	mov	w0, w20
	smp_wmb();
ffffffffea80fc34:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea80fc38:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80fc3c:	a8d57bfd 	ldp	x29, x30, [sp], #336
ffffffffea80fc40:	d65f03c0 	ret
ffffffffea80fc44:	f94017b6 	ldr	x22, [x29, #40]
		handle_close(chan);
ffffffffea80fc48:	97ffe99a 	bl	ffffffffea80a2b0 <handle_close>
		chan = NULL;
ffffffffea80fc4c:	f9001bbf 	str	xzr, [x29, #48]
		return set_status(dev, opcode, ERR_NO_RESOURCES, 0);
ffffffffea80fc50:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80fc54:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80fc58:	128fffc2 	mov	w2, #0xffff8001            	// #-32767
ffffffffea80fc5c:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80fc60:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea80fc64:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea80fc68:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, ERR_NO_RESOURCES, 0);
ffffffffea80fc6c:	12800514 	mov	w20, #0xffffffd7            	// #-41
ffffffffea80fc70:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80fc74:	17ffffc0 	b	ffffffffea80fb74 <dev_connect+0x84>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80fc78:	52800020 	mov	w0, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80fc7c:	128fffc1 	mov	w1, #0xffff8001            	// #-32767
ffffffffea80fc80:	790002a1 	strh	w1, [x21]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80fc84:	b90006a0 	str	w0, [x21, #4]
	ns_hdr->payload_len = len;
ffffffffea80fc88:	b9000ebf 	str	wzr, [x21, #12]
	smp_wmb();
ffffffffea80fc8c:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, ERR_INVALID_ARGS, 0);
ffffffffea80fc90:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80fc94:	17ffffb8 	b	ffffffffea80fb74 <dev_connect+0x84>

ffffffffea80fc98 <ql_tipc_create_device>:
	}
}

long ql_tipc_create_device(ns_addr_t buf_pa, ns_size_t buf_sz,
                           uint buf_mmu_flags)
{
ffffffffea80fc98:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80fc9c:	910003fd 	mov	x29, sp
ffffffffea80fca0:	f90017f6 	str	x22, [sp, #40]
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80fca4:	d0000056 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea80fca8:	913a02c5 	add	x5, x22, #0xe80
ffffffffea80fcac:	f94004a3 	ldr	x3, [x5, #8]
ffffffffea80fcb0:	eb05007f 	cmp	x3, x5
ffffffffea80fcb4:	540000a1 	b.ne	ffffffffea80fcc8 <ql_tipc_create_device+0x30>  // b.any
ffffffffea80fcb8:	1400000b 	b	ffffffffea80fce4 <ql_tipc_create_device+0x4c>
ffffffffea80fcbc:	f9400463 	ldr	x3, [x3, #8]
ffffffffea80fcc0:	eb05007f 	cmp	x3, x5
ffffffffea80fcc4:	54000100 	b.eq	ffffffffea80fce4 <ql_tipc_create_device+0x4c>  // b.none
		if(dev->ns_pa == buf_pa) {
ffffffffea80fcc8:	f9403464 	ldr	x4, [x3, #104]
ffffffffea80fccc:	eb04001f 	cmp	x0, x4
ffffffffea80fcd0:	54ffff61 	b.ne	ffffffffea80fcbc <ql_tipc_create_device+0x24>  // b.any
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80fcd4:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
	return dev_create(buf_pa, buf_sz, buf_mmu_flags);
}
ffffffffea80fcd8:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80fcdc:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80fce0:	d65f03c0 	ret
	if (!buf_sz) {
ffffffffea80fce4:	f2402c1f 	tst	x0, #0xfff
ffffffffea80fce8:	7a400824 	ccmp	w1, #0x0, #0x4, eq  // eq = none
ffffffffea80fcec:	54ffff40 	b.eq	ffffffffea80fcd4 <ql_tipc_create_device+0x3c>  // b.none
ffffffffea80fcf0:	f90023b9 	str	x25, [x29, #64]
	if (buf_sz & (PAGE_SIZE-1)) {
ffffffffea80fcf4:	f2402c3f 	tst	x1, #0xfff
ffffffffea80fcf8:	2a0103f9 	mov	w25, w1
ffffffffea80fcfc:	54000841 	b.ne	ffffffffea80fe04 <ql_tipc_create_device+0x16c>  // b.any
ffffffffea80fd00:	f9001fb8 	str	x24, [x29, #56]
	if (_dev_cnt >= QL_TIPC_DEV_MAX_NUM) {
ffffffffea80fd04:	d0000278 	adrp	x24, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea80fd08:	b94f3f03 	ldr	w3, [x24, #3900]
ffffffffea80fd0c:	7100047f 	cmp	w3, #0x1
ffffffffea80fd10:	54000648 	b.hi	ffffffffea80fdd8 <ql_tipc_create_device+0x140>  // b.pmore
ffffffffea80fd14:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80fd18:	aa0003f3 	mov	x19, x0
ffffffffea80fd1c:	f90013b5 	str	x21, [x29, #32]
	dev = calloc(1, sizeof(*dev));
ffffffffea80fd20:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80fd24:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80fd28:	2a0103f5 	mov	w21, w1
ffffffffea80fd2c:	2a0203f7 	mov	w23, w2
ffffffffea80fd30:	d2805201 	mov	x1, #0x290                 	// #656
ffffffffea80fd34:	94000d6d 	bl	ffffffffea8132e8 <calloc>
ffffffffea80fd38:	aa0003f4 	mov	x20, x0
	if (!dev) {
ffffffffea80fd3c:	b4000580 	cbz	x0, ffffffffea80fdec <ql_tipc_create_device+0x154>
	item->prev = item->next = 0;
ffffffffea80fd40:	f900041f 	str	xzr, [x0, #8]
	dev->uuid = &zero_uuid;
ffffffffea80fd44:	90000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
	dev->guest = 0;
ffffffffea80fd48:	b900781f 	str	wzr, [x0, #120]
	dev->uuid = &zero_uuid;
ffffffffea80fd4c:	91182021 	add	x1, x1, #0x608
ffffffffea80fd50:	f9004001 	str	x1, [x0, #128]
ffffffffea80fd54:	f801041f 	str	xzr, [x0], #16
	handle_list_init(&dev->handle_list);
ffffffffea80fd58:	97ffe9ba 	bl	ffffffffea80a440 <handle_list_init>
	dev->ns_sz = buf_sz;
ffffffffea80fd5c:	290c5697 	stp	w23, w21, [x20, #96]
	                         ROUNDUP(buf_sz, PAGE_SIZE),
ffffffffea80fd60:	913fff22 	add	x2, x25, #0xfff
	res = vmm_alloc_physical(vmm_get_kernel_aspace(), "tipc",
ffffffffea80fd64:	90000041 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea80fd68:	f0000260 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
ffffffffea80fd6c:	2a1703e7 	mov	w7, w23
ffffffffea80fd70:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80fd74:	aa1303e5 	mov	x5, x19
ffffffffea80fd78:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea80fd7c:	9101c283 	add	x3, x20, #0x70
ffffffffea80fd80:	92745042 	and	x2, x2, #0x1fffff000
ffffffffea80fd84:	912dc021 	add	x1, x1, #0xb70
ffffffffea80fd88:	91034000 	add	x0, x0, #0xd0
	dev->ns_pa = buf_pa;
ffffffffea80fd8c:	f9003693 	str	x19, [x20, #104]
	res = vmm_alloc_physical(vmm_get_kernel_aspace(), "tipc",
ffffffffea80fd90:	94000582 	bl	ffffffffea811398 <vmm_alloc_physical>
	if (res != NO_ERROR) {
ffffffffea80fd94:	35000280 	cbnz	w0, ffffffffea80fde4 <ql_tipc_create_device+0x14c>
	item->next = list->next;
ffffffffea80fd98:	913a02d6 	add	x22, x22, #0xe80
	_dev_cnt++;
ffffffffea80fd9c:	b94f3f01 	ldr	w1, [x24, #3900]
ffffffffea80fda0:	f94013b5 	ldr	x21, [x29, #32]
	return 0;
ffffffffea80fda4:	d2800000 	mov	x0, #0x0                   	// #0
	_dev_cnt++;
ffffffffea80fda8:	11000421 	add	w1, w1, #0x1
ffffffffea80fdac:	b90f3f01 	str	w1, [x24, #3900]
ffffffffea80fdb0:	f94006c1 	ldr	x1, [x22, #8]
ffffffffea80fdb4:	a9000696 	stp	x22, x1, [x20]
ffffffffea80fdb8:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80fdbc:	f94023b9 	ldr	x25, [x29, #64]
	list->next->prev = item;
ffffffffea80fdc0:	f9000034 	str	x20, [x1]
	list->next = item;
ffffffffea80fdc4:	f90006d4 	str	x20, [x22, #8]
ffffffffea80fdc8:	a94153b3 	ldp	x19, x20, [x29, #16]
}
ffffffffea80fdcc:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80fdd0:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80fdd4:	d65f03c0 	ret
		return SM_ERR_NOT_ALLOWED;
ffffffffea80fdd8:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
ffffffffea80fddc:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80fde0:	17ffffbe 	b	ffffffffea80fcd8 <ql_tipc_create_device+0x40>
		free(dev);
ffffffffea80fde4:	aa1403e0 	mov	x0, x20
ffffffffea80fde8:	94000d50 	bl	ffffffffea813328 <free>
		return SM_ERR_INTERNAL_FAILURE;
ffffffffea80fdec:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea80fdf0:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80fdf4:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80fdf8:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80fdfc:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80fe00:	17ffffb6 	b	ffffffffea80fcd8 <ql_tipc_create_device+0x40>
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80fe04:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80fe08:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80fe0c:	17ffffb3 	b	ffffffffea80fcd8 <ql_tipc_create_device+0x40>

ffffffffea80fe10 <ql_tipc_shutdown_device>:

long ql_tipc_shutdown_device(ns_addr_t buf_pa)
{
ffffffffea80fe10:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80fe14:	d0000041 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea80fe18:	913a0021 	add	x1, x1, #0xe80
{
ffffffffea80fe1c:	910003fd 	mov	x29, sp
ffffffffea80fe20:	f90013f5 	str	x21, [sp, #32]
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80fe24:	f9400435 	ldr	x21, [x1, #8]
ffffffffea80fe28:	eb0102bf 	cmp	x21, x1
ffffffffea80fe2c:	540007a0 	b.eq	ffffffffea80ff20 <ql_tipc_shutdown_device+0x110>  // b.none
		if(dev->ns_pa == buf_pa) {
ffffffffea80fe30:	f94036a2 	ldr	x2, [x21, #104]
ffffffffea80fe34:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80fe38:	f90017b6 	str	x22, [x29, #40]
ffffffffea80fe3c:	eb02001f 	cmp	x0, x2
ffffffffea80fe40:	540000a1 	b.ne	ffffffffea80fe54 <ql_tipc_shutdown_device+0x44>  // b.any
ffffffffea80fe44:	1400000d 	b	ffffffffea80fe78 <ql_tipc_shutdown_device+0x68>
ffffffffea80fe48:	f94036a2 	ldr	x2, [x21, #104]
ffffffffea80fe4c:	eb02001f 	cmp	x0, x2
ffffffffea80fe50:	54000140 	b.eq	ffffffffea80fe78 <ql_tipc_shutdown_device+0x68>  // b.none
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80fe54:	f94006b5 	ldr	x21, [x21, #8]
ffffffffea80fe58:	eb0102bf 	cmp	x21, x1
ffffffffea80fe5c:	54ffff61 	b.ne	ffffffffea80fe48 <ql_tipc_shutdown_device+0x38>  // b.any
	struct ql_tipc_dev *dev = dev_lookup(buf_pa);
	if (!dev) {
		LTRACEF("0x%llx: device not found\n", buf_pa);
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80fe60:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80fe64:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80fe68:	a94153b3 	ldp	x19, x20, [x29, #16]
	}
	dev_shutdown(dev);
	return 0;
}
ffffffffea80fe6c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80fe70:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80fe74:	d65f03c0 	ret
	item->next->prev = item->prev;
ffffffffea80fe78:	a9400ea2 	ldp	x2, x3, [x21]
	_dev_cnt--;
ffffffffea80fe7c:	d0000264 	adrp	x4, ffffffffea85d000 <idle_threads+0xeb0>
	vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)dev->ns_va);
ffffffffea80fe80:	f9403aa1 	ldr	x1, [x21, #112]
ffffffffea80fe84:	910242b4 	add	x20, x21, #0x90
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80fe88:	910042b6 	add	x22, x21, #0x10
	vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)dev->ns_va);
ffffffffea80fe8c:	f0000260 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
ffffffffea80fe90:	f9000062 	str	x2, [x3]
ffffffffea80fe94:	91034000 	add	x0, x0, #0xd0
	_dev_cnt--;
ffffffffea80fe98:	b94f3c82 	ldr	w2, [x4, #3900]
	for (uint slot = 0; slot < countof(dev->epts); slot++) {
ffffffffea80fe9c:	52800013 	mov	w19, #0x0                   	// #0
	item->prev->next = item->next;
ffffffffea80fea0:	f94002a5 	ldr	x5, [x21]
	_dev_cnt--;
ffffffffea80fea4:	51000442 	sub	w2, w2, #0x1
ffffffffea80fea8:	b90f3c82 	str	w2, [x4, #3900]
ffffffffea80feac:	f90004a3 	str	x3, [x5, #8]
	item->prev = item->next = 0;
ffffffffea80feb0:	a9007ebf 	stp	xzr, xzr, [x21]
	vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)dev->ns_va);
ffffffffea80feb4:	9400059b 	bl	ffffffffea811520 <vmm_free_region>
	dev->ns_va = NULL;
ffffffffea80feb8:	f9003abf 	str	xzr, [x21, #112]
ffffffffea80febc:	d503201f 	nop
ffffffffea80fec0:	f94046a1 	ldr	x1, [x21, #136]
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80fec4:	aa1603e0 	mov	x0, x22
ffffffffea80fec8:	9ad32421 	lsr	x1, x1, x19
	for (uint slot = 0; slot < countof(dev->epts); slot++) {
ffffffffea80fecc:	11000673 	add	w19, w19, #0x1
		if (!bitmap_test(dev->inuse, slot))
ffffffffea80fed0:	36000121 	tbz	w1, #0, ffffffffea80fef4 <ql_tipc_shutdown_device+0xe4>
		if (!ept->chan)
ffffffffea80fed4:	f9400282 	ldr	x2, [x20]
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80fed8:	aa0203e1 	mov	x1, x2
		if (!ept->chan)
ffffffffea80fedc:	b40000c2 	cbz	x2, ffffffffea80fef4 <ql_tipc_shutdown_device+0xe4>
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80fee0:	97ffe990 	bl	ffffffffea80a520 <handle_list_del>
		handle_set_cookie(ept->chan, NULL);
ffffffffea80fee4:	f9400281 	ldr	x1, [x20]
		handle_close(ept->chan);
ffffffffea80fee8:	aa0103e0 	mov	x0, x1
ffffffffea80feec:	f900183f 	str	xzr, [x1, #48]
ffffffffea80fef0:	97ffe8f0 	bl	ffffffffea80a2b0 <handle_close>
ffffffffea80fef4:	91004294 	add	x20, x20, #0x10
	for (uint slot = 0; slot < countof(dev->epts); slot++) {
ffffffffea80fef8:	7100827f 	cmp	w19, #0x20
ffffffffea80fefc:	54fffe21 	b.ne	ffffffffea80fec0 <ql_tipc_shutdown_device+0xb0>  // b.any
	free(dev);
ffffffffea80ff00:	aa1503e0 	mov	x0, x21
ffffffffea80ff04:	94000d09 	bl	ffffffffea813328 <free>
ffffffffea80ff08:	a94153b3 	ldp	x19, x20, [x29, #16]
	return 0;
ffffffffea80ff0c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80ff10:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea80ff14:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ff18:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ff1c:	d65f03c0 	ret
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80ff20:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80ff24:	17fffffc 	b	ffffffffea80ff14 <ql_tipc_shutdown_device+0x104>

ffffffffea80ff28 <ql_tipc_handle_cmd>:

long ql_tipc_handle_cmd(ns_addr_t buf_pa, ns_size_t cmd_sz)
{
ffffffffea80ff28:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80ff2c:	d0000042 	adrp	x2, ffffffffea819000 <_mem_phys_base>
ffffffffea80ff30:	913a0042 	add	x2, x2, #0xe80
{
ffffffffea80ff34:	910003fd 	mov	x29, sp
ffffffffea80ff38:	f9000bf3 	str	x19, [sp, #16]
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80ff3c:	f9400453 	ldr	x19, [x2, #8]
ffffffffea80ff40:	eb02027f 	cmp	x19, x2
ffffffffea80ff44:	540001a0 	b.eq	ffffffffea80ff78 <ql_tipc_handle_cmd+0x50>  // b.none
		if(dev->ns_pa == buf_pa) {
ffffffffea80ff48:	f9403663 	ldr	x3, [x19, #104]
ffffffffea80ff4c:	a901d7b4 	stp	x20, x21, [x29, #24]
ffffffffea80ff50:	eb03001f 	cmp	x0, x3
ffffffffea80ff54:	540000a1 	b.ne	ffffffffea80ff68 <ql_tipc_handle_cmd+0x40>  // b.any
ffffffffea80ff58:	1400000c 	b	ffffffffea80ff88 <ql_tipc_handle_cmd+0x60>
ffffffffea80ff5c:	f9403663 	ldr	x3, [x19, #104]
ffffffffea80ff60:	eb03001f 	cmp	x0, x3
ffffffffea80ff64:	54000120 	b.eq	ffffffffea80ff88 <ql_tipc_handle_cmd+0x60>  // b.none
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80ff68:	f9400673 	ldr	x19, [x19, #8]
ffffffffea80ff6c:	eb02027f 	cmp	x19, x2
ffffffffea80ff70:	54ffff61 	b.ne	ffffffffea80ff5c <ql_tipc_handle_cmd+0x34>  // b.any
ffffffffea80ff74:	a941d7b4 	ldp	x20, x21, [x29, #24]

	/* lookup device */
	struct ql_tipc_dev *dev = dev_lookup(buf_pa);
	if (!dev) {
		LTRACEF("0x%llx: device not found\n", buf_pa);
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80ff78:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
		LTRACEF("malformed command\n");
		return SM_ERR_INVALID_PARAMETERS;
	}

	return dev_handle_cmd(dev, &cmd_hdr, dev->ns_va + sizeof(cmd_hdr));
}
ffffffffea80ff7c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80ff80:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80ff84:	d65f03c0 	ret
	if (cmd_sz < sizeof(cmd_hdr)) {
ffffffffea80ff88:	71003c3f 	cmp	w1, #0xf
ffffffffea80ff8c:	54ffff49 	b.ls	ffffffffea80ff74 <ql_tipc_handle_cmd+0x4c>  // b.plast
ffffffffea80ff90:	2a0103f4 	mov	w20, w1
	memcpy(&cmd_hdr, dev->ns_va, sizeof(cmd_hdr));
ffffffffea80ff94:	f9403a61 	ldr	x1, [x19, #112]
ffffffffea80ff98:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80ff9c:	aa1e03f5 	mov	x21, x30
ffffffffea80ffa0:	910103a0 	add	x0, x29, #0x40
ffffffffea80ffa4:	94000ce3 	bl	ffffffffea813330 <memcpy>
	if (cmd_hdr.payload_len != (cmd_sz - sizeof(cmd_hdr))) {
ffffffffea80ffa8:	b9404fa3 	ldr	w3, [x29, #76]
ffffffffea80ffac:	2a1403e1 	mov	w1, w20
ffffffffea80ffb0:	d1004021 	sub	x1, x1, #0x10
ffffffffea80ffb4:	2a0303e2 	mov	w2, w3
ffffffffea80ffb8:	eb01005f 	cmp	x2, x1
ffffffffea80ffbc:	54fffdc1 	b.ne	ffffffffea80ff74 <ql_tipc_handle_cmd+0x4c>  // b.any
	switch (cmd->opcode) {
ffffffffea80ffc0:	794083a0 	ldrh	w0, [x29, #64]
	return dev_handle_cmd(dev, &cmd_hdr, dev->ns_va + sizeof(cmd_hdr));
ffffffffea80ffc4:	f9403a74 	ldr	x20, [x19, #112]
	switch (cmd->opcode) {
ffffffffea80ffc8:	71000c1f 	cmp	w0, #0x3
	return dev_handle_cmd(dev, &cmd_hdr, dev->ns_va + sizeof(cmd_hdr));
ffffffffea80ffcc:	91004281 	add	x1, x20, #0x10
	switch (cmd->opcode) {
ffffffffea80ffd0:	540010c0 	b.eq	ffffffffea8101e8 <ql_tipc_handle_cmd+0x2c0>  // b.none
ffffffffea80ffd4:	54000608 	b.hi	ffffffffea810094 <ql_tipc_handle_cmd+0x16c>  // b.pmore
ffffffffea80ffd8:	7100041f 	cmp	w0, #0x1
ffffffffea80ffdc:	54000f80 	b.eq	ffffffffea8101cc <ql_tipc_handle_cmd+0x2a4>  // b.none
ffffffffea80ffe0:	7100081f 	cmp	w0, #0x2
ffffffffea80ffe4:	54000aa1 	b.ne	ffffffffea810138 <ql_tipc_handle_cmd+0x210>  // b.any
ffffffffea80ffe8:	f9001bb7 	str	x23, [x29, #48]
	if (ns_sz < sizeof(req))
ffffffffea80ffec:	71001c7f 	cmp	w3, #0x7
	uint32_t  chan_event = 0;
ffffffffea80fff0:	b90063bf 	str	wzr, [x29, #96]
			return dev_get_event(dev, ns_payload, cmd->payload_len, cmd->handle);
ffffffffea80fff4:	b9404bb7 	ldr	w23, [x29, #72]
	if (ns_sz < sizeof(req))
ffffffffea80fff8:	54001c09 	b.ls	ffffffffea810378 <ql_tipc_handle_cmd+0x450>  // b.plast
	if (target) {
ffffffffea80fffc:	34001877 	cbz	w23, ffffffffea810308 <ql_tipc_handle_cmd+0x3e0>
	return (uint)(addr - QL_TIPC_ADDR_BASE);
ffffffffea810000:	510082e0 	sub	w0, w23, #0x20
	if (slot < QL_TIPC_ADDR_MAX_NUM) {
ffffffffea810004:	71007c1f 	cmp	w0, #0x1f
ffffffffea810008:	54001b88 	b.hi	ffffffffea810378 <ql_tipc_handle_cmd+0x450>  // b.pmore
ffffffffea81000c:	f9404661 	ldr	x1, [x19, #136]
ffffffffea810010:	9ac02421 	lsr	x1, x1, x0
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea810014:	36001b21 	tbz	w1, #0, ffffffffea810378 <ql_tipc_handle_cmd+0x450>
ffffffffea810018:	d37c7c00 	ubfiz	x0, x0, #4, #32
ffffffffea81001c:	f90017b6 	str	x22, [x29, #40]
ffffffffea810020:	8b000276 	add	x22, x19, x0
		if (!ept || !ept->chan)
ffffffffea810024:	f9404ac0 	ldr	x0, [x22, #144]
ffffffffea810028:	b4001a60 	cbz	x0, ffffffffea810374 <ql_tipc_handle_cmd+0x44c>
		rc = handle_wait(chan, &chan_event, 0);
ffffffffea81002c:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea810030:	910183a1 	add	x1, x29, #0x60
		chan = ept->chan;
ffffffffea810034:	f9003ba0 	str	x0, [x29, #112]
		rc = handle_wait(chan, &chan_event, 0);
ffffffffea810038:	97ffe8aa 	bl	ffffffffea80a2e0 <handle_wait>
		if (rc == ERR_TIMED_OUT) {
ffffffffea81003c:	3100341f 	cmn	w0, #0xd
ffffffffea810040:	54001940 	b.eq	ffffffffea810368 <ql_tipc_handle_cmd+0x440>  // b.none
		else if (rc < 0) {
ffffffffea810044:	37f81f00 	tbnz	w0, #31, ffffffffea810424 <ql_tipc_handle_cmd+0x4fc>
			evt->cookie = ept->cookie;
ffffffffea810048:	f9404ec1 	ldr	x1, [x22, #152]
ffffffffea81004c:	f94017b6 	ldr	x22, [x29, #40]
			evt->handle = target;
ffffffffea810050:	b9001697 	str	w23, [x20, #20]
			evt->event  = chan_event;
ffffffffea810054:	b94063a0 	ldr	w0, [x29, #96]
ffffffffea810058:	b9001280 	str	w0, [x20, #16]
			evt->cookie = ept->cookie;
ffffffffea81005c:	f9000e81 	str	x1, [x20, #24]
	return set_status(dev, opcode, 0, sizeof(*evt));
ffffffffea810060:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->payload_len = len;
ffffffffea810064:	52800201 	mov	w1, #0x10                  	// #16
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810068:	128fffa2 	mov	w2, #0xffff8002            	// #-32766
ffffffffea81006c:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810070:	b900041f 	str	wzr, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea810074:	b9000c01 	str	w1, [x0, #12]
	smp_wmb();
ffffffffea810078:	d5033abf 	dmb	ishst
	return set_status(dev, opcode, 0, sizeof(*evt));
ffffffffea81007c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea810080:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea810084:	a941d7b4 	ldp	x20, x21, [x29, #24]
}
ffffffffea810088:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea81008c:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea810090:	d65f03c0 	ret
	switch (cmd->opcode) {
ffffffffea810094:	7100101f 	cmp	w0, #0x4
ffffffffea810098:	54000660 	b.eq	ffffffffea810164 <ql_tipc_handle_cmd+0x23c>  // b.none
ffffffffea81009c:	7100141f 	cmp	w0, #0x5
ffffffffea8100a0:	540004c1 	b.ne	ffffffffea810138 <ql_tipc_handle_cmd+0x210>  // b.any
	return (uint)(addr - QL_TIPC_ADDR_BASE);
ffffffffea8100a4:	b9404bb4 	ldr	w20, [x29, #72]
ffffffffea8100a8:	51008294 	sub	w20, w20, #0x20
	if (slot < QL_TIPC_ADDR_MAX_NUM) {
ffffffffea8100ac:	71007e9f 	cmp	w20, #0x1f
ffffffffea8100b0:	54fff628 	b.hi	ffffffffea80ff74 <ql_tipc_handle_cmd+0x4c>  // b.pmore
ffffffffea8100b4:	f9404660 	ldr	x0, [x19, #136]
ffffffffea8100b8:	9ad42400 	lsr	x0, x0, x20
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea8100bc:	3607f5c0 	tbz	w0, #0, ffffffffea80ff74 <ql_tipc_handle_cmd+0x4c>
ffffffffea8100c0:	d37c7e95 	ubfiz	x21, x20, #4, #32
ffffffffea8100c4:	8b150275 	add	x21, x19, x21
	if (!ept || !ept->chan)
ffffffffea8100c8:	f9404aa1 	ldr	x1, [x21, #144]
ffffffffea8100cc:	b4fff541 	cbz	x1, ffffffffea80ff74 <ql_tipc_handle_cmd+0x4c>
	handle_list_del(&dev->handle_list, ept->chan);
ffffffffea8100d0:	91004260 	add	x0, x19, #0x10
ffffffffea8100d4:	97ffe913 	bl	ffffffffea80a520 <handle_list_del>
	handle_set_cookie(ept->chan, NULL);
ffffffffea8100d8:	f9404aa1 	ldr	x1, [x21, #144]
	handle_close(ept->chan);
ffffffffea8100dc:	aa0103e0 	mov	x0, x1
ffffffffea8100e0:	f900183f 	str	xzr, [x1, #48]
ffffffffea8100e4:	97ffe873 	bl	ffffffffea80a2b0 <handle_close>
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea8100e8:	52800020 	mov	w0, #0x1                   	// #1
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea8100ec:	91022261 	add	x1, x19, #0x88
ffffffffea8100f0:	1ad42000 	lsl	w0, w0, w20
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea8100f4:	2a2003e0 	mvn	w0, w0
ffffffffea8100f8:	885f7c22 	ldxr	w2, [x1]
ffffffffea8100fc:	0a000042 	and	w2, w2, w0
ffffffffea810100:	88037c22 	stxr	w3, w2, [x1]
ffffffffea810104:	35ffffa3 	cbnz	w3, ffffffffea8100f8 <ql_tipc_handle_cmd+0x1d0>
		dev->epts[slot].cookie = 0;
ffffffffea810108:	a9097ebf 	stp	xzr, xzr, [x21, #144]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea81010c:	128fff41 	mov	w1, #0xffff8005            	// #-32763
	return set_status(dev, opcode, 0, 0);
ffffffffea810110:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810114:	79000001 	strh	w1, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810118:	b900041f 	str	wzr, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea81011c:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea810120:	d5033abf 	dmb	ishst
	return set_status(dev, opcode, 0, 0);
ffffffffea810124:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea810128:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea81012c:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea810130:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea810134:	d65f03c0 	ret
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810138:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea81013c:	32114000 	orr	w0, w0, #0xffff8000
ffffffffea810140:	79000280 	strh	w0, [x20]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810144:	b9000681 	str	w1, [x20, #4]
	ns_hdr->payload_len = len;
ffffffffea810148:	b9000e9f 	str	wzr, [x20, #12]
	smp_wmb();
ffffffffea81014c:	d5033abf 	dmb	ishst
			return set_status(dev, cmd->opcode, ERR_NOT_SUPPORTED, 0);
ffffffffea810150:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
}
ffffffffea810154:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea810158:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea81015c:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea810160:	d65f03c0 	ret
	return (uint)(addr - QL_TIPC_ADDR_BASE);
ffffffffea810164:	b9404ba0 	ldr	w0, [x29, #72]
ffffffffea810168:	51008000 	sub	w0, w0, #0x20
	if (slot < QL_TIPC_ADDR_MAX_NUM) {
ffffffffea81016c:	71007c1f 	cmp	w0, #0x1f
ffffffffea810170:	54001188 	b.hi	ffffffffea8103a0 <ql_tipc_handle_cmd+0x478>  // b.pmore
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea810174:	f9404661 	ldr	x1, [x19, #136]
ffffffffea810178:	9ac02421 	lsr	x1, x1, x0
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea81017c:	36001121 	tbz	w1, #0, ffffffffea8103a0 <ql_tipc_handle_cmd+0x478>
ffffffffea810180:	d37c7c00 	ubfiz	x0, x0, #4, #32
ffffffffea810184:	8b000275 	add	x21, x19, x0
	if (!ept || !ept->chan)
ffffffffea810188:	f9404aa0 	ldr	x0, [x21, #144]
ffffffffea81018c:	b40010a0 	cbz	x0, ffffffffea8103a0 <ql_tipc_handle_cmd+0x478>
	rc = ipc_get_msg(ept->chan, &mi);
ffffffffea810190:	910143a1 	add	x1, x29, #0x50
ffffffffea810194:	97fff319 	bl	ffffffffea80cdf8 <ipc_get_msg>
	if (rc < 0)
ffffffffea810198:	36f805c0 	tbz	w0, #31, ffffffffea810250 <ql_tipc_handle_cmd+0x328>
		return set_status(dev, opcode, rc, 0);
ffffffffea81019c:	f9403a61 	ldr	x1, [x19, #112]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8101a0:	52800022 	mov	w2, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea8101a4:	128fff63 	mov	w3, #0xffff8004            	// #-32764
ffffffffea8101a8:	79000023 	strh	w3, [x1]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8101ac:	b9000422 	str	w2, [x1, #4]
	ns_hdr->payload_len = len;
ffffffffea8101b0:	b9000c3f 	str	wzr, [x1, #12]
	smp_wmb();
ffffffffea8101b4:	d5033abf 	dmb	ishst
ffffffffea8101b8:	a941d7b4 	ldp	x20, x21, [x29, #24]
	return err;
ffffffffea8101bc:	93407c00 	sxtw	x0, w0
}
ffffffffea8101c0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8101c4:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea8101c8:	d65f03c0 	ret
			return dev_connect(dev, ns_payload, cmd->payload_len);
ffffffffea8101cc:	aa1303e0 	mov	x0, x19
ffffffffea8101d0:	97fffe48 	bl	ffffffffea80faf0 <dev_connect>
ffffffffea8101d4:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea8101d8:	93407c00 	sxtw	x0, w0
}
ffffffffea8101dc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8101e0:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea8101e4:	d65f03c0 	ret
	return (uint)(addr - QL_TIPC_ADDR_BASE);
ffffffffea8101e8:	b9404ba0 	ldr	w0, [x29, #72]
ffffffffea8101ec:	51008000 	sub	w0, w0, #0x20
	if (slot < QL_TIPC_ADDR_MAX_NUM) {
ffffffffea8101f0:	71007c1f 	cmp	w0, #0x1f
ffffffffea8101f4:	54000e88 	b.hi	ffffffffea8103c4 <ql_tipc_handle_cmd+0x49c>  // b.pmore
ffffffffea8101f8:	f9404663 	ldr	x3, [x19, #136]
ffffffffea8101fc:	9ac02463 	lsr	x3, x3, x0
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea810200:	36000e23 	tbz	w3, #0, ffffffffea8103c4 <ql_tipc_handle_cmd+0x49c>
	if (!ept || !ept->chan)
ffffffffea810204:	d37c7c00 	ubfiz	x0, x0, #4, #32
ffffffffea810208:	91024000 	add	x0, x0, #0x90
ffffffffea81020c:	f8606a60 	ldr	x0, [x19, x0]
ffffffffea810210:	b4000da0 	cbz	x0, ffffffffea8103c4 <ql_tipc_handle_cmd+0x49c>
	ipc_msg_kern_t msg = {
ffffffffea810214:	9101d3a3 	add	x3, x29, #0x74
		.iov = (iovec_kern_t[]) {
ffffffffea810218:	a9050ba1 	stp	x1, x2, [x29, #80]
	ipc_msg_kern_t msg = {
ffffffffea81021c:	910143a2 	add	x2, x29, #0x50
	return set_status(dev, opcode, ipc_send_msg(ept->chan, &msg), 0);
ffffffffea810220:	9101c3a1 	add	x1, x29, #0x70
	ipc_msg_kern_t msg = {
ffffffffea810224:	a9007c7f 	stp	xzr, xzr, [x3]
ffffffffea810228:	52800023 	mov	w3, #0x1                   	// #1
ffffffffea81022c:	b90073a3 	str	w3, [x29, #112]
ffffffffea810230:	f9003fa2 	str	x2, [x29, #120]
ffffffffea810234:	f80843bf 	stur	xzr, [x29, #132]
ffffffffea810238:	b9008fbf 	str	wzr, [x29, #140]
	return set_status(dev, opcode, ipc_send_msg(ept->chan, &msg), 0);
ffffffffea81023c:	97fff281 	bl	ffffffffea80cc40 <ipc_send_msg>
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810240:	128fff83 	mov	w3, #0xffff8003            	// #-32765
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810244:	531f7c02 	lsr	w2, w0, #31
	return set_status(dev, opcode, ipc_send_msg(ept->chan, &msg), 0);
ffffffffea810248:	f9403a61 	ldr	x1, [x19, #112]
ffffffffea81024c:	17ffffd7 	b	ffffffffea8101a8 <ql_tipc_handle_cmd+0x280>
	ipc_msg_kern_t msg = {
ffffffffea810250:	9101d3a4 	add	x4, x29, #0x74
				.len  = dev->ns_sz - sizeof(struct tipc_cmd_hdr),
ffffffffea810254:	b9406662 	ldr	w2, [x19, #100]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea810258:	f9404aa0 	ldr	x0, [x21, #144]
ffffffffea81025c:	b94057a1 	ldr	w1, [x29, #84]
				.len  = dev->ns_sz - sizeof(struct tipc_cmd_hdr),
ffffffffea810260:	d1004042 	sub	x2, x2, #0x10
				.base = dev->ns_va + sizeof(struct tipc_cmd_hdr),
ffffffffea810264:	f9403a63 	ldr	x3, [x19, #112]
	ipc_msg_kern_t msg = {
ffffffffea810268:	a9007c9f 	stp	xzr, xzr, [x4]
ffffffffea81026c:	52800024 	mov	w4, #0x1                   	// #1
				.base = dev->ns_va + sizeof(struct tipc_cmd_hdr),
ffffffffea810270:	91004063 	add	x3, x3, #0x10
		.iov = (iovec_kern_t[]) {
ffffffffea810274:	a9060ba3 	stp	x3, x2, [x29, #96]
	ipc_msg_kern_t msg = {
ffffffffea810278:	910183a2 	add	x2, x29, #0x60
ffffffffea81027c:	b90073a4 	str	w4, [x29, #112]
ffffffffea810280:	f9003fa2 	str	x2, [x29, #120]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea810284:	9101c3a3 	add	x3, x29, #0x70
	ipc_msg_kern_t msg = {
ffffffffea810288:	f80843bf 	stur	xzr, [x29, #132]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea81028c:	52800002 	mov	w2, #0x0                   	// #0
	ipc_msg_kern_t msg = {
ffffffffea810290:	b9008fbf 	str	wzr, [x29, #140]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea810294:	97fff3a7 	bl	ffffffffea80d130 <ipc_read_msg>
	ipc_put_msg(ept->chan, mi.id);
ffffffffea810298:	b94057a1 	ldr	w1, [x29, #84]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea81029c:	2a0003f4 	mov	w20, w0
	ipc_put_msg(ept->chan, mi.id);
ffffffffea8102a0:	f9404aa0 	ldr	x0, [x21, #144]
ffffffffea8102a4:	97fff309 	bl	ffffffffea80cec8 <ipc_put_msg>
	if (rc < 0)
ffffffffea8102a8:	37f801d4 	tbnz	w20, #31, ffffffffea8102e0 <ql_tipc_handle_cmd+0x3b8>
	if (rc < (int)mi.len)
ffffffffea8102ac:	b94053a1 	ldr	w1, [x29, #80]
ffffffffea8102b0:	f9403a60 	ldr	x0, [x19, #112]
ffffffffea8102b4:	6b01029f 	cmp	w20, w1
ffffffffea8102b8:	540008cb 	b.lt	ffffffffea8103d0 <ql_tipc_handle_cmd+0x4a8>  // b.tstop
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8102bc:	531f7e82 	lsr	w2, w20, #31
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea8102c0:	128fff63 	mov	w3, #0xffff8004            	// #-32764
ffffffffea8102c4:	79000003 	strh	w3, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8102c8:	b9000402 	str	w2, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea8102cc:	b9000c01 	str	w1, [x0, #12]
	smp_wmb();
ffffffffea8102d0:	d5033abf 	dmb	ishst
	return err;
ffffffffea8102d4:	93407e80 	sxtw	x0, w20
ffffffffea8102d8:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea8102dc:	17ffff28 	b	ffffffffea80ff7c <ql_tipc_handle_cmd+0x54>
		return set_status(dev, opcode, rc, 0);
ffffffffea8102e0:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8102e4:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea8102e8:	128fff62 	mov	w2, #0xffff8004            	// #-32764
ffffffffea8102ec:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8102f0:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea8102f4:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea8102f8:	d5033abf 	dmb	ishst
	return err;
ffffffffea8102fc:	93407e80 	sxtw	x0, w20
ffffffffea810300:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea810304:	17ffff1e 	b	ffffffffea80ff7c <ql_tipc_handle_cmd+0x54>
		rc = handle_list_wait(&dev->handle_list, &chan,
ffffffffea810308:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea81030c:	910183a2 	add	x2, x29, #0x60
ffffffffea810310:	9101c3a1 	add	x1, x29, #0x70
ffffffffea810314:	91004260 	add	x0, x19, #0x10
ffffffffea810318:	97ffe894 	bl	ffffffffea80a568 <handle_list_wait>
		if (rc == ERR_NOT_FOUND) {
ffffffffea81031c:	3100081f 	cmn	w0, #0x2
ffffffffea810320:	540006a0 	b.eq	ffffffffea8103f4 <ql_tipc_handle_cmd+0x4cc>  // b.none
		if (rc == ERR_TIMED_OUT) {
ffffffffea810324:	3100341f 	cmn	w0, #0xd
ffffffffea810328:	54000040 	b.eq	ffffffffea810330 <ql_tipc_handle_cmd+0x408>  // b.none
		if (rc < 0 && rc != ERR_TIMED_OUT) {
ffffffffea81032c:	37f807a0 	tbnz	w0, #31, ffffffffea810420 <ql_tipc_handle_cmd+0x4f8>
			ept = handle_get_cookie(chan);
ffffffffea810330:	f9403ba2 	ldr	x2, [x29, #112]
	return slot_to_addr(ept - dev->epts);
ffffffffea810334:	91024261 	add	x1, x19, #0x90
			handle_decref(chan);
ffffffffea810338:	aa0203e0 	mov	x0, x2
	return handle->cookie;
ffffffffea81033c:	f9401842 	ldr	x2, [x2, #48]
	return slot_to_addr(ept - dev->epts);
ffffffffea810340:	cb010041 	sub	x1, x2, x1
			evt->cookie = ept->cookie;
ffffffffea810344:	f9400442 	ldr	x2, [x2, #8]
	return slot_to_addr(ept - dev->epts);
ffffffffea810348:	9344fc21 	asr	x1, x1, #4
	return (uint32_t) (slot + QL_TIPC_ADDR_BASE);
ffffffffea81034c:	11008021 	add	w1, w1, #0x20
			evt->handle = ept_to_addr(dev, ept);
ffffffffea810350:	b9001681 	str	w1, [x20, #20]
			evt->event  = chan_event;
ffffffffea810354:	b94063a1 	ldr	w1, [x29, #96]
ffffffffea810358:	b9001281 	str	w1, [x20, #16]
			evt->cookie = ept->cookie;
ffffffffea81035c:	f9000e82 	str	x2, [x20, #24]
			handle_decref(chan);
ffffffffea810360:	97ffe7ac 	bl	ffffffffea80a210 <handle_decref>
ffffffffea810364:	17ffff3f 	b	ffffffffea810060 <ql_tipc_handle_cmd+0x138>
			evt->handle = 0;
ffffffffea810368:	a9017e9f 	stp	xzr, xzr, [x20, #16]
ffffffffea81036c:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea810370:	17ffff3c 	b	ffffffffea810060 <ql_tipc_handle_cmd+0x138>
ffffffffea810374:	f94017b6 	ldr	x22, [x29, #40]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810378:	52800020 	mov	w0, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea81037c:	128fffa1 	mov	w1, #0xffff8002            	// #-32766
ffffffffea810380:	79000281 	strh	w1, [x20]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810384:	b9000680 	str	w0, [x20, #4]
	ns_hdr->payload_len = len;
ffffffffea810388:	b9000e9f 	str	wzr, [x20, #12]
	smp_wmb();
ffffffffea81038c:	d5033abf 	dmb	ishst
			return set_status(dev, opcode, ERR_INVALID_ARGS, 0);
ffffffffea810390:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea810394:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea810398:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea81039c:	17fffef8 	b	ffffffffea80ff7c <ql_tipc_handle_cmd+0x54>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8103a0:	52800020 	mov	w0, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea8103a4:	128fff61 	mov	w1, #0xffff8004            	// #-32764
ffffffffea8103a8:	79000281 	strh	w1, [x20]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8103ac:	b9000680 	str	w0, [x20, #4]
	ns_hdr->payload_len = len;
ffffffffea8103b0:	b9000e9f 	str	wzr, [x20, #12]
	smp_wmb();
ffffffffea8103b4:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, ERR_INVALID_ARGS, 0);
ffffffffea8103b8:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea8103bc:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea8103c0:	17fffeef 	b	ffffffffea80ff7c <ql_tipc_handle_cmd+0x54>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8103c4:	52800020 	mov	w0, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea8103c8:	128fff81 	mov	w1, #0xffff8003            	// #-32765
ffffffffea8103cc:	17fffff7 	b	ffffffffea8103a8 <ql_tipc_handle_cmd+0x480>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8103d0:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea8103d4:	128fff62 	mov	w2, #0xffff8004            	// #-32764
ffffffffea8103d8:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8103dc:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea8103e0:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea8103e4:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, ERR_BAD_LEN, 0);
ffffffffea8103e8:	928003e0 	mov	x0, #0xffffffffffffffe0    	// #-32
ffffffffea8103ec:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea8103f0:	17fffee3 	b	ffffffffea80ff7c <ql_tipc_handle_cmd+0x54>
			return set_status(dev, opcode, rc, 0);
ffffffffea8103f4:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8103f8:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea8103fc:	128fffa2 	mov	w2, #0xffff8002            	// #-32766
ffffffffea810400:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810404:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea810408:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea81040c:	d5033abf 	dmb	ishst
			return set_status(dev, opcode, rc, 0);
ffffffffea810410:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea810414:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea810418:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea81041c:	17fffed8 	b	ffffffffea80ff7c <ql_tipc_handle_cmd+0x54>
ffffffffea810420:	f90017b6 	str	x22, [x29, #40]
			panic("%s: couldn't wait for handle events (%d)\n",
ffffffffea810424:	f0000022 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea810428:	f0000021 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea81042c:	2a0003e3 	mov	w3, w0
ffffffffea810430:	912d8042 	add	x2, x2, #0xb60
ffffffffea810434:	9129e021 	add	x1, x1, #0xa78
ffffffffea810438:	aa1503e0 	mov	x0, x21
ffffffffea81043c:	94000617 	bl	ffffffffea811c98 <_panic>

ffffffffea810440 <tipc_init>:
	}
	return false;
}

static void tipc_init(uint level)
{
ffffffffea810440:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	status_t res;

	res = create_tipc_device(&_descr0, sizeof(_descr0), &zero_uuid, 0, NULL);
ffffffffea810444:	f0000022 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea810448:	f0000020 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea81044c:	d2800004 	mov	x4, #0x0                   	// #0
{
ffffffffea810450:	910003fd 	mov	x29, sp
	res = create_tipc_device(&_descr0, sizeof(_descr0), &zero_uuid, 0, NULL);
ffffffffea810454:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea810458:	91182042 	add	x2, x2, #0x608
ffffffffea81045c:	d2800d81 	mov	x1, #0x6c                  	// #108
ffffffffea810460:	912e2000 	add	x0, x0, #0xb88
ffffffffea810464:	97fffd61 	bl	ffffffffea80f9e8 <create_tipc_device>
	if (res != NO_ERROR) {
ffffffffea810468:	35000060 	cbnz	w0, ffffffffea810474 <tipc_init+0x34>
		TRACEF("WARNING: failed (%d) to register tipc device\n", res);
	}
}
ffffffffea81046c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea810470:	d65f03c0 	ret
ffffffffea810474:	a8c17bfd 	ldp	x29, x30, [sp], #16
		TRACEF("WARNING: failed (%d) to register tipc device\n", res);
ffffffffea810478:	f0000024 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea81047c:	2a0003e3 	mov	w3, w0
ffffffffea810480:	f0000021 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea810484:	52800c42 	mov	w2, #0x62                  	// #98
ffffffffea810488:	912de021 	add	x1, x1, #0xb78
ffffffffea81048c:	912fe080 	add	x0, x4, #0xbf8
ffffffffea810490:	14000b68 	b	ffffffffea813230 <_printf>
ffffffffea810494:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810498 <is_ns_client>:
	if (uuid == &zero_uuid) {
ffffffffea810498:	f0000021 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea81049c:	91182021 	add	x1, x1, #0x608
ffffffffea8104a0:	eb00003f 	cmp	x1, x0
}
ffffffffea8104a4:	1a9f17e0 	cset	w0, eq  // eq = none
ffffffffea8104a8:	d65f03c0 	ret
ffffffffea8104ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8104b0 <target_early_init>:
 * chooses not to implement.
 */

__WEAK void target_early_init(void)
{
}
ffffffffea8104b0:	d65f03c0 	ret
ffffffffea8104b4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8104b8 <target_init>:
ffffffffea8104b8:	d65f03c0 	ret
ffffffffea8104bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8104c0 <boot_alloc_mem>:

void *boot_alloc_mem(size_t len)
{
    uintptr_t ptr;

    ptr = ALIGN(boot_alloc_end, 8);
ffffffffea8104c0:	b0000042 	adrp	x2, ffffffffea819000 <_mem_phys_base>
    boot_alloc_end = (ptr + ALIGN(len, 8));
ffffffffea8104c4:	91001c01 	add	x1, x0, #0x7
ffffffffea8104c8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    ptr = ALIGN(boot_alloc_end, 8);
ffffffffea8104cc:	f9474840 	ldr	x0, [x2, #3728]
ffffffffea8104d0:	91001c00 	add	x0, x0, #0x7
ffffffffea8104d4:	927df000 	and	x0, x0, #0xfffffffffffffff8
    boot_alloc_end = (ptr + ALIGN(len, 8));
ffffffffea8104d8:	8b000021 	add	x1, x1, x0
ffffffffea8104dc:	f9074841 	str	x1, [x2, #3728]

    LTRACEF("len %zu, ptr %p\n", len, (void *)ptr);

    return (void *)ptr;
}
ffffffffea8104e0:	d65f03c0 	ret
ffffffffea8104e4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8104e8 <pmm_alloc_contiguous.part.0>:
        return NULL;

    return paddr_to_kvaddr(pa);
}

uint pmm_alloc_contiguous(uint count, uint8_t alignment_log2, paddr_t *pa, struct list_node *list)
ffffffffea8104e8:	12001c21 	and	w1, w1, #0xff
ffffffffea8104ec:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea8104f0:	7100303f 	cmp	w1, #0xc
ffffffffea8104f4:	910003fd 	mov	x29, sp
ffffffffea8104f8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8104fc:	2a0003f4 	mov	w20, w0
ffffffffea810500:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea810504:	aa0303f3 	mov	x19, x3
ffffffffea810508:	aa0203f6 	mov	x22, x2
ffffffffea81050c:	f9001bf7 	str	x23, [sp, #48]
ffffffffea810510:	52800195 	mov	w21, #0xc                   	// #12
ffffffffea810514:	b0000057 	adrp	x23, ffffffffea819000 <_mem_phys_base>
ffffffffea810518:	1a952035 	csel	w21, w1, w21, cs  // cs = hs, nlast
ffffffffea81051c:	913ac2e0 	add	x0, x23, #0xeb0
ffffffffea810520:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea810524:	97ffd525 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
        alignment_log2 = PAGE_SIZE_SHIFT;

    mutex_acquire(&lock);

    pmm_arena_t *a;
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810528:	b0000042 	adrp	x2, ffffffffea819000 <_mem_phys_base>
ffffffffea81052c:	913a8042 	add	x2, x2, #0xea0
ffffffffea810530:	f9400446 	ldr	x6, [x2, #8]
ffffffffea810534:	eb0200df 	cmp	x6, x2
ffffffffea810538:	54000d20 	b.eq	ffffffffea8106dc <pmm_alloc_contiguous.part.0+0x1f4>  // b.none
ffffffffea81053c:	12001ea3 	and	w3, w21, #0xff
                for (uint i = 0; i < count; i++) {
                    if (p->flags & VM_PAGE_FLAG_NONFREE) {
                        /* this run is broken, break out of the inner loop.
                         * start over at the next alignment boundary
                         */
                        start = ROUNDUP(start - aligned_offset + i + 1, 1UL << (alignment_log2 - PAGE_SIZE_SHIFT)) + aligned_offset;
ffffffffea810540:	51003060 	sub	w0, w3, #0xc
            paddr_t rounded_base = ROUNDUP(a->base, 1UL << alignment_log2);
ffffffffea810544:	d2800023 	mov	x3, #0x1                   	// #1
ffffffffea810548:	9ad52061 	lsl	x1, x3, x21
ffffffffea81054c:	d100042c 	sub	x12, x1, #0x1
                        start = ROUNDUP(start - aligned_offset + i + 1, 1UL << (alignment_log2 - PAGE_SIZE_SHIFT)) + aligned_offset;
ffffffffea810550:	9ac02063 	lsl	x3, x3, x0
            paddr_t rounded_base = ROUNDUP(a->base, 1UL << alignment_log2);
ffffffffea810554:	cb0103e0 	neg	x0, x1
                        start = ROUNDUP(start - aligned_offset + i + 1, 1UL << (alignment_log2 - PAGE_SIZE_SHIFT)) + aligned_offset;
ffffffffea810558:	2a0303ed 	mov	w13, w3
ffffffffea81055c:	4b0303ea 	neg	w10, w3
        if (a->flags & PMM_ARENA_FLAG_KMAP) {
ffffffffea810560:	b94018c1 	ldr	w1, [x6, #24]
ffffffffea810564:	36000b61 	tbz	w1, #0, ffffffffea8106d0 <pmm_alloc_contiguous.part.0+0x1e8>
            paddr_t rounded_base = ROUNDUP(a->base, 1UL << alignment_log2);
ffffffffea810568:	f94010c7 	ldr	x7, [x6, #32]
ffffffffea81056c:	8b0c00e1 	add	x1, x7, x12
ffffffffea810570:	8a000021 	and	x1, x1, x0
            if (rounded_base < a->base || rounded_base > a->base + a->size - 1)
ffffffffea810574:	eb0100ff 	cmp	x7, x1
ffffffffea810578:	54000ac8 	b.hi	ffffffffea8106d0 <pmm_alloc_contiguous.part.0+0x1e8>  // b.pmore
ffffffffea81057c:	f94014c3 	ldr	x3, [x6, #40]
ffffffffea810580:	8b0300e4 	add	x4, x7, x3
ffffffffea810584:	d1000484 	sub	x4, x4, #0x1
ffffffffea810588:	eb04003f 	cmp	x1, x4
ffffffffea81058c:	54000a28 	b.hi	ffffffffea8106d0 <pmm_alloc_contiguous.part.0+0x1e8>  // b.pmore
            uint aligned_offset = (rounded_base - a->base) / PAGE_SIZE;
ffffffffea810590:	cb070021 	sub	x1, x1, x7
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea810594:	d34cfc68 	lsr	x8, x3, #12
            uint aligned_offset = (rounded_base - a->base) / PAGE_SIZE;
ffffffffea810598:	d34cfc21 	lsr	x1, x1, #12
ffffffffea81059c:	92407c2b 	and	x11, x1, #0xffffffff
ffffffffea8105a0:	2a0103ef 	mov	w15, w1
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea8105a4:	eb0b011f 	cmp	x8, x11
ffffffffea8105a8:	54000949 	b.ls	ffffffffea8106d0 <pmm_alloc_contiguous.part.0+0x1e8>  // b.plast
                   ((start + count) <= a->size / PAGE_SIZE)) {
ffffffffea8105ac:	0b010289 	add	w9, w20, w1
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea8105b0:	eb29411f 	cmp	x8, w9, uxtw
ffffffffea8105b4:	540008e3 	b.cc	ffffffffea8106d0 <pmm_alloc_contiguous.part.0+0x1e8>  // b.lo, b.ul, b.last
                vm_page_t *p = &a->page_array[start];
ffffffffea8105b8:	f9401cce 	ldr	x14, [x6, #56]
ffffffffea8105bc:	4b0101b0 	sub	w16, w13, w1
ffffffffea8105c0:	8b0b0564 	add	x4, x11, x11, lsl #1
ffffffffea8105c4:	8b040dc4 	add	x4, x14, x4, lsl #3
                for (uint i = 0; i < count; i++) {
ffffffffea8105c8:	34000174 	cbz	w20, ffffffffea8105f4 <pmm_alloc_contiguous.part.0+0x10c>
                    if (p->flags & VM_PAGE_FLAG_NONFREE) {
ffffffffea8105cc:	39404083 	ldrb	w3, [x4, #16]
ffffffffea8105d0:	370006c3 	tbnz	w3, #0, ffffffffea8106a8 <pmm_alloc_contiguous.part.0+0x1c0>
                for (uint i = 0; i < count; i++) {
ffffffffea8105d4:	52800005 	mov	w5, #0x0                   	// #0
ffffffffea8105d8:	14000003 	b	ffffffffea8105e4 <pmm_alloc_contiguous.part.0+0xfc>
                    if (p->flags & VM_PAGE_FLAG_NONFREE) {
ffffffffea8105dc:	39404083 	ldrb	w3, [x4, #16]
ffffffffea8105e0:	37000623 	tbnz	w3, #0, ffffffffea8106a4 <pmm_alloc_contiguous.part.0+0x1bc>
                for (uint i = 0; i < count; i++) {
ffffffffea8105e4:	110004a5 	add	w5, w5, #0x1
                        goto retry;
                    }
                    p++;
ffffffffea8105e8:	91006084 	add	x4, x4, #0x18
                for (uint i = 0; i < count; i++) {
ffffffffea8105ec:	6b1400bf 	cmp	w5, w20
ffffffffea8105f0:	54ffff61 	b.ne	ffffffffea8105dc <pmm_alloc_contiguous.part.0+0xf4>  // b.any

                /* we found a run */
                LTRACEF("found run from pn %u to %u\n", start, start + count);

                /* remove the pages from the run out of the free list */
                for (uint i = start; i < start + count; i++) {
ffffffffea8105f4:	6b01013f 	cmp	w9, w1
ffffffffea8105f8:	54000409 	b.ls	ffffffffea810678 <pmm_alloc_contiguous.part.0+0x190>  // b.plast
ffffffffea8105fc:	51000529 	sub	w9, w9, #0x1
ffffffffea810600:	52800302 	mov	w2, #0x18                  	// #24
ffffffffea810604:	4b010129 	sub	w9, w9, w1
ffffffffea810608:	910061c0 	add	x0, x14, #0x18
ffffffffea81060c:	8b214124 	add	x4, x9, w1, uxtw
ffffffffea810610:	f94018c5 	ldr	x5, [x6, #48]
ffffffffea810614:	d503201f 	nop
ffffffffea810618:	9ba23821 	umaddl	x1, w1, w2, x14
ffffffffea81061c:	8b040484 	add	x4, x4, x4, lsl #1
ffffffffea810620:	8b040c04 	add	x4, x0, x4, lsl #3
ffffffffea810624:	d503201f 	nop
	item->next->prev = item->prev;
ffffffffea810628:	a9400022 	ldp	x2, x0, [x1]
ffffffffea81062c:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea810630:	f9400022 	ldr	x2, [x1]
ffffffffea810634:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea810638:	a9007c3f 	stp	xzr, xzr, [x1]
                    p = &a->page_array[i];
                    DEBUG_ASSERT(!(p->flags & VM_PAGE_FLAG_NONFREE));
                    DEBUG_ASSERT(list_in_list(&p->node));

                    list_delete(&p->node);
                    p->flags |= VM_PAGE_FLAG_NONFREE;
ffffffffea81063c:	39404023 	ldrb	w3, [x1, #16]
ffffffffea810640:	32000063 	orr	w3, w3, #0x1
ffffffffea810644:	39004023 	strb	w3, [x1, #16]
                    a->free_count--;

                    if (list)
ffffffffea810648:	b40000d3 	cbz	x19, ffffffffea810660 <pmm_alloc_contiguous.part.0+0x178>
	item->prev = list->prev;
ffffffffea81064c:	f9400260 	ldr	x0, [x19]
	item->next = list;
ffffffffea810650:	a9004c20 	stp	x0, x19, [x1]
	list->prev->next = item;
ffffffffea810654:	f9400260 	ldr	x0, [x19]
ffffffffea810658:	f9000401 	str	x1, [x0, #8]
	list->prev = item;
ffffffffea81065c:	f9000261 	str	x1, [x19]
ffffffffea810660:	91006021 	add	x1, x1, #0x18
                for (uint i = start; i < start + count; i++) {
ffffffffea810664:	eb04003f 	cmp	x1, x4
ffffffffea810668:	54fffe01 	b.ne	ffffffffea810628 <pmm_alloc_contiguous.part.0+0x140>  // b.any
ffffffffea81066c:	d10004a5 	sub	x5, x5, #0x1
ffffffffea810670:	cb0900a9 	sub	x9, x5, x9
ffffffffea810674:	f90018c9 	str	x9, [x6, #48]
                        list_add_tail(list, &p->node);
                }

                if (pa)
ffffffffea810678:	b4000076 	cbz	x22, ffffffffea810684 <pmm_alloc_contiguous.part.0+0x19c>
                    *pa = a->base + start * PAGE_SIZE;
ffffffffea81067c:	8b0b30e7 	add	x7, x7, x11, lsl #12
ffffffffea810680:	f90002c7 	str	x7, [x22]

                mutex_release(&lock);
ffffffffea810684:	913ac2e0 	add	x0, x23, #0xeb0
ffffffffea810688:	97ffd4f8 	bl	ffffffffea805a68 <mutex_release>
ffffffffea81068c:	2a1403e0 	mov	w0, w20

    mutex_release(&lock);

    LTRACEF("couldn't find run\n");
    return 0;
}
ffffffffea810690:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea810694:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea810698:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea81069c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8106a0:	d65f03c0 	ret
ffffffffea8106a4:	0b050021 	add	w1, w1, w5
                        start = ROUNDUP(start - aligned_offset + i + 1, 1UL << (alignment_log2 - PAGE_SIZE_SHIFT)) + aligned_offset;
ffffffffea8106a8:	0b010201 	add	w1, w16, w1
ffffffffea8106ac:	0a0a0021 	and	w1, w1, w10
ffffffffea8106b0:	0b0f002b 	add	w11, w1, w15
ffffffffea8106b4:	aa0b03e1 	mov	x1, x11
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea8106b8:	eb08017f 	cmp	x11, x8
ffffffffea8106bc:	540000a2 	b.cs	ffffffffea8106d0 <pmm_alloc_contiguous.part.0+0x1e8>  // b.hs, b.nlast
                   ((start + count) <= a->size / PAGE_SIZE)) {
ffffffffea8106c0:	0b140169 	add	w9, w11, w20
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea8106c4:	eb29411f 	cmp	x8, w9, uxtw
ffffffffea8106c8:	54fff7c2 	b.cs	ffffffffea8105c0 <pmm_alloc_contiguous.part.0+0xd8>  // b.hs, b.nlast
ffffffffea8106cc:	d503201f 	nop
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8106d0:	f94004c6 	ldr	x6, [x6, #8]
ffffffffea8106d4:	eb0200df 	cmp	x6, x2
ffffffffea8106d8:	54fff441 	b.ne	ffffffffea810560 <pmm_alloc_contiguous.part.0+0x78>  // b.any
    mutex_release(&lock);
ffffffffea8106dc:	913ac2e0 	add	x0, x23, #0xeb0
ffffffffea8106e0:	97ffd4e2 	bl	ffffffffea805a68 <mutex_release>
    return 0;
ffffffffea8106e4:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea8106e8:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea8106ec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8106f0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8106f4:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8106f8:	d65f03c0 	ret
ffffffffea8106fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810700 <page_to_address>:
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810700:	b0000044 	adrp	x4, ffffffffea819000 <_mem_phys_base>
ffffffffea810704:	913a8084 	add	x4, x4, #0xea0
ffffffffea810708:	f9400481 	ldr	x1, [x4, #8]
ffffffffea81070c:	eb04003f 	cmp	x1, x4
ffffffffea810710:	540001c0 	b.eq	ffffffffea810748 <page_to_address+0x48>  // b.none
ffffffffea810714:	d503201f 	nop
        if (PAGE_BELONGS_TO_ARENA(page, a)) {
ffffffffea810718:	f9401c23 	ldr	x3, [x1, #56]
ffffffffea81071c:	eb00007f 	cmp	x3, x0
ffffffffea810720:	540000e8 	b.hi	ffffffffea81073c <page_to_address+0x3c>  // b.pmore
ffffffffea810724:	f9401422 	ldr	x2, [x1, #40]
ffffffffea810728:	d34cfc42 	lsr	x2, x2, #12
ffffffffea81072c:	8b020442 	add	x2, x2, x2, lsl #1
ffffffffea810730:	8b020c62 	add	x2, x3, x2, lsl #3
ffffffffea810734:	eb00005f 	cmp	x2, x0
ffffffffea810738:	540000c8 	b.hi	ffffffffea810750 <page_to_address+0x50>  // b.pmore
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea81073c:	f9400421 	ldr	x1, [x1, #8]
ffffffffea810740:	eb04003f 	cmp	x1, x4
ffffffffea810744:	54fffea1 	b.ne	ffffffffea810718 <page_to_address+0x18>  // b.any
    return -1;
ffffffffea810748:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
}
ffffffffea81074c:	d65f03c0 	ret
            return PAGE_ADDRESS_FROM_ARENA(page, a);
ffffffffea810750:	cb030000 	sub	x0, x0, x3
ffffffffea810754:	b201f3e3 	mov	x3, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
ffffffffea810758:	f2955563 	movk	x3, #0xaaab
ffffffffea81075c:	f9401021 	ldr	x1, [x1, #32]
ffffffffea810760:	9bc37c00 	umulh	x0, x0, x3
ffffffffea810764:	d344fc00 	lsr	x0, x0, #4
ffffffffea810768:	8b003020 	add	x0, x1, x0, lsl #12
}
ffffffffea81076c:	d65f03c0 	ret

ffffffffea810770 <address_to_page>:
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810770:	b0000044 	adrp	x4, ffffffffea819000 <_mem_phys_base>
ffffffffea810774:	913a8084 	add	x4, x4, #0xea0
ffffffffea810778:	f9400481 	ldr	x1, [x4, #8]
ffffffffea81077c:	eb04003f 	cmp	x1, x4
ffffffffea810780:	540001a0 	b.eq	ffffffffea8107b4 <address_to_page+0x44>  // b.none
ffffffffea810784:	d503201f 	nop
        if (addr >= a->base && addr <= a->base + a->size - 1) {
ffffffffea810788:	f9401023 	ldr	x3, [x1, #32]
ffffffffea81078c:	eb00007f 	cmp	x3, x0
ffffffffea810790:	540000c8 	b.hi	ffffffffea8107a8 <address_to_page+0x38>  // b.pmore
ffffffffea810794:	f9401422 	ldr	x2, [x1, #40]
ffffffffea810798:	8b020062 	add	x2, x3, x2
ffffffffea81079c:	d1000442 	sub	x2, x2, #0x1
ffffffffea8107a0:	eb00005f 	cmp	x2, x0
ffffffffea8107a4:	540000c2 	b.cs	ffffffffea8107bc <address_to_page+0x4c>  // b.hs, b.nlast
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8107a8:	f9400421 	ldr	x1, [x1, #8]
ffffffffea8107ac:	eb04003f 	cmp	x1, x4
ffffffffea8107b0:	54fffec1 	b.ne	ffffffffea810788 <address_to_page+0x18>  // b.any
    return NULL;
ffffffffea8107b4:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea8107b8:	d65f03c0 	ret
            size_t index = (addr - a->base) / PAGE_SIZE;
ffffffffea8107bc:	cb030000 	sub	x0, x0, x3
            return &a->page_array[index];
ffffffffea8107c0:	f9401c21 	ldr	x1, [x1, #56]
            size_t index = (addr - a->base) / PAGE_SIZE;
ffffffffea8107c4:	d34cfc00 	lsr	x0, x0, #12
            return &a->page_array[index];
ffffffffea8107c8:	8b000400 	add	x0, x0, x0, lsl #1
ffffffffea8107cc:	8b000c20 	add	x0, x1, x0, lsl #3
}
ffffffffea8107d0:	d65f03c0 	ret
ffffffffea8107d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8107d8 <pmm_add_arena>:
{
ffffffffea8107d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8107dc:	b0000044 	adrp	x4, ffffffffea819000 <_mem_phys_base>
ffffffffea8107e0:	913a8082 	add	x2, x4, #0xea0
{
ffffffffea8107e4:	910003fd 	mov	x29, sp
ffffffffea8107e8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8107ec:	aa0003f3 	mov	x19, x0
ffffffffea8107f0:	a9025bf5 	stp	x21, x22, [sp, #32]
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8107f4:	f9400440 	ldr	x0, [x2, #8]
ffffffffea8107f8:	eb02001f 	cmp	x0, x2
ffffffffea8107fc:	54000180 	b.eq	ffffffffea81082c <pmm_add_arena+0x54>  // b.none
        if (a->priority > arena->priority) {
ffffffffea810800:	b9401c01 	ldr	w1, [x0, #28]
ffffffffea810804:	b9401e63 	ldr	w3, [x19, #28]
ffffffffea810808:	6b01007f 	cmp	w3, w1
ffffffffea81080c:	540000a2 	b.cs	ffffffffea810820 <pmm_add_arena+0x48>  // b.hs, b.nlast
ffffffffea810810:	1400002d 	b	ffffffffea8108c4 <pmm_add_arena+0xec>
ffffffffea810814:	b9401c01 	ldr	w1, [x0, #28]
ffffffffea810818:	6b03003f 	cmp	w1, w3
ffffffffea81081c:	54000548 	b.hi	ffffffffea8108c4 <pmm_add_arena+0xec>  // b.pmore
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810820:	f9400400 	ldr	x0, [x0, #8]
ffffffffea810824:	eb02001f 	cmp	x0, x2
ffffffffea810828:	54ffff61 	b.ne	ffffffffea810814 <pmm_add_arena+0x3c>  // b.any
	item->prev = list->prev;
ffffffffea81082c:	f9475081 	ldr	x1, [x4, #3744]
ffffffffea810830:	913a8080 	add	x0, x4, #0xea0
	item->next = list;
ffffffffea810834:	a9000261 	stp	x1, x0, [x19]
	list->prev->next = item;
ffffffffea810838:	f9475080 	ldr	x0, [x4, #3744]
	list->prev = item;
ffffffffea81083c:	f9075093 	str	x19, [x4, #3744]
	list->prev->next = item;
ffffffffea810840:	f9000413 	str	x19, [x0, #8]
    size_t page_count = arena->size / PAGE_SIZE;
ffffffffea810844:	f9401676 	ldr	x22, [x19, #40]
    list_initialize(&arena->free_list);
ffffffffea810848:	91010275 	add	x21, x19, #0x40
    arena->free_count = 0;
ffffffffea81084c:	f9001a7f 	str	xzr, [x19, #48]
	list->prev = list->next = list;
ffffffffea810850:	a9045675 	stp	x21, x21, [x19, #64]
    size_t page_count = arena->size / PAGE_SIZE;
ffffffffea810854:	d34cfed6 	lsr	x22, x22, #12
    arena->page_array = boot_alloc_mem(page_count * sizeof(vm_page_t));
ffffffffea810858:	8b1606c2 	add	x2, x22, x22, lsl #1
ffffffffea81085c:	d37df054 	lsl	x20, x2, #3
ffffffffea810860:	aa1403e0 	mov	x0, x20
ffffffffea810864:	97ffff17 	bl	ffffffffea8104c0 <boot_alloc_mem>
ffffffffea810868:	f9001e60 	str	x0, [x19, #56]
    memset(arena->page_array, 0, page_count * sizeof(vm_page_t));
ffffffffea81086c:	aa1403e2 	mov	x2, x20
ffffffffea810870:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea810874:	94000b6b 	bl	ffffffffea813620 <memset>
    for (size_t i = 0; i < page_count; i++) {
ffffffffea810878:	b40001d6 	cbz	x22, ffffffffea8108b0 <pmm_add_arena+0xd8>
ffffffffea81087c:	a9430264 	ldp	x4, x0, [x19, #48]
ffffffffea810880:	f9402261 	ldr	x1, [x19, #64]
ffffffffea810884:	8b000282 	add	x2, x20, x0
	item->next = list;
ffffffffea810888:	a9005401 	stp	x1, x21, [x0]
        list_add_tail(&arena->free_list, &p->node);
ffffffffea81088c:	aa0003e1 	mov	x1, x0
	list->prev->next = item;
ffffffffea810890:	f9402263 	ldr	x3, [x19, #64]
ffffffffea810894:	f9000460 	str	x0, [x3, #8]
	list->prev = item;
ffffffffea810898:	f9002260 	str	x0, [x19, #64]
ffffffffea81089c:	91006000 	add	x0, x0, #0x18
    for (size_t i = 0; i < page_count; i++) {
ffffffffea8108a0:	eb02001f 	cmp	x0, x2
ffffffffea8108a4:	54ffff21 	b.ne	ffffffffea810888 <pmm_add_arena+0xb0>  // b.any
ffffffffea8108a8:	8b160084 	add	x4, x4, x22
ffffffffea8108ac:	f9001a64 	str	x4, [x19, #48]
}
ffffffffea8108b0:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8108b4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8108b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8108bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8108c0:	d65f03c0 	ret
	item->prev = list->prev;
ffffffffea8108c4:	f9400001 	ldr	x1, [x0]
	item->next = list;
ffffffffea8108c8:	a9000261 	stp	x1, x0, [x19]
	list->prev->next = item;
ffffffffea8108cc:	f9400001 	ldr	x1, [x0]
ffffffffea8108d0:	f9000433 	str	x19, [x1, #8]
	list->prev = item;
ffffffffea8108d4:	f9000013 	str	x19, [x0]
ffffffffea8108d8:	17ffffdb 	b	ffffffffea810844 <pmm_add_arena+0x6c>
ffffffffea8108dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8108e0 <pmm_alloc_pages>:
{
ffffffffea8108e0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8108e4:	910003fd 	mov	x29, sp
ffffffffea8108e8:	f9000ff4 	str	x20, [sp, #24]
ffffffffea8108ec:	2a0003f4 	mov	w20, w0
    if (count == 0)
ffffffffea8108f0:	350000a0 	cbnz	w0, ffffffffea810904 <pmm_alloc_pages+0x24>
}
ffffffffea8108f4:	2a1403e0 	mov	w0, w20
ffffffffea8108f8:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea8108fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea810900:	d65f03c0 	ret
ffffffffea810904:	f9000bb3 	str	x19, [x29, #16]
ffffffffea810908:	aa0103f3 	mov	x19, x1
ffffffffea81090c:	f90013b5 	str	x21, [x29, #32]
ffffffffea810910:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea810914:	b0000055 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea810918:	913ac2a0 	add	x0, x21, #0xeb0
ffffffffea81091c:	97ffd427 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810920:	b0000048 	adrp	x8, ffffffffea819000 <_mem_phys_base>
ffffffffea810924:	913a8108 	add	x8, x8, #0xea0
    uint allocated = 0;
ffffffffea810928:	52800002 	mov	w2, #0x0                   	// #0
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea81092c:	f9400505 	ldr	x5, [x8, #8]
ffffffffea810930:	eb0800bf 	cmp	x5, x8
ffffffffea810934:	540005e0 	b.eq	ffffffffea8109f0 <pmm_alloc_pages+0x110>  // b.none
        while (allocated < count) {
ffffffffea810938:	6b02029f 	cmp	w20, w2
ffffffffea81093c:	540003c9 	b.ls	ffffffffea8109b4 <pmm_alloc_pages+0xd4>  // b.plast
	if (list->next != list) {
ffffffffea810940:	f94024a0 	ldr	x0, [x5, #72]
            vm_page_t *page = list_remove_head_type(&a->free_list, vm_page_t, node);
ffffffffea810944:	910100a7 	add	x7, x5, #0x40
ffffffffea810948:	eb07001f 	cmp	x0, x7
ffffffffea81094c:	540003a0 	b.eq	ffffffffea8109c0 <pmm_alloc_pages+0xe0>  // b.none
ffffffffea810950:	f94018a3 	ldr	x3, [x5, #48]
ffffffffea810954:	d1000463 	sub	x3, x3, #0x1
ffffffffea810958:	14000005 	b	ffffffffea81096c <pmm_alloc_pages+0x8c>
ffffffffea81095c:	f94024a0 	ldr	x0, [x5, #72]
ffffffffea810960:	eb07001f 	cmp	x0, x7
ffffffffea810964:	54000320 	b.eq	ffffffffea8109c8 <pmm_alloc_pages+0xe8>  // b.none
ffffffffea810968:	aa0603e3 	mov	x3, x6
	item->next->prev = item->prev;
ffffffffea81096c:	a9400404 	ldp	x4, x1, [x0]
            allocated++;
ffffffffea810970:	11000442 	add	w2, w2, #0x1
ffffffffea810974:	d1000466 	sub	x6, x3, #0x1
        while (allocated < count) {
ffffffffea810978:	6b02029f 	cmp	w20, w2
ffffffffea81097c:	f9000024 	str	x4, [x1]
	item->prev->next = item->next;
ffffffffea810980:	f9400004 	ldr	x4, [x0]
ffffffffea810984:	f9000481 	str	x1, [x4, #8]
	item->prev = item->next = 0;
ffffffffea810988:	f900001f 	str	xzr, [x0]
            page->flags |= VM_PAGE_FLAG_NONFREE;
ffffffffea81098c:	39404001 	ldrb	w1, [x0, #16]
ffffffffea810990:	32000021 	orr	w1, w1, #0x1
ffffffffea810994:	39004001 	strb	w1, [x0, #16]
	item->prev = list->prev;
ffffffffea810998:	f9400261 	ldr	x1, [x19]
	item->next = list;
ffffffffea81099c:	a9004c01 	stp	x1, x19, [x0]
	list->prev->next = item;
ffffffffea8109a0:	f9400261 	ldr	x1, [x19]
ffffffffea8109a4:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea8109a8:	f9000260 	str	x0, [x19]
        while (allocated < count) {
ffffffffea8109ac:	54fffd81 	b.ne	ffffffffea81095c <pmm_alloc_pages+0x7c>  // b.any
ffffffffea8109b0:	f90018a3 	str	x3, [x5, #48]
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8109b4:	f94004a5 	ldr	x5, [x5, #8]
ffffffffea8109b8:	eb0800bf 	cmp	x5, x8
ffffffffea8109bc:	54fffbe1 	b.ne	ffffffffea810938 <pmm_alloc_pages+0x58>  // b.any
	if (list->next != list) {
ffffffffea8109c0:	2a0203f4 	mov	w20, w2
ffffffffea8109c4:	14000003 	b	ffffffffea8109d0 <pmm_alloc_pages+0xf0>
            allocated++;
ffffffffea8109c8:	2a0203f4 	mov	w20, w2
ffffffffea8109cc:	f90018a3 	str	x3, [x5, #48]
    mutex_release(&lock);
ffffffffea8109d0:	913ac2a0 	add	x0, x21, #0xeb0
ffffffffea8109d4:	97ffd425 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea8109d8:	2a1403e0 	mov	w0, w20
    mutex_release(&lock);
ffffffffea8109dc:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8109e0:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea8109e4:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea8109e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8109ec:	d65f03c0 	ret
    uint allocated = 0;
ffffffffea8109f0:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea8109f4:	17fffff7 	b	ffffffffea8109d0 <pmm_alloc_pages+0xf0>

ffffffffea8109f8 <pmm_alloc_range>:
{
ffffffffea8109f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8109fc:	910003fd 	mov	x29, sp
ffffffffea810a00:	f90013f5 	str	x21, [sp, #32]
ffffffffea810a04:	2a0103f5 	mov	w21, w1
    if (count == 0)
ffffffffea810a08:	350000a1 	cbnz	w1, ffffffffea810a1c <pmm_alloc_range+0x24>
}
ffffffffea810a0c:	2a1503e0 	mov	w0, w21
ffffffffea810a10:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea810a14:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea810a18:	d65f03c0 	ret
ffffffffea810a1c:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea810a20:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea810a24:	f90017b6 	str	x22, [x29, #40]
ffffffffea810a28:	aa0203f4 	mov	x20, x2
    address = ROUNDDOWN(address, PAGE_SIZE);
ffffffffea810a2c:	9274cc13 	and	x19, x0, #0xfffffffffffff000
ffffffffea810a30:	b0000056 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea810a34:	913ac2c0 	add	x0, x22, #0xeb0
ffffffffea810a38:	97ffd3e0 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810a3c:	b000004a 	adrp	x10, ffffffffea819000 <_mem_phys_base>
ffffffffea810a40:	913a814a 	add	x10, x10, #0xea0
    uint allocated = 0;
ffffffffea810a44:	52800003 	mov	w3, #0x0                   	// #0
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810a48:	f9400549 	ldr	x9, [x10, #8]
ffffffffea810a4c:	eb0a013f 	cmp	x9, x10
ffffffffea810a50:	54000640 	b.eq	ffffffffea810b18 <pmm_alloc_range+0x120>  // b.none
ffffffffea810a54:	d503201f 	nop
        while (allocated < count && ADDRESS_IN_ARENA(address, a)) {
ffffffffea810a58:	6b0302bf 	cmp	w21, w3
ffffffffea810a5c:	54000709 	b.ls	ffffffffea810b3c <pmm_alloc_range+0x144>  // b.plast
ffffffffea810a60:	f9401124 	ldr	x4, [x9, #32]
ffffffffea810a64:	eb13009f 	cmp	x4, x19
ffffffffea810a68:	540006c8 	b.hi	ffffffffea810b40 <pmm_alloc_range+0x148>  // b.pmore
ffffffffea810a6c:	f9401527 	ldr	x7, [x9, #40]
ffffffffea810a70:	8b070087 	add	x7, x4, x7
ffffffffea810a74:	d10004e7 	sub	x7, x7, #0x1
ffffffffea810a78:	eb1300ff 	cmp	x7, x19
ffffffffea810a7c:	54000623 	b.cc	ffffffffea810b40 <pmm_alloc_range+0x148>  // b.lo, b.ul, b.last
            size_t index = (address - a->base) / PAGE_SIZE;
ffffffffea810a80:	cb040260 	sub	x0, x19, x4
            vm_page_t *page = &a->page_array[index];
ffffffffea810a84:	f9401d28 	ldr	x8, [x9, #56]
            size_t index = (address - a->base) / PAGE_SIZE;
ffffffffea810a88:	d34cfc00 	lsr	x0, x0, #12
            vm_page_t *page = &a->page_array[index];
ffffffffea810a8c:	8b000400 	add	x0, x0, x0, lsl #1
ffffffffea810a90:	8b000d00 	add	x0, x8, x0, lsl #3
            if (page->flags & VM_PAGE_FLAG_NONFREE) {
ffffffffea810a94:	39404001 	ldrb	w1, [x0, #16]
ffffffffea810a98:	37000541 	tbnz	w1, #0, ffffffffea810b40 <pmm_alloc_range+0x148>
ffffffffea810a9c:	f9401925 	ldr	x5, [x9, #48]
ffffffffea810aa0:	14000007 	b	ffffffffea810abc <pmm_alloc_range+0xc4>
        while (allocated < count && ADDRESS_IN_ARENA(address, a)) {
ffffffffea810aa4:	eb04027f 	cmp	x19, x4
ffffffffea810aa8:	54000543 	b.cc	ffffffffea810b50 <pmm_alloc_range+0x158>  // b.lo, b.ul, b.last
ffffffffea810aac:	eb07027f 	cmp	x19, x7
ffffffffea810ab0:	54000508 	b.hi	ffffffffea810b50 <pmm_alloc_range+0x158>  // b.pmore
            if (page->flags & VM_PAGE_FLAG_NONFREE) {
ffffffffea810ab4:	39404001 	ldrb	w1, [x0, #16]
ffffffffea810ab8:	370004c1 	tbnz	w1, #0, ffffffffea810b50 <pmm_alloc_range+0x158>
	item->next->prev = item->prev;
ffffffffea810abc:	a9400806 	ldp	x6, x2, [x0]
            address += PAGE_SIZE;
ffffffffea810ac0:	91400673 	add	x19, x19, #0x1, lsl #12
            size_t index = (address - a->base) / PAGE_SIZE;
ffffffffea810ac4:	cb040261 	sub	x1, x19, x4
            allocated++;
ffffffffea810ac8:	11000463 	add	w3, w3, #0x1
        while (allocated < count && ADDRESS_IN_ARENA(address, a)) {
ffffffffea810acc:	6b0302bf 	cmp	w21, w3
            a->free_count--;
ffffffffea810ad0:	d10004a5 	sub	x5, x5, #0x1
ffffffffea810ad4:	f9000046 	str	x6, [x2]
            size_t index = (address - a->base) / PAGE_SIZE;
ffffffffea810ad8:	d34cfc21 	lsr	x1, x1, #12
	item->prev->next = item->next;
ffffffffea810adc:	f9400006 	ldr	x6, [x0]
            vm_page_t *page = &a->page_array[index];
ffffffffea810ae0:	8b010421 	add	x1, x1, x1, lsl #1
ffffffffea810ae4:	f90004c2 	str	x2, [x6, #8]
	item->prev = item->next = 0;
ffffffffea810ae8:	f900001f 	str	xzr, [x0]
            page->flags |= VM_PAGE_FLAG_NONFREE;
ffffffffea810aec:	39404002 	ldrb	w2, [x0, #16]
ffffffffea810af0:	32000042 	orr	w2, w2, #0x1
ffffffffea810af4:	39004002 	strb	w2, [x0, #16]
	item->prev = list->prev;
ffffffffea810af8:	f9400282 	ldr	x2, [x20]
	item->next = list;
ffffffffea810afc:	a9005002 	stp	x2, x20, [x0]
	list->prev->next = item;
ffffffffea810b00:	f9400282 	ldr	x2, [x20]
ffffffffea810b04:	f9000440 	str	x0, [x2, #8]
	list->prev = item;
ffffffffea810b08:	f9000280 	str	x0, [x20]
            vm_page_t *page = &a->page_array[index];
ffffffffea810b0c:	8b010d00 	add	x0, x8, x1, lsl #3
        while (allocated < count && ADDRESS_IN_ARENA(address, a)) {
ffffffffea810b10:	54fffca1 	b.ne	ffffffffea810aa4 <pmm_alloc_range+0xac>  // b.any
ffffffffea810b14:	f9001925 	str	x5, [x9, #48]
    return allocated;
ffffffffea810b18:	2a0303f5 	mov	w21, w3
    mutex_release(&lock);
ffffffffea810b1c:	913ac2c0 	add	x0, x22, #0xeb0
ffffffffea810b20:	97ffd3d2 	bl	ffffffffea805a68 <mutex_release>
    return allocated;
ffffffffea810b24:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea810b28:	2a1503e0 	mov	w0, w21
ffffffffea810b2c:	f94013f5 	ldr	x21, [sp, #32]
    return allocated;
ffffffffea810b30:	a94153b3 	ldp	x19, x20, [x29, #16]
}
ffffffffea810b34:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea810b38:	d65f03c0 	ret
        if (allocated == count)
ffffffffea810b3c:	54fffee0 	b.eq	ffffffffea810b18 <pmm_alloc_range+0x120>  // b.none
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810b40:	f9400529 	ldr	x9, [x9, #8]
ffffffffea810b44:	eb0a013f 	cmp	x9, x10
ffffffffea810b48:	54fff881 	b.ne	ffffffffea810a58 <pmm_alloc_range+0x60>  // b.any
ffffffffea810b4c:	17fffff3 	b	ffffffffea810b18 <pmm_alloc_range+0x120>
ffffffffea810b50:	f9001925 	str	x5, [x9, #48]
ffffffffea810b54:	f9400529 	ldr	x9, [x9, #8]
ffffffffea810b58:	eb0a013f 	cmp	x9, x10
ffffffffea810b5c:	54fff7e1 	b.ne	ffffffffea810a58 <pmm_alloc_range+0x60>  // b.any
ffffffffea810b60:	17ffffee 	b	ffffffffea810b18 <pmm_alloc_range+0x120>
ffffffffea810b64:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810b68 <pmm_free>:
{
ffffffffea810b68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea810b6c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea810b70:	910003fd 	mov	x29, sp
ffffffffea810b74:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea810b78:	aa0003f3 	mov	x19, x0
ffffffffea810b7c:	f90013f5 	str	x21, [sp, #32]
ffffffffea810b80:	b0000055 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea810b84:	913ac2a0 	add	x0, x21, #0xeb0
ffffffffea810b88:	97ffd38c 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
        list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810b8c:	b0000044 	adrp	x4, ffffffffea819000 <_mem_phys_base>
ffffffffea810b90:	913a8084 	add	x4, x4, #0xea0
    uint count = 0;
ffffffffea810b94:	52800014 	mov	w20, #0x0                   	// #0
	return (list->next == list) ? true : false;
ffffffffea810b98:	f9400662 	ldr	x2, [x19, #8]
    while (!list_is_empty(list)) {
ffffffffea810b9c:	eb02027f 	cmp	x19, x2
ffffffffea810ba0:	540004c0 	b.eq	ffffffffea810c38 <pmm_free+0xd0>  // b.none
	item->next->prev = item->prev;
ffffffffea810ba4:	a9400041 	ldp	x1, x0, [x2]
ffffffffea810ba8:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea810bac:	f9400041 	ldr	x1, [x2]
ffffffffea810bb0:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea810bb4:	a9007c5f 	stp	xzr, xzr, [x2]
        list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810bb8:	f9400480 	ldr	x0, [x4, #8]
ffffffffea810bbc:	eb04001f 	cmp	x0, x4
ffffffffea810bc0:	540000a1 	b.ne	ffffffffea810bd4 <pmm_free+0x6c>  // b.any
ffffffffea810bc4:	17fffff5 	b	ffffffffea810b98 <pmm_free+0x30>
ffffffffea810bc8:	f9400400 	ldr	x0, [x0, #8]
ffffffffea810bcc:	eb04001f 	cmp	x0, x4
ffffffffea810bd0:	54fffe40 	b.eq	ffffffffea810b98 <pmm_free+0x30>  // b.none
            if (PAGE_BELONGS_TO_ARENA(page, a)) {
ffffffffea810bd4:	f9401c03 	ldr	x3, [x0, #56]
ffffffffea810bd8:	eb02007f 	cmp	x3, x2
ffffffffea810bdc:	54ffff68 	b.hi	ffffffffea810bc8 <pmm_free+0x60>  // b.pmore
ffffffffea810be0:	f9401401 	ldr	x1, [x0, #40]
ffffffffea810be4:	d34cfc21 	lsr	x1, x1, #12
ffffffffea810be8:	8b010421 	add	x1, x1, x1, lsl #1
ffffffffea810bec:	8b010c61 	add	x1, x3, x1, lsl #3
ffffffffea810bf0:	eb02003f 	cmp	x1, x2
ffffffffea810bf4:	54fffea9 	b.ls	ffffffffea810bc8 <pmm_free+0x60>  // b.plast
                page->flags &= ~VM_PAGE_FLAG_NONFREE;
ffffffffea810bf8:	39404043 	ldrb	w3, [x2, #16]
                list_add_head(&a->free_list, &page->node);
ffffffffea810bfc:	91010005 	add	x5, x0, #0x40
                a->free_count++;
ffffffffea810c00:	f9401801 	ldr	x1, [x0, #48]
                count++;
ffffffffea810c04:	11000694 	add	w20, w20, #0x1
                page->flags &= ~VM_PAGE_FLAG_NONFREE;
ffffffffea810c08:	121f7863 	and	w3, w3, #0xfffffffe
ffffffffea810c0c:	39004043 	strb	w3, [x2, #16]
                a->free_count++;
ffffffffea810c10:	91000421 	add	x1, x1, #0x1
	item->next = list->next;
ffffffffea810c14:	f9402403 	ldr	x3, [x0, #72]
ffffffffea810c18:	a9000c45 	stp	x5, x3, [x2]
	list->next->prev = item;
ffffffffea810c1c:	f9402403 	ldr	x3, [x0, #72]
ffffffffea810c20:	f9000062 	str	x2, [x3]
	list->next = item;
ffffffffea810c24:	f9002402 	str	x2, [x0, #72]
ffffffffea810c28:	f9001801 	str	x1, [x0, #48]
	return (list->next == list) ? true : false;
ffffffffea810c2c:	f9400662 	ldr	x2, [x19, #8]
    while (!list_is_empty(list)) {
ffffffffea810c30:	eb02027f 	cmp	x19, x2
ffffffffea810c34:	54fffb81 	b.ne	ffffffffea810ba4 <pmm_free+0x3c>  // b.any
    mutex_release(&lock);
ffffffffea810c38:	913ac2a0 	add	x0, x21, #0xeb0
ffffffffea810c3c:	97ffd38b 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea810c40:	2a1403e0 	mov	w0, w20
ffffffffea810c44:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea810c48:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea810c4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea810c50:	d65f03c0 	ret
ffffffffea810c54:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810c58 <pmm_free_page>:
{
ffffffffea810c58:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea810c5c:	aa0003e1 	mov	x1, x0
ffffffffea810c60:	910003fd 	mov	x29, sp
	item->next = list->next;
ffffffffea810c64:	910043a2 	add	x2, x29, #0x10
ffffffffea810c68:	a9000822 	stp	x2, x2, [x1]
    return pmm_free(&list);
ffffffffea810c6c:	aa0203e0 	mov	x0, x2
	list->next = item;
ffffffffea810c70:	a90107a1 	stp	x1, x1, [x29, #16]
ffffffffea810c74:	97ffffbd 	bl	ffffffffea810b68 <pmm_free>
}
ffffffffea810c78:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea810c7c:	d65f03c0 	ret

ffffffffea810c80 <pmm_alloc_kpages>:
    if (count == 0)
ffffffffea810c80:	340001e0 	cbz	w0, ffffffffea810cbc <pmm_alloc_kpages+0x3c>
{
ffffffffea810c84:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea810c88:	aa0103e3 	mov	x3, x1
ffffffffea810c8c:	52800181 	mov	w1, #0xc                   	// #12
ffffffffea810c90:	910003fd 	mov	x29, sp
ffffffffea810c94:	910063a2 	add	x2, x29, #0x18
ffffffffea810c98:	97fffe14 	bl	ffffffffea8104e8 <pmm_alloc_contiguous.part.0>
    if (alloc_count == 0)
ffffffffea810c9c:	340000a0 	cbz	w0, ffffffffea810cb0 <pmm_alloc_kpages+0x30>
    return paddr_to_kvaddr(pa);
ffffffffea810ca0:	f9400fa0 	ldr	x0, [x29, #24]
ffffffffea810ca4:	94000067 	bl	ffffffffea810e40 <paddr_to_kvaddr>
}
ffffffffea810ca8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea810cac:	d65f03c0 	ret
        return NULL;
ffffffffea810cb0:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea810cb4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea810cb8:	d65f03c0 	ret
        return NULL;
ffffffffea810cbc:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea810cc0:	d65f03c0 	ret
ffffffffea810cc4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810cc8 <pmm_alloc_contiguous>:
{
ffffffffea810cc8:	12001c21 	and	w1, w1, #0xff
    if (count == 0)
ffffffffea810ccc:	34000040 	cbz	w0, ffffffffea810cd4 <pmm_alloc_contiguous+0xc>
ffffffffea810cd0:	17fffe06 	b	ffffffffea8104e8 <pmm_alloc_contiguous.part.0>
}
ffffffffea810cd4:	d65f03c0 	ret

ffffffffea810cd8 <mark_pages_in_use>:
extern int _end;

/* mark the physical pages backing a range of virtual as in use.
 * allocate the physical pages and throw them away */
static void mark_pages_in_use(vaddr_t va, size_t len)
{
ffffffffea810cd8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!

    struct list_node list;
    list_initialize(&list);

    /* make sure we are inclusive of all of the pages in the address range */
    len = PAGE_ALIGN(len + (va & (PAGE_SIZE - 1)));
ffffffffea810cdc:	913ffc21 	add	x1, x1, #0xfff
{
ffffffffea810ce0:	910003fd 	mov	x29, sp
ffffffffea810ce4:	f9000ff4 	str	x20, [sp, #24]
    len = PAGE_ALIGN(len + (va & (PAGE_SIZE - 1)));
ffffffffea810ce8:	92402c14 	and	x20, x0, #0xfff
{
ffffffffea810cec:	f90017f6 	str	x22, [sp, #40]
	list->prev = list->next = list;
ffffffffea810cf0:	910143b6 	add	x22, x29, #0x50
ffffffffea810cf4:	a9055bb6 	stp	x22, x22, [x29, #80]
    len = PAGE_ALIGN(len + (va & (PAGE_SIZE - 1)));
ffffffffea810cf8:	8b010294 	add	x20, x20, x1
    va = ROUNDDOWN(va, PAGE_SIZE);

    LTRACEF("aligned va 0x%lx, len 0x%zx\n", va, len);

    for (size_t offset = 0; offset < len; offset += PAGE_SIZE) {
ffffffffea810cfc:	f274ce94 	ands	x20, x20, #0xfffffffffffff000
ffffffffea810d00:	540002e0 	b.eq	ffffffffea810d5c <mark_pages_in_use+0x84>  // b.none
ffffffffea810d04:	f90013b5 	str	x21, [x29, #32]
ffffffffea810d08:	9274cc15 	and	x21, x0, #0xfffffffffffff000
ffffffffea810d0c:	f9001bb7 	str	x23, [x29, #48]
ffffffffea810d10:	aa1e03f7 	mov	x23, x30
ffffffffea810d14:	f9000bb3 	str	x19, [x29, #16]
ffffffffea810d18:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea810d1c:	d503201f 	nop
        uint flags;
        paddr_t pa;

        status_t err = arch_mmu_query(va + offset, &pa, &flags);
ffffffffea810d20:	910113a2 	add	x2, x29, #0x44
ffffffffea810d24:	910123a1 	add	x1, x29, #0x48
ffffffffea810d28:	8b1302a0 	add	x0, x21, x19
ffffffffea810d2c:	97ffc9f7 	bl	ffffffffea803508 <arch_mmu_query>
        if (err >= 0) {
ffffffffea810d30:	37f801e0 	tbnz	w0, #31, ffffffffea810d6c <mark_pages_in_use+0x94>
            //LTRACEF("va 0x%x, pa 0x%x, flags 0x%x, err %d\n", va + offset, pa, flags, err);

            /* alloate the range, throw the results away */
            pmm_alloc_range(pa, 1, &list);
ffffffffea810d34:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea810d38:	aa1603e2 	mov	x2, x22
ffffffffea810d3c:	52800021 	mov	w1, #0x1                   	// #1
    for (size_t offset = 0; offset < len; offset += PAGE_SIZE) {
ffffffffea810d40:	91400673 	add	x19, x19, #0x1, lsl #12
            pmm_alloc_range(pa, 1, &list);
ffffffffea810d44:	97ffff2d 	bl	ffffffffea8109f8 <pmm_alloc_range>
    for (size_t offset = 0; offset < len; offset += PAGE_SIZE) {
ffffffffea810d48:	eb13029f 	cmp	x20, x19
ffffffffea810d4c:	54fffea8 	b.hi	ffffffffea810d20 <mark_pages_in_use+0x48>  // b.pmore
ffffffffea810d50:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea810d54:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea810d58:	f9401bb7 	ldr	x23, [x29, #48]
        } else {
            panic("Could not find pa for va 0x%lx\n", va);
        }
    }
}
ffffffffea810d5c:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea810d60:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea810d64:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea810d68:	d65f03c0 	ret
            panic("Could not find pa for va 0x%lx\n", va);
ffffffffea810d6c:	f0000021 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea810d70:	aa1503e2 	mov	x2, x21
ffffffffea810d74:	9130c021 	add	x1, x1, #0xc30
ffffffffea810d78:	aa1703e0 	mov	x0, x23
ffffffffea810d7c:	940003c7 	bl	ffffffffea811c98 <_panic>

ffffffffea810d80 <vm_init_preheap>:

static void vm_init_preheap(uint level)
{
ffffffffea810d80:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    LTRACE_ENTRY;

    /* mark all of the kernel pages in use */
    LTRACEF("marking all kernel pages as used\n");
    mark_pages_in_use((vaddr_t)&_start, ((uintptr_t)&_end - (uintptr_t)&_start));
ffffffffea810d84:	90ffff80 	adrp	x0, ffffffffea800000 <_start>
ffffffffea810d88:	d0000261 	adrp	x1, ffffffffea85e000 <rb_data+0x18>
ffffffffea810d8c:	91000000 	add	x0, x0, #0x0
ffffffffea810d90:	9104a021 	add	x1, x1, #0x128
{
ffffffffea810d94:	910003fd 	mov	x29, sp
    mark_pages_in_use((vaddr_t)&_start, ((uintptr_t)&_end - (uintptr_t)&_start));
ffffffffea810d98:	cb000021 	sub	x1, x1, x0
ffffffffea810d9c:	97ffffcf 	bl	ffffffffea810cd8 <mark_pages_in_use>

    /* mark the physical pages used by the boot time allocator */
    if (boot_alloc_end != boot_alloc_start) {
ffffffffea810da0:	b0000041 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea810da4:	b0000040 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea810da8:	f9474821 	ldr	x1, [x1, #3728]
ffffffffea810dac:	f9474c00 	ldr	x0, [x0, #3736]
ffffffffea810db0:	eb00003f 	cmp	x1, x0
ffffffffea810db4:	54000080 	b.eq	ffffffffea810dc4 <vm_init_preheap+0x44>  // b.none
        LTRACEF("marking boot alloc used from 0x%lx to 0x%lx\n", boot_alloc_start, boot_alloc_end);

        mark_pages_in_use(boot_alloc_start, boot_alloc_end - boot_alloc_start);
    }
}
ffffffffea810db8:	a8c17bfd 	ldp	x29, x30, [sp], #16
        mark_pages_in_use(boot_alloc_start, boot_alloc_end - boot_alloc_start);
ffffffffea810dbc:	cb000021 	sub	x1, x1, x0
ffffffffea810dc0:	17ffffc6 	b	ffffffffea810cd8 <mark_pages_in_use>
}
ffffffffea810dc4:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea810dc8:	d65f03c0 	ret
ffffffffea810dcc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810dd0 <vm_init_postheap>:

static void vm_init_postheap(uint level)
{
ffffffffea810dd0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea810dd4:	910003fd 	mov	x29, sp
ffffffffea810dd8:	f9000bf3 	str	x19, [sp, #16]

    vmm_init();

    /* create vmm regions to cover what is already there from the initial mapping table */
    struct mmu_initial_mapping *map = mmu_initial_mappings;
    while (map->size > 0) {
ffffffffea810ddc:	b0000053 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea810de0:	91006273 	add	x19, x19, #0x18
    vmm_init();
ffffffffea810de4:	94000037 	bl	ffffffffea810ec0 <vmm_init>
    while (map->size > 0) {
ffffffffea810de8:	f9400a62 	ldr	x2, [x19, #16]
ffffffffea810dec:	b4000242 	cbz	x2, ffffffffea810e34 <vm_init_postheap+0x64>
ffffffffea810df0:	f9000fb4 	str	x20, [x29, #24]
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY)) {
            vmm_reserve_space(vmm_get_kernel_aspace(), map->name, map->size, map->virt);
ffffffffea810df4:	d0000274 	adrp	x20, ffffffffea85e000 <rb_data+0x18>
ffffffffea810df8:	91034294 	add	x20, x20, #0xd0
ffffffffea810dfc:	14000004 	b	ffffffffea810e0c <vm_init_postheap+0x3c>
        }

        map++;
ffffffffea810e00:	9100a273 	add	x19, x19, #0x28
    while (map->size > 0) {
ffffffffea810e04:	f9400a62 	ldr	x2, [x19, #16]
ffffffffea810e08:	b4000142 	cbz	x2, ffffffffea810e30 <vm_init_postheap+0x60>
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY)) {
ffffffffea810e0c:	b9401a60 	ldr	w0, [x19, #24]
ffffffffea810e10:	3707ff80 	tbnz	w0, #0, ffffffffea810e00 <vm_init_postheap+0x30>
            vmm_reserve_space(vmm_get_kernel_aspace(), map->name, map->size, map->virt);
ffffffffea810e14:	f9400663 	ldr	x3, [x19, #8]
        map++;
ffffffffea810e18:	9100a273 	add	x19, x19, #0x28
            vmm_reserve_space(vmm_get_kernel_aspace(), map->name, map->size, map->virt);
ffffffffea810e1c:	f85f8261 	ldur	x1, [x19, #-8]
ffffffffea810e20:	aa1403e0 	mov	x0, x20
ffffffffea810e24:	94000107 	bl	ffffffffea811240 <vmm_reserve_space>
    while (map->size > 0) {
ffffffffea810e28:	f9400a62 	ldr	x2, [x19, #16]
ffffffffea810e2c:	b5ffff02 	cbnz	x2, ffffffffea810e0c <vm_init_postheap+0x3c>
ffffffffea810e30:	f9400fb4 	ldr	x20, [x29, #24]
    }
}
ffffffffea810e34:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea810e38:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea810e3c:	d65f03c0 	ret

ffffffffea810e40 <paddr_to_kvaddr>:

void *paddr_to_kvaddr(paddr_t pa)
{
    /* slow path to do reverse lookup */
    struct mmu_initial_mapping *map = mmu_initial_mappings;
    while (map->size > 0) {
ffffffffea810e40:	b0000041 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea810e44:	91006021 	add	x1, x1, #0x18
ffffffffea810e48:	f9400822 	ldr	x2, [x1, #16]
ffffffffea810e4c:	b40001a2 	cbz	x2, ffffffffea810e80 <paddr_to_kvaddr+0x40>
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY) &&
ffffffffea810e50:	b9401823 	ldr	w3, [x1, #24]
ffffffffea810e54:	37000103 	tbnz	w3, #0, ffffffffea810e74 <paddr_to_kvaddr+0x34>
            pa >= map->phys &&
ffffffffea810e58:	f9400024 	ldr	x4, [x1]
            pa <= map->phys + map->size - 1) {
ffffffffea810e5c:	d1000483 	sub	x3, x4, #0x1
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY) &&
ffffffffea810e60:	eb00009f 	cmp	x4, x0
            pa <= map->phys + map->size - 1) {
ffffffffea810e64:	8b020062 	add	x2, x3, x2
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY) &&
ffffffffea810e68:	54000068 	b.hi	ffffffffea810e74 <paddr_to_kvaddr+0x34>  // b.pmore
            pa >= map->phys &&
ffffffffea810e6c:	eb00005f 	cmp	x2, x0
ffffffffea810e70:	540000c2 	b.cs	ffffffffea810e88 <paddr_to_kvaddr+0x48>  // b.hs, b.nlast
            return (void *)(map->virt + (pa - map->phys));
        }
        map++;
ffffffffea810e74:	9100a021 	add	x1, x1, #0x28
    while (map->size > 0) {
ffffffffea810e78:	f9400822 	ldr	x2, [x1, #16]
ffffffffea810e7c:	b5fffea2 	cbnz	x2, ffffffffea810e50 <paddr_to_kvaddr+0x10>
    }
    return NULL;
ffffffffea810e80:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea810e84:	d65f03c0 	ret
            return (void *)(map->virt + (pa - map->phys));
ffffffffea810e88:	f9400421 	ldr	x1, [x1, #8]
ffffffffea810e8c:	cb040024 	sub	x4, x1, x4
ffffffffea810e90:	8b000080 	add	x0, x4, x0
}
ffffffffea810e94:	d65f03c0 	ret

ffffffffea810e98 <kvaddr_to_paddr>:

paddr_t kvaddr_to_paddr(void *ptr)
{
ffffffffea810e98:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    status_t rc;
    paddr_t  pa;

    rc = arch_mmu_query((vaddr_t)ptr, &pa, NULL);
ffffffffea810e9c:	d2800002 	mov	x2, #0x0                   	// #0
{
ffffffffea810ea0:	910003fd 	mov	x29, sp
    rc = arch_mmu_query((vaddr_t)ptr, &pa, NULL);
ffffffffea810ea4:	910063a1 	add	x1, x29, #0x18
ffffffffea810ea8:	97ffc998 	bl	ffffffffea803508 <arch_mmu_query>
    if (rc)
        return (paddr_t) NULL;
    return pa;
ffffffffea810eac:	7100001f 	cmp	w0, #0x0
ffffffffea810eb0:	f9400fa1 	ldr	x1, [x29, #24]
}
ffffffffea810eb4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea810eb8:	9a9f0020 	csel	x0, x1, xzr, eq  // eq = none
ffffffffea810ebc:	d65f03c0 	ret

ffffffffea810ec0 <vmm_init>:
static mutex_t vmm_lock = MUTEX_INITIAL_VALUE(vmm_lock);

vmm_aspace_t _kernel_aspace;

void vmm_init(void)
{
ffffffffea810ec0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    /* initialize the kernel address space */
    strlcpy(_kernel_aspace.name, "kernel", sizeof(_kernel_aspace.name));
ffffffffea810ec4:	d2800402 	mov	x2, #0x20                  	// #32
ffffffffea810ec8:	f0000021 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea810ecc:	d0000260 	adrp	x0, ffffffffea85e000 <rb_data+0x18>
{
ffffffffea810ed0:	910003fd 	mov	x29, sp
    strlcpy(_kernel_aspace.name, "kernel", sizeof(_kernel_aspace.name));
ffffffffea810ed4:	9131a021 	add	x1, x1, #0xc68
ffffffffea810ed8:	91038000 	add	x0, x0, #0xe0
ffffffffea810edc:	94000a13 	bl	ffffffffea813728 <strlcpy>
	item->next = list->next;
ffffffffea810ee0:	b0000041 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea810ee4:	913ba021 	add	x1, x1, #0xee8
    _kernel_aspace.base = KERNEL_ASPACE_BASE,
ffffffffea810ee8:	d0000264 	adrp	x4, ffffffffea85e000 <rb_data+0x18>
ffffffffea810eec:	91034080 	add	x0, x4, #0xd0
ffffffffea810ef0:	b2638be6 	mov	x6, #0xffffffffe0000000    	// #-536870912
    _kernel_aspace.size = KERNEL_ASPACE_SIZE,
ffffffffea810ef4:	d2a40005 	mov	x5, #0x20000000            	// #536870912
ffffffffea810ef8:	f9400423 	ldr	x3, [x1, #8]
	list->prev = list->next = list;
ffffffffea810efc:	d0000262 	adrp	x2, ffffffffea85e000 <rb_data+0x18>
	item->next = list->next;
ffffffffea810f00:	f9000403 	str	x3, [x0, #8]
	list->prev = list->next = list;
ffffffffea810f04:	91046042 	add	x2, x2, #0x118
ffffffffea810f08:	a9039406 	stp	x6, x5, [x0, #56]
ffffffffea810f0c:	a9048802 	stp	x2, x2, [x0, #72]
	item->prev = list;
ffffffffea810f10:	f9006881 	str	x1, [x4, #208]
	list->next->prev = item;
ffffffffea810f14:	f9000060 	str	x0, [x3]
	list->next = item;
ffffffffea810f18:	f9000420 	str	x0, [x1, #8]
    list_initialize(&_kernel_aspace.region_list);

    list_add_head(&aspace_list, &_kernel_aspace.node);
}
ffffffffea810f1c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea810f20:	d65f03c0 	ret
ffffffffea810f24:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810f28 <arch_mmu_pick_spot>:
__WEAK vaddr_t arch_mmu_pick_spot(vaddr_t base, uint prev_region_arch_mmu_flags,
                                  vaddr_t end,  uint next_region_arch_mmu_flags,
                                  vaddr_t align, size_t size, uint arch_mmu_flags)
{
    /* just align it by default */
    return ALIGN(base, align);
ffffffffea810f28:	d1000400 	sub	x0, x0, #0x1
ffffffffea810f2c:	8b040000 	add	x0, x0, x4
ffffffffea810f30:	cb0403e4 	neg	x4, x4
}
ffffffffea810f34:	8a040000 	and	x0, x0, x4
ffffffffea810f38:	d65f03c0 	ret
ffffffffea810f3c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810f40 <alloc_region>:

/* allocate a region structure and stick it in the address space */
static vmm_region_t *alloc_region(vmm_aspace_t *aspace, const char *name, size_t size,
        vaddr_t vaddr, uint8_t align_pow2,
        uint vmm_flags, uint region_flags, uint arch_mmu_flags)
{
ffffffffea810f40:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea810f44:	910003fd 	mov	x29, sp
ffffffffea810f48:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea810f4c:	aa0303f4 	mov	x20, x3
ffffffffea810f50:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea810f54:	aa0203f6 	mov	x22, x2
ffffffffea810f58:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea810f5c:	2a0503f5 	mov	w21, w5
ffffffffea810f60:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea810f64:	aa0003f7 	mov	x23, x0
ffffffffea810f68:	f9002bfb 	str	x27, [sp, #80]
ffffffffea810f6c:	12001c99 	and	w25, w4, #0xff
ffffffffea810f70:	2a0603fa 	mov	w26, w6
ffffffffea810f74:	2a0703f8 	mov	w24, w7
    vmm_region_t *r = malloc(sizeof(vmm_region_t));
ffffffffea810f78:	d2800b00 	mov	x0, #0x58                  	// #88
{
ffffffffea810f7c:	aa0103fb 	mov	x27, x1
    vmm_region_t *r = malloc(sizeof(vmm_region_t));
ffffffffea810f80:	940008d4 	bl	ffffffffea8132d0 <malloc>
ffffffffea810f84:	aa0003f3 	mov	x19, x0
    if (!r)
ffffffffea810f88:	b40006e0 	cbz	x0, ffffffffea811064 <alloc_region+0x124>
    strlcpy(r->name, name, sizeof(r->name));
ffffffffea810f8c:	d2800402 	mov	x2, #0x20                  	// #32
ffffffffea810f90:	aa1b03e1 	mov	x1, x27
ffffffffea810f94:	91004000 	add	x0, x0, #0x10
ffffffffea810f98:	940009e4 	bl	ffffffffea813728 <strlcpy>
    list_initialize(&r->page_list);
ffffffffea810f9c:	91012260 	add	x0, x19, #0x48
    r->arch_mmu_flags = arch_mmu_flags;
ffffffffea810fa0:	2906627a 	stp	w26, w24, [x19, #48]
    r->size = size;
ffffffffea810fa4:	a903da74 	stp	x20, x22, [x19, #56]
	list->prev = list->next = list;
ffffffffea810fa8:	a9048260 	stp	x0, x0, [x19, #72]
    vmm_region_t *r = alloc_region_struct(name, vaddr, size, region_flags, arch_mmu_flags);
    if (!r)
        return NULL;

    /* if they ask us for a specific spot, put it there */
    if (vmm_flags & VMM_FLAG_VALLOC_SPECIFIC) {
ffffffffea810fac:	360006d5 	tbz	w21, #0, ffffffffea811084 <alloc_region+0x144>
    if (r->size == 0 || !is_region_inside_aspace(aspace, r->base, r->size)) {
ffffffffea810fb0:	b4000556 	cbz	x22, ffffffffea811058 <alloc_region+0x118>
    if (!is_inside_aspace(aspace, vaddr))
ffffffffea810fb4:	f9401ee0 	ldr	x0, [x23, #56]
    return (vaddr >= aspace->base && vaddr <= aspace->base + aspace->size - 1);
ffffffffea810fb8:	eb00029f 	cmp	x20, x0
ffffffffea810fbc:	540004e3 	b.cc	ffffffffea811058 <alloc_region+0x118>  // b.lo, b.ul, b.last
ffffffffea810fc0:	f94022e1 	ldr	x1, [x23, #64]
ffffffffea810fc4:	8b010000 	add	x0, x0, x1
ffffffffea810fc8:	d1000400 	sub	x0, x0, #0x1
ffffffffea810fcc:	eb00029f 	cmp	x20, x0
ffffffffea810fd0:	54000448 	b.hi	ffffffffea811058 <alloc_region+0x118>  // b.pmore
    if (vaddr + size - 1 < vaddr)
ffffffffea810fd4:	d10006d6 	sub	x22, x22, #0x1
ffffffffea810fd8:	8b1402d6 	add	x22, x22, x20
ffffffffea810fdc:	eb16029f 	cmp	x20, x22
ffffffffea810fe0:	540003c8 	b.hi	ffffffffea811058 <alloc_region+0x118>  // b.pmore
    if (vaddr + size - 1 > aspace->base + aspace->size - 1)
ffffffffea810fe4:	eb16001f 	cmp	x0, x22
ffffffffea810fe8:	54000383 	b.cc	ffffffffea811058 <alloc_region+0x118>  // b.lo, b.ul, b.last
	if (list->next != list) {
ffffffffea810fec:	f9402ae0 	ldr	x0, [x23, #80]
    last = list_peek_head_type(&aspace->region_list, vmm_region_t, node);
ffffffffea810ff0:	910122e2 	add	x2, x23, #0x48
ffffffffea810ff4:	f100001f 	cmp	x0, #0x0
ffffffffea810ff8:	fa401044 	ccmp	x2, x0, #0x4, ne  // ne = any
ffffffffea810ffc:	54001000 	b.eq	ffffffffea8111fc <alloc_region+0x2bc>  // b.none
    if (!last || r_end < last->base) {
ffffffffea811000:	f9401c03 	ldr	x3, [x0, #56]
ffffffffea811004:	eb16007f 	cmp	x3, x22
ffffffffea811008:	54000fa8 	b.hi	ffffffffea8111fc <alloc_region+0x2bc>  // b.pmore
    list_for_every_entry(&aspace->region_list, last, vmm_region_t, node) {
ffffffffea81100c:	eb00005f 	cmp	x2, x0
ffffffffea811010:	54000061 	b.ne	ffffffffea81101c <alloc_region+0xdc>  // b.any
ffffffffea811014:	14000011 	b	ffffffffea811058 <alloc_region+0x118>
ffffffffea811018:	f9401c03 	ldr	x3, [x0, #56]
        if (r->base > last->base + last->size - 1) {
ffffffffea81101c:	f9402001 	ldr	x1, [x0, #64]
ffffffffea811020:	d1000421 	sub	x1, x1, #0x1
ffffffffea811024:	8b030021 	add	x1, x1, x3
ffffffffea811028:	eb01029f 	cmp	x20, x1
ffffffffea81102c:	54000109 	b.ls	ffffffffea81104c <alloc_region+0x10c>  // b.plast
ffffffffea811030:	f9400401 	ldr	x1, [x0, #8]
	if (item->next != list)
ffffffffea811034:	eb01005f 	cmp	x2, x1
ffffffffea811038:	54000f80 	b.eq	ffffffffea811228 <alloc_region+0x2e8>  // b.none
            vmm_region_t *next = list_next_type(&aspace->region_list, &last->node, vmm_region_t, node);
ffffffffea81103c:	b4000f61 	cbz	x1, ffffffffea811228 <alloc_region+0x2e8>
            if (!next || (r_end < next->base)) {
ffffffffea811040:	f9401c23 	ldr	x3, [x1, #56]
ffffffffea811044:	eb16007f 	cmp	x3, x22
ffffffffea811048:	54000f08 	b.hi	ffffffffea811228 <alloc_region+0x2e8>  // b.pmore
    list_for_every_entry(&aspace->region_list, last, vmm_region_t, node) {
ffffffffea81104c:	f9400400 	ldr	x0, [x0, #8]
ffffffffea811050:	eb00005f 	cmp	x2, x0
ffffffffea811054:	54fffe21 	b.ne	ffffffffea811018 <alloc_region+0xd8>  // b.any
        vaddr = alloc_spot(aspace, size, align_pow2, arch_mmu_flags, &before);
        LTRACEF("alloc_spot returns 0x%lx, before %p\n", vaddr, before);

        if (vaddr == (vaddr_t)-1) {
            LTRACEF("failed to find spot\n");
            free(r);
ffffffffea811058:	aa1303e0 	mov	x0, x19
            return NULL;
ffffffffea81105c:	d2800013 	mov	x19, #0x0                   	// #0
            free(r);
ffffffffea811060:	940008b2 	bl	ffffffffea813328 <free>
        /* add it to the region list */
        list_add_after(before, &r->node);
    }

    return r;
}
ffffffffea811064:	aa1303e0 	mov	x0, x19
ffffffffea811068:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea81106c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811070:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea811074:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea811078:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea81107c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea811080:	d65f03c0 	ret
    vaddr_t align = 1UL << align_pow2;
ffffffffea811084:	7100333f 	cmp	w25, #0xc
	if (list->next != list) {
ffffffffea811088:	f9402af4 	ldr	x20, [x23, #80]
ffffffffea81108c:	52800180 	mov	w0, #0xc                   	// #12
ffffffffea811090:	1a802339 	csel	w25, w25, w0, cs  // cs = hs, nlast
                  list_peek_head_type(&aspace->region_list, vmm_region_t, node),
ffffffffea811094:	910122fb 	add	x27, x23, #0x48
    vaddr_t align = 1UL << align_pow2;
ffffffffea811098:	d2800020 	mov	x0, #0x1                   	// #1
                  list_peek_head_type(&aspace->region_list, vmm_region_t, node),
ffffffffea81109c:	f100029f 	cmp	x20, #0x0
    vaddr_t align = 1UL << align_pow2;
ffffffffea8110a0:	9ad92019 	lsl	x25, x0, x25
ffffffffea8110a4:	f9401efa 	ldr	x26, [x23, #56]
                  list_peek_head_type(&aspace->region_list, vmm_region_t, node),
ffffffffea8110a8:	fa541364 	ccmp	x27, x20, #0x4, ne  // ne = any
ffffffffea8110ac:	54000101 	b.ne	ffffffffea8110cc <alloc_region+0x18c>  // b.any
        if (gap_beg == (aspace->base + aspace->size))
ffffffffea8110b0:	f94022f5 	ldr	x21, [x23, #64]
ffffffffea8110b4:	8b150355 	add	x21, x26, x21
ffffffffea8110b8:	eb15035f 	cmp	x26, x21
ffffffffea8110bc:	54fffce0 	b.eq	ffffffffea811058 <alloc_region+0x118>  // b.none
        gap_end = aspace->base + aspace->size - 1;
ffffffffea8110c0:	d10006b5 	sub	x21, x21, #0x1
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea8110c4:	52801003 	mov	w3, #0x80                  	// #128
ffffffffea8110c8:	14000006 	b	ffffffffea8110e0 <alloc_region+0x1a0>
        if (gap_beg == next->base)
ffffffffea8110cc:	f9401e95 	ldr	x21, [x20, #56]
ffffffffea8110d0:	eb1a02bf 	cmp	x21, x26
ffffffffea8110d4:	54000260 	b.eq	ffffffffea811120 <alloc_region+0x1e0>  // b.none
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea8110d8:	b9403683 	ldr	w3, [x20, #52]
        gap_end = next->base - 1;
ffffffffea8110dc:	d10006b5 	sub	x21, x21, #0x1
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea8110e0:	2a1803e6 	mov	w6, w24
ffffffffea8110e4:	aa1603e5 	mov	x5, x22
ffffffffea8110e8:	aa1903e4 	mov	x4, x25
ffffffffea8110ec:	aa1503e2 	mov	x2, x21
ffffffffea8110f0:	52801001 	mov	w1, #0x80                  	// #128
ffffffffea8110f4:	aa1a03e0 	mov	x0, x26
ffffffffea8110f8:	97ffff8c 	bl	ffffffffea810f28 <arch_mmu_pick_spot>
    if (*pva < gap_beg)
ffffffffea8110fc:	eb00035f 	cmp	x26, x0
ffffffffea811100:	54fffac8 	b.hi	ffffffffea811058 <alloc_region+0x118>  // b.pmore
    if (*pva < gap_end && ((gap_end - *pva + 1) >= size)) {
ffffffffea811104:	eb15001f 	cmp	x0, x21
ffffffffea811108:	540000a2 	b.cs	ffffffffea81111c <alloc_region+0x1dc>  // b.hs, b.nlast
ffffffffea81110c:	910006b5 	add	x21, x21, #0x1
ffffffffea811110:	cb0002b5 	sub	x21, x21, x0
ffffffffea811114:	eb1502df 	cmp	x22, x21
ffffffffea811118:	540003e9 	b.ls	ffffffffea811194 <alloc_region+0x254>  // b.plast
ffffffffea81111c:	f9402af4 	ldr	x20, [x23, #80]
    list_for_every_entry(&aspace->region_list, r, vmm_region_t, node) {
ffffffffea811120:	eb14037f 	cmp	x27, x20
ffffffffea811124:	54fff9a0 	b.eq	ffffffffea811058 <alloc_region+0x118>  // b.none
                      list_next_type(&aspace->region_list, &r->node, vmm_region_t, node),
ffffffffea811128:	f9400680 	ldr	x0, [x20, #8]
ffffffffea81112c:	a943ea81 	ldp	x1, x26, [x20, #56]
ffffffffea811130:	f100001f 	cmp	x0, #0x0
ffffffffea811134:	fa401364 	ccmp	x27, x0, #0x4, ne  // ne = any
ffffffffea811138:	8b01035a 	add	x26, x26, x1
ffffffffea81113c:	54000500 	b.eq	ffffffffea8111dc <alloc_region+0x29c>  // b.none
        if (gap_beg == next->base)
ffffffffea811140:	f9401c02 	ldr	x2, [x0, #56]
ffffffffea811144:	eb02035f 	cmp	x26, x2
ffffffffea811148:	54000460 	b.eq	ffffffffea8111d4 <alloc_region+0x294>  // b.none
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea81114c:	b9403403 	ldr	w3, [x0, #52]
        gap_end = next->base - 1;
ffffffffea811150:	d1000455 	sub	x21, x2, #0x1
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea811154:	b9403681 	ldr	w1, [x20, #52]
ffffffffea811158:	2a1803e6 	mov	w6, w24
ffffffffea81115c:	aa1603e5 	mov	x5, x22
ffffffffea811160:	aa1903e4 	mov	x4, x25
ffffffffea811164:	aa1503e2 	mov	x2, x21
ffffffffea811168:	aa1a03e0 	mov	x0, x26
ffffffffea81116c:	97ffff6f 	bl	ffffffffea810f28 <arch_mmu_pick_spot>
    if (*pva < gap_beg)
ffffffffea811170:	eb00035f 	cmp	x26, x0
ffffffffea811174:	54fff728 	b.hi	ffffffffea811058 <alloc_region+0x118>  // b.pmore
    if (*pva < gap_end && ((gap_end - *pva + 1) >= size)) {
ffffffffea811178:	eb15001f 	cmp	x0, x21
ffffffffea81117c:	54000282 	b.cs	ffffffffea8111cc <alloc_region+0x28c>  // b.hs, b.nlast
ffffffffea811180:	910006a2 	add	x2, x21, #0x1
ffffffffea811184:	cb000042 	sub	x2, x2, x0
ffffffffea811188:	eb0202df 	cmp	x22, x2
ffffffffea81118c:	54000208 	b.hi	ffffffffea8111cc <alloc_region+0x28c>  // b.pmore
        *before = r ? &r->node : &aspace->region_list;
ffffffffea811190:	aa1403fb 	mov	x27, x20
	item->next = list->next;
ffffffffea811194:	f9400761 	ldr	x1, [x27, #8]
ffffffffea811198:	a900067b 	stp	x27, x1, [x19]
        r->base = (vaddr_t)vaddr;
ffffffffea81119c:	f9001e60 	str	x0, [x19, #56]
	list->next->prev = item;
ffffffffea8111a0:	f9400760 	ldr	x0, [x27, #8]
}
ffffffffea8111a4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8111a8:	f9000013 	str	x19, [x0]
ffffffffea8111ac:	aa1303e0 	mov	x0, x19
	list->next = item;
ffffffffea8111b0:	f9000773 	str	x19, [x27, #8]
ffffffffea8111b4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8111b8:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8111bc:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea8111c0:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea8111c4:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8111c8:	d65f03c0 	ret
ffffffffea8111cc:	f9400694 	ldr	x20, [x20, #8]
ffffffffea8111d0:	17ffffd4 	b	ffffffffea811120 <alloc_region+0x1e0>
        if (gap_beg == next->base)
ffffffffea8111d4:	aa0003f4 	mov	x20, x0
ffffffffea8111d8:	17ffffd2 	b	ffffffffea811120 <alloc_region+0x1e0>
        if (gap_beg == (aspace->base + aspace->size))
ffffffffea8111dc:	a9438af5 	ldp	x21, x2, [x23, #56]
ffffffffea8111e0:	8b150042 	add	x2, x2, x21
ffffffffea8111e4:	eb1a005f 	cmp	x2, x26
ffffffffea8111e8:	54fff380 	b.eq	ffffffffea811058 <alloc_region+0x118>  // b.none
        gap_end = aspace->base + aspace->size - 1;
ffffffffea8111ec:	d1000455 	sub	x21, x2, #0x1
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea8111f0:	52801003 	mov	w3, #0x80                  	// #128
ffffffffea8111f4:	b9403681 	ldr	w1, [x20, #52]
ffffffffea8111f8:	17ffffd8 	b	ffffffffea811158 <alloc_region+0x218>
	item->next = list->next;
ffffffffea8111fc:	a9000262 	stp	x2, x0, [x19]
	list->next->prev = item;
ffffffffea811200:	f9000013 	str	x19, [x0]
}
ffffffffea811204:	aa1303e0 	mov	x0, x19
	list->next = item;
ffffffffea811208:	f9002af3 	str	x19, [x23, #80]
ffffffffea81120c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811210:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea811214:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea811218:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea81121c:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea811220:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea811224:	d65f03c0 	ret
	item->next = list->next;
ffffffffea811228:	a9000660 	stp	x0, x1, [x19]
	list->next->prev = item;
ffffffffea81122c:	f9400401 	ldr	x1, [x0, #8]
ffffffffea811230:	f9000033 	str	x19, [x1]
	list->next = item;
ffffffffea811234:	f9000413 	str	x19, [x0, #8]
ffffffffea811238:	17ffff8b 	b	ffffffffea811064 <alloc_region+0x124>
ffffffffea81123c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811240 <vmm_reserve_space>:

status_t vmm_reserve_space(vmm_aspace_t *aspace, const char *name, size_t size, vaddr_t vaddr)
{
ffffffffea811240:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea811244:	910003fd 	mov	x29, sp
ffffffffea811248:	f9000ff4 	str	x20, [sp, #24]
ffffffffea81124c:	aa0103f4 	mov	x20, x1
    DEBUG_ASSERT(aspace);
    DEBUG_ASSERT(IS_PAGE_ALIGNED(vaddr));
    DEBUG_ASSERT(IS_PAGE_ALIGNED(size));

    if (!name)
        name = "";
ffffffffea811250:	f100029f 	cmp	x20, #0x0
ffffffffea811254:	90000021 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea811258:	911ce021 	add	x1, x1, #0x738
ffffffffea81125c:	9a940034 	csel	x20, x1, x20, eq  // eq = none

    if (!aspace)
        return ERR_INVALID_ARGS;
    if (size == 0)
ffffffffea811260:	b4000702 	cbz	x2, ffffffffea811340 <vmm_reserve_space+0x100>
ffffffffea811264:	f9000bb3 	str	x19, [x29, #16]
ffffffffea811268:	aa0203f3 	mov	x19, x2
ffffffffea81126c:	f90013b5 	str	x21, [x29, #32]
ffffffffea811270:	aa0303f5 	mov	x21, x3
ffffffffea811274:	f9001bb7 	str	x23, [x29, #48]
ffffffffea811278:	aa0003f7 	mov	x23, x0
        return NO_ERROR;
    if (!IS_PAGE_ALIGNED(vaddr) || !IS_PAGE_ALIGNED(size))
ffffffffea81127c:	aa030040 	orr	x0, x2, x3
ffffffffea811280:	f2402c1f 	tst	x0, #0xfff
ffffffffea811284:	54000801 	b.ne	ffffffffea811384 <vmm_reserve_space+0x144>  // b.any
        return ERR_INVALID_ARGS;

    if (!is_inside_aspace(aspace, vaddr))
ffffffffea811288:	f9401ee1 	ldr	x1, [x23, #56]
        return ERR_OUT_OF_RANGE;
ffffffffea81128c:	12800480 	mov	w0, #0xffffffdb            	// #-37
    return (vaddr >= aspace->base && vaddr <= aspace->base + aspace->size - 1);
ffffffffea811290:	eb01007f 	cmp	x3, x1
ffffffffea811294:	540005e3 	b.cc	ffffffffea811350 <vmm_reserve_space+0x110>  // b.lo, b.ul, b.last
ffffffffea811298:	f94022e2 	ldr	x2, [x23, #64]
ffffffffea81129c:	f90017b6 	str	x22, [x29, #40]
ffffffffea8112a0:	8b010043 	add	x3, x2, x1
ffffffffea8112a4:	d1000463 	sub	x3, x3, #0x1
ffffffffea8112a8:	eb0302bf 	cmp	x21, x3
ffffffffea8112ac:	54000608 	b.hi	ffffffffea81136c <vmm_reserve_space+0x12c>  // b.pmore
    size_t offset = vaddr - aspace->base;
ffffffffea8112b0:	cb0102a0 	sub	x0, x21, x1
    if (offset + size < offset)
ffffffffea8112b4:	8b000261 	add	x1, x19, x0
ffffffffea8112b8:	eb01001f 	cmp	x0, x1
ffffffffea8112bc:	54000069 	b.ls	ffffffffea8112c8 <vmm_reserve_space+0x88>  // b.plast
        size = ULONG_MAX - offset - 1;
ffffffffea8112c0:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
ffffffffea8112c4:	cb000033 	sub	x19, x1, x0
    if (offset + size >= aspace->size - 1)
ffffffffea8112c8:	d1000443 	sub	x3, x2, #0x1
        size = aspace->size - offset;
ffffffffea8112cc:	cb000040 	sub	x0, x2, x0
ffffffffea8112d0:	eb03003f 	cmp	x1, x3
ffffffffea8112d4:	90000056 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea8112d8:	913be2d6 	add	x22, x22, #0xef8
ffffffffea8112dc:	9a932013 	csel	x19, x0, x19, cs  // cs = hs, nlast
ffffffffea8112e0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8112e4:	aa1603e0 	mov	x0, x22
ffffffffea8112e8:	97ffd1b4 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
    size = trim_to_aspace(aspace, vaddr, size);

    mutex_acquire(&vmm_lock);

    /* lookup how it's already mapped */
    uint arch_mmu_flags = 0;
ffffffffea8112ec:	910143a2 	add	x2, x29, #0x50
    arch_mmu_query(vaddr, NULL, &arch_mmu_flags);
ffffffffea8112f0:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8112f4:	aa1503e0 	mov	x0, x21
    uint arch_mmu_flags = 0;
ffffffffea8112f8:	b81fcc5f 	str	wzr, [x2, #-4]!
    arch_mmu_query(vaddr, NULL, &arch_mmu_flags);
ffffffffea8112fc:	97ffc883 	bl	ffffffffea803508 <arch_mmu_query>

    /* build a new region structure */
    vmm_region_t *r = alloc_region(aspace, name, size, vaddr, 0, VMM_FLAG_VALLOC_SPECIFIC, VMM_REGION_FLAG_RESERVED, arch_mmu_flags);
ffffffffea811300:	b9404fa7 	ldr	w7, [x29, #76]
ffffffffea811304:	52800026 	mov	w6, #0x1                   	// #1
ffffffffea811308:	aa1303e2 	mov	x2, x19
ffffffffea81130c:	aa1503e3 	mov	x3, x21
ffffffffea811310:	2a0603e5 	mov	w5, w6
ffffffffea811314:	aa1403e1 	mov	x1, x20
ffffffffea811318:	52800004 	mov	w4, #0x0                   	// #0
ffffffffea81131c:	aa1703e0 	mov	x0, x23
ffffffffea811320:	97ffff08 	bl	ffffffffea810f40 <alloc_region>
ffffffffea811324:	aa0003f3 	mov	x19, x0

    mutex_release(&vmm_lock);
ffffffffea811328:	aa1603e0 	mov	x0, x22
ffffffffea81132c:	97ffd1cf 	bl	ffffffffea805a68 <mutex_release>
    return r ? NO_ERROR : ERR_NO_MEMORY;
ffffffffea811330:	b40001d3 	cbz	x19, ffffffffea811368 <vmm_reserve_space+0x128>
ffffffffea811334:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea811338:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea81133c:	f9401bb7 	ldr	x23, [x29, #48]
        return NO_ERROR;
ffffffffea811340:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea811344:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea811348:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea81134c:	d65f03c0 	ret
ffffffffea811350:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea811354:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea811358:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea81135c:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea811360:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea811364:	d65f03c0 	ret
    return r ? NO_ERROR : ERR_NO_MEMORY;
ffffffffea811368:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea81136c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea811370:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea811374:	f9401bb7 	ldr	x23, [x29, #48]
}
ffffffffea811378:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea81137c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea811380:	d65f03c0 	ret
        return ERR_INVALID_ARGS;
ffffffffea811384:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea811388:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea81138c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea811390:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea811394:	17ffffec 	b	ffffffffea811344 <vmm_reserve_space+0x104>

ffffffffea811398 <vmm_alloc_physical>:

status_t vmm_alloc_physical(vmm_aspace_t *aspace, const char *name, size_t size, void **ptr, uint8_t align_log2, paddr_t paddr, uint vmm_flags, uint arch_mmu_flags)
{
ffffffffea811398:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea81139c:	910003fd 	mov	x29, sp
ffffffffea8113a0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea8113a4:	aa0103f3 	mov	x19, x1
    DEBUG_ASSERT(aspace);
    DEBUG_ASSERT(IS_PAGE_ALIGNED(paddr));
    DEBUG_ASSERT(IS_PAGE_ALIGNED(size));

    if (!name)
        name = "";
ffffffffea8113a8:	f100027f 	cmp	x19, #0x0
ffffffffea8113ac:	90000021 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8113b0:	911ce021 	add	x1, x1, #0x738
ffffffffea8113b4:	9a930033 	csel	x19, x1, x19, eq  // eq = none

    if (!aspace)
        return ERR_INVALID_ARGS;
    if (size == 0)
ffffffffea8113b8:	b40006a2 	cbz	x2, ffffffffea81148c <vmm_alloc_physical+0xf4>
ffffffffea8113bc:	f9000fb4 	str	x20, [x29, #24]
ffffffffea8113c0:	aa0203f4 	mov	x20, x2
ffffffffea8113c4:	f9001bb7 	str	x23, [x29, #48]
ffffffffea8113c8:	aa0503f7 	mov	x23, x5
ffffffffea8113cc:	f90027ba 	str	x26, [x29, #72]
ffffffffea8113d0:	aa0003fa 	mov	x26, x0
        return NO_ERROR;
    if (!IS_PAGE_ALIGNED(paddr) || !IS_PAGE_ALIGNED(size))
ffffffffea8113d4:	aa050040 	orr	x0, x2, x5
ffffffffea8113d8:	f2402c1f 	tst	x0, #0xfff
ffffffffea8113dc:	540008a1 	b.ne	ffffffffea8114f0 <vmm_alloc_physical+0x158>  // b.any
ffffffffea8113e0:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8113e4:	aa0303f5 	mov	x21, x3
ffffffffea8113e8:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea8113ec:	2a0603f6 	mov	w22, w6
ffffffffea8113f0:	f9002bbb 	str	x27, [x29, #80]
ffffffffea8113f4:	2a0703f8 	mov	w24, w7
ffffffffea8113f8:	12001c9b 	and	w27, w4, #0xff
        return ERR_INVALID_ARGS;

    /* if they're asking for a specific spot, copy the address */
    if (vmm_flags & VMM_FLAG_VALLOC_SPECIFIC) {
ffffffffea8113fc:	36000536 	tbz	w22, #0, ffffffffea8114a0 <vmm_alloc_physical+0x108>
        /* can't ask for a specific spot and then not provide one */
        if (!ptr) {
ffffffffea811400:	b4000823 	cbz	x3, ffffffffea811504 <vmm_alloc_physical+0x16c>
ffffffffea811404:	f9002fbc 	str	x28, [x29, #88]
ffffffffea811408:	12800001 	mov	w1, #0xffffffff            	// #-1
            return ERR_INVALID_ARGS;
        }
        vaddr = (vaddr_t)*ptr;
ffffffffea81140c:	f940007c 	ldr	x28, [x3]
ffffffffea811410:	90000059 	adrp	x25, ffffffffea819000 <_mem_phys_base>
ffffffffea811414:	913be320 	add	x0, x25, #0xef8
ffffffffea811418:	97ffd168 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
    }

    mutex_acquire(&vmm_lock);

    /* allocate a region and put it in the aspace list */
    r = alloc_region(aspace, name, size, vaddr, align_log2, vmm_flags, VMM_REGION_FLAG_PHYSICAL, arch_mmu_flags);
ffffffffea81141c:	2a1803e7 	mov	w7, w24
ffffffffea811420:	52800046 	mov	w6, #0x2                   	// #2
ffffffffea811424:	2a1603e5 	mov	w5, w22
ffffffffea811428:	2a1b03e4 	mov	w4, w27
ffffffffea81142c:	aa1c03e3 	mov	x3, x28
ffffffffea811430:	aa1403e2 	mov	x2, x20
ffffffffea811434:	aa1303e1 	mov	x1, x19
ffffffffea811438:	aa1a03e0 	mov	x0, x26
ffffffffea81143c:	97fffec1 	bl	ffffffffea810f40 <alloc_region>
    if (!r) {
ffffffffea811440:	b4000520 	cbz	x0, ffffffffea8114e4 <vmm_alloc_physical+0x14c>
ffffffffea811444:	f9401c00 	ldr	x0, [x0, #56]
ffffffffea811448:	f9402fbc 	ldr	x28, [x29, #88]
        goto err_alloc_region;
    }

    /* return the vaddr if requested */
    if (ptr)
        *ptr = (void *)r->base;
ffffffffea81144c:	f90002a0 	str	x0, [x21]

    /* map all of the pages */
    err = arch_mmu_map(r->base, paddr, size / PAGE_SIZE, arch_mmu_flags);
    LTRACEF("arch_mmu_map returns %d\n", err);

    ret = NO_ERROR;
ffffffffea811450:	52800013 	mov	w19, #0x0                   	// #0
    err = arch_mmu_map(r->base, paddr, size / PAGE_SIZE, arch_mmu_flags);
ffffffffea811454:	2a1803e3 	mov	w3, w24
ffffffffea811458:	d34cae82 	ubfx	x2, x20, #12, #32
ffffffffea81145c:	aa1703e1 	mov	x1, x23
ffffffffea811460:	97ffc9b4 	bl	ffffffffea803b30 <arch_mmu_map>

err_alloc_region:
    mutex_release(&vmm_lock);
ffffffffea811464:	913be320 	add	x0, x25, #0xef8
ffffffffea811468:	97ffd180 	bl	ffffffffea805a68 <mutex_release>
    return ret;
ffffffffea81146c:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea811470:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea811474:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea811478:	a944efba 	ldp	x26, x27, [x29, #72]
}
ffffffffea81147c:	2a1303e0 	mov	w0, w19
ffffffffea811480:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea811484:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea811488:	d65f03c0 	ret
        return NO_ERROR;
ffffffffea81148c:	52800013 	mov	w19, #0x0                   	// #0
}
ffffffffea811490:	2a1303e0 	mov	w0, w19
ffffffffea811494:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea811498:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea81149c:	d65f03c0 	ret
ffffffffea8114a0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8114a4:	90000059 	adrp	x25, ffffffffea819000 <_mem_phys_base>
ffffffffea8114a8:	913be320 	add	x0, x25, #0xef8
ffffffffea8114ac:	97ffd143 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
    r = alloc_region(aspace, name, size, vaddr, align_log2, vmm_flags, VMM_REGION_FLAG_PHYSICAL, arch_mmu_flags);
ffffffffea8114b0:	2a1803e7 	mov	w7, w24
ffffffffea8114b4:	52800046 	mov	w6, #0x2                   	// #2
ffffffffea8114b8:	2a1603e5 	mov	w5, w22
ffffffffea8114bc:	2a1b03e4 	mov	w4, w27
ffffffffea8114c0:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea8114c4:	aa1403e2 	mov	x2, x20
ffffffffea8114c8:	aa1303e1 	mov	x1, x19
ffffffffea8114cc:	aa1a03e0 	mov	x0, x26
ffffffffea8114d0:	97fffe9c 	bl	ffffffffea810f40 <alloc_region>
    if (!r) {
ffffffffea8114d4:	b40000a0 	cbz	x0, ffffffffea8114e8 <vmm_alloc_physical+0x150>
ffffffffea8114d8:	f9401c00 	ldr	x0, [x0, #56]
    if (ptr)
ffffffffea8114dc:	b4fffbb5 	cbz	x21, ffffffffea811450 <vmm_alloc_physical+0xb8>
ffffffffea8114e0:	17ffffdb 	b	ffffffffea81144c <vmm_alloc_physical+0xb4>
ffffffffea8114e4:	f9402fbc 	ldr	x28, [x29, #88]
        ret = ERR_NO_MEMORY;
ffffffffea8114e8:	12800093 	mov	w19, #0xfffffffb            	// #-5
ffffffffea8114ec:	17ffffde 	b	ffffffffea811464 <vmm_alloc_physical+0xcc>
        return ERR_INVALID_ARGS;
ffffffffea8114f0:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea8114f4:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea8114f8:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea8114fc:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea811500:	17ffffdf 	b	ffffffffea81147c <vmm_alloc_physical+0xe4>
ffffffffea811504:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea811508:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea81150c:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea811510:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea811514:	a944efba 	ldp	x26, x27, [x29, #72]
ffffffffea811518:	17ffffd9 	b	ffffffffea81147c <vmm_alloc_physical+0xe4>
ffffffffea81151c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811520 <vmm_free_region>:

    return NULL;
}

status_t vmm_free_region(vmm_aspace_t *aspace, vaddr_t vaddr)
{
ffffffffea811520:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811524:	910003fd 	mov	x29, sp
ffffffffea811528:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea81152c:	aa0003f4 	mov	x20, x0
ffffffffea811530:	f90017f6 	str	x22, [sp, #40]
ffffffffea811534:	aa0103f5 	mov	x21, x1
ffffffffea811538:	90000056 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea81153c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea811540:	913be2c0 	add	x0, x22, #0xef8
ffffffffea811544:	97ffd11d 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
    if (!aspace)
ffffffffea811548:	b4000254 	cbz	x20, ffffffffea811590 <vmm_free_region+0x70>
ffffffffea81154c:	f9000bb3 	str	x19, [x29, #16]
    list_for_every_entry(&aspace->region_list, r, vmm_region_t, node) {
ffffffffea811550:	91012283 	add	x3, x20, #0x48
ffffffffea811554:	f9402a93 	ldr	x19, [x20, #80]
ffffffffea811558:	eb13007f 	cmp	x3, x19
ffffffffea81155c:	54000180 	b.eq	ffffffffea81158c <vmm_free_region+0x6c>  // b.none
        if ((vaddr >= r->base) && (vaddr <= r->base + r->size - 1))
ffffffffea811560:	f9401e60 	ldr	x0, [x19, #56]
ffffffffea811564:	eb0002bf 	cmp	x21, x0
ffffffffea811568:	540000c3 	b.cc	ffffffffea811580 <vmm_free_region+0x60>  // b.lo, b.ul, b.last
ffffffffea81156c:	f9402261 	ldr	x1, [x19, #64]
ffffffffea811570:	8b010002 	add	x2, x0, x1
ffffffffea811574:	d1000442 	sub	x2, x2, #0x1
ffffffffea811578:	eb0202bf 	cmp	x21, x2
ffffffffea81157c:	54000189 	b.ls	ffffffffea8115ac <vmm_free_region+0x8c>  // b.plast
    list_for_every_entry(&aspace->region_list, r, vmm_region_t, node) {
ffffffffea811580:	f9400673 	ldr	x19, [x19, #8]
ffffffffea811584:	eb03027f 	cmp	x19, x3
ffffffffea811588:	54fffec1 	b.ne	ffffffffea811560 <vmm_free_region+0x40>  // b.any
ffffffffea81158c:	f9400bb3 	ldr	x19, [x29, #16]
    mutex_acquire(&vmm_lock);

    vmm_region_t *r = vmm_find_region (aspace, vaddr);
    if (!r) {
        mutex_release(&vmm_lock);
ffffffffea811590:	913be2c0 	add	x0, x22, #0xef8
ffffffffea811594:	97ffd135 	bl	ffffffffea805a68 <mutex_release>
        return ERR_NOT_FOUND;
ffffffffea811598:	12800020 	mov	w0, #0xfffffffe            	// #-2

    /* free it */
    free (r);

    return NO_ERROR;
}
ffffffffea81159c:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea8115a0:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8115a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8115a8:	d65f03c0 	ret
	item->next->prev = item->prev;
ffffffffea8115ac:	a9400a63 	ldp	x3, x2, [x19]
	item->prev = item->next = 0;
ffffffffea8115b0:	aa1303f4 	mov	x20, x19
    arch_mmu_unmap(r->base, r->size / PAGE_SIZE);
ffffffffea8115b4:	d34cac21 	ubfx	x1, x1, #12, #32
	item->next->prev = item->prev;
ffffffffea8115b8:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea8115bc:	f9400263 	ldr	x3, [x19]
ffffffffea8115c0:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea8115c4:	f900067f 	str	xzr, [x19, #8]
ffffffffea8115c8:	f804869f 	str	xzr, [x20], #72
ffffffffea8115cc:	97ffc98d 	bl	ffffffffea803c00 <arch_mmu_unmap>
    mutex_release(&vmm_lock);
ffffffffea8115d0:	913be2c0 	add	x0, x22, #0xef8
ffffffffea8115d4:	97ffd125 	bl	ffffffffea805a68 <mutex_release>
    pmm_free (&r->page_list);
ffffffffea8115d8:	aa1403e0 	mov	x0, x20
ffffffffea8115dc:	97fffd63 	bl	ffffffffea810b68 <pmm_free>
    free (r);
ffffffffea8115e0:	aa1303e0 	mov	x0, x19
ffffffffea8115e4:	94000751 	bl	ffffffffea813328 <free>
    return NO_ERROR;
ffffffffea8115e8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8115ec:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea8115f0:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8115f4:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea8115f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8115fc:	d65f03c0 	ret

ffffffffea811600 <__debug_stdio_fgetc>:
{
	return _dputs(s);
}

static int __debug_stdio_fgetc(void *ctx)
{
ffffffffea811600:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return platform_dgetc(c, true);
ffffffffea811604:	52800021 	mov	w1, #0x1                   	// #1
{
ffffffffea811608:	910003fd 	mov	x29, sp
	return platform_dgetc(c, true);
ffffffffea81160c:	91007fa0 	add	x0, x29, #0x1f
ffffffffea811610:	97ffc292 	bl	ffffffffea802058 <platform_dgetc>
	int err;

	err = input_char(&c);
	if (err < 0)
		return err;
	return (unsigned char)c;
ffffffffea811614:	7100001f 	cmp	w0, #0x0
ffffffffea811618:	39407fa1 	ldrb	w1, [x29, #31]
}
ffffffffea81161c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea811620:	1a80a020 	csel	w0, w1, w0, ge  // ge = tcont
ffffffffea811624:	d65f03c0 	ret

ffffffffea811628 <out_count>:
{
ffffffffea811628:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea81162c:	52800004 	mov	w4, #0x0                   	// #0
ffffffffea811630:	910003fd 	mov	x29, sp
ffffffffea811634:	a9025bf5 	stp	x21, x22, [sp, #32]
	list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
ffffffffea811638:	90000055 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea81163c:	913ea2b5 	add	x21, x21, #0xfa8
{
ffffffffea811640:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811644:	aa0103f6 	mov	x22, x1
ffffffffea811648:	aa0003f4 	mov	x20, x0
	list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
ffffffffea81164c:	f94006b3 	ldr	x19, [x21, #8]
ffffffffea811650:	eb15027f 	cmp	x19, x21
ffffffffea811654:	54000200 	b.eq	ffffffffea811694 <out_count+0x6c>  // b.none
		if (cb->print) {
ffffffffea811658:	f9400a63 	ldr	x3, [x19, #16]
			cb->print(cb, str, len);
ffffffffea81165c:	aa1303e0 	mov	x0, x19
ffffffffea811660:	aa1603e2 	mov	x2, x22
ffffffffea811664:	aa1403e1 	mov	x1, x20
		if (cb->print) {
ffffffffea811668:	b4000063 	cbz	x3, ffffffffea811674 <out_count+0x4c>
			cb->print(cb, str, len);
ffffffffea81166c:	d63f0060 	blr	x3
			reg_logger = 1;
ffffffffea811670:	52800024 	mov	w4, #0x1                   	// #1
	list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
ffffffffea811674:	f9400673 	ldr	x19, [x19, #8]
ffffffffea811678:	eb15027f 	cmp	x19, x21
ffffffffea81167c:	54fffee1 	b.ne	ffffffffea811658 <out_count+0x30>  // b.any
	if(!reg_logger) {
ffffffffea811680:	340000a4 	cbz	w4, ffffffffea811694 <out_count+0x6c>
}
ffffffffea811684:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811688:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea81168c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811690:	d65f03c0 	ret
ffffffffea811694:	aa1403f3 	mov	x19, x20
ffffffffea811698:	8b160294 	add	x20, x20, x22
		for (i = 0; i < len; i++)
ffffffffea81169c:	b4ffff56 	cbz	x22, ffffffffea811684 <out_count+0x5c>
			platform_dputc(str[i]);
ffffffffea8116a0:	38401660 	ldrb	w0, [x19], #1
ffffffffea8116a4:	97ffc24b 	bl	ffffffffea801fd0 <platform_dputc>
		for (i = 0; i < len; i++)
ffffffffea8116a8:	eb14027f 	cmp	x19, x20
ffffffffea8116ac:	54fffec0 	b.eq	ffffffffea811684 <out_count+0x5c>  // b.none
			platform_dputc(str[i]);
ffffffffea8116b0:	38401660 	ldrb	w0, [x19], #1
ffffffffea8116b4:	97ffc247 	bl	ffffffffea801fd0 <platform_dputc>
		for (i = 0; i < len; i++)
ffffffffea8116b8:	eb14027f 	cmp	x19, x20
ffffffffea8116bc:	54ffff21 	b.ne	ffffffffea8116a0 <out_count+0x78>  // b.any
ffffffffea8116c0:	17fffff1 	b	ffffffffea811684 <out_count+0x5c>
ffffffffea8116c4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8116c8 <_dprintf_output_func>:

	return 0;
}

static int _dprintf_output_func(const char *str, size_t len, void *state)
{
ffffffffea8116c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea8116cc:	910003fd 	mov	x29, sp
ffffffffea8116d0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8116d4:	aa0003f4 	mov	x20, x0
	size_t n = strnlen(str, len);
ffffffffea8116d8:	9400085e 	bl	ffffffffea813850 <strnlen>
ffffffffea8116dc:	aa0003f3 	mov	x19, x0

	out_count(str, n);
ffffffffea8116e0:	aa0003e1 	mov	x1, x0
ffffffffea8116e4:	aa1403e0 	mov	x0, x20
ffffffffea8116e8:	97ffffd0 	bl	ffffffffea811628 <out_count>
	return n;
}
ffffffffea8116ec:	2a1303e0 	mov	w0, w19
ffffffffea8116f0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8116f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8116f8:	d65f03c0 	ret
ffffffffea8116fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811700 <register_print_callback>:
{
ffffffffea811700:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811704:	910003fd 	mov	x29, sp
ffffffffea811708:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81170c:	aa0003f3 	mov	x19, x0
ffffffffea811710:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811714:	d53b4220 	mrs	x0, daif
ffffffffea811718:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea81171c:	37380060 	tbnz	w0, #7, ffffffffea811728 <register_print_callback+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811720:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811724:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811728:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea81172c:	373002e0 	tbnz	w0, #6, ffffffffea811788 <register_print_callback+0x88>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea811730:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea811734:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea811738:	90000275 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea81173c:	913d02b5 	add	x21, x21, #0xf40
ffffffffea811740:	aa1503e0 	mov	x0, x21
ffffffffea811744:	97ffc455 	bl	ffffffffea802898 <arch_spin_lock>
	item->next = list->next;
ffffffffea811748:	90000041 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea81174c:	913ea021 	add	x1, x1, #0xfa8
    arch_spin_unlock(lock);
ffffffffea811750:	aa1503e0 	mov	x0, x21
ffffffffea811754:	f9400422 	ldr	x2, [x1, #8]
ffffffffea811758:	a9000a61 	stp	x1, x2, [x19]
	list->next->prev = item;
ffffffffea81175c:	f9400422 	ldr	x2, [x1, #8]
ffffffffea811760:	f9000053 	str	x19, [x2]
	list->next = item;
ffffffffea811764:	f9000433 	str	x19, [x1, #8]
ffffffffea811768:	97ffc454 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea81176c:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea811770:	36000054 	tbz	w20, #0, ffffffffea811778 <register_print_callback+0x78>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea811774:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea811778:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81177c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea811780:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811784:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea811788:	90000275 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea81178c:	913d02b5 	add	x21, x21, #0xf40
ffffffffea811790:	aa1503e0 	mov	x0, x21
ffffffffea811794:	97ffc441 	bl	ffffffffea802898 <arch_spin_lock>
	item->next = list->next;
ffffffffea811798:	90000041 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea81179c:	913ea021 	add	x1, x1, #0xfa8
    arch_spin_unlock(lock);
ffffffffea8117a0:	aa1503e0 	mov	x0, x21
ffffffffea8117a4:	f9400422 	ldr	x2, [x1, #8]
ffffffffea8117a8:	a9000a61 	stp	x1, x2, [x19]
	list->next->prev = item;
ffffffffea8117ac:	f9400422 	ldr	x2, [x1, #8]
ffffffffea8117b0:	f9000053 	str	x19, [x2]
	list->next = item;
ffffffffea8117b4:	f9000433 	str	x19, [x1, #8]
ffffffffea8117b8:	97ffc440 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea8117bc:	17ffffed 	b	ffffffffea811770 <register_print_callback+0x70>

ffffffffea8117c0 <unregister_print_callback>:
{
ffffffffea8117c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8117c4:	910003fd 	mov	x29, sp
ffffffffea8117c8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8117cc:	aa0003f3 	mov	x19, x0
ffffffffea8117d0:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8117d4:	d53b4220 	mrs	x0, daif
ffffffffea8117d8:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8117dc:	37380060 	tbnz	w0, #7, ffffffffea8117e8 <unregister_print_callback+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8117e0:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8117e4:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8117e8:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea8117ec:	373002a0 	tbnz	w0, #6, ffffffffea811840 <unregister_print_callback+0x80>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea8117f0:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8117f4:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea8117f8:	90000275 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8117fc:	913d02b5 	add	x21, x21, #0xf40
ffffffffea811800:	aa1503e0 	mov	x0, x21
ffffffffea811804:	97ffc425 	bl	ffffffffea802898 <arch_spin_lock>
	item->next->prev = item->prev;
ffffffffea811808:	a9400662 	ldp	x2, x1, [x19]
    arch_spin_unlock(lock);
ffffffffea81180c:	aa1503e0 	mov	x0, x21
ffffffffea811810:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea811814:	f9400262 	ldr	x2, [x19]
ffffffffea811818:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea81181c:	a9007e7f 	stp	xzr, xzr, [x19]
ffffffffea811820:	97ffc426 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea811824:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea811828:	36000054 	tbz	w20, #0, ffffffffea811830 <unregister_print_callback+0x70>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea81182c:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea811830:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811834:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea811838:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea81183c:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea811840:	90000275 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea811844:	913d02b5 	add	x21, x21, #0xf40
ffffffffea811848:	aa1503e0 	mov	x0, x21
ffffffffea81184c:	97ffc413 	bl	ffffffffea802898 <arch_spin_lock>
	item->next->prev = item->prev;
ffffffffea811850:	a9400662 	ldp	x2, x1, [x19]
    arch_spin_unlock(lock);
ffffffffea811854:	aa1503e0 	mov	x0, x21
ffffffffea811858:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea81185c:	f9400262 	ldr	x2, [x19]
ffffffffea811860:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea811864:	a9007e7f 	stp	xzr, xzr, [x19]
ffffffffea811868:	97ffc414 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea81186c:	17ffffef 	b	ffffffffea811828 <unregister_print_callback+0x68>

ffffffffea811870 <_dputc>:
{
ffffffffea811870:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea811874:	910003fd 	mov	x29, sp
ffffffffea811878:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81187c:	f90013f5 	str	x21, [sp, #32]
ffffffffea811880:	12001c15 	and	w21, w0, #0xff
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811884:	d53b4220 	mrs	x0, daif
ffffffffea811888:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea81188c:	37380060 	tbnz	w0, #7, ffffffffea811898 <_dputc+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811890:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811894:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811898:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea81189c:	37300280 	tbnz	w0, #6, ffffffffea8118ec <_dputc+0x7c>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea8118a0:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8118a4:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea8118a8:	90000274 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8118ac:	913d0294 	add	x20, x20, #0xf40
ffffffffea8118b0:	aa1403e0 	mov	x0, x20
ffffffffea8118b4:	97ffc3f9 	bl	ffffffffea802898 <arch_spin_lock>
ffffffffea8118b8:	910103a0 	add	x0, x29, #0x40
	out_count(&c, 1);
ffffffffea8118bc:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8118c0:	381ffc15 	strb	w21, [x0, #-1]!
ffffffffea8118c4:	97ffff59 	bl	ffffffffea811628 <out_count>
    arch_spin_unlock(lock);
ffffffffea8118c8:	aa1403e0 	mov	x0, x20
ffffffffea8118cc:	97ffc3fb 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea8118d0:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8118d4:	36000053 	tbz	w19, #0, ffffffffea8118dc <_dputc+0x6c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8118d8:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8118dc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8118e0:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8118e4:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8118e8:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8118ec:	90000274 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8118f0:	913d0294 	add	x20, x20, #0xf40
ffffffffea8118f4:	aa1403e0 	mov	x0, x20
ffffffffea8118f8:	97ffc3e8 	bl	ffffffffea802898 <arch_spin_lock>
ffffffffea8118fc:	910103a0 	add	x0, x29, #0x40
	out_count(&c, 1);
ffffffffea811900:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea811904:	381ffc15 	strb	w21, [x0, #-1]!
ffffffffea811908:	97ffff48 	bl	ffffffffea811628 <out_count>
    arch_spin_unlock(lock);
ffffffffea81190c:	aa1403e0 	mov	x0, x20
ffffffffea811910:	97ffc3ea 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea811914:	17fffff0 	b	ffffffffea8118d4 <_dputc+0x64>

ffffffffea811918 <__debug_stdio_fputc>:
{
ffffffffea811918:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	_dputc(c);
ffffffffea81191c:	2a0103e0 	mov	w0, w1
{
ffffffffea811920:	910003fd 	mov	x29, sp
	_dputc(c);
ffffffffea811924:	97ffffd3 	bl	ffffffffea811870 <_dputc>
}
ffffffffea811928:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea81192c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea811930:	d65f03c0 	ret
ffffffffea811934:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811938 <_dputs>:
{
ffffffffea811938:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea81193c:	910003fd 	mov	x29, sp
ffffffffea811940:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811944:	aa0003f4 	mov	x20, x0
ffffffffea811948:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea81194c:	d53b4220 	mrs	x0, daif
ffffffffea811950:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea811954:	37380060 	tbnz	w0, #7, ffffffffea811960 <_dputs+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811958:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea81195c:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811960:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea811964:	373002c0 	tbnz	w0, #6, ffffffffea8119bc <_dputs+0x84>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea811968:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea81196c:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea811970:	90000275 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea811974:	913d02b5 	add	x21, x21, #0xf40
ffffffffea811978:	aa1503e0 	mov	x0, x21
ffffffffea81197c:	97ffc3c7 	bl	ffffffffea802898 <arch_spin_lock>
	out_count(str, strlen(str));
ffffffffea811980:	aa1403e0 	mov	x0, x20
ffffffffea811984:	94000789 	bl	ffffffffea8137a8 <strlen>
ffffffffea811988:	aa0003e1 	mov	x1, x0
ffffffffea81198c:	aa1403e0 	mov	x0, x20
ffffffffea811990:	97ffff26 	bl	ffffffffea811628 <out_count>
    arch_spin_unlock(lock);
ffffffffea811994:	aa1503e0 	mov	x0, x21
ffffffffea811998:	97ffc3c8 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea81199c:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8119a0:	36000053 	tbz	w19, #0, ffffffffea8119a8 <_dputs+0x70>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8119a4:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8119a8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8119ac:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8119b0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8119b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8119b8:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8119bc:	90000275 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8119c0:	913d02b5 	add	x21, x21, #0xf40
ffffffffea8119c4:	aa1503e0 	mov	x0, x21
ffffffffea8119c8:	97ffc3b4 	bl	ffffffffea802898 <arch_spin_lock>
	out_count(str, strlen(str));
ffffffffea8119cc:	aa1403e0 	mov	x0, x20
ffffffffea8119d0:	94000776 	bl	ffffffffea8137a8 <strlen>
ffffffffea8119d4:	aa0003e1 	mov	x1, x0
ffffffffea8119d8:	aa1403e0 	mov	x0, x20
ffffffffea8119dc:	97ffff13 	bl	ffffffffea811628 <out_count>
    arch_spin_unlock(lock);
ffffffffea8119e0:	aa1503e0 	mov	x0, x21
ffffffffea8119e4:	97ffc3b5 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea8119e8:	17ffffee 	b	ffffffffea8119a0 <_dputs+0x68>
ffffffffea8119ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8119f0 <__debug_stdio_fputs>:
	return _dputs(s);
ffffffffea8119f0:	aa0103e0 	mov	x0, x1
ffffffffea8119f4:	17ffffd1 	b	ffffffffea811938 <_dputs>

ffffffffea8119f8 <_dwrite>:
{
ffffffffea8119f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8119fc:	910003fd 	mov	x29, sp
ffffffffea811a00:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811a04:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea811a08:	aa0003f5 	mov	x21, x0
ffffffffea811a0c:	aa0103f6 	mov	x22, x1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811a10:	d53b4220 	mrs	x0, daif
ffffffffea811a14:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea811a18:	37380060 	tbnz	w0, #7, ffffffffea811a24 <_dwrite+0x2c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811a1c:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811a20:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811a24:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea811a28:	37300280 	tbnz	w0, #6, ffffffffea811a78 <_dwrite+0x80>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea811a2c:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea811a30:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea811a34:	90000274 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea811a38:	913d0294 	add	x20, x20, #0xf40
ffffffffea811a3c:	aa1403e0 	mov	x0, x20
ffffffffea811a40:	97ffc396 	bl	ffffffffea802898 <arch_spin_lock>
	out_count(ptr, len);
ffffffffea811a44:	aa1603e1 	mov	x1, x22
ffffffffea811a48:	aa1503e0 	mov	x0, x21
ffffffffea811a4c:	97fffef7 	bl	ffffffffea811628 <out_count>
    arch_spin_unlock(lock);
ffffffffea811a50:	aa1403e0 	mov	x0, x20
ffffffffea811a54:	97ffc399 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea811a58:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea811a5c:	36000053 	tbz	w19, #0, ffffffffea811a64 <_dwrite+0x6c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea811a60:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea811a64:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea811a68:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811a6c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea811a70:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811a74:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea811a78:	90000274 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea811a7c:	913d0294 	add	x20, x20, #0xf40
ffffffffea811a80:	aa1403e0 	mov	x0, x20
ffffffffea811a84:	97ffc385 	bl	ffffffffea802898 <arch_spin_lock>
	out_count(ptr, len);
ffffffffea811a88:	aa1603e1 	mov	x1, x22
ffffffffea811a8c:	aa1503e0 	mov	x0, x21
ffffffffea811a90:	97fffee6 	bl	ffffffffea811628 <out_count>
    arch_spin_unlock(lock);
ffffffffea811a94:	aa1403e0 	mov	x0, x20
ffffffffea811a98:	97ffc388 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea811a9c:	17fffff0 	b	ffffffffea811a5c <_dwrite+0x64>

ffffffffea811aa0 <_dprintf>:

int _dprintf(const char *fmt, ...)
{
ffffffffea811aa0:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
	spin_lock_saved_state_t state;
	int err;
	va_list ap;

	va_start(ap, fmt);
ffffffffea811aa4:	128006e8 	mov	w8, #0xffffffc8            	// #-56
{
ffffffffea811aa8:	910003fd 	mov	x29, sp
	va_start(ap, fmt);
ffffffffea811aac:	9101c3a9 	add	x9, x29, #0x70
{
ffffffffea811ab0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811ab4:	f90013f5 	str	x21, [sp, #32]
ffffffffea811ab8:	aa0003f5 	mov	x21, x0
	va_start(ap, fmt);
ffffffffea811abc:	f90033a9 	str	x9, [x29, #96]
ffffffffea811ac0:	9102c3a0 	add	x0, x29, #0xb0
ffffffffea811ac4:	a90503a0 	stp	x0, x0, [x29, #80]
ffffffffea811ac8:	290d7fa8 	stp	w8, wzr, [x29, #104]
{
ffffffffea811acc:	a9078ba1 	stp	x1, x2, [x29, #120]
ffffffffea811ad0:	a90893a3 	stp	x3, x4, [x29, #136]
ffffffffea811ad4:	a9099ba5 	stp	x5, x6, [x29, #152]
ffffffffea811ad8:	f90057a7 	str	x7, [x29, #168]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811adc:	d53b4220 	mrs	x0, daif
ffffffffea811ae0:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea811ae4:	37380060 	tbnz	w0, #7, ffffffffea811af0 <_dprintf+0x50>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811ae8:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811aec:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811af0:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea811af4:	37300380 	tbnz	w0, #6, ffffffffea811b64 <_dprintf+0xc4>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea811af8:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea811afc:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea811b00:	90000274 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea811b04:	913d0294 	add	x20, x20, #0xf40
ffffffffea811b08:	aa1403e0 	mov	x0, x20
ffffffffea811b0c:	97ffc363 	bl	ffffffffea802898 <arch_spin_lock>
	spin_lock_save(&print_spin_lock, &state, PRINT_LOCK_FLAGS);
	err = _printf_engine(&_dprintf_output_func, NULL, fmt, ap);
ffffffffea811b10:	a9451fa6 	ldp	x6, x7, [x29, #80]
ffffffffea811b14:	aa1503e2 	mov	x2, x21
ffffffffea811b18:	a94617a4 	ldp	x4, x5, [x29, #96]
ffffffffea811b1c:	9100c3a3 	add	x3, x29, #0x30
ffffffffea811b20:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea811b24:	a9031fa6 	stp	x6, x7, [x29, #48]
ffffffffea811b28:	a90417a4 	stp	x4, x5, [x29, #64]
ffffffffea811b2c:	90000000 	adrp	x0, ffffffffea811000 <alloc_region+0xc0>
ffffffffea811b30:	911b2000 	add	x0, x0, #0x6c8
ffffffffea811b34:	9400030f 	bl	ffffffffea812770 <_printf_engine>
ffffffffea811b38:	2a0003f5 	mov	w21, w0
    arch_spin_unlock(lock);
ffffffffea811b3c:	aa1403e0 	mov	x0, x20
ffffffffea811b40:	97ffc35e 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea811b44:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea811b48:	36000053 	tbz	w19, #0, ffffffffea811b50 <_dprintf+0xb0>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea811b4c:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&print_spin_lock, state, PRINT_LOCK_FLAGS);
	va_end(ap);

	return err;
}
ffffffffea811b50:	2a1503e0 	mov	w0, w21
ffffffffea811b54:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea811b58:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811b5c:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea811b60:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea811b64:	90000274 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea811b68:	913d0294 	add	x20, x20, #0xf40
ffffffffea811b6c:	aa1403e0 	mov	x0, x20
ffffffffea811b70:	97ffc34a 	bl	ffffffffea802898 <arch_spin_lock>
	err = _printf_engine(&_dprintf_output_func, NULL, fmt, ap);
ffffffffea811b74:	a9451fa6 	ldp	x6, x7, [x29, #80]
ffffffffea811b78:	aa1503e2 	mov	x2, x21
ffffffffea811b7c:	a94617a4 	ldp	x4, x5, [x29, #96]
ffffffffea811b80:	9100c3a3 	add	x3, x29, #0x30
ffffffffea811b84:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea811b88:	a9031fa6 	stp	x6, x7, [x29, #48]
ffffffffea811b8c:	a90417a4 	stp	x4, x5, [x29, #64]
ffffffffea811b90:	90000000 	adrp	x0, ffffffffea811000 <alloc_region+0xc0>
ffffffffea811b94:	911b2000 	add	x0, x0, #0x6c8
ffffffffea811b98:	940002f6 	bl	ffffffffea812770 <_printf_engine>
ffffffffea811b9c:	2a0003f5 	mov	w21, w0
    arch_spin_unlock(lock);
ffffffffea811ba0:	aa1403e0 	mov	x0, x20
ffffffffea811ba4:	97ffc345 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea811ba8:	17ffffe8 	b	ffffffffea811b48 <_dprintf+0xa8>
ffffffffea811bac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811bb0 <_dvprintf>:

int _dvprintf(const char *fmt, va_list ap)
{
ffffffffea811bb0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea811bb4:	910003fd 	mov	x29, sp
ffffffffea811bb8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811bbc:	aa0103f4 	mov	x20, x1
ffffffffea811bc0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea811bc4:	aa0003f6 	mov	x22, x0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811bc8:	d53b4220 	mrs	x0, daif
ffffffffea811bcc:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea811bd0:	37380060 	tbnz	w0, #7, ffffffffea811bdc <_dvprintf+0x2c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811bd4:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811bd8:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811bdc:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea811be0:	37300380 	tbnz	w0, #6, ffffffffea811c50 <_dvprintf+0xa0>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea811be4:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea811be8:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea811bec:	90000275 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea811bf0:	913d02b5 	add	x21, x21, #0xf40
ffffffffea811bf4:	aa1503e0 	mov	x0, x21
ffffffffea811bf8:	97ffc328 	bl	ffffffffea802898 <arch_spin_lock>
	spin_lock_saved_state_t state;
	int err;

	spin_lock_save(&print_spin_lock, &state, PRINT_LOCK_FLAGS);
	err = _printf_engine(&_dprintf_output_func, NULL, fmt, ap);
ffffffffea811bfc:	a9401e86 	ldp	x6, x7, [x20]
ffffffffea811c00:	9100c3a3 	add	x3, x29, #0x30
ffffffffea811c04:	a9411684 	ldp	x4, x5, [x20, #16]
ffffffffea811c08:	aa1603e2 	mov	x2, x22
ffffffffea811c0c:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea811c10:	a9031fa6 	stp	x6, x7, [x29, #48]
ffffffffea811c14:	a90417a4 	stp	x4, x5, [x29, #64]
ffffffffea811c18:	90000000 	adrp	x0, ffffffffea811000 <alloc_region+0xc0>
ffffffffea811c1c:	911b2000 	add	x0, x0, #0x6c8
ffffffffea811c20:	940002d4 	bl	ffffffffea812770 <_printf_engine>
ffffffffea811c24:	2a0003f4 	mov	w20, w0
    arch_spin_unlock(lock);
ffffffffea811c28:	aa1503e0 	mov	x0, x21
ffffffffea811c2c:	97ffc323 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea811c30:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea811c34:	36000053 	tbz	w19, #0, ffffffffea811c3c <_dvprintf+0x8c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea811c38:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&print_spin_lock, state, PRINT_LOCK_FLAGS);

	return err;
}
ffffffffea811c3c:	2a1403e0 	mov	w0, w20
ffffffffea811c40:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811c44:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea811c48:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea811c4c:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea811c50:	90000275 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea811c54:	913d02b5 	add	x21, x21, #0xf40
ffffffffea811c58:	aa1503e0 	mov	x0, x21
ffffffffea811c5c:	97ffc30f 	bl	ffffffffea802898 <arch_spin_lock>
	err = _printf_engine(&_dprintf_output_func, NULL, fmt, ap);
ffffffffea811c60:	a9401e86 	ldp	x6, x7, [x20]
ffffffffea811c64:	9100c3a3 	add	x3, x29, #0x30
ffffffffea811c68:	a9411684 	ldp	x4, x5, [x20, #16]
ffffffffea811c6c:	aa1603e2 	mov	x2, x22
ffffffffea811c70:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea811c74:	a9031fa6 	stp	x6, x7, [x29, #48]
ffffffffea811c78:	a90417a4 	stp	x4, x5, [x29, #64]
ffffffffea811c7c:	90000000 	adrp	x0, ffffffffea811000 <alloc_region+0xc0>
ffffffffea811c80:	911b2000 	add	x0, x0, #0x6c8
ffffffffea811c84:	940002bb 	bl	ffffffffea812770 <_printf_engine>
ffffffffea811c88:	2a0003f4 	mov	w20, w0
    arch_spin_unlock(lock);
ffffffffea811c8c:	aa1503e0 	mov	x0, x21
ffffffffea811c90:	97ffc30a 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea811c94:	17ffffe8 	b	ffffffffea811c34 <_dvprintf+0x84>

ffffffffea811c98 <_panic>:
{
ffffffffea811c98:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
ffffffffea811c9c:	910003fd 	mov	x29, sp
ffffffffea811ca0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea811ca4:	aa0103f3 	mov	x19, x1
	dprintf(ALWAYS, "panic (caller %p): ", caller);
ffffffffea811ca8:	aa0003e1 	mov	x1, x0
ffffffffea811cac:	d0000020 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
{
ffffffffea811cb0:	a9060fa2 	stp	x2, x3, [x29, #96]
	dprintf(ALWAYS, "panic (caller %p): ", caller);
ffffffffea811cb4:	9131c000 	add	x0, x0, #0xc70
{
ffffffffea811cb8:	a90717a4 	stp	x4, x5, [x29, #112]
ffffffffea811cbc:	a9081fa6 	stp	x6, x7, [x29, #128]
	dprintf(ALWAYS, "panic (caller %p): ", caller);
ffffffffea811cc0:	97ffff78 	bl	ffffffffea811aa0 <_dprintf>
	va_start(ap, fmt);
ffffffffea811cc4:	910243a0 	add	x0, x29, #0x90
ffffffffea811cc8:	910183a1 	add	x1, x29, #0x60
ffffffffea811ccc:	a90403a0 	stp	x0, x0, [x29, #64]
ffffffffea811cd0:	128005e0 	mov	w0, #0xffffffd0            	// #-48
ffffffffea811cd4:	f9002ba1 	str	x1, [x29, #80]
	_dvprintf(fmt, ap);
ffffffffea811cd8:	910083a1 	add	x1, x29, #0x20
	va_start(ap, fmt);
ffffffffea811cdc:	b9005ba0 	str	w0, [x29, #88]
	_dvprintf(fmt, ap);
ffffffffea811ce0:	aa1303e0 	mov	x0, x19
	va_start(ap, fmt);
ffffffffea811ce4:	b9005fbf 	str	wzr, [x29, #92]
	_dvprintf(fmt, ap);
ffffffffea811ce8:	a94417a4 	ldp	x4, x5, [x29, #64]
ffffffffea811cec:	a90217a4 	stp	x4, x5, [x29, #32]
ffffffffea811cf0:	a9450fa2 	ldp	x2, x3, [x29, #80]
ffffffffea811cf4:	a9030fa2 	stp	x2, x3, [x29, #48]
ffffffffea811cf8:	97ffffae 	bl	ffffffffea811bb0 <_dvprintf>
	platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
ffffffffea811cfc:	52800121 	mov	w1, #0x9                   	// #9
ffffffffea811d00:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea811d04:	97ffd7c3 	bl	ffffffffea807c10 <platform_halt>

ffffffffea811d08 <__debug_stdio_vfprintf>:
{
ffffffffea811d08:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811d0c:	aa0103e0 	mov	x0, x1
ffffffffea811d10:	910003fd 	mov	x29, sp
	return _dvprintf(fmt, ap);
ffffffffea811d14:	a9401444 	ldp	x4, x5, [x2]
ffffffffea811d18:	910043a1 	add	x1, x29, #0x10
ffffffffea811d1c:	a9410c42 	ldp	x2, x3, [x2, #16]
ffffffffea811d20:	a90117a4 	stp	x4, x5, [x29, #16]
ffffffffea811d24:	a9020fa2 	stp	x2, x3, [x29, #32]
ffffffffea811d28:	97ffffa2 	bl	ffffffffea811bb0 <_dvprintf>
}
ffffffffea811d2c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811d30:	d65f03c0 	ret
ffffffffea811d34:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811d38 <heap_insert_free_chunk>:
static ssize_t heap_grow(size_t len);

// try to insert this free chunk into the free list, consuming the chunk by merging it with
// nearby ones if possible. Returns base of whatever chunk it became in the list.
static struct free_heap_chunk *heap_insert_free_chunk(struct free_heap_chunk *chunk)
{
ffffffffea811d38:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811d3c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea811d40:	910003fd 	mov	x29, sp
ffffffffea811d44:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811d48:	aa0003f3 	mov	x19, x0
ffffffffea811d4c:	f90013f5 	str	x21, [sp, #32]
ffffffffea811d50:	90000274 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea811d54:	913d2295 	add	x21, x20, #0xf48
ffffffffea811d58:	910082a0 	add	x0, x21, #0x20
ffffffffea811d5c:	97ffcf17 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	struct free_heap_chunk *next_chunk;
	struct free_heap_chunk *last_chunk;

	mutex_acquire(&theheap.lock);

	theheap.remaining += chunk->len;
ffffffffea811d60:	f9400a63 	ldr	x3, [x19, #16]

	// walk through the list, finding the node to insert before
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
ffffffffea811d64:	910162a1 	add	x1, x21, #0x58
	theheap.remaining += chunk->len;
ffffffffea811d68:	f9400aa2 	ldr	x2, [x21, #16]
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
ffffffffea811d6c:	f94032a0 	ldr	x0, [x21, #96]
	theheap.remaining += chunk->len;
ffffffffea811d70:	8b030042 	add	x2, x2, x3
ffffffffea811d74:	f9000aa2 	str	x2, [x21, #16]
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
ffffffffea811d78:	eb01001f 	cmp	x0, x1
ffffffffea811d7c:	540000a1 	b.ne	ffffffffea811d90 <heap_insert_free_chunk+0x58>  // b.any
ffffffffea811d80:	14000022 	b	ffffffffea811e08 <heap_insert_free_chunk+0xd0>
ffffffffea811d84:	f9400400 	ldr	x0, [x0, #8]
ffffffffea811d88:	eb01001f 	cmp	x0, x1
ffffffffea811d8c:	540003e0 	b.eq	ffffffffea811e08 <heap_insert_free_chunk+0xd0>  // b.none
		if (chunk < next_chunk) {
ffffffffea811d90:	eb00027f 	cmp	x19, x0
ffffffffea811d94:	54ffff82 	b.cs	ffffffffea811d84 <heap_insert_free_chunk+0x4c>  // b.hs, b.nlast
	item->prev = list->prev;
ffffffffea811d98:	f9400001 	ldr	x1, [x0]
	// walked off the end of the list, add it at the tail
	list_add_tail(&theheap.free_list, &chunk->node);

	// try to merge with the previous chunk
try_merge:
	last_chunk = list_prev_type(&theheap.free_list, &chunk->node, struct free_heap_chunk, node);
ffffffffea811d9c:	913d2282 	add	x2, x20, #0xf48
	item->next = list;
ffffffffea811da0:	a9000261 	stp	x1, x0, [x19]
ffffffffea811da4:	91016042 	add	x2, x2, #0x58
	list->prev->next = item;
ffffffffea811da8:	f9400001 	ldr	x1, [x0]
ffffffffea811dac:	f9000433 	str	x19, [x1, #8]
	list->prev = item;
ffffffffea811db0:	f9000013 	str	x19, [x0]
ffffffffea811db4:	f9400261 	ldr	x1, [x19]
ffffffffea811db8:	f100003f 	cmp	x1, #0x0
ffffffffea811dbc:	fa421024 	ccmp	x1, x2, #0x4, ne  // ne = any
ffffffffea811dc0:	540000c0 	b.eq	ffffffffea811dd8 <heap_insert_free_chunk+0xa0>  // b.none
	if (last_chunk) {
		if ((vaddr_t)last_chunk + last_chunk->len == (vaddr_t)chunk) {
ffffffffea811dc4:	f9400822 	ldr	x2, [x1, #16]
ffffffffea811dc8:	8b020024 	add	x4, x1, x2
ffffffffea811dcc:	eb04027f 	cmp	x19, x4
ffffffffea811dd0:	54000360 	b.eq	ffffffffea811e3c <heap_insert_free_chunk+0x104>  // b.none
			chunk = last_chunk;
		}
	}

	// try to merge with the next chunk
	if (next_chunk) {
ffffffffea811dd4:	b40000a0 	cbz	x0, ffffffffea811de8 <heap_insert_free_chunk+0xb0>
		if ((vaddr_t)chunk + chunk->len == (vaddr_t)next_chunk) {
ffffffffea811dd8:	f9400a61 	ldr	x1, [x19, #16]
ffffffffea811ddc:	8b010262 	add	x2, x19, x1
ffffffffea811de0:	eb02001f 	cmp	x0, x2
ffffffffea811de4:	54000400 	b.eq	ffffffffea811e64 <heap_insert_free_chunk+0x12c>  // b.none
			// remove them from the list
			list_delete(&next_chunk->node);
		}
	}

	mutex_release(&theheap.lock);
ffffffffea811de8:	913d2280 	add	x0, x20, #0xf48
ffffffffea811dec:	91008000 	add	x0, x0, #0x20
ffffffffea811df0:	97ffcf1e 	bl	ffffffffea805a68 <mutex_release>

	return chunk;
}
ffffffffea811df4:	aa1303e0 	mov	x0, x19
ffffffffea811df8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea811dfc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811e00:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811e04:	d65f03c0 	ret
	item->prev = list->prev;
ffffffffea811e08:	913d2281 	add	x1, x20, #0xf48
ffffffffea811e0c:	aa0103e2 	mov	x2, x1
ffffffffea811e10:	f8458c44 	ldr	x4, [x2, #88]!
	item->next = list;
ffffffffea811e14:	a9000a64 	stp	x4, x2, [x19]
	list->prev->next = item;
ffffffffea811e18:	f9402c24 	ldr	x4, [x1, #88]
ffffffffea811e1c:	f9000493 	str	x19, [x4, #8]
	list->prev = item;
ffffffffea811e20:	f9002c33 	str	x19, [x1, #88]
	last_chunk = list_prev_type(&theheap.free_list, &chunk->node, struct free_heap_chunk, node);
ffffffffea811e24:	f9400261 	ldr	x1, [x19]
ffffffffea811e28:	f100003f 	cmp	x1, #0x0
ffffffffea811e2c:	fa421024 	ccmp	x1, x2, #0x4, ne  // ne = any
ffffffffea811e30:	54fffca1 	b.ne	ffffffffea811dc4 <heap_insert_free_chunk+0x8c>  // b.any
	if (next_chunk) {
ffffffffea811e34:	b5fffd20 	cbnz	x0, ffffffffea811dd8 <heap_insert_free_chunk+0xa0>
ffffffffea811e38:	17ffffec 	b	ffffffffea811de8 <heap_insert_free_chunk+0xb0>
	item->next->prev = item->prev;
ffffffffea811e3c:	f9400664 	ldr	x4, [x19, #8]
			last_chunk->len += chunk->len;
ffffffffea811e40:	8b020063 	add	x3, x3, x2
ffffffffea811e44:	f9000823 	str	x3, [x1, #16]
ffffffffea811e48:	f9000081 	str	x1, [x4]
	item->prev->next = item->next;
ffffffffea811e4c:	f9400262 	ldr	x2, [x19]
ffffffffea811e50:	f9000444 	str	x4, [x2, #8]
	item->prev = item->next = 0;
ffffffffea811e54:	a9007e7f 	stp	xzr, xzr, [x19]
ffffffffea811e58:	aa0103f3 	mov	x19, x1
	if (next_chunk) {
ffffffffea811e5c:	b5fffbe0 	cbnz	x0, ffffffffea811dd8 <heap_insert_free_chunk+0xa0>
ffffffffea811e60:	17ffffe2 	b	ffffffffea811de8 <heap_insert_free_chunk+0xb0>
	item->next->prev = item->prev;
ffffffffea811e64:	a9400c04 	ldp	x4, x3, [x0]
			chunk->len += next_chunk->len;
ffffffffea811e68:	f9400802 	ldr	x2, [x0, #16]
ffffffffea811e6c:	8b010041 	add	x1, x2, x1
ffffffffea811e70:	f9000a61 	str	x1, [x19, #16]
ffffffffea811e74:	f9000064 	str	x4, [x3]
	item->prev->next = item->next;
ffffffffea811e78:	f9400001 	ldr	x1, [x0]
ffffffffea811e7c:	f9000423 	str	x3, [x1, #8]
	item->prev = item->next = 0;
ffffffffea811e80:	a9007c1f 	stp	xzr, xzr, [x0]
	mutex_release(&theheap.lock);
ffffffffea811e84:	913d2280 	add	x0, x20, #0xf48
ffffffffea811e88:	91008000 	add	x0, x0, #0x20
ffffffffea811e8c:	97ffcef7 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea811e90:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea811e94:	aa1303e0 	mov	x0, x19
ffffffffea811e98:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811e9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811ea0:	d65f03c0 	ret
ffffffffea811ea4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811ea8 <heap_free_delayed_list>:

	return chunk;
}

static void heap_free_delayed_list(void)
{
ffffffffea811ea8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea811eac:	910003fd 	mov	x29, sp
ffffffffea811eb0:	a90153f3 	stp	x19, x20, [sp, #16]
	list->prev = list->next = list;
ffffffffea811eb4:	910103b3 	add	x19, x29, #0x40
ffffffffea811eb8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea811ebc:	a9044fb3 	stp	x19, x19, [x29, #64]
ffffffffea811ec0:	f9001bf7 	str	x23, [sp, #48]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811ec4:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea811ec8:	37380620 	tbnz	w0, #7, ffffffffea811f8c <heap_free_delayed_list+0xe4>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811ecc:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea811ed0:	90000274 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea811ed4:	913d2296 	add	x22, x20, #0xf48
ffffffffea811ed8:	9101e2d7 	add	x23, x22, #0x78
	if (list->next != list) {
ffffffffea811edc:	9101a2d6 	add	x22, x22, #0x68
ffffffffea811ee0:	aa1703e0 	mov	x0, x23
ffffffffea811ee4:	97ffc26d 	bl	ffffffffea802898 <arch_spin_lock>
ffffffffea811ee8:	f94006c1 	ldr	x1, [x22, #8]
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811eec:	52800035 	mov	w21, #0x1                   	// #1
ffffffffea811ef0:	eb16003f 	cmp	x1, x22
ffffffffea811ef4:	54000660 	b.eq	ffffffffea811fc0 <heap_free_delayed_list+0x118>  // b.none
ffffffffea811ef8:	913d2280 	add	x0, x20, #0xf48
ffffffffea811efc:	9101a004 	add	x4, x0, #0x68
	item->next->prev = item->prev;
ffffffffea811f00:	a9400823 	ldp	x3, x2, [x1]
ffffffffea811f04:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea811f08:	f9400023 	ldr	x3, [x1]
ffffffffea811f0c:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea811f10:	f900043f 	str	xzr, [x1, #8]
	item->next = list->next;
ffffffffea811f14:	f94027a2 	ldr	x2, [x29, #72]
ffffffffea811f18:	a9000833 	stp	x19, x2, [x1]
	list->next->prev = item;
ffffffffea811f1c:	f94027a2 	ldr	x2, [x29, #72]
ffffffffea811f20:	f9000041 	str	x1, [x2]
	list->next = item;
ffffffffea811f24:	f90027a1 	str	x1, [x29, #72]
	if (list->next != list) {
ffffffffea811f28:	f9403801 	ldr	x1, [x0, #112]
ffffffffea811f2c:	eb04003f 	cmp	x1, x4
ffffffffea811f30:	54fffe81 	b.ne	ffffffffea811f00 <heap_free_delayed_list+0x58>  // b.any
    arch_spin_unlock(lock);
ffffffffea811f34:	9101e000 	add	x0, x0, #0x78
ffffffffea811f38:	97ffc260 	bl	ffffffffea8028b8 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea811f3c:	34000195 	cbz	w21, ffffffffea811f6c <heap_free_delayed_list+0xc4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea811f40:	d50342ff 	msr	daifclr, #0x2
ffffffffea811f44:	f94027a1 	ldr	x1, [x29, #72]
ffffffffea811f48:	eb13003f 	cmp	x1, x19
ffffffffea811f4c:	54000160 	b.eq	ffffffffea811f78 <heap_free_delayed_list+0xd0>  // b.none
	item->next->prev = item->prev;
ffffffffea811f50:	a9400823 	ldp	x3, x2, [x1]
	}
	spin_unlock_irqrestore(&theheap.delayed_free_lock, state);

	while ((chunk = list_remove_head_type(&list, struct free_heap_chunk, node))) {
		LTRACEF("freeing chunk %p\n", chunk);
		heap_insert_free_chunk(chunk);
ffffffffea811f54:	aa0103e0 	mov	x0, x1
ffffffffea811f58:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea811f5c:	f9400023 	ldr	x3, [x1]
ffffffffea811f60:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea811f64:	a9007c3f 	stp	xzr, xzr, [x1]
ffffffffea811f68:	97ffff74 	bl	ffffffffea811d38 <heap_insert_free_chunk>
	if (list->next != list) {
ffffffffea811f6c:	f94027a1 	ldr	x1, [x29, #72]
ffffffffea811f70:	eb13003f 	cmp	x1, x19
ffffffffea811f74:	54fffee1 	b.ne	ffffffffea811f50 <heap_free_delayed_list+0xa8>  // b.any
	}
}
ffffffffea811f78:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811f7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea811f80:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea811f84:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea811f88:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea811f8c:	90000274 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea811f90:	913d2296 	add	x22, x20, #0xf48
ffffffffea811f94:	9101e2d7 	add	x23, x22, #0x78
ffffffffea811f98:	9101a2d6 	add	x22, x22, #0x68
ffffffffea811f9c:	aa1703e0 	mov	x0, x23
ffffffffea811fa0:	97ffc23e 	bl	ffffffffea802898 <arch_spin_lock>
ffffffffea811fa4:	f94006c1 	ldr	x1, [x22, #8]
    spin_lock_saved_state_t state = 0;
ffffffffea811fa8:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea811fac:	eb16003f 	cmp	x1, x22
ffffffffea811fb0:	54fffa41 	b.ne	ffffffffea811ef8 <heap_free_delayed_list+0x50>  // b.any
    arch_spin_unlock(lock);
ffffffffea811fb4:	aa1703e0 	mov	x0, x23
ffffffffea811fb8:	97ffc240 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea811fbc:	17ffffec 	b	ffffffffea811f6c <heap_free_delayed_list+0xc4>
ffffffffea811fc0:	aa1703e0 	mov	x0, x23
ffffffffea811fc4:	97ffc23d 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea811fc8:	d50342ff 	msr	daifclr, #0x2
ffffffffea811fcc:	17ffffde 	b	ffffffffea811f44 <heap_free_delayed_list+0x9c>

ffffffffea811fd0 <heap_alloc>:

void *heap_alloc(size_t size, unsigned int alignment)
{
ffffffffea811fd0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea811fd4:	910003fd 	mov	x29, sp
ffffffffea811fd8:	a901d7f4 	stp	x20, x21, [sp, #24]
	return (list->next == list) ? true : false;
ffffffffea811fdc:	90000275 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea811fe0:	913d22a2 	add	x2, x21, #0xf48
ffffffffea811fe4:	f9001bf7 	str	x23, [sp, #48]
ffffffffea811fe8:	2a0103f7 	mov	w23, w1
#endif

	LTRACEF("size %zd, align %d\n", size, alignment);

	// deal with the pending free list
	if (unlikely(!list_is_empty(&theheap.delayed_free_list))) {
ffffffffea811fec:	9101a043 	add	x3, x2, #0x68
ffffffffea811ff0:	f9403841 	ldr	x1, [x2, #112]
ffffffffea811ff4:	eb03003f 	cmp	x1, x3
ffffffffea811ff8:	540014a1 	b.ne	ffffffffea81228c <heap_alloc+0x2bc>  // b.any
		heap_free_delayed_list();
	}

	// alignment must be power of 2
	if (alignment & (alignment - 1))
ffffffffea811ffc:	510006e1 	sub	w1, w23, #0x1
ffffffffea812000:	6a17003f 	tst	w1, w23
ffffffffea812004:	54000a21 	b.ne	ffffffffea812148 <heap_alloc+0x178>  // b.any
		return NULL;

	// we always put a size field + base pointer + magic in front of the allocation
	size += sizeof(struct alloc_struct_begin);
ffffffffea812008:	91004000 	add	x0, x0, #0x10
ffffffffea81200c:	f9000bb3 	str	x19, [x29, #16]
	// in the spot
	if (size < sizeof(struct free_heap_chunk))
		size = sizeof(struct free_heap_chunk);

	// round up size to a multiple of native pointer size
	size = ROUNDUP(size, sizeof(void *));
ffffffffea812010:	d2800313 	mov	x19, #0x18                  	// #24
ffffffffea812014:	eb13001f 	cmp	x0, x19
ffffffffea812018:	9a932013 	csel	x19, x0, x19, cs  // cs = hs, nlast
ffffffffea81201c:	f90017b6 	str	x22, [x29, #40]
ffffffffea812020:	91001e73 	add	x19, x19, #0x7
ffffffffea812024:	927df273 	and	x19, x19, #0xfffffffffffffff8

	// deal with nonzero alignments
	if (alignment > 0) {
ffffffffea812028:	35001237 	cbnz	w23, ffffffffea81226c <heap_alloc+0x29c>
	mutex_release(&theheap.lock);

#if WITH_KERNEL_VM
	/* try to grow the heap if we can */
	if (ptr == NULL && retry_count == 0) {
		size_t growby = MAX(HEAP_GROW_SIZE, ROUNDUP(size, PAGE_SIZE));
ffffffffea81202c:	913ffe62 	add	x2, x19, #0xfff
ffffffffea812030:	d2a00020 	mov	x0, #0x10000               	// #65536
ffffffffea812034:	9274cc42 	and	x2, x2, #0xfffffffffffff000
ffffffffea812038:	913d22b4 	add	x20, x21, #0xf48
ffffffffea81203c:	eb00005f 	cmp	x2, x0
ffffffffea812040:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea812044:	9a802042 	csel	x2, x2, x0, cs  // cs = hs, nlast
ffffffffea812048:	91008280 	add	x0, x20, #0x20
}

static ssize_t heap_grow(size_t size)
{
#if WITH_KERNEL_VM
	size = ROUNDUP(size, PAGE_SIZE);
ffffffffea81204c:	913ffc56 	add	x22, x2, #0xfff
ffffffffea812050:	97ffce5a 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea812054:	f9403280 	ldr	x0, [x20, #96]
ffffffffea812058:	91016282 	add	x2, x20, #0x58

	void *ptr = pmm_alloc_kpages(size / PAGE_SIZE, NULL);
ffffffffea81205c:	d34cfed4 	lsr	x20, x22, #12
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea812060:	eb02001f 	cmp	x0, x2
ffffffffea812064:	54000160 	b.eq	ffffffffea812090 <heap_alloc+0xc0>  // b.none
		if (chunk->len >= size) {
ffffffffea812068:	f9400801 	ldr	x1, [x0, #16]
ffffffffea81206c:	eb13003f 	cmp	x1, x19
ffffffffea812070:	540000a3 	b.cc	ffffffffea812084 <heap_alloc+0xb4>  // b.lo, b.ul, b.last
ffffffffea812074:	1400003b 	b	ffffffffea812160 <heap_alloc+0x190>
ffffffffea812078:	f9400801 	ldr	x1, [x0, #16]
ffffffffea81207c:	eb01027f 	cmp	x19, x1
ffffffffea812080:	54000709 	b.ls	ffffffffea812160 <heap_alloc+0x190>  // b.plast
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea812084:	f9400400 	ldr	x0, [x0, #8]
ffffffffea812088:	eb02001f 	cmp	x0, x2
ffffffffea81208c:	54ffff61 	b.ne	ffffffffea812078 <heap_alloc+0xa8>  // b.any
	mutex_release(&theheap.lock);
ffffffffea812090:	913d22a0 	add	x0, x21, #0xf48
	size = ROUNDUP(size, PAGE_SIZE);
ffffffffea812094:	9274ced6 	and	x22, x22, #0xfffffffffffff000
	mutex_release(&theheap.lock);
ffffffffea812098:	91008000 	add	x0, x0, #0x20
ffffffffea81209c:	97ffce73 	bl	ffffffffea805a68 <mutex_release>
	void *ptr = pmm_alloc_kpages(size / PAGE_SIZE, NULL);
ffffffffea8120a0:	2a1403e0 	mov	w0, w20
ffffffffea8120a4:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8120a8:	97fffaf6 	bl	ffffffffea810c80 <pmm_alloc_kpages>
ffffffffea8120ac:	aa0003f4 	mov	x20, x0
	if (!ptr) {
ffffffffea8120b0:	b4000fe0 	cbz	x0, ffffffffea8122ac <heap_alloc+0x2dc>
	chunk->len = len;
ffffffffea8120b4:	f9000816 	str	x22, [x0, #16]
		return ERR_NO_MEMORY;
	}

	LTRACEF("growing heap by 0x%zx bytes, new ptr %p\n", size, ptr);

	heap_insert_free_chunk(heap_create_free_chunk(ptr, size, true));
ffffffffea8120b8:	97ffff20 	bl	ffffffffea811d38 <heap_insert_free_chunk>

	/* change the heap start and end variables */
	if ((uintptr_t)ptr < (uintptr_t)theheap.base)
ffffffffea8120bc:	f947a6a1 	ldr	x1, [x21, #3912]
ffffffffea8120c0:	eb14003f 	cmp	x1, x20
ffffffffea8120c4:	54000069 	b.ls	ffffffffea8120d0 <heap_alloc+0x100>  // b.plast
		theheap.base = ptr;
ffffffffea8120c8:	aa1403e1 	mov	x1, x20
ffffffffea8120cc:	f907a6b4 	str	x20, [x21, #3912]

	uintptr_t endptr = (uintptr_t)ptr + size;
	if (endptr > (uintptr_t)theheap.base + theheap.len) {
ffffffffea8120d0:	913d22a2 	add	x2, x21, #0xf48
	uintptr_t endptr = (uintptr_t)ptr + size;
ffffffffea8120d4:	8b160294 	add	x20, x20, x22
	if (endptr > (uintptr_t)theheap.base + theheap.len) {
ffffffffea8120d8:	f9400440 	ldr	x0, [x2, #8]
ffffffffea8120dc:	8b000020 	add	x0, x1, x0
ffffffffea8120e0:	eb00029f 	cmp	x20, x0
ffffffffea8120e4:	54000ce8 	b.hi	ffffffffea812280 <heap_alloc+0x2b0>  // b.pmore
		if (err >= 0) {
ffffffffea8120e8:	b7f80db6 	tbnz	x22, #63, ffffffffea81229c <heap_alloc+0x2cc>
ffffffffea8120ec:	913d22b4 	add	x20, x21, #0xf48
ffffffffea8120f0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8120f4:	91008280 	add	x0, x20, #0x20
ffffffffea8120f8:	97ffce30 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea8120fc:	91016282 	add	x2, x20, #0x58
ffffffffea812100:	f9403280 	ldr	x0, [x20, #96]
ffffffffea812104:	eb02001f 	cmp	x0, x2
ffffffffea812108:	54000160 	b.eq	ffffffffea812134 <heap_alloc+0x164>  // b.none
		if (chunk->len >= size) {
ffffffffea81210c:	f9400801 	ldr	x1, [x0, #16]
ffffffffea812110:	eb01027f 	cmp	x19, x1
ffffffffea812114:	540000a8 	b.hi	ffffffffea812128 <heap_alloc+0x158>  // b.pmore
ffffffffea812118:	14000012 	b	ffffffffea812160 <heap_alloc+0x190>
ffffffffea81211c:	f9400801 	ldr	x1, [x0, #16]
ffffffffea812120:	eb13003f 	cmp	x1, x19
ffffffffea812124:	540001e2 	b.cs	ffffffffea812160 <heap_alloc+0x190>  // b.hs, b.nlast
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea812128:	f9400400 	ldr	x0, [x0, #8]
ffffffffea81212c:	eb02001f 	cmp	x0, x2
ffffffffea812130:	54ffff61 	b.ne	ffffffffea81211c <heap_alloc+0x14c>  // b.any
	mutex_release(&theheap.lock);
ffffffffea812134:	913d22a0 	add	x0, x21, #0xf48
ffffffffea812138:	91008000 	add	x0, x0, #0x20
ffffffffea81213c:	97ffce4b 	bl	ffffffffea805a68 <mutex_release>
ffffffffea812140:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea812144:	f94017b6 	ldr	x22, [x29, #40]
		return NULL;
ffffffffea812148:	d2800014 	mov	x20, #0x0                   	// #0
}
ffffffffea81214c:	aa1403e0 	mov	x0, x20
ffffffffea812150:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea812154:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea812158:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea81215c:	d65f03c0 	ret
			struct list_node *next_node = list_next(&theheap.free_list, &chunk->node);
ffffffffea812160:	a9400806 	ldp	x6, x2, [x0]
	if (item->next != list)
ffffffffea812164:	913d22a3 	add	x3, x21, #0xf48
ffffffffea812168:	91016064 	add	x4, x3, #0x58
ffffffffea81216c:	91006265 	add	x5, x19, #0x18
ffffffffea812170:	eb04005f 	cmp	x2, x4
ffffffffea812174:	54000560 	b.eq	ffffffffea812220 <heap_alloc+0x250>  // b.none
	item->next->prev = item->prev;
ffffffffea812178:	f9000046 	str	x6, [x2]
			if (chunk->len > size + sizeof(struct free_heap_chunk)) {
ffffffffea81217c:	eb05003f 	cmp	x1, x5
	item->prev->next = item->next;
ffffffffea812180:	f9400003 	ldr	x3, [x0]
ffffffffea812184:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea812188:	a9007c1f 	stp	xzr, xzr, [x0]
ffffffffea81218c:	54000569 	b.ls	ffffffffea812238 <heap_alloc+0x268>  // b.plast
				struct free_heap_chunk *newchunk = heap_create_free_chunk((uint8_t *)ptr + size, chunk->len - size, true);
ffffffffea812190:	8b130003 	add	x3, x0, x19
	item->prev = list->prev;
ffffffffea812194:	f9400044 	ldr	x4, [x2]
ffffffffea812198:	cb130021 	sub	x1, x1, x19
	chunk->len = len;
ffffffffea81219c:	f9000861 	str	x1, [x3, #16]
				chunk->len -= chunk->len - size;
ffffffffea8121a0:	f9000813 	str	x19, [x0, #16]
ffffffffea8121a4:	f8336804 	str	x4, [x0, x19]
	list->prev->next = item;
ffffffffea8121a8:	f9400041 	ldr	x1, [x2]
	item->next = list;
ffffffffea8121ac:	f9000462 	str	x2, [x3, #8]
	list->prev->next = item;
ffffffffea8121b0:	f9000423 	str	x3, [x1, #8]
	list->prev = item;
ffffffffea8121b4:	f9000043 	str	x3, [x2]
				ptr = (void *)ROUNDUP((addr_t)ptr, (addr_t)alignment);
ffffffffea8121b8:	2a1703e2 	mov	w2, w23
			ptr = (void *)((addr_t)ptr + sizeof(struct alloc_struct_begin));
ffffffffea8121bc:	91004014 	add	x20, x0, #0x10
				ptr = (void *)ROUNDUP((addr_t)ptr, (addr_t)alignment);
ffffffffea8121c0:	d1000441 	sub	x1, x2, #0x1
			theheap.remaining -= size;
ffffffffea8121c4:	913d22a3 	add	x3, x21, #0xf48
				ptr = (void *)ROUNDUP((addr_t)ptr, (addr_t)alignment);
ffffffffea8121c8:	cb0203e2 	neg	x2, x2
ffffffffea8121cc:	8b140021 	add	x1, x1, x20
ffffffffea8121d0:	710002ff 	cmp	w23, #0x0
ffffffffea8121d4:	8a020021 	and	x1, x1, x2
ffffffffea8121d8:	9a810294 	csel	x20, x20, x1, eq  // eq = none
			if (theheap.remaining < theheap.low_watermark) {
ffffffffea8121dc:	a9410861 	ldp	x1, x2, [x3, #16]
			as->size = size;
ffffffffea8121e0:	a93f4e80 	stp	x0, x19, [x20, #-16]
			theheap.remaining -= size;
ffffffffea8121e4:	cb130033 	sub	x19, x1, x19
ffffffffea8121e8:	f9000873 	str	x19, [x3, #16]
			if (theheap.remaining < theheap.low_watermark) {
ffffffffea8121ec:	eb02027f 	cmp	x19, x2
ffffffffea8121f0:	54000042 	b.cs	ffffffffea8121f8 <heap_alloc+0x228>  // b.hs, b.nlast
				theheap.low_watermark = theheap.remaining;
ffffffffea8121f4:	f9000c73 	str	x19, [x3, #24]
	mutex_release(&theheap.lock);
ffffffffea8121f8:	913d22a0 	add	x0, x21, #0xf48
ffffffffea8121fc:	91008000 	add	x0, x0, #0x20
ffffffffea812200:	97ffce1a 	bl	ffffffffea805a68 <mutex_release>
ffffffffea812204:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea812208:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea81220c:	aa1403e0 	mov	x0, x20
ffffffffea812210:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea812214:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea812218:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea81221c:	d65f03c0 	ret
	item->next->prev = item->prev;
ffffffffea812220:	f9002c66 	str	x6, [x3, #88]
			if (chunk->len > size + sizeof(struct free_heap_chunk)) {
ffffffffea812224:	eb05003f 	cmp	x1, x5
	item->prev->next = item->next;
ffffffffea812228:	f9400004 	ldr	x4, [x0]
ffffffffea81222c:	f9000482 	str	x2, [x4, #8]
	item->prev = item->next = 0;
ffffffffea812230:	a9007c1f 	stp	xzr, xzr, [x0]
ffffffffea812234:	54000068 	b.hi	ffffffffea812240 <heap_alloc+0x270>  // b.pmore
ffffffffea812238:	f9400813 	ldr	x19, [x0, #16]
ffffffffea81223c:	17ffffdf 	b	ffffffffea8121b8 <heap_alloc+0x1e8>
				struct free_heap_chunk *newchunk = heap_create_free_chunk((uint8_t *)ptr + size, chunk->len - size, true);
ffffffffea812240:	8b130004 	add	x4, x0, x19
	item->prev = list->prev;
ffffffffea812244:	f9402c65 	ldr	x5, [x3, #88]
ffffffffea812248:	cb130021 	sub	x1, x1, x19
	chunk->len = len;
ffffffffea81224c:	f9000881 	str	x1, [x4, #16]
				chunk->len -= chunk->len - size;
ffffffffea812250:	f9000813 	str	x19, [x0, #16]
ffffffffea812254:	f8336805 	str	x5, [x0, x19]
	item->next = list;
ffffffffea812258:	f9000482 	str	x2, [x4, #8]
	list->prev->next = item;
ffffffffea81225c:	f9402c61 	ldr	x1, [x3, #88]
ffffffffea812260:	f9000424 	str	x4, [x1, #8]
	list->prev = item;
ffffffffea812264:	f9002c64 	str	x4, [x3, #88]
ffffffffea812268:	17ffffd4 	b	ffffffffea8121b8 <heap_alloc+0x1e8>
ffffffffea81226c:	710042ff 	cmp	w23, #0x10
ffffffffea812270:	52800200 	mov	w0, #0x10                  	// #16
ffffffffea812274:	1a8022f7 	csel	w23, w23, w0, cs  // cs = hs, nlast
		size += alignment;
ffffffffea812278:	8b374273 	add	x19, x19, w23, uxtw
ffffffffea81227c:	17ffff6c 	b	ffffffffea81202c <heap_alloc+0x5c>
		theheap.len = (uintptr_t)endptr - (uintptr_t)theheap.base;
ffffffffea812280:	cb010294 	sub	x20, x20, x1
ffffffffea812284:	f9000454 	str	x20, [x2, #8]
ffffffffea812288:	17ffff98 	b	ffffffffea8120e8 <heap_alloc+0x118>
ffffffffea81228c:	f90027a0 	str	x0, [x29, #72]
		heap_free_delayed_list();
ffffffffea812290:	97ffff06 	bl	ffffffffea811ea8 <heap_free_delayed_list>
ffffffffea812294:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea812298:	17ffff59 	b	ffffffffea811ffc <heap_alloc+0x2c>
ffffffffea81229c:	f9400bb3 	ldr	x19, [x29, #16]
		return NULL;
ffffffffea8122a0:	d2800014 	mov	x20, #0x0                   	// #0
ffffffffea8122a4:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea8122a8:	17ffffa9 	b	ffffffffea81214c <heap_alloc+0x17c>
		TRACEF("failed to grow kernel heap by 0x%zx bytes\n", size);
ffffffffea8122ac:	aa1603e3 	mov	x3, x22
ffffffffea8122b0:	b0000021 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea8122b4:	b0000020 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea8122b8:	528036c2 	mov	w2, #0x1b6                 	// #438
ffffffffea8122bc:	91322021 	add	x1, x1, #0xc88
ffffffffea8122c0:	91326000 	add	x0, x0, #0xc98
ffffffffea8122c4:	940003db 	bl	ffffffffea813230 <_printf>
ffffffffea8122c8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8122cc:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea8122d0:	17ffffcf 	b	ffffffffea81220c <heap_alloc+0x23c>
ffffffffea8122d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8122d8 <heap_free>:
	if (ptr == 0)
ffffffffea8122d8:	b40000a0 	cbz	x0, ffffffffea8122ec <heap_free+0x14>
	chunk->len = len;
ffffffffea8122dc:	a97f0801 	ldp	x1, x2, [x0, #-16]
ffffffffea8122e0:	f9000822 	str	x2, [x1, #16]
	heap_insert_free_chunk(heap_create_free_chunk(as->ptr, as->size, true));
ffffffffea8122e4:	aa0103e0 	mov	x0, x1
ffffffffea8122e8:	17fffe94 	b	ffffffffea811d38 <heap_insert_free_chunk>
}
ffffffffea8122ec:	d65f03c0 	ret

ffffffffea8122f0 <heap_delayed_free>:
{
ffffffffea8122f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8122f4:	910003fd 	mov	x29, sp
ffffffffea8122f8:	a90153f3 	stp	x19, x20, [sp, #16]
	chunk->len = len;
ffffffffea8122fc:	a97f0013 	ldp	x19, x0, [x0, #-16]
{
ffffffffea812300:	f90013f5 	str	x21, [sp, #32]
	chunk->len = len;
ffffffffea812304:	f9000a60 	str	x0, [x19, #16]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea812308:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea81230c:	37380280 	tbnz	w0, #7, ffffffffea81235c <heap_delayed_free+0x6c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea812310:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea812314:	f0000254 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea812318:	913d2294 	add	x20, x20, #0xf48
ffffffffea81231c:	9101e295 	add	x21, x20, #0x78
ffffffffea812320:	aa1503e0 	mov	x0, x21
ffffffffea812324:	97ffc15d 	bl	ffffffffea802898 <arch_spin_lock>
	item->next = list->next;
ffffffffea812328:	f9403a80 	ldr	x0, [x20, #112]
	item->prev = list;
ffffffffea81232c:	9101a281 	add	x1, x20, #0x68
	item->next = list->next;
ffffffffea812330:	a9000261 	stp	x1, x0, [x19]
    arch_spin_unlock(lock);
ffffffffea812334:	aa1503e0 	mov	x0, x21
	list->next->prev = item;
ffffffffea812338:	f9403a81 	ldr	x1, [x20, #112]
ffffffffea81233c:	f9000033 	str	x19, [x1]
	list->next = item;
ffffffffea812340:	f9003a93 	str	x19, [x20, #112]
ffffffffea812344:	97ffc15d 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea812348:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea81234c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812350:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea812354:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea812358:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea81235c:	f0000254 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea812360:	913d2294 	add	x20, x20, #0xf48
ffffffffea812364:	9101e295 	add	x21, x20, #0x78
ffffffffea812368:	aa1503e0 	mov	x0, x21
ffffffffea81236c:	97ffc14b 	bl	ffffffffea802898 <arch_spin_lock>
	item->next = list->next;
ffffffffea812370:	f9403a80 	ldr	x0, [x20, #112]
	item->prev = list;
ffffffffea812374:	9101a281 	add	x1, x20, #0x68
	item->next = list->next;
ffffffffea812378:	a9000261 	stp	x1, x0, [x19]
    arch_spin_unlock(lock);
ffffffffea81237c:	aa1503e0 	mov	x0, x21
ffffffffea812380:	f94013f5 	ldr	x21, [sp, #32]
	list->next->prev = item;
ffffffffea812384:	f9403a81 	ldr	x1, [x20, #112]
ffffffffea812388:	f9000033 	str	x19, [x1]
	list->next = item;
ffffffffea81238c:	f9003a93 	str	x19, [x20, #112]
ffffffffea812390:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812394:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea812398:	17ffc148 	b	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea81239c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8123a0 <heap_init>:
	return ERR_NO_MEMORY;
#endif
}

void heap_init(void)
{
ffffffffea8123a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8123a4:	910003fd 	mov	x29, sp
ffffffffea8123a8:	a90153f3 	stp	x19, x20, [sp, #16]
	LTRACE_ENTRY;

	// create a mutex
	mutex_init(&theheap.lock);
ffffffffea8123ac:	f0000254 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8123b0:	913d2293 	add	x19, x20, #0xf48
{
ffffffffea8123b4:	f90013f5 	str	x21, [sp, #32]
	mutex_init(&theheap.lock);
ffffffffea8123b8:	91008260 	add	x0, x19, #0x20
ffffffffea8123bc:	aa1e03f5 	mov	x21, x30
ffffffffea8123c0:	97ffcd72 	bl	ffffffffea805988 <mutex_init>
	list->prev = list->next = list;
ffffffffea8123c4:	91016261 	add	x1, x19, #0x58
ffffffffea8123c8:	9101a260 	add	x0, x19, #0x68
ffffffffea8123cc:	a9058661 	stp	x1, x1, [x19, #88]
	list_initialize(&theheap.delayed_free_list);
	spin_lock_init(&theheap.delayed_free_lock);

	// set the heap range
#if WITH_KERNEL_VM
	theheap.base = pmm_alloc_kpages(HEAP_GROW_SIZE / PAGE_SIZE, NULL);
ffffffffea8123d0:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8123d4:	a9068260 	stp	x0, x0, [x19, #104]
ffffffffea8123d8:	52800200 	mov	w0, #0x10                  	// #16
    *lock = SPIN_LOCK_INITIAL_VALUE;
ffffffffea8123dc:	f9003e7f 	str	xzr, [x19, #120]
ffffffffea8123e0:	97fffa28 	bl	ffffffffea810c80 <pmm_alloc_kpages>
	theheap.len = HEAP_GROW_SIZE;
ffffffffea8123e4:	d2a00022 	mov	x2, #0x10000               	// #65536
	theheap.base = pmm_alloc_kpages(HEAP_GROW_SIZE / PAGE_SIZE, NULL);
ffffffffea8123e8:	f907a680 	str	x0, [x20, #3912]
	theheap.len = HEAP_GROW_SIZE;
ffffffffea8123ec:	f9000662 	str	x2, [x19, #8]

	if (theheap.base == 0) {
ffffffffea8123f0:	b40000e0 	cbz	x0, ffffffffea81240c <heap_init+0x6c>
#else
	theheap.base = (void *)HEAP_START;
	theheap.len = HEAP_LEN;
#endif
	theheap.remaining = 0; // will get set by heap_insert_free_chunk()
	theheap.low_watermark = theheap.len;
ffffffffea8123f4:	a9010a7f 	stp	xzr, x2, [x19, #16]
	LTRACEF("base %p size %zd bytes\n", theheap.base, theheap.len);

	// create an initial free chunk
	heap_insert_free_chunk(heap_create_free_chunk(theheap.base, theheap.len, false));
}
ffffffffea8123f8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8123fc:	f94013f5 	ldr	x21, [sp, #32]
	chunk->len = len;
ffffffffea812400:	f9000802 	str	x2, [x0, #16]
}
ffffffffea812404:	a8c37bfd 	ldp	x29, x30, [sp], #48
	heap_insert_free_chunk(heap_create_free_chunk(theheap.base, theheap.len, false));
ffffffffea812408:	17fffe4c 	b	ffffffffea811d38 <heap_insert_free_chunk>
		panic("HEAP: error allocating initial heap size\n");
ffffffffea81240c:	b0000021 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea812410:	aa1503e0 	mov	x0, x21
ffffffffea812414:	91334021 	add	x1, x1, #0xcd0
ffffffffea812418:	97fffe20 	bl	ffffffffea811c98 <_panic>
ffffffffea81241c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812420 <strtoul>:
	}

	return value;
}

unsigned long strtoul(const char *nptr, char **endptr, int base) {
ffffffffea812420:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	int neg = 0;
	unsigned long ret = 0;

	if (base < 0 || base == 1 || base > 36) {
ffffffffea812424:	7100045f 	cmp	w2, #0x1
unsigned long strtoul(const char *nptr, char **endptr, int base) {
ffffffffea812428:	910003fd 	mov	x29, sp
ffffffffea81242c:	f9000bf3 	str	x19, [sp, #16]
ffffffffea812430:	aa0003f3 	mov	x19, x0
ffffffffea812434:	f90013f5 	str	x21, [sp, #32]
	if (base < 0 || base == 1 || base > 36) {
ffffffffea812438:	1a9f17f5 	cset	w21, eq  // eq = none
ffffffffea81243c:	7100905f 	cmp	w2, #0x24
ffffffffea812440:	1a9f97e0 	cset	w0, hi  // hi = pmore
ffffffffea812444:	2a0002b5 	orr	w21, w21, w0
ffffffffea812448:	34000155 	cbz	w21, ffffffffea812470 <strtoul+0x50>
		errno = EINVAL;
ffffffffea81244c:	9400006f 	bl	ffffffffea812608 <__geterrno>
	if (neg && ret != ULONG_MAX) {
		ret = -ret;
	}

	return ret;
}
ffffffffea812450:	f9400bf3 	ldr	x19, [sp, #16]
		errno = EINVAL;
ffffffffea812454:	528002c2 	mov	w2, #0x16                  	// #22
ffffffffea812458:	b9000002 	str	w2, [x0]
		return 0;
ffffffffea81245c:	d2800001 	mov	x1, #0x0                   	// #0
}
ffffffffea812460:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea812464:	aa0103e0 	mov	x0, x1
ffffffffea812468:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea81246c:	d65f03c0 	ret
ffffffffea812470:	f9000fb4 	str	x20, [x29, #24]
ffffffffea812474:	2a0203f4 	mov	w20, w2
ffffffffea812478:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea81247c:	aa0103f7 	mov	x23, x1
ffffffffea812480:	f9001fb8 	str	x24, [x29, #56]
ffffffffea812484:	14000002 	b	ffffffffea81248c <strtoul+0x6c>
		nptr++;
ffffffffea812488:	91000673 	add	x19, x19, #0x1
	while (isspace(*nptr)) {
ffffffffea81248c:	39400260 	ldrb	w0, [x19]
ffffffffea812490:	94000056 	bl	ffffffffea8125e8 <isspace>
ffffffffea812494:	35ffffa0 	cbnz	w0, ffffffffea812488 <strtoul+0x68>
	if (*nptr == '+') {
ffffffffea812498:	39400260 	ldrb	w0, [x19]
ffffffffea81249c:	7100ac1f 	cmp	w0, #0x2b
ffffffffea8124a0:	54000800 	b.eq	ffffffffea8125a0 <strtoul+0x180>  // b.none
	} else if (*nptr == '-') {
ffffffffea8124a4:	7100b41f 	cmp	w0, #0x2d
ffffffffea8124a8:	54000740 	b.eq	ffffffffea812590 <strtoul+0x170>  // b.none
	if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
ffffffffea8124ac:	721b7a9f 	tst	w20, #0xffffffef
ffffffffea8124b0:	54000640 	b.eq	ffffffffea812578 <strtoul+0x158>  // b.none
		if (c >= 'A' && c <= 'Z') {
ffffffffea8124b4:	51010402 	sub	w2, w0, #0x41
		new_ret = ret * base;
ffffffffea8124b8:	93407e98 	sxtw	x24, w20
		if (c >= 'A' && c <= 'Z') {
ffffffffea8124bc:	12001c42 	and	w2, w2, #0xff
		base = 10;
ffffffffea8124c0:	d2800001 	mov	x1, #0x0                   	// #0
			errno = ERANGE;
ffffffffea8124c4:	52800456 	mov	w22, #0x22                  	// #34
		if (c >= 'A' && c <= 'Z') {
ffffffffea8124c8:	7100645f 	cmp	w2, #0x19
ffffffffea8124cc:	540002a8 	b.hi	ffffffffea812520 <strtoul+0x100>  // b.pmore
			v = c - 'A' + 10;
ffffffffea8124d0:	5100dc00 	sub	w0, w0, #0x37
		if (v < 0 || v >= base) {
ffffffffea8124d4:	6b00029f 	cmp	w20, w0
ffffffffea8124d8:	54000389 	b.ls	ffffffffea812548 <strtoul+0x128>  // b.plast
		new_ret = ret * base;
ffffffffea8124dc:	9b017f02 	mul	x2, x24, x1
		if (new_ret / base != ret ||
ffffffffea8124e0:	9ad80843 	udiv	x3, x2, x24
ffffffffea8124e4:	eb01007f 	cmp	x3, x1
ffffffffea8124e8:	540000c1 	b.ne	ffffffffea812500 <strtoul+0xe0>  // b.any
		    new_ret + v < new_ret ||
ffffffffea8124ec:	8b20c040 	add	x0, x2, w0, sxtw
ffffffffea8124f0:	eb02001f 	cmp	x0, x2
ffffffffea8124f4:	ba412824 	ccmn	x1, #0x1, #0x4, cs  // cs = hs, nlast
ffffffffea8124f8:	aa0003e1 	mov	x1, x0
ffffffffea8124fc:	54000081 	b.ne	ffffffffea81250c <strtoul+0xec>  // b.any
			errno = ERANGE;
ffffffffea812500:	94000042 	bl	ffffffffea812608 <__geterrno>
ffffffffea812504:	b9000016 	str	w22, [x0]
			ret = ULONG_MAX;
ffffffffea812508:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
ffffffffea81250c:	38401e60 	ldrb	w0, [x19, #1]!
		if (c >= 'A' && c <= 'Z') {
ffffffffea812510:	51010402 	sub	w2, w0, #0x41
ffffffffea812514:	12001c42 	and	w2, w2, #0xff
ffffffffea812518:	7100645f 	cmp	w2, #0x19
ffffffffea81251c:	54fffda9 	b.ls	ffffffffea8124d0 <strtoul+0xb0>  // b.plast
		} else if (c >= 'a' && c <= 'z') {
ffffffffea812520:	51018402 	sub	w2, w0, #0x61
ffffffffea812524:	12001c42 	and	w2, w2, #0xff
ffffffffea812528:	7100645f 	cmp	w2, #0x19
ffffffffea81252c:	54000068 	b.hi	ffffffffea812538 <strtoul+0x118>  // b.pmore
			v = c - 'a' + 10;
ffffffffea812530:	51015c00 	sub	w0, w0, #0x57
ffffffffea812534:	17ffffe8 	b	ffffffffea8124d4 <strtoul+0xb4>
		} else if (c >= '0' && c <= '9') {
ffffffffea812538:	5100c000 	sub	w0, w0, #0x30
ffffffffea81253c:	12001c02 	and	w2, w0, #0xff
ffffffffea812540:	7100245f 	cmp	w2, #0x9
ffffffffea812544:	54fffc89 	b.ls	ffffffffea8124d4 <strtoul+0xb4>  // b.plast
	if (neg && ret != ULONG_MAX) {
ffffffffea812548:	710002bf 	cmp	w21, #0x0
ffffffffea81254c:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea812550:	f9401fb8 	ldr	x24, [x29, #56]
		ret = -ret;
ffffffffea812554:	ba411824 	ccmn	x1, #0x1, #0x4, ne  // ne = any
			*endptr = (char *) nptr;
ffffffffea812558:	f90002f3 	str	x19, [x23]
		ret = -ret;
ffffffffea81255c:	da810421 	cneg	x1, x1, ne  // ne = any
ffffffffea812560:	a942dfb6 	ldp	x22, x23, [x29, #40]
}
ffffffffea812564:	aa0103e0 	mov	x0, x1
ffffffffea812568:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea81256c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea812570:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea812574:	d65f03c0 	ret
	if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
ffffffffea812578:	7100c01f 	cmp	w0, #0x30
ffffffffea81257c:	540001c0 	b.eq	ffffffffea8125b4 <strtoul+0x194>  // b.none
		base = 10;
ffffffffea812580:	7100029f 	cmp	w20, #0x0
ffffffffea812584:	52800141 	mov	w1, #0xa                   	// #10
ffffffffea812588:	1a811294 	csel	w20, w20, w1, ne  // ne = any
ffffffffea81258c:	17ffffca 	b	ffffffffea8124b4 <strtoul+0x94>
ffffffffea812590:	39400660 	ldrb	w0, [x19, #1]
		nptr++;
ffffffffea812594:	52800035 	mov	w21, #0x1                   	// #1
ffffffffea812598:	91000673 	add	x19, x19, #0x1
ffffffffea81259c:	17ffffc4 	b	ffffffffea8124ac <strtoul+0x8c>
ffffffffea8125a0:	39400660 	ldrb	w0, [x19, #1]
	if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
ffffffffea8125a4:	721b7a9f 	tst	w20, #0xffffffef
		nptr++;
ffffffffea8125a8:	91000673 	add	x19, x19, #0x1
	if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
ffffffffea8125ac:	54fff841 	b.ne	ffffffffea8124b4 <strtoul+0x94>  // b.any
ffffffffea8125b0:	17fffff2 	b	ffffffffea812578 <strtoul+0x158>
ffffffffea8125b4:	39400661 	ldrb	w1, [x19, #1]
ffffffffea8125b8:	7101e03f 	cmp	w1, #0x78
ffffffffea8125bc:	540000c0 	b.eq	ffffffffea8125d4 <strtoul+0x1b4>  // b.none
	} else if (base == 0 && nptr[0] == '0') {
ffffffffea8125c0:	35fff7b4 	cbnz	w20, ffffffffea8124b4 <strtoul+0x94>
		nptr++;
ffffffffea8125c4:	91000673 	add	x19, x19, #0x1
ffffffffea8125c8:	2a0103e0 	mov	w0, w1
		base = 8;
ffffffffea8125cc:	52800114 	mov	w20, #0x8                   	// #8
		nptr++;
ffffffffea8125d0:	17ffffb9 	b	ffffffffea8124b4 <strtoul+0x94>
ffffffffea8125d4:	39400a60 	ldrb	w0, [x19, #2]
		base = 16;
ffffffffea8125d8:	52800214 	mov	w20, #0x10                  	// #16
		nptr += 2;
ffffffffea8125dc:	91000a73 	add	x19, x19, #0x2
ffffffffea8125e0:	17ffffb5 	b	ffffffffea8124b4 <strtoul+0x94>
ffffffffea8125e4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8125e8 <isspace>:
	return (c == ' ' || c == '\t');
}

int isspace(int c)
{
	return (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v');
ffffffffea8125e8:	7100801f 	cmp	w0, #0x20
ffffffffea8125ec:	540000a0 	b.eq	ffffffffea812600 <isspace+0x18>  // b.none
ffffffffea8125f0:	51002400 	sub	w0, w0, #0x9
ffffffffea8125f4:	7100101f 	cmp	w0, #0x4
ffffffffea8125f8:	1a9f87e0 	cset	w0, ls  // ls = plast
}
ffffffffea8125fc:	d65f03c0 	ret
	return (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v');
ffffffffea812600:	52800020 	mov	w0, #0x1                   	// #1
}
ffffffffea812604:	d65f03c0 	ret

ffffffffea812608 <__geterrno>:
/* TODO: pull from kernel TLS or some other thread local storage */
static int _errno;

int *__geterrno(void)
{
    return &_errno;
ffffffffea812608:	f0000240 	adrp	x0, ffffffffea85d000 <idle_threads+0xeb0>
}
ffffffffea81260c:	913f2000 	add	x0, x0, #0xfc8
ffffffffea812610:	d65f03c0 	ret
ffffffffea812614:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812618 <_vsnprintf_output>:
static int _vsnprintf_output(const char *str, size_t len, void *state)
{
	struct _output_args *args = state;

	size_t count = 0;
	while (count < len && *str) {
ffffffffea812618:	b40002c1 	cbz	x1, ffffffffea812670 <_vsnprintf_output+0x58>
ffffffffea81261c:	39400003 	ldrb	w3, [x0]
ffffffffea812620:	34000283 	cbz	w3, ffffffffea812670 <_vsnprintf_output+0x58>
	size_t count = 0;
ffffffffea812624:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea812628:	14000003 	b	ffffffffea812634 <_vsnprintf_output+0x1c>
	while (count < len && *str) {
ffffffffea81262c:	38636804 	ldrb	w4, [x0, x3]
ffffffffea812630:	340001c4 	cbz	w4, ffffffffea812668 <_vsnprintf_output+0x50>
		if (args->pos < args->len) {
ffffffffea812634:	a9409045 	ldp	x5, x4, [x2, #8]
			args->outstr[args->pos++] = *str;
ffffffffea812638:	91000486 	add	x6, x4, #0x1
		if (args->pos < args->len) {
ffffffffea81263c:	eb05009f 	cmp	x4, x5
ffffffffea812640:	540000a2 	b.cs	ffffffffea812654 <_vsnprintf_output+0x3c>  // b.hs, b.nlast
			args->outstr[args->pos++] = *str;
ffffffffea812644:	f9000846 	str	x6, [x2, #16]
ffffffffea812648:	f9400045 	ldr	x5, [x2]
ffffffffea81264c:	38636806 	ldrb	w6, [x0, x3]
ffffffffea812650:	382468a6 	strb	w6, [x5, x4]
		}

		str++;
		count++;
ffffffffea812654:	91000463 	add	x3, x3, #0x1
	while (count < len && *str) {
ffffffffea812658:	eb03003f 	cmp	x1, x3
ffffffffea81265c:	54fffe81 	b.ne	ffffffffea81262c <_vsnprintf_output+0x14>  // b.any
ffffffffea812660:	2a0103e0 	mov	w0, w1
	}

	return count;
}
ffffffffea812664:	d65f03c0 	ret
ffffffffea812668:	2a0303e0 	mov	w0, w3
ffffffffea81266c:	d65f03c0 	ret
	while (count < len && *str) {
ffffffffea812670:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea812674:	d65f03c0 	ret

ffffffffea812678 <longlong_to_string.constprop.0>:
	int negative = 0;
ffffffffea812678:	52800009 	mov	w9, #0x0                   	// #0
	if ((flag & SIGNEDFLAG) && (long long)n < 0) {
ffffffffea81267c:	36500042 	tbz	w2, #10, ffffffffea812684 <longlong_to_string.constprop.0+0xc>
ffffffffea812680:	b7f80481 	tbnz	x1, #63, ffffffffea812710 <longlong_to_string.constprop.0+0x98>
	buf[--pos] = 0;
ffffffffea812684:	39007c1f 	strb	wzr, [x0, #31]
	while (n >= 10) {
ffffffffea812688:	f100243f 	cmp	x1, #0x9
ffffffffea81268c:	540004e9 	b.ls	ffffffffea812728 <longlong_to_string.constprop.0+0xb0>  // b.plast
		int digit = n % 10;
ffffffffea812690:	b202e7e8 	mov	x8, #0xcccccccccccccccc    	// #-3689348814741910324
	buf[--pos] = 0;
ffffffffea812694:	d28003e7 	mov	x7, #0x1f                  	// #31
		int digit = n % 10;
ffffffffea812698:	f29999a8 	movk	x8, #0xcccd
ffffffffea81269c:	14000002 	b	ffffffffea8126a4 <longlong_to_string.constprop.0+0x2c>
		buf[--pos] = digit + '0';
ffffffffea8126a0:	aa0603e7 	mov	x7, x6
		int digit = n % 10;
ffffffffea8126a4:	9bc87c25 	umulh	x5, x1, x8
		buf[--pos] = digit + '0';
ffffffffea8126a8:	d10004e6 	sub	x6, x7, #0x1
		int digit = n % 10;
ffffffffea8126ac:	d343fca4 	lsr	x4, x5, #3
ffffffffea8126b0:	8b040884 	add	x4, x4, x4, lsl #2
ffffffffea8126b4:	cb040424 	sub	x4, x1, x4, lsl #1
		n /= 10;
ffffffffea8126b8:	d343fca1 	lsr	x1, x5, #3
		buf[--pos] = digit + '0';
ffffffffea8126bc:	1100c084 	add	w4, w4, #0x30
ffffffffea8126c0:	38266804 	strb	w4, [x0, x6]
	while (n >= 10) {
ffffffffea8126c4:	f100243f 	cmp	x1, #0x9
ffffffffea8126c8:	54fffec8 	b.hi	ffffffffea8126a0 <longlong_to_string.constprop.0+0x28>  // b.pmore
ffffffffea8126cc:	d10008e7 	sub	x7, x7, #0x2
	buf[--pos] = n + '0';
ffffffffea8126d0:	1100c021 	add	w1, w1, #0x30
ffffffffea8126d4:	38276801 	strb	w1, [x0, x7]
ffffffffea8126d8:	8b070000 	add	x0, x0, x7
	if (negative)
ffffffffea8126dc:	35000149 	cbnz	w9, ffffffffea812704 <longlong_to_string.constprop.0+0x8c>
	else if ((flag & SHOWSIGNFLAG))
ffffffffea8126e0:	374800c2 	tbnz	w2, #9, ffffffffea8126f8 <longlong_to_string.constprop.0+0x80>
		*signchar = ' ';
ffffffffea8126e4:	f273005f 	tst	x2, #0x2000
ffffffffea8126e8:	52800401 	mov	w1, #0x20                  	// #32
ffffffffea8126ec:	1a9f1021 	csel	w1, w1, wzr, ne  // ne = any
ffffffffea8126f0:	39000061 	strb	w1, [x3]
}
ffffffffea8126f4:	d65f03c0 	ret
		*signchar = '+';
ffffffffea8126f8:	52800561 	mov	w1, #0x2b                  	// #43
ffffffffea8126fc:	39000061 	strb	w1, [x3]
}
ffffffffea812700:	d65f03c0 	ret
		*signchar = '-';
ffffffffea812704:	528005a1 	mov	w1, #0x2d                  	// #45
ffffffffea812708:	39000061 	strb	w1, [x3]
}
ffffffffea81270c:	d65f03c0 	ret
	buf[--pos] = 0;
ffffffffea812710:	39007c1f 	strb	wzr, [x0, #31]
		n = -n;
ffffffffea812714:	cb0103e1 	neg	x1, x1
		negative = 1;
ffffffffea812718:	52800029 	mov	w9, #0x1                   	// #1
	while (n >= 10) {
ffffffffea81271c:	f100243f 	cmp	x1, #0x9
ffffffffea812720:	54fffb88 	b.hi	ffffffffea812690 <longlong_to_string.constprop.0+0x18>  // b.pmore
ffffffffea812724:	d503201f 	nop
ffffffffea812728:	d28003c7 	mov	x7, #0x1e                  	// #30
ffffffffea81272c:	17ffffe9 	b	ffffffffea8126d0 <longlong_to_string.constprop.0+0x58>

ffffffffea812730 <longlong_to_hexstring.constprop.1>:
	const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
ffffffffea812730:	7218005f 	tst	w2, #0x100
ffffffffea812734:	b0000023 	adrp	x3, ffffffffea817000 <__func__.2428+0x420>
ffffffffea812738:	b0000024 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea81273c:	91370063 	add	x3, x3, #0xdc0
ffffffffea812740:	91374084 	add	x4, x4, #0xdd0
ffffffffea812744:	91007802 	add	x2, x0, #0x1e
ffffffffea812748:	9a831084 	csel	x4, x4, x3, ne  // ne = any
	buf[--pos] = 0;
ffffffffea81274c:	39007c1f 	strb	wzr, [x0, #31]
		unsigned int digit = u % 16;
ffffffffea812750:	12000c23 	and	w3, w1, #0xf
		buf[--pos] = table[digit];
ffffffffea812754:	aa0203e0 	mov	x0, x2
		u /= 16;
ffffffffea812758:	d344fc21 	lsr	x1, x1, #4
		buf[--pos] = table[digit];
ffffffffea81275c:	38634883 	ldrb	w3, [x4, w3, uxtw]
ffffffffea812760:	381ff443 	strb	w3, [x2], #-1
	} while (u != 0);
ffffffffea812764:	b5ffff61 	cbnz	x1, ffffffffea812750 <longlong_to_hexstring.constprop.1+0x20>
}
ffffffffea812768:	d65f03c0 	ret
ffffffffea81276c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812770 <_printf_engine>:
		str[wlen] = '\0';
	return wlen;
}

int _printf_engine(_printf_engine_output_func out, void *state, const char *fmt, va_list ap)
{
ffffffffea812770:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
ffffffffea812774:	910003fd 	mov	x29, sp
ffffffffea812778:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81277c:	aa0003f4 	mov	x20, x0
ffffffffea812780:	aa0203e0 	mov	x0, x2
ffffffffea812784:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea812788:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea81278c:	aa0103f5 	mov	x21, x1
ffffffffea812790:	b9401878 	ldr	w24, [x3, #24]
		/* grab the next format character */
		c = *fmt++;
		if (c == 0)
			break;

		switch (c) {
ffffffffea812794:	b0000036 	adrp	x22, ffffffffea817000 <__func__.2428+0x420>
ffffffffea812798:	a9400477 	ldp	x23, x1, [x3]
{
ffffffffea81279c:	f9002ffc 	str	x28, [sp, #88]
ffffffffea8127a0:	f9003ba1 	str	x1, [x29, #112]
	size_t chars_written = 0;
ffffffffea8127a4:	d2800013 	mov	x19, #0x0                   	// #0
		while ((c = *fmt++) != 0) {
ffffffffea8127a8:	39400001 	ldrb	w1, [x0]
		switch (c) {
ffffffffea8127ac:	9133f2d6 	add	x22, x22, #0xcfc
		signchar = '\0';
ffffffffea8127b0:	39023fbf 	strb	wzr, [x29, #143]
		while ((c = *fmt++) != 0) {
ffffffffea8127b4:	9100041c 	add	x28, x0, #0x1
ffffffffea8127b8:	34001101 	cbz	w1, ffffffffea8129d8 <_printf_engine+0x268>
			if (c == '%')
ffffffffea8127bc:	7100943f 	cmp	w1, #0x25
ffffffffea8127c0:	54000081 	b.ne	ffffffffea8127d0 <_printf_engine+0x60>  // b.any
ffffffffea8127c4:	1400000f 	b	ffffffffea812800 <_printf_engine+0x90>
ffffffffea8127c8:	7100945f 	cmp	w2, #0x25
ffffffffea8127cc:	540001e0 	b.eq	ffffffffea812808 <_printf_engine+0x98>  // b.none
ffffffffea8127d0:	cb000381 	sub	x1, x28, x0
		while ((c = *fmt++) != 0) {
ffffffffea8127d4:	38401782 	ldrb	w2, [x28], #1
ffffffffea8127d8:	35ffff82 	cbnz	w2, ffffffffea8127c8 <_printf_engine+0x58>
		OUTPUT_STRING(s, string_len);
ffffffffea8127dc:	aa1503e2 	mov	x2, x21
ffffffffea8127e0:	d63f0280 	blr	x20
ffffffffea8127e4:	36f82780 	tbz	w0, #31, ffffffffea812cd4 <_printf_engine+0x564>
#undef OUTPUT_STRING
#undef OUTPUT_CHAR

exit:
	return (err < 0) ? err : (int)chars_written;
}
ffffffffea8127e8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8127ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8127f0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8127f4:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea8127f8:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea8127fc:	d65f03c0 	ret
		string_len = 0;
ffffffffea812800:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea812804:	d503201f 	nop
		OUTPUT_STRING(s, string_len);
ffffffffea812808:	aa1503e2 	mov	x2, x21
ffffffffea81280c:	d63f0280 	blr	x20
ffffffffea812810:	37fffec0 	tbnz	w0, #31, ffffffffea8127e8 <_printf_engine+0x78>
ffffffffea812814:	8b20c273 	add	x19, x19, w0, sxtw
ffffffffea812818:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea81281c:	f9002bbb 	str	x27, [x29, #80]
		flags = 0;
ffffffffea812820:	52800019 	mov	w25, #0x0                   	// #0
		format_num = 0;
ffffffffea812824:	5280001b 	mov	w27, #0x0                   	// #0
		c = *fmt++;
ffffffffea812828:	3840179a 	ldrb	w26, [x28], #1
		if (c == 0)
ffffffffea81282c:	34001b3a 	cbz	w26, ffffffffea812b90 <_printf_engine+0x420>
		switch (c) {
ffffffffea812830:	51008340 	sub	w0, w26, #0x20
ffffffffea812834:	7101681f 	cmp	w0, #0x5a
ffffffffea812838:	540002e9 	b.ls	ffffffffea812894 <_printf_engine+0x124>  // b.plast
				OUTPUT_CHAR('%');
ffffffffea81283c:	528004a0 	mov	w0, #0x25                  	// #37
ffffffffea812840:	390223a0 	strb	w0, [x29, #136]
ffffffffea812844:	aa1503e2 	mov	x2, x21
ffffffffea812848:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea81284c:	910223a0 	add	x0, x29, #0x88
ffffffffea812850:	d63f0280 	blr	x20
ffffffffea812854:	2a0003f9 	mov	w25, w0
ffffffffea812858:	37f82040 	tbnz	w0, #31, ffffffffea812c60 <_printf_engine+0x4f0>
				OUTPUT_CHAR(c);
ffffffffea81285c:	390223ba 	strb	w26, [x29, #136]
ffffffffea812860:	aa1503e2 	mov	x2, x21
ffffffffea812864:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea812868:	910223a0 	add	x0, x29, #0x88
ffffffffea81286c:	d63f0280 	blr	x20
ffffffffea812870:	36f818c0 	tbz	w0, #31, ffffffffea812b88 <_printf_engine+0x418>
ffffffffea812874:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea812878:	f9402bbb 	ldr	x27, [x29, #80]
}
ffffffffea81287c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812880:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea812884:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea812888:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea81288c:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea812890:	d65f03c0 	ret
		switch (c) {
ffffffffea812894:	78605ac0 	ldrh	w0, [x22, w0, uxtw #1]
ffffffffea812898:	10000061 	adr	x1, ffffffffea8128a4 <_printf_engine+0x134>
ffffffffea81289c:	8b20a820 	add	x0, x1, w0, sxth #2
ffffffffea8128a0:	d61f0000 	br	x0
				flags |= CAPSFLAG;
ffffffffea8128a4:	32180339 	orr	w25, w25, #0x100
				n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
ffffffffea8128a8:	360806b9 	tbz	w25, #1, ffffffffea81297c <_printf_engine+0x20c>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea8128ac:	37f82a58 	tbnz	w24, #31, ffffffffea812df4 <_printf_engine+0x684>
ffffffffea8128b0:	91003ee1 	add	x1, x23, #0xf
ffffffffea8128b4:	aa1703e0 	mov	x0, x23
ffffffffea8128b8:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea8128bc:	f9400001 	ldr	x1, [x0]
				s = longlong_to_hexstring(num_buffer, n, sizeof(num_buffer), flags);
ffffffffea8128c0:	2a1903e2 	mov	w2, w25
ffffffffea8128c4:	910243a0 	add	x0, x29, #0x90
ffffffffea8128c8:	97ffff9a 	bl	ffffffffea812730 <longlong_to_hexstring.constprop.1>
ffffffffea8128cc:	aa0003fa 	mov	x26, x0
				if (flags & ALTFLAG) {
ffffffffea8128d0:	36380299 	tbz	w25, #7, ffffffffea812920 <_printf_engine+0x1b0>
					OUTPUT_CHAR('0');
ffffffffea8128d4:	52800600 	mov	w0, #0x30                  	// #48
ffffffffea8128d8:	390223a0 	strb	w0, [x29, #136]
ffffffffea8128dc:	aa1503e2 	mov	x2, x21
ffffffffea8128e0:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8128e4:	910223a0 	add	x0, x29, #0x88
ffffffffea8128e8:	d63f0280 	blr	x20
ffffffffea8128ec:	37fffc40 	tbnz	w0, #31, ffffffffea812874 <_printf_engine+0x104>
					OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
ffffffffea8128f0:	f278033f 	tst	x25, #0x100
ffffffffea8128f4:	52800b01 	mov	w1, #0x58                  	// #88
					OUTPUT_CHAR('0');
ffffffffea8128f8:	8b20c273 	add	x19, x19, w0, sxtw
					OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
ffffffffea8128fc:	52800f00 	mov	w0, #0x78                  	// #120
ffffffffea812900:	1a810000 	csel	w0, w0, w1, eq  // eq = none
ffffffffea812904:	390223a0 	strb	w0, [x29, #136]
ffffffffea812908:	aa1503e2 	mov	x2, x21
ffffffffea81290c:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea812910:	910223a0 	add	x0, x29, #0x88
ffffffffea812914:	d63f0280 	blr	x20
ffffffffea812918:	37fffae0 	tbnz	w0, #31, ffffffffea812874 <_printf_engine+0x104>
ffffffffea81291c:	8b20c273 	add	x19, x19, w0, sxtw
		if (flags & LEFTFORMATFLAG) {
ffffffffea812920:	36580ab9 	tbz	w25, #11, ffffffffea812a74 <_printf_engine+0x304>
			OUTPUT_STRING(s, SIZE_MAX);
ffffffffea812924:	aa1503e2 	mov	x2, x21
ffffffffea812928:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
ffffffffea81292c:	aa1a03e0 	mov	x0, x26
ffffffffea812930:	d63f0280 	blr	x20
ffffffffea812934:	37fffa00 	tbnz	w0, #31, ffffffffea812874 <_printf_engine+0x104>
			uint written = err;
ffffffffea812938:	2a0003f9 	mov	w25, w0
			OUTPUT_STRING(s, SIZE_MAX);
ffffffffea81293c:	8b20c273 	add	x19, x19, w0, sxtw
			for (; format_num > written; format_num--)
ffffffffea812940:	6b00037f 	cmp	w27, w0
ffffffffea812944:	540003c9 	b.ls	ffffffffea8129bc <_printf_engine+0x24c>  // b.plast
				OUTPUT_CHAR(' ');
ffffffffea812948:	5280041a 	mov	w26, #0x20                  	// #32
ffffffffea81294c:	14000005 	b	ffffffffea812960 <_printf_engine+0x1f0>
			for (; format_num > written; format_num--)
ffffffffea812950:	5100077b 	sub	w27, w27, #0x1
				OUTPUT_CHAR(' ');
ffffffffea812954:	8b20c273 	add	x19, x19, w0, sxtw
			for (; format_num > written; format_num--)
ffffffffea812958:	6b1b033f 	cmp	w25, w27
ffffffffea81295c:	54000300 	b.eq	ffffffffea8129bc <_printf_engine+0x24c>  // b.none
				OUTPUT_CHAR(' ');
ffffffffea812960:	390223ba 	strb	w26, [x29, #136]
ffffffffea812964:	aa1503e2 	mov	x2, x21
ffffffffea812968:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea81296c:	910223a0 	add	x0, x29, #0x88
ffffffffea812970:	d63f0280 	blr	x20
ffffffffea812974:	36fffee0 	tbz	w0, #31, ffffffffea812950 <_printf_engine+0x1e0>
ffffffffea812978:	17ffffbf 	b	ffffffffea812874 <_printf_engine+0x104>
				    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
ffffffffea81297c:	3707f999 	tbnz	w25, #0, ffffffffea8128ac <_printf_engine+0x13c>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea812980:	361811b9 	tbz	w25, #3, ffffffffea812bb4 <_printf_engine+0x444>
ffffffffea812984:	37f83bd8 	tbnz	w24, #31, ffffffffea8130fc <_printf_engine+0x98c>
ffffffffea812988:	aa1703e0 	mov	x0, x23
ffffffffea81298c:	91002ee1 	add	x1, x23, #0xb
ffffffffea812990:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea812994:	39400001 	ldrb	w1, [x0]
ffffffffea812998:	17ffffca 	b	ffffffffea8128c0 <_printf_engine+0x150>
				OUTPUT_CHAR('%');
ffffffffea81299c:	528004a0 	mov	w0, #0x25                  	// #37
				uc = va_arg(ap, unsigned int);
ffffffffea8129a0:	390223a0 	strb	w0, [x29, #136]
				OUTPUT_CHAR(uc);
ffffffffea8129a4:	aa1503e2 	mov	x2, x21
ffffffffea8129a8:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8129ac:	910223a0 	add	x0, x29, #0x88
ffffffffea8129b0:	d63f0280 	blr	x20
ffffffffea8129b4:	37fff600 	tbnz	w0, #31, ffffffffea812874 <_printf_engine+0x104>
				OUTPUT_CHAR(c);
ffffffffea8129b8:	8b20c273 	add	x19, x19, w0, sxtw
{
ffffffffea8129bc:	aa1c03e0 	mov	x0, x28
		signchar = '\0';
ffffffffea8129c0:	39023fbf 	strb	wzr, [x29, #143]
{
ffffffffea8129c4:	a9446bb9 	ldp	x25, x26, [x29, #64]
		while ((c = *fmt++) != 0) {
ffffffffea8129c8:	9100041c 	add	x28, x0, #0x1
ffffffffea8129cc:	39400001 	ldrb	w1, [x0]
{
ffffffffea8129d0:	f9402bbb 	ldr	x27, [x29, #80]
		while ((c = *fmt++) != 0) {
ffffffffea8129d4:	35ffef41 	cbnz	w1, ffffffffea8127bc <_printf_engine+0x4c>
		string_len = 0;
ffffffffea8129d8:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8129dc:	17ffff80 	b	ffffffffea8127dc <_printf_engine+0x6c>
					flags |= LONGLONGFLAG;
ffffffffea8129e0:	321f0320 	orr	w0, w25, #0x2
ffffffffea8129e4:	f240033f 	tst	x25, #0x1
ffffffffea8129e8:	1a991019 	csel	w25, w0, w25, ne  // ne = any
				flags |= LONGFLAG;
ffffffffea8129ec:	32000339 	orr	w25, w25, #0x1
				goto next_format;
ffffffffea8129f0:	17ffff8e 	b	ffffffffea812828 <_printf_engine+0xb8>
				flags |= LONGFLAG | ALTFLAG;
ffffffffea8129f4:	52801020 	mov	w0, #0x81                  	// #129
ffffffffea8129f8:	2a000339 	orr	w25, w25, w0
				n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
ffffffffea8129fc:	360ffc19 	tbz	w25, #1, ffffffffea81297c <_printf_engine+0x20c>
ffffffffea812a00:	17ffffab 	b	ffffffffea8128ac <_printf_engine+0x13c>
				flags |= PTRDIFFFLAG;
ffffffffea812a04:	321a0339 	orr	w25, w25, #0x40
				goto next_format;
ffffffffea812a08:	17ffff88 	b	ffffffffea812828 <_printf_engine+0xb8>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
ffffffffea812a0c:	36080af9 	tbz	w25, #1, ffffffffea812b68 <_printf_engine+0x3f8>
				    (flags & INTMAXFLAG) ? va_arg(ap, uintmax_t) :
ffffffffea812a10:	37f82678 	tbnz	w24, #31, ffffffffea812edc <_printf_engine+0x76c>
ffffffffea812a14:	aa1703e0 	mov	x0, x23
ffffffffea812a18:	91003ee1 	add	x1, x23, #0xf
ffffffffea812a1c:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea812a20:	f9400001 	ldr	x1, [x0]
ffffffffea812a24:	1400000e 	b	ffffffffea812a5c <_printf_engine+0x2ec>
				flags |= SIZETFLAG;
ffffffffea812a28:	321c0339 	orr	w25, w25, #0x10
				goto next_format;
ffffffffea812a2c:	17ffff7f 	b	ffffffffea812828 <_printf_engine+0xb8>
				flags |= ALTFLAG;
ffffffffea812a30:	32190339 	orr	w25, w25, #0x80
				goto next_format;
ffffffffea812a34:	17ffff7d 	b	ffffffffea812828 <_printf_engine+0xb8>
				flags |= BLANKPOSFLAG;
ffffffffea812a38:	32130339 	orr	w25, w25, #0x2000
				goto next_format;
ffffffffea812a3c:	17ffff7b 	b	ffffffffea812828 <_printf_engine+0xb8>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812a40:	36080859 	tbz	w25, #1, ffffffffea812b48 <_printf_engine+0x3d8>
				    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
ffffffffea812a44:	37f829d8 	tbnz	w24, #31, ffffffffea812f7c <_printf_engine+0x80c>
ffffffffea812a48:	aa1703e0 	mov	x0, x23
ffffffffea812a4c:	91003ee1 	add	x1, x23, #0xf
ffffffffea812a50:	927df037 	and	x23, x1, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812a54:	f9400001 	ldr	x1, [x0]
				flags |= SIGNEDFLAG;
ffffffffea812a58:	32160339 	orr	w25, w25, #0x400
				s = longlong_to_string(num_buffer, n, sizeof(num_buffer), flags, &signchar);
ffffffffea812a5c:	91023fa3 	add	x3, x29, #0x8f
ffffffffea812a60:	2a1903e2 	mov	w2, w25
ffffffffea812a64:	910243a0 	add	x0, x29, #0x90
ffffffffea812a68:	97ffff04 	bl	ffffffffea812678 <longlong_to_string.constprop.0>
ffffffffea812a6c:	aa0003fa 	mov	x26, x0
		if (flags & LEFTFORMATFLAG) {
ffffffffea812a70:	375ff5b9 	tbnz	w25, #11, ffffffffea812924 <_printf_engine+0x1b4>
			string_len = strlen(s);
ffffffffea812a74:	aa1a03e0 	mov	x0, x26
ffffffffea812a78:	9400034c 	bl	ffffffffea8137a8 <strlen>
ffffffffea812a7c:	f9003fa0 	str	x0, [x29, #120]
ffffffffea812a80:	12140321 	and	w1, w25, #0x1000
			if (signchar != '\0' && format_num > 0)
ffffffffea812a84:	39423fa0 	ldrb	w0, [x29, #143]
ffffffffea812a88:	b9006fa1 	str	w1, [x29, #108]
ffffffffea812a8c:	35000f40 	cbnz	w0, ffffffffea812c74 <_printf_engine+0x504>
			for (; format_num > string_len; format_num--)
ffffffffea812a90:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea812a94:	eb3b401f 	cmp	x0, w27, uxtw
ffffffffea812a98:	54000222 	b.cs	ffffffffea812adc <_printf_engine+0x36c>  // b.hs, b.nlast
ffffffffea812a9c:	b9406fa0 	ldr	w0, [x29, #108]
ffffffffea812aa0:	52800619 	mov	w25, #0x30                  	// #48
ffffffffea812aa4:	7100001f 	cmp	w0, #0x0
ffffffffea812aa8:	52800400 	mov	w0, #0x20                  	// #32
ffffffffea812aac:	1a801339 	csel	w25, w25, w0, ne  // ne = any
				OUTPUT_CHAR(flags & LEADZEROFLAG ? '0' : ' ');
ffffffffea812ab0:	390223b9 	strb	w25, [x29, #136]
ffffffffea812ab4:	aa1503e2 	mov	x2, x21
ffffffffea812ab8:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea812abc:	910223a0 	add	x0, x29, #0x88
ffffffffea812ac0:	d63f0280 	blr	x20
ffffffffea812ac4:	37ffed80 	tbnz	w0, #31, ffffffffea812874 <_printf_engine+0x104>
ffffffffea812ac8:	8b20c273 	add	x19, x19, w0, sxtw
			for (; format_num > string_len; format_num--)
ffffffffea812acc:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea812ad0:	5100077b 	sub	w27, w27, #0x1
ffffffffea812ad4:	eb3b401f 	cmp	x0, w27, uxtw
ffffffffea812ad8:	54fffec3 	b.cc	ffffffffea812ab0 <_printf_engine+0x340>  // b.lo, b.ul, b.last
			if (!(flags & LEADZEROFLAG) && signchar != '\0')
ffffffffea812adc:	b9406fa0 	ldr	w0, [x29, #108]
ffffffffea812ae0:	34001220 	cbz	w0, ffffffffea812d24 <_printf_engine+0x5b4>
			OUTPUT_STRING(s, SIZE_MAX);
ffffffffea812ae4:	aa1503e2 	mov	x2, x21
ffffffffea812ae8:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
ffffffffea812aec:	aa1a03e0 	mov	x0, x26
ffffffffea812af0:	d63f0280 	blr	x20
ffffffffea812af4:	37ffec00 	tbnz	w0, #31, ffffffffea812874 <_printf_engine+0x104>
ffffffffea812af8:	17ffffb0 	b	ffffffffea8129b8 <_printf_engine+0x248>
					flags |= HALFHALFFLAG;
ffffffffea812afc:	321d0320 	orr	w0, w25, #0x8
ffffffffea812b00:	f27e033f 	tst	x25, #0x4
ffffffffea812b04:	1a991019 	csel	w25, w0, w25, ne  // ne = any
				flags |= HALFFLAG;
ffffffffea812b08:	321e0339 	orr	w25, w25, #0x4
				goto next_format;
ffffffffea812b0c:	17ffff47 	b	ffffffffea812828 <_printf_engine+0xb8>
				flags |= LEFTFORMATFLAG;
ffffffffea812b10:	32150339 	orr	w25, w25, #0x800
				goto next_format;
ffffffffea812b14:	17ffff45 	b	ffffffffea812828 <_printf_engine+0xb8>
				if (c == '0' && format_num == 0)
ffffffffea812b18:	7100c35f 	cmp	w26, #0x30
				format_num *= 10;
ffffffffea812b1c:	0b1b0b60 	add	w0, w27, w27, lsl #2
					flags |= LEADZEROFLAG;
ffffffffea812b20:	7a400b60 	ccmp	w27, #0x0, #0x0, eq  // eq = none
ffffffffea812b24:	32140321 	orr	w1, w25, #0x1000
				format_num += c - '0';
ffffffffea812b28:	5100c345 	sub	w5, w26, #0x30
					flags |= LEADZEROFLAG;
ffffffffea812b2c:	1a990039 	csel	w25, w1, w25, eq  // eq = none
				format_num += c - '0';
ffffffffea812b30:	0b0004bb 	add	w27, w5, w0, lsl #1
				goto next_format;
ffffffffea812b34:	17ffff3d 	b	ffffffffea812828 <_printf_engine+0xb8>
				flags |= SHOWSIGNFLAG;
ffffffffea812b38:	32170339 	orr	w25, w25, #0x200
				goto next_format;
ffffffffea812b3c:	17ffff3b 	b	ffffffffea812828 <_printf_engine+0xb8>
				flags |= INTMAXFLAG;
ffffffffea812b40:	321b0339 	orr	w25, w25, #0x20
				goto next_format;
ffffffffea812b44:	17ffff39 	b	ffffffffea812828 <_printf_engine+0xb8>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812b48:	3707f7f9 	tbnz	w25, #0, ffffffffea812a44 <_printf_engine+0x2d4>
ffffffffea812b4c:	36180d19 	tbz	w25, #3, ffffffffea812cec <_printf_engine+0x57c>
				    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
ffffffffea812b50:	37f81358 	tbnz	w24, #31, ffffffffea812db8 <_printf_engine+0x648>
ffffffffea812b54:	aa1703e0 	mov	x0, x23
ffffffffea812b58:	91002ee1 	add	x1, x23, #0xb
ffffffffea812b5c:	927df037 	and	x23, x1, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812b60:	39800001 	ldrsb	x1, [x0]
ffffffffea812b64:	17ffffbd 	b	ffffffffea812a58 <_printf_engine+0x2e8>
				    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
ffffffffea812b68:	3707f559 	tbnz	w25, #0, ffffffffea812a10 <_printf_engine+0x2a0>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea812b6c:	36180cf9 	tbz	w25, #3, ffffffffea812d08 <_printf_engine+0x598>
ffffffffea812b70:	37f81a58 	tbnz	w24, #31, ffffffffea812eb8 <_printf_engine+0x748>
ffffffffea812b74:	aa1703e0 	mov	x0, x23
ffffffffea812b78:	91002ee1 	add	x1, x23, #0xb
ffffffffea812b7c:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea812b80:	39400001 	ldrb	w1, [x0]
ffffffffea812b84:	17ffffb6 	b	ffffffffea812a5c <_printf_engine+0x2ec>
				OUTPUT_CHAR('%');
ffffffffea812b88:	8b39c273 	add	x19, x19, w25, sxtw
ffffffffea812b8c:	17ffff8b 	b	ffffffffea8129b8 <_printf_engine+0x248>
ffffffffea812b90:	a9446bb9 	ldp	x25, x26, [x29, #64]
	return (err < 0) ? err : (int)chars_written;
ffffffffea812b94:	2a1303e0 	mov	w0, w19
ffffffffea812b98:	f9402bbb 	ldr	x27, [x29, #80]
}
ffffffffea812b9c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812ba0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea812ba4:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea812ba8:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea812bac:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea812bb0:	d65f03c0 	ret
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea812bb4:	371004b9 	tbnz	w25, #2, ffffffffea812c48 <_printf_engine+0x4d8>
				    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
ffffffffea812bb8:	3727e7b9 	tbnz	w25, #4, ffffffffea8128ac <_printf_engine+0x13c>
				    (flags & INTMAXFLAG) ? va_arg(ap, uintmax_t) :
ffffffffea812bbc:	372fe799 	tbnz	w25, #5, ffffffffea8128ac <_printf_engine+0x13c>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812bc0:	3737e779 	tbnz	w25, #6, ffffffffea8128ac <_printf_engine+0x13c>
				    va_arg(ap, unsigned int);
ffffffffea812bc4:	37f80e98 	tbnz	w24, #31, ffffffffea812d94 <_printf_engine+0x624>
ffffffffea812bc8:	aa1703e0 	mov	x0, x23
ffffffffea812bcc:	91002ee1 	add	x1, x23, #0xb
ffffffffea812bd0:	927df037 	and	x23, x1, #0xfffffffffffffff8
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812bd4:	b9400001 	ldr	w1, [x0]
ffffffffea812bd8:	17ffff3a 	b	ffffffffea8128c0 <_printf_engine+0x150>
				ptr = va_arg(ap, void *);
ffffffffea812bdc:	37f81ed8 	tbnz	w24, #31, ffffffffea812fb4 <_printf_engine+0x844>
ffffffffea812be0:	91003ee1 	add	x1, x23, #0xf
ffffffffea812be4:	aa1703e0 	mov	x0, x23
ffffffffea812be8:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea812bec:	f9400000 	ldr	x0, [x0]
				if (flags & LONGLONGFLAG)
ffffffffea812bf0:	370803f9 	tbnz	w25, #1, ffffffffea812c6c <_printf_engine+0x4fc>
				else if (flags & LONGFLAG)
ffffffffea812bf4:	370003d9 	tbnz	w25, #0, ffffffffea812c6c <_printf_engine+0x4fc>
				else if (flags & HALFHALFFLAG)
ffffffffea812bf8:	36180759 	tbz	w25, #3, ffffffffea812ce0 <_printf_engine+0x570>
					*(signed char *)ptr = chars_written;
ffffffffea812bfc:	39000013 	strb	w19, [x0]
ffffffffea812c00:	17ffff6f 	b	ffffffffea8129bc <_printf_engine+0x24c>
				uc = va_arg(ap, unsigned int);
ffffffffea812c04:	37f81498 	tbnz	w24, #31, ffffffffea812e94 <_printf_engine+0x724>
ffffffffea812c08:	aa1703e0 	mov	x0, x23
ffffffffea812c0c:	91002ee1 	add	x1, x23, #0xb
ffffffffea812c10:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea812c14:	b9400000 	ldr	w0, [x0]
ffffffffea812c18:	17ffff62 	b	ffffffffea8129a0 <_printf_engine+0x230>
				s = va_arg(ap, const char *);
ffffffffea812c1c:	37f818f8 	tbnz	w24, #31, ffffffffea812f38 <_printf_engine+0x7c8>
ffffffffea812c20:	91003ee1 	add	x1, x23, #0xf
ffffffffea812c24:	aa1703e0 	mov	x0, x23
ffffffffea812c28:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea812c2c:	f940001a 	ldr	x26, [x0]
					s = "<null>";
ffffffffea812c30:	b0000020 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea812c34:	9136e000 	add	x0, x0, #0xdb8
				flags &= ~LEADZEROFLAG; /* doesn't make sense for strings */
ffffffffea812c38:	12137b39 	and	w25, w25, #0xffffefff
					s = "<null>";
ffffffffea812c3c:	f100035f 	cmp	x26, #0x0
ffffffffea812c40:	9a9a001a 	csel	x26, x0, x26, eq  // eq = none
				goto _output_string;
ffffffffea812c44:	17ffff37 	b	ffffffffea812920 <_printf_engine+0x1b0>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea812c48:	37f81678 	tbnz	w24, #31, ffffffffea812f14 <_printf_engine+0x7a4>
ffffffffea812c4c:	aa1703e0 	mov	x0, x23
ffffffffea812c50:	91002ee1 	add	x1, x23, #0xb
ffffffffea812c54:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea812c58:	79400001 	ldrh	w1, [x0]
ffffffffea812c5c:	17ffff19 	b	ffffffffea8128c0 <_printf_engine+0x150>
ffffffffea812c60:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea812c64:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea812c68:	17fffee0 	b	ffffffffea8127e8 <_printf_engine+0x78>
					*(size_t *)ptr = chars_written;
ffffffffea812c6c:	f9000013 	str	x19, [x0]
ffffffffea812c70:	17ffff53 	b	ffffffffea8129bc <_printf_engine+0x24c>
			if (signchar != '\0' && format_num > 0)
ffffffffea812c74:	340001db 	cbz	w27, ffffffffea812cac <_printf_engine+0x53c>
				format_num--;
ffffffffea812c78:	5100077b 	sub	w27, w27, #0x1
			if (flags & LEADZEROFLAG && signchar != '\0')
ffffffffea812c7c:	34001ac1 	cbz	w1, ffffffffea812fd4 <_printf_engine+0x864>
				OUTPUT_CHAR(signchar);
ffffffffea812c80:	390223a0 	strb	w0, [x29, #136]
ffffffffea812c84:	aa1503e2 	mov	x2, x21
ffffffffea812c88:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea812c8c:	910223a0 	add	x0, x29, #0x88
ffffffffea812c90:	d63f0280 	blr	x20
ffffffffea812c94:	37ffdf00 	tbnz	w0, #31, ffffffffea812874 <_printf_engine+0x104>
ffffffffea812c98:	8b20c273 	add	x19, x19, w0, sxtw
			for (; format_num > string_len; format_num--)
ffffffffea812c9c:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea812ca0:	eb3b401f 	cmp	x0, w27, uxtw
ffffffffea812ca4:	54ffefc3 	b.cc	ffffffffea812a9c <_printf_engine+0x32c>  // b.lo, b.ul, b.last
ffffffffea812ca8:	17ffff8f 	b	ffffffffea812ae4 <_printf_engine+0x374>
			if (flags & LEADZEROFLAG && signchar != '\0')
ffffffffea812cac:	b9406fa1 	ldr	w1, [x29, #108]
ffffffffea812cb0:	35fffe81 	cbnz	w1, ffffffffea812c80 <_printf_engine+0x510>
				OUTPUT_CHAR(signchar);
ffffffffea812cb4:	390223a0 	strb	w0, [x29, #136]
ffffffffea812cb8:	aa1503e2 	mov	x2, x21
ffffffffea812cbc:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea812cc0:	910223a0 	add	x0, x29, #0x88
ffffffffea812cc4:	d63f0280 	blr	x20
ffffffffea812cc8:	37ffdd60 	tbnz	w0, #31, ffffffffea812874 <_printf_engine+0x104>
ffffffffea812ccc:	8b20c273 	add	x19, x19, w0, sxtw
ffffffffea812cd0:	17ffff85 	b	ffffffffea812ae4 <_printf_engine+0x374>
		OUTPUT_STRING(s, string_len);
ffffffffea812cd4:	8b20c273 	add	x19, x19, w0, sxtw
	return (err < 0) ? err : (int)chars_written;
ffffffffea812cd8:	2a1303e0 	mov	w0, w19
ffffffffea812cdc:	17ffffb0 	b	ffffffffea812b9c <_printf_engine+0x42c>
				else if (flags & HALFFLAG)
ffffffffea812ce0:	36100299 	tbz	w25, #2, ffffffffea812d30 <_printf_engine+0x5c0>
					*(short *)ptr = chars_written;
ffffffffea812ce4:	79000013 	strh	w19, [x0]
ffffffffea812ce8:	17ffff35 	b	ffffffffea8129bc <_printf_engine+0x24c>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812cec:	36100299 	tbz	w25, #2, ffffffffea812d3c <_printf_engine+0x5cc>
				    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
ffffffffea812cf0:	37f81858 	tbnz	w24, #31, ffffffffea812ff8 <_printf_engine+0x888>
ffffffffea812cf4:	aa1703e0 	mov	x0, x23
ffffffffea812cf8:	91002ee1 	add	x1, x23, #0xb
ffffffffea812cfc:	927df037 	and	x23, x1, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812d00:	79800001 	ldrsh	x1, [x0]
ffffffffea812d04:	17ffff55 	b	ffffffffea812a58 <_printf_engine+0x2e8>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea812d08:	36100319 	tbz	w25, #2, ffffffffea812d68 <_printf_engine+0x5f8>
ffffffffea812d0c:	37f81cd8 	tbnz	w24, #31, ffffffffea8130a4 <_printf_engine+0x934>
ffffffffea812d10:	aa1703e0 	mov	x0, x23
ffffffffea812d14:	91002ee1 	add	x1, x23, #0xb
ffffffffea812d18:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea812d1c:	79400001 	ldrh	w1, [x0]
ffffffffea812d20:	17ffff4f 	b	ffffffffea812a5c <_printf_engine+0x2ec>
ffffffffea812d24:	39423fa0 	ldrb	w0, [x29, #143]
			if (!(flags & LEADZEROFLAG) && signchar != '\0')
ffffffffea812d28:	35fffc60 	cbnz	w0, ffffffffea812cb4 <_printf_engine+0x544>
ffffffffea812d2c:	17ffff6e 	b	ffffffffea812ae4 <_printf_engine+0x374>
				else if (flags & SIZETFLAG)
ffffffffea812d30:	3727f9f9 	tbnz	w25, #4, ffffffffea812c6c <_printf_engine+0x4fc>
					*(int *)ptr = chars_written;
ffffffffea812d34:	b9000013 	str	w19, [x0]
ffffffffea812d38:	17ffff21 	b	ffffffffea8129bc <_printf_engine+0x24c>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812d3c:	3727e859 	tbnz	w25, #4, ffffffffea812a44 <_printf_engine+0x2d4>
ffffffffea812d40:	372fe839 	tbnz	w25, #5, ffffffffea812a44 <_printf_engine+0x2d4>
ffffffffea812d44:	363018d9 	tbz	w25, #6, ffffffffea81305c <_printf_engine+0x8ec>
				    (flags & PTRDIFFFLAG) ? va_arg(ap, ptrdiff_t) :
ffffffffea812d48:	37f817f8 	tbnz	w24, #31, ffffffffea813044 <_printf_engine+0x8d4>
ffffffffea812d4c:	91003ee0 	add	x0, x23, #0xf
ffffffffea812d50:	2a1803e2 	mov	w2, w24
ffffffffea812d54:	927df000 	and	x0, x0, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812d58:	f94002e1 	ldr	x1, [x23]
ffffffffea812d5c:	2a0203f8 	mov	w24, w2
ffffffffea812d60:	aa0003f7 	mov	x23, x0
ffffffffea812d64:	17ffff3d 	b	ffffffffea812a58 <_printf_engine+0x2e8>
				    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
ffffffffea812d68:	3727e559 	tbnz	w25, #4, ffffffffea812a10 <_printf_engine+0x2a0>
				    (flags & INTMAXFLAG) ? va_arg(ap, uintmax_t) :
ffffffffea812d6c:	372fe539 	tbnz	w25, #5, ffffffffea812a10 <_printf_engine+0x2a0>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812d70:	36300539 	tbz	w25, #6, ffffffffea812e14 <_printf_engine+0x6a4>
ffffffffea812d74:	37f80358 	tbnz	w24, #31, ffffffffea812ddc <_printf_engine+0x66c>
ffffffffea812d78:	91003ee0 	add	x0, x23, #0xf
ffffffffea812d7c:	2a1803e2 	mov	w2, w24
ffffffffea812d80:	927df000 	and	x0, x0, #0xfffffffffffffff8
ffffffffea812d84:	f94002e1 	ldr	x1, [x23]
ffffffffea812d88:	2a0203f8 	mov	w24, w2
ffffffffea812d8c:	aa0003f7 	mov	x23, x0
ffffffffea812d90:	17ffff33 	b	ffffffffea812a5c <_printf_engine+0x2ec>
				    va_arg(ap, unsigned int);
ffffffffea812d94:	11002301 	add	w1, w24, #0x8
ffffffffea812d98:	7100003f 	cmp	w1, #0x0
ffffffffea812d9c:	540004cd 	b.le	ffffffffea812e34 <_printf_engine+0x6c4>
ffffffffea812da0:	aa1703e0 	mov	x0, x23
ffffffffea812da4:	91002ee2 	add	x2, x23, #0xb
ffffffffea812da8:	2a0103f8 	mov	w24, w1
ffffffffea812dac:	927df057 	and	x23, x2, #0xfffffffffffffff8
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812db0:	b9400001 	ldr	w1, [x0]
ffffffffea812db4:	17fffec3 	b	ffffffffea8128c0 <_printf_engine+0x150>
				    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
ffffffffea812db8:	11002301 	add	w1, w24, #0x8
ffffffffea812dbc:	7100003f 	cmp	w1, #0x0
ffffffffea812dc0:	5400044d 	b.le	ffffffffea812e48 <_printf_engine+0x6d8>
ffffffffea812dc4:	aa1703e0 	mov	x0, x23
ffffffffea812dc8:	91002ee2 	add	x2, x23, #0xb
ffffffffea812dcc:	2a0103f8 	mov	w24, w1
ffffffffea812dd0:	927df057 	and	x23, x2, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812dd4:	39800001 	ldrsb	x1, [x0]
ffffffffea812dd8:	17ffff20 	b	ffffffffea812a58 <_printf_engine+0x2e8>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812ddc:	11002302 	add	w2, w24, #0x8
ffffffffea812de0:	7100005f 	cmp	w2, #0x0
ffffffffea812de4:	5400044d 	b.le	ffffffffea812e6c <_printf_engine+0x6fc>
ffffffffea812de8:	91003ee0 	add	x0, x23, #0xf
ffffffffea812dec:	927df000 	and	x0, x0, #0xfffffffffffffff8
ffffffffea812df0:	17ffffe5 	b	ffffffffea812d84 <_printf_engine+0x614>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812df4:	11002301 	add	w1, w24, #0x8
ffffffffea812df8:	7100003f 	cmp	w1, #0x0
ffffffffea812dfc:	5400030d 	b.le	ffffffffea812e5c <_printf_engine+0x6ec>
ffffffffea812e00:	91003ee2 	add	x2, x23, #0xf
ffffffffea812e04:	aa1703e0 	mov	x0, x23
ffffffffea812e08:	2a0103f8 	mov	w24, w1
ffffffffea812e0c:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812e10:	17fffeab 	b	ffffffffea8128bc <_printf_engine+0x14c>
				    va_arg(ap, unsigned int);
ffffffffea812e14:	37f80358 	tbnz	w24, #31, ffffffffea812e7c <_printf_engine+0x70c>
ffffffffea812e18:	91002ee0 	add	x0, x23, #0xb
ffffffffea812e1c:	2a1803e2 	mov	w2, w24
ffffffffea812e20:	927df000 	and	x0, x0, #0xfffffffffffffff8
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812e24:	b94002e1 	ldr	w1, [x23]
ffffffffea812e28:	2a0203f8 	mov	w24, w2
ffffffffea812e2c:	aa0003f7 	mov	x23, x0
ffffffffea812e30:	17ffff0b 	b	ffffffffea812a5c <_printf_engine+0x2ec>
				    va_arg(ap, unsigned int);
ffffffffea812e34:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812e38:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812e3c:	2a0103f8 	mov	w24, w1
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812e40:	b9400001 	ldr	w1, [x0]
ffffffffea812e44:	17fffe9f 	b	ffffffffea8128c0 <_printf_engine+0x150>
				    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
ffffffffea812e48:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812e4c:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812e50:	2a0103f8 	mov	w24, w1
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812e54:	39800001 	ldrsb	x1, [x0]
ffffffffea812e58:	17ffff00 	b	ffffffffea812a58 <_printf_engine+0x2e8>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812e5c:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812e60:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812e64:	2a0103f8 	mov	w24, w1
ffffffffea812e68:	17fffe95 	b	ffffffffea8128bc <_printf_engine+0x14c>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812e6c:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea812e70:	aa1703e0 	mov	x0, x23
ffffffffea812e74:	8b38c037 	add	x23, x1, w24, sxtw
ffffffffea812e78:	17ffffc3 	b	ffffffffea812d84 <_printf_engine+0x614>
				    va_arg(ap, unsigned int);
ffffffffea812e7c:	11002302 	add	w2, w24, #0x8
ffffffffea812e80:	7100005f 	cmp	w2, #0x0
ffffffffea812e84:	5400122d 	b.le	ffffffffea8130c8 <_printf_engine+0x958>
ffffffffea812e88:	91002ee0 	add	x0, x23, #0xb
ffffffffea812e8c:	927df000 	and	x0, x0, #0xfffffffffffffff8
ffffffffea812e90:	17ffffe5 	b	ffffffffea812e24 <_printf_engine+0x6b4>
				uc = va_arg(ap, unsigned int);
ffffffffea812e94:	11002301 	add	w1, w24, #0x8
ffffffffea812e98:	7100003f 	cmp	w1, #0x0
ffffffffea812e9c:	54000c0d 	b.le	ffffffffea81301c <_printf_engine+0x8ac>
ffffffffea812ea0:	aa1703e0 	mov	x0, x23
ffffffffea812ea4:	91002ee2 	add	x2, x23, #0xb
ffffffffea812ea8:	2a0103f8 	mov	w24, w1
ffffffffea812eac:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812eb0:	b9400000 	ldr	w0, [x0]
ffffffffea812eb4:	17fffebb 	b	ffffffffea8129a0 <_printf_engine+0x230>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea812eb8:	11002301 	add	w1, w24, #0x8
ffffffffea812ebc:	7100003f 	cmp	w1, #0x0
ffffffffea812ec0:	540013ad 	b.le	ffffffffea813134 <_printf_engine+0x9c4>
ffffffffea812ec4:	aa1703e0 	mov	x0, x23
ffffffffea812ec8:	91002ee2 	add	x2, x23, #0xb
ffffffffea812ecc:	2a0103f8 	mov	w24, w1
ffffffffea812ed0:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812ed4:	39400001 	ldrb	w1, [x0]
ffffffffea812ed8:	17fffee1 	b	ffffffffea812a5c <_printf_engine+0x2ec>
				    (flags & INTMAXFLAG) ? va_arg(ap, uintmax_t) :
ffffffffea812edc:	11002301 	add	w1, w24, #0x8
ffffffffea812ee0:	7100003f 	cmp	w1, #0x0
ffffffffea812ee4:	540000ed 	b.le	ffffffffea812f00 <_printf_engine+0x790>
ffffffffea812ee8:	aa1703e0 	mov	x0, x23
ffffffffea812eec:	91003ee2 	add	x2, x23, #0xf
ffffffffea812ef0:	2a0103f8 	mov	w24, w1
ffffffffea812ef4:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812ef8:	f9400001 	ldr	x1, [x0]
ffffffffea812efc:	17fffed8 	b	ffffffffea812a5c <_printf_engine+0x2ec>
ffffffffea812f00:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812f04:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812f08:	2a0103f8 	mov	w24, w1
ffffffffea812f0c:	f9400001 	ldr	x1, [x0]
ffffffffea812f10:	17fffed3 	b	ffffffffea812a5c <_printf_engine+0x2ec>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea812f14:	11002301 	add	w1, w24, #0x8
ffffffffea812f18:	7100003f 	cmp	w1, #0x0
ffffffffea812f1c:	540001ed 	b.le	ffffffffea812f58 <_printf_engine+0x7e8>
ffffffffea812f20:	aa1703e0 	mov	x0, x23
ffffffffea812f24:	91002ee2 	add	x2, x23, #0xb
ffffffffea812f28:	2a0103f8 	mov	w24, w1
ffffffffea812f2c:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812f30:	79400001 	ldrh	w1, [x0]
ffffffffea812f34:	17fffe63 	b	ffffffffea8128c0 <_printf_engine+0x150>
				s = va_arg(ap, const char *);
ffffffffea812f38:	11002301 	add	w1, w24, #0x8
ffffffffea812f3c:	7100003f 	cmp	w1, #0x0
ffffffffea812f40:	5400016d 	b.le	ffffffffea812f6c <_printf_engine+0x7fc>
ffffffffea812f44:	91003ee2 	add	x2, x23, #0xf
ffffffffea812f48:	aa1703e0 	mov	x0, x23
ffffffffea812f4c:	2a0103f8 	mov	w24, w1
ffffffffea812f50:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812f54:	17ffff36 	b	ffffffffea812c2c <_printf_engine+0x4bc>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea812f58:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812f5c:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812f60:	2a0103f8 	mov	w24, w1
ffffffffea812f64:	79400001 	ldrh	w1, [x0]
ffffffffea812f68:	17fffe56 	b	ffffffffea8128c0 <_printf_engine+0x150>
				s = va_arg(ap, const char *);
ffffffffea812f6c:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812f70:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812f74:	2a0103f8 	mov	w24, w1
ffffffffea812f78:	17ffff2d 	b	ffffffffea812c2c <_printf_engine+0x4bc>
				    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
ffffffffea812f7c:	11002301 	add	w1, w24, #0x8
ffffffffea812f80:	7100003f 	cmp	w1, #0x0
ffffffffea812f84:	540000ed 	b.le	ffffffffea812fa0 <_printf_engine+0x830>
ffffffffea812f88:	aa1703e0 	mov	x0, x23
ffffffffea812f8c:	91003ee2 	add	x2, x23, #0xf
ffffffffea812f90:	2a0103f8 	mov	w24, w1
ffffffffea812f94:	927df057 	and	x23, x2, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812f98:	f9400001 	ldr	x1, [x0]
ffffffffea812f9c:	17fffeaf 	b	ffffffffea812a58 <_printf_engine+0x2e8>
				    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
ffffffffea812fa0:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812fa4:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812fa8:	2a0103f8 	mov	w24, w1
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812fac:	f9400001 	ldr	x1, [x0]
ffffffffea812fb0:	17fffeaa 	b	ffffffffea812a58 <_printf_engine+0x2e8>
				ptr = va_arg(ap, void *);
ffffffffea812fb4:	11002301 	add	w1, w24, #0x8
ffffffffea812fb8:	7100003f 	cmp	w1, #0x0
ffffffffea812fbc:	5400016d 	b.le	ffffffffea812fe8 <_printf_engine+0x878>
ffffffffea812fc0:	91003ee2 	add	x2, x23, #0xf
ffffffffea812fc4:	aa1703e0 	mov	x0, x23
ffffffffea812fc8:	2a0103f8 	mov	w24, w1
ffffffffea812fcc:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812fd0:	17ffff07 	b	ffffffffea812bec <_printf_engine+0x47c>
			for (; format_num > string_len; format_num--)
ffffffffea812fd4:	f9403fa1 	ldr	x1, [x29, #120]
ffffffffea812fd8:	eb3b403f 	cmp	x1, w27, uxtw
ffffffffea812fdc:	54ffd603 	b.cc	ffffffffea812a9c <_printf_engine+0x32c>  // b.lo, b.ul, b.last
			if (!(flags & LEADZEROFLAG) && signchar != '\0')
ffffffffea812fe0:	35ffe6a0 	cbnz	w0, ffffffffea812cb4 <_printf_engine+0x544>
ffffffffea812fe4:	17fffec0 	b	ffffffffea812ae4 <_printf_engine+0x374>
				ptr = va_arg(ap, void *);
ffffffffea812fe8:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812fec:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812ff0:	2a0103f8 	mov	w24, w1
ffffffffea812ff4:	17fffefe 	b	ffffffffea812bec <_printf_engine+0x47c>
				    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
ffffffffea812ff8:	11002301 	add	w1, w24, #0x8
ffffffffea812ffc:	7100003f 	cmp	w1, #0x0
ffffffffea813000:	5400018d 	b.le	ffffffffea813030 <_printf_engine+0x8c0>
ffffffffea813004:	aa1703e0 	mov	x0, x23
ffffffffea813008:	91002ee2 	add	x2, x23, #0xb
ffffffffea81300c:	2a0103f8 	mov	w24, w1
ffffffffea813010:	927df057 	and	x23, x2, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea813014:	79800001 	ldrsh	x1, [x0]
ffffffffea813018:	17fffe90 	b	ffffffffea812a58 <_printf_engine+0x2e8>
				uc = va_arg(ap, unsigned int);
ffffffffea81301c:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea813020:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea813024:	2a0103f8 	mov	w24, w1
ffffffffea813028:	b9400000 	ldr	w0, [x0]
ffffffffea81302c:	17fffe5d 	b	ffffffffea8129a0 <_printf_engine+0x230>
				    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
ffffffffea813030:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea813034:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea813038:	2a0103f8 	mov	w24, w1
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea81303c:	79800001 	ldrsh	x1, [x0]
ffffffffea813040:	17fffe86 	b	ffffffffea812a58 <_printf_engine+0x2e8>
				    (flags & PTRDIFFFLAG) ? va_arg(ap, ptrdiff_t) :
ffffffffea813044:	11002302 	add	w2, w24, #0x8
ffffffffea813048:	7100005f 	cmp	w2, #0x0
ffffffffea81304c:	5400018d 	b.le	ffffffffea81307c <_printf_engine+0x90c>
ffffffffea813050:	91003ee0 	add	x0, x23, #0xf
ffffffffea813054:	927df000 	and	x0, x0, #0xfffffffffffffff8
ffffffffea813058:	17ffff40 	b	ffffffffea812d58 <_printf_engine+0x5e8>
				    va_arg(ap, int);
ffffffffea81305c:	37f80198 	tbnz	w24, #31, ffffffffea81308c <_printf_engine+0x91c>
ffffffffea813060:	91002ee0 	add	x0, x23, #0xb
ffffffffea813064:	2a1803e2 	mov	w2, w24
ffffffffea813068:	927df000 	and	x0, x0, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea81306c:	b98002e1 	ldrsw	x1, [x23]
ffffffffea813070:	2a0203f8 	mov	w24, w2
ffffffffea813074:	aa0003f7 	mov	x23, x0
ffffffffea813078:	17fffe78 	b	ffffffffea812a58 <_printf_engine+0x2e8>
				    (flags & PTRDIFFFLAG) ? va_arg(ap, ptrdiff_t) :
ffffffffea81307c:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea813080:	aa1703e0 	mov	x0, x23
ffffffffea813084:	8b38c037 	add	x23, x1, w24, sxtw
ffffffffea813088:	17ffff34 	b	ffffffffea812d58 <_printf_engine+0x5e8>
				    va_arg(ap, int);
ffffffffea81308c:	11002302 	add	w2, w24, #0x8
ffffffffea813090:	7100005f 	cmp	w2, #0x0
ffffffffea813094:	5400022d 	b.le	ffffffffea8130d8 <_printf_engine+0x968>
ffffffffea813098:	91002ee0 	add	x0, x23, #0xb
ffffffffea81309c:	927df000 	and	x0, x0, #0xfffffffffffffff8
ffffffffea8130a0:	17fffff3 	b	ffffffffea81306c <_printf_engine+0x8fc>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea8130a4:	11002301 	add	w1, w24, #0x8
ffffffffea8130a8:	7100003f 	cmp	w1, #0x0
ffffffffea8130ac:	540001ed 	b.le	ffffffffea8130e8 <_printf_engine+0x978>
ffffffffea8130b0:	aa1703e0 	mov	x0, x23
ffffffffea8130b4:	91002ee2 	add	x2, x23, #0xb
ffffffffea8130b8:	2a0103f8 	mov	w24, w1
ffffffffea8130bc:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea8130c0:	79400001 	ldrh	w1, [x0]
ffffffffea8130c4:	17fffe66 	b	ffffffffea812a5c <_printf_engine+0x2ec>
				    va_arg(ap, unsigned int);
ffffffffea8130c8:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea8130cc:	aa1703e0 	mov	x0, x23
ffffffffea8130d0:	8b38c037 	add	x23, x1, w24, sxtw
ffffffffea8130d4:	17ffff54 	b	ffffffffea812e24 <_printf_engine+0x6b4>
				    va_arg(ap, int);
ffffffffea8130d8:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea8130dc:	aa1703e0 	mov	x0, x23
ffffffffea8130e0:	8b38c037 	add	x23, x1, w24, sxtw
ffffffffea8130e4:	17ffffe2 	b	ffffffffea81306c <_printf_engine+0x8fc>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea8130e8:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea8130ec:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea8130f0:	2a0103f8 	mov	w24, w1
ffffffffea8130f4:	79400001 	ldrh	w1, [x0]
ffffffffea8130f8:	17fffe59 	b	ffffffffea812a5c <_printf_engine+0x2ec>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea8130fc:	11002301 	add	w1, w24, #0x8
ffffffffea813100:	7100003f 	cmp	w1, #0x0
ffffffffea813104:	540000ed 	b.le	ffffffffea813120 <_printf_engine+0x9b0>
ffffffffea813108:	aa1703e0 	mov	x0, x23
ffffffffea81310c:	91002ee2 	add	x2, x23, #0xb
ffffffffea813110:	2a0103f8 	mov	w24, w1
ffffffffea813114:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea813118:	39400001 	ldrb	w1, [x0]
ffffffffea81311c:	17fffde9 	b	ffffffffea8128c0 <_printf_engine+0x150>
ffffffffea813120:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea813124:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea813128:	2a0103f8 	mov	w24, w1
ffffffffea81312c:	39400001 	ldrb	w1, [x0]
ffffffffea813130:	17fffde4 	b	ffffffffea8128c0 <_printf_engine+0x150>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea813134:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea813138:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea81313c:	2a0103f8 	mov	w24, w1
ffffffffea813140:	39400001 	ldrb	w1, [x0]
ffffffffea813144:	17fffe46 	b	ffffffffea812a5c <_printf_engine+0x2ec>

ffffffffea813148 <vsnprintf>:
{
ffffffffea813148:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea81314c:	910003fd 	mov	x29, sp
	wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
ffffffffea813150:	a9401464 	ldp	x4, x5, [x3]
{
ffffffffea813154:	a90153f3 	stp	x19, x20, [sp, #16]
	args.len = len;
ffffffffea813158:	a90487a0 	stp	x0, x1, [x29, #72]
{
ffffffffea81315c:	aa0103f4 	mov	x20, x1
ffffffffea813160:	aa0003f3 	mov	x19, x0
	args.pos = 0;
ffffffffea813164:	f9002fbf 	str	xzr, [x29, #88]
	wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
ffffffffea813168:	a9410460 	ldp	x0, x1, [x3, #16]
ffffffffea81316c:	a90217a4 	stp	x4, x5, [x29, #32]
ffffffffea813170:	a90307a0 	stp	x0, x1, [x29, #48]
ffffffffea813174:	910083a3 	add	x3, x29, #0x20
ffffffffea813178:	910123a1 	add	x1, x29, #0x48
ffffffffea81317c:	f0ffffe0 	adrp	x0, ffffffffea812000 <heap_alloc+0x30>
ffffffffea813180:	91186000 	add	x0, x0, #0x618
ffffffffea813184:	97fffd7b 	bl	ffffffffea812770 <_printf_engine>
	if (args.pos >= len)
ffffffffea813188:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea81318c:	eb14003f 	cmp	x1, x20
ffffffffea813190:	540000a2 	b.cs	ffffffffea8131a4 <vsnprintf+0x5c>  // b.hs, b.nlast
		str[wlen] = '\0';
ffffffffea813194:	3820ca7f 	strb	wzr, [x19, w0, sxtw]
}
ffffffffea813198:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81319c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8131a0:	d65f03c0 	ret
		str[len-1] = '\0';
ffffffffea8131a4:	8b140273 	add	x19, x19, x20
ffffffffea8131a8:	381ff27f 	sturb	wzr, [x19, #-1]
}
ffffffffea8131ac:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8131b0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8131b4:	d65f03c0 	ret

ffffffffea8131b8 <snprintf>:
{
ffffffffea8131b8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea8131bc:	910003fd 	mov	x29, sp
	va_start(ap, fmt);
ffffffffea8131c0:	910203a8 	add	x8, x29, #0x80
ffffffffea8131c4:	910143a9 	add	x9, x29, #0x50
ffffffffea8131c8:	a90323a8 	stp	x8, x8, [x29, #48]
ffffffffea8131cc:	128004e8 	mov	w8, #0xffffffd8            	// #-40
ffffffffea8131d0:	f90023a9 	str	x9, [x29, #64]
ffffffffea8131d4:	b9004ba8 	str	w8, [x29, #72]
ffffffffea8131d8:	b9004fbf 	str	wzr, [x29, #76]
	err = vsnprintf(str, len, fmt, ap);
ffffffffea8131dc:	a9432faa 	ldp	x10, x11, [x29, #48]
ffffffffea8131e0:	a9012faa 	stp	x10, x11, [x29, #16]
ffffffffea8131e4:	a94427a8 	ldp	x8, x9, [x29, #64]
ffffffffea8131e8:	a90227a8 	stp	x8, x9, [x29, #32]
{
ffffffffea8131ec:	a90593a3 	stp	x3, x4, [x29, #88]
	err = vsnprintf(str, len, fmt, ap);
ffffffffea8131f0:	910043a3 	add	x3, x29, #0x10
{
ffffffffea8131f4:	a9069ba5 	stp	x5, x6, [x29, #104]
ffffffffea8131f8:	f9003fa7 	str	x7, [x29, #120]
	err = vsnprintf(str, len, fmt, ap);
ffffffffea8131fc:	97ffffd3 	bl	ffffffffea813148 <vsnprintf>
}
ffffffffea813200:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea813204:	d65f03c0 	ret

ffffffffea813208 <rand>:
	randseed ^= enp;
}

int rand(void)
{
	return (randseed = randseed * 1664525 + 1013904223);
ffffffffea813208:	d0000021 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea81320c:	528cc1a3 	mov	w3, #0x660d                	// #26125
ffffffffea813210:	529e6be2 	mov	w2, #0xf35f                	// #62303
ffffffffea813214:	72a00323 	movk	w3, #0x19, lsl #16
ffffffffea813218:	b94fb820 	ldr	w0, [x1, #4024]
ffffffffea81321c:	72a78dc2 	movk	w2, #0x3c6e, lsl #16
ffffffffea813220:	1b030800 	madd	w0, w0, w3, w2
ffffffffea813224:	b90fb820 	str	w0, [x1, #4024]
}
ffffffffea813228:	d65f03c0 	ret
ffffffffea81322c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813230 <_printf>:
	va_end(ap);
	return err;
}

int _printf(const char *fmt, ...)
{
ffffffffea813230:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813234:	d0000028 	adrp	x8, ffffffffea819000 <_mem_phys_base>
ffffffffea813238:	913cc108 	add	x8, x8, #0xf30
{
ffffffffea81323c:	910003fd 	mov	x29, sp
	va_list ap;
	int err;

	va_start(ap, fmt);
ffffffffea813240:	9102c3a9 	add	x9, x29, #0xb0
ffffffffea813244:	9101c3aa 	add	x10, x29, #0x70
ffffffffea813248:	a90327a9 	stp	x9, x9, [x29, #48]
ffffffffea81324c:	128006e9 	mov	w9, #0xffffffc8            	// #-56
ffffffffea813250:	f90023aa 	str	x10, [x29, #64]
{
ffffffffea813254:	f9003fa1 	str	x1, [x29, #120]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813258:	aa0003e1 	mov	x1, x0
	va_start(ap, fmt);
ffffffffea81325c:	b9004fbf 	str	wzr, [x29, #76]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813260:	f9401500 	ldr	x0, [x8, #40]
ffffffffea813264:	f940250c 	ldr	x12, [x8, #72]
	va_start(ap, fmt);
ffffffffea813268:	b9004ba9 	str	w9, [x29, #72]
ffffffffea81326c:	a9432faa 	ldp	x10, x11, [x29, #48]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813270:	a9012faa 	stp	x10, x11, [x29, #16]
ffffffffea813274:	a94427a8 	ldp	x8, x9, [x29, #64]
ffffffffea813278:	a90227a8 	stp	x8, x9, [x29, #32]
{
ffffffffea81327c:	a9080fa2 	stp	x2, x3, [x29, #128]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813280:	910043a2 	add	x2, x29, #0x10
{
ffffffffea813284:	a90917a4 	stp	x4, x5, [x29, #144]
ffffffffea813288:	a90a1fa6 	stp	x6, x7, [x29, #160]
ffffffffea81328c:	a9052faa 	stp	x10, x11, [x29, #80]
ffffffffea813290:	a90627a8 	stp	x8, x9, [x29, #96]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813294:	d63f0180 	blr	x12
	err = vfprintf(stdout, fmt, ap);
	va_end(ap);

	return err;
}
ffffffffea813298:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea81329c:	d65f03c0 	ret

ffffffffea8132a0 <__guard_setup>:

#include <rand.h>

unsigned int __stack_chk_guard = 0xaff;

static void __attribute__((constructor)) __guard_setup (void){
ffffffffea8132a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea8132a4:	910003fd 	mov	x29, sp
ffffffffea8132a8:	f9000bf3 	str	x19, [sp, #16]
        /* 
         * included for future use. rand.h must be seeded and -fstack_protector must be disabled in
         * stack contexts preceeding this call.
         */
  	if ( __stack_chk_guard == 0U )
ffffffffea8132ac:	d0000033 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea8132b0:	b94fbe60 	ldr	w0, [x19, #4028]
ffffffffea8132b4:	35000060 	cbnz	w0, ffffffffea8132c0 <__guard_setup+0x20>
  		__stack_chk_guard = rand();
ffffffffea8132b8:	97ffffd4 	bl	ffffffffea813208 <rand>
ffffffffea8132bc:	b90fbe60 	str	w0, [x19, #4028]
}
ffffffffea8132c0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8132c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8132c8:	d65f03c0 	ret
ffffffffea8132cc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8132d0 <malloc>:
#include <string.h>
#include <lib/heap.h>

void *malloc(size_t size)
{
	return heap_alloc(size, 0);
ffffffffea8132d0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8132d4:	17fffb3f 	b	ffffffffea811fd0 <heap_alloc>

ffffffffea8132d8 <memalign>:
}

void *memalign(size_t boundary, size_t size)
{
ffffffffea8132d8:	aa0103e2 	mov	x2, x1
	return heap_alloc(size, boundary);
ffffffffea8132dc:	2a0003e1 	mov	w1, w0
ffffffffea8132e0:	aa0203e0 	mov	x0, x2
ffffffffea8132e4:	17fffb3b 	b	ffffffffea811fd0 <heap_alloc>

ffffffffea8132e8 <calloc>:
}

void *calloc(size_t count, size_t size)
{
ffffffffea8132e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea8132ec:	910003fd 	mov	x29, sp
ffffffffea8132f0:	a90153f3 	stp	x19, x20, [sp, #16]
	void *ptr;
	size_t realsize = count * size;
ffffffffea8132f4:	9b017c14 	mul	x20, x0, x1

	ptr = heap_alloc(realsize, 0);
ffffffffea8132f8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8132fc:	aa1403e0 	mov	x0, x20
ffffffffea813300:	97fffb34 	bl	ffffffffea811fd0 <heap_alloc>
ffffffffea813304:	aa0003f3 	mov	x19, x0
	if (!ptr)
ffffffffea813308:	b4000080 	cbz	x0, ffffffffea813318 <calloc+0x30>
		return NULL;

	memset(ptr, 0, realsize);
ffffffffea81330c:	aa1403e2 	mov	x2, x20
ffffffffea813310:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea813314:	940000c3 	bl	ffffffffea813620 <memset>
	return ptr;
}
ffffffffea813318:	aa1303e0 	mov	x0, x19
ffffffffea81331c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea813320:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea813324:	d65f03c0 	ret

ffffffffea813328 <free>:
	return p;
}

void free(void *ptr)
{
	return heap_free(ptr);
ffffffffea813328:	17fffbec 	b	ffffffffea8122d8 <heap_free>
ffffffffea81332c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813330 <memcpy>:
{
	char *d = (char *)dest;
	const char *s = (const char *)src;
	int len;

	if (count == 0 || dest == src)
ffffffffea813330:	f100005f 	cmp	x2, #0x0
ffffffffea813334:	fa411004 	ccmp	x0, x1, #0x4, ne  // ne = any
ffffffffea813338:	540006e0 	b.eq	ffffffffea813414 <memcpy+0xe4>  // b.none
		return dest;

	if (((long)d | (long)s) & lmask) {
ffffffffea81333c:	aa010003 	orr	x3, x0, x1
ffffffffea813340:	aa0003e4 	mov	x4, x0
ffffffffea813344:	f240087f 	tst	x3, #0x7
ffffffffea813348:	540002e0 	b.eq	ffffffffea8133a4 <memcpy+0x74>  // b.none
		// src and/or dest do not align on word boundary
		if ((((long)d ^ (long)s) & lmask) || (count < lsize))
ffffffffea81334c:	ca010003 	eor	x3, x0, x1
ffffffffea813350:	f240087f 	tst	x3, #0x7
ffffffffea813354:	fa470840 	ccmp	x2, #0x7, #0x0, eq  // eq = none
ffffffffea813358:	54000608 	b.hi	ffffffffea813418 <memcpy+0xe8>  // b.pmore
			len = count; // copy the rest of the buffer with the byte mover
ffffffffea81335c:	2a0203e3 	mov	w3, w2
		else
			len = lsize - ((long)d & lmask); // move the ptrs up to a word boundary

		count -= len;
ffffffffea813360:	cb22c042 	sub	x2, x2, w2, sxtw
		for (; len > 0; len--)
ffffffffea813364:	7100007f 	cmp	w3, #0x0
ffffffffea813368:	540001ed 	b.le	ffffffffea8133a4 <memcpy+0x74>
ffffffffea81336c:	51000466 	sub	w6, w3, #0x1
{
ffffffffea813370:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea813374:	aa0603e5 	mov	x5, x6
ffffffffea813378:	910004c6 	add	x6, x6, #0x1
ffffffffea81337c:	d503201f 	nop
			*d++ = *s++;
ffffffffea813380:	38636824 	ldrb	w4, [x1, x3]
ffffffffea813384:	38236804 	strb	w4, [x0, x3]
ffffffffea813388:	91000463 	add	x3, x3, #0x1
		for (; len > 0; len--)
ffffffffea81338c:	eb06007f 	cmp	x3, x6
ffffffffea813390:	54ffff81 	b.ne	ffffffffea813380 <memcpy+0x50>  // b.any
ffffffffea813394:	93407ca3 	sxtw	x3, w5
ffffffffea813398:	91000463 	add	x3, x3, #0x1
ffffffffea81339c:	8b030004 	add	x4, x0, x3
ffffffffea8133a0:	8b030021 	add	x1, x1, x3
	}
	for (len = count / lsize; len > 0; len--) {
ffffffffea8133a4:	d343fc43 	lsr	x3, x2, #3
ffffffffea8133a8:	7100007f 	cmp	w3, #0x0
ffffffffea8133ac:	540001ed 	b.le	ffffffffea8133e8 <memcpy+0xb8>
ffffffffea8133b0:	51000466 	sub	w6, w3, #0x1
ffffffffea8133b4:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea8133b8:	d37d7cc7 	ubfiz	x7, x6, #3, #32
ffffffffea8133bc:	910020e7 	add	x7, x7, #0x8
		*(word *)d = *(word *)s;
ffffffffea8133c0:	f8636825 	ldr	x5, [x1, x3]
ffffffffea8133c4:	f8236885 	str	x5, [x4, x3]
ffffffffea8133c8:	91002063 	add	x3, x3, #0x8
	for (len = count / lsize; len > 0; len--) {
ffffffffea8133cc:	eb07007f 	cmp	x3, x7
ffffffffea8133d0:	54ffff81 	b.ne	ffffffffea8133c0 <memcpy+0x90>  // b.any
ffffffffea8133d4:	93407cc3 	sxtw	x3, w6
ffffffffea8133d8:	91000463 	add	x3, x3, #0x1
ffffffffea8133dc:	d37df063 	lsl	x3, x3, #3
ffffffffea8133e0:	8b030084 	add	x4, x4, x3
ffffffffea8133e4:	8b030021 	add	x1, x1, x3
		d += lsize;
		s += lsize;
	}
	for (len = count & lmask; len > 0; len--)
ffffffffea8133e8:	72000842 	ands	w2, w2, #0x7
ffffffffea8133ec:	54000140 	b.eq	ffffffffea813414 <memcpy+0xe4>  // b.none
ffffffffea8133f0:	51000443 	sub	w3, w2, #0x1
ffffffffea8133f4:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea8133f8:	91000463 	add	x3, x3, #0x1
ffffffffea8133fc:	d503201f 	nop
		*d++ = *s++;
ffffffffea813400:	38626825 	ldrb	w5, [x1, x2]
ffffffffea813404:	38226885 	strb	w5, [x4, x2]
ffffffffea813408:	91000442 	add	x2, x2, #0x1
	for (len = count & lmask; len > 0; len--)
ffffffffea81340c:	eb03005f 	cmp	x2, x3
ffffffffea813410:	54ffff81 	b.ne	ffffffffea813400 <memcpy+0xd0>  // b.any

	return dest;
}
ffffffffea813414:	d65f03c0 	ret
			len = lsize - ((long)d & lmask); // move the ptrs up to a word boundary
ffffffffea813418:	12000804 	and	w4, w0, #0x7
ffffffffea81341c:	52800103 	mov	w3, #0x8                   	// #8
ffffffffea813420:	4b040063 	sub	w3, w3, w4
		count -= len;
ffffffffea813424:	cb23c042 	sub	x2, x2, w3, sxtw
ffffffffea813428:	17ffffd1 	b	ffffffffea81336c <memcpy+0x3c>
ffffffffea81342c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813430 <memmove>:
{
	char *d = (char *)dest;
	const char *s = (const char *)src;
	int len;

	if (count == 0 || dest == src)
ffffffffea813430:	f100005f 	cmp	x2, #0x0
ffffffffea813434:	fa411004 	ccmp	x0, x1, #0x4, ne  // ne = any
ffffffffea813438:	54000720 	b.eq	ffffffffea81351c <memmove+0xec>  // b.none
		return dest;

	if ((long)d < (long)s) {
ffffffffea81343c:	eb01001f 	cmp	x0, x1
ffffffffea813440:	5400070a 	b.ge	ffffffffea813520 <memmove+0xf0>  // b.tcont
		if (((long)d | (long)s) & lmask) {
ffffffffea813444:	aa010003 	orr	x3, x0, x1
ffffffffea813448:	aa0003e4 	mov	x4, x0
ffffffffea81344c:	f240087f 	tst	x3, #0x7
ffffffffea813450:	540002e0 	b.eq	ffffffffea8134ac <memmove+0x7c>  // b.none
			// src and/or dest do not align on word boundary
			if ((((long)d ^ (long)s) & lmask) || (count < lsize))
ffffffffea813454:	ca010003 	eor	x3, x0, x1
ffffffffea813458:	f240087f 	tst	x3, #0x7
ffffffffea81345c:	fa470840 	ccmp	x2, #0x7, #0x0, eq  // eq = none
ffffffffea813460:	54000d48 	b.hi	ffffffffea813608 <memmove+0x1d8>  // b.pmore
				len = count; // copy the rest of the buffer with the byte mover
ffffffffea813464:	2a0203e3 	mov	w3, w2
			else
				len = lsize - ((long)d & lmask); // move the ptrs up to a word boundary

			count -= len;
ffffffffea813468:	cb22c042 	sub	x2, x2, w2, sxtw
			for (; len > 0; len--)
ffffffffea81346c:	7100007f 	cmp	w3, #0x0
ffffffffea813470:	540001ed 	b.le	ffffffffea8134ac <memmove+0x7c>
ffffffffea813474:	51000466 	sub	w6, w3, #0x1
{
ffffffffea813478:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea81347c:	aa0603e5 	mov	x5, x6
ffffffffea813480:	910004c6 	add	x6, x6, #0x1
ffffffffea813484:	d503201f 	nop
				*d++ = *s++;
ffffffffea813488:	38636824 	ldrb	w4, [x1, x3]
ffffffffea81348c:	38236804 	strb	w4, [x0, x3]
ffffffffea813490:	91000463 	add	x3, x3, #0x1
			for (; len > 0; len--)
ffffffffea813494:	eb06007f 	cmp	x3, x6
ffffffffea813498:	54ffff81 	b.ne	ffffffffea813488 <memmove+0x58>  // b.any
ffffffffea81349c:	93407ca3 	sxtw	x3, w5
ffffffffea8134a0:	91000463 	add	x3, x3, #0x1
ffffffffea8134a4:	8b030004 	add	x4, x0, x3
ffffffffea8134a8:	8b030021 	add	x1, x1, x3
		}
		for (len = count / lsize; len > 0; len--) {
ffffffffea8134ac:	d343fc43 	lsr	x3, x2, #3
ffffffffea8134b0:	7100007f 	cmp	w3, #0x0
ffffffffea8134b4:	540001ed 	b.le	ffffffffea8134f0 <memmove+0xc0>
ffffffffea8134b8:	51000466 	sub	w6, w3, #0x1
ffffffffea8134bc:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea8134c0:	d37d7cc7 	ubfiz	x7, x6, #3, #32
ffffffffea8134c4:	910020e7 	add	x7, x7, #0x8
			*(word *)d = *(word *)s;
ffffffffea8134c8:	f8636825 	ldr	x5, [x1, x3]
ffffffffea8134cc:	f8236885 	str	x5, [x4, x3]
ffffffffea8134d0:	91002063 	add	x3, x3, #0x8
		for (len = count / lsize; len > 0; len--) {
ffffffffea8134d4:	eb07007f 	cmp	x3, x7
ffffffffea8134d8:	54ffff81 	b.ne	ffffffffea8134c8 <memmove+0x98>  // b.any
ffffffffea8134dc:	93407cc3 	sxtw	x3, w6
ffffffffea8134e0:	91000463 	add	x3, x3, #0x1
ffffffffea8134e4:	d37df063 	lsl	x3, x3, #3
ffffffffea8134e8:	8b030084 	add	x4, x4, x3
ffffffffea8134ec:	8b030021 	add	x1, x1, x3
			d += lsize;
			s += lsize;
		}
		for (len = count & lmask; len > 0; len--)
ffffffffea8134f0:	72000842 	ands	w2, w2, #0x7
ffffffffea8134f4:	54000140 	b.eq	ffffffffea81351c <memmove+0xec>  // b.none
ffffffffea8134f8:	51000445 	sub	w5, w2, #0x1
ffffffffea8134fc:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea813500:	910004a5 	add	x5, x5, #0x1
ffffffffea813504:	d503201f 	nop
			*d++ = *s++;
ffffffffea813508:	38626823 	ldrb	w3, [x1, x2]
ffffffffea81350c:	38226883 	strb	w3, [x4, x2]
ffffffffea813510:	91000442 	add	x2, x2, #0x1
		for (len = count & lmask; len > 0; len--)
ffffffffea813514:	eb05005f 	cmp	x2, x5
ffffffffea813518:	54ffff81 	b.ne	ffffffffea813508 <memmove+0xd8>  // b.any
		for (len = count & lmask; len > 0; len--)
			*--d = *--s;
	}

	return dest;
}
ffffffffea81351c:	d65f03c0 	ret
		d += count;
ffffffffea813520:	8b020004 	add	x4, x0, x2
		s += count;
ffffffffea813524:	8b020021 	add	x1, x1, x2
		if (((long)d | (long)s) & lmask) {
ffffffffea813528:	aa010083 	orr	x3, x4, x1
ffffffffea81352c:	f240087f 	tst	x3, #0x7
ffffffffea813530:	540002e0 	b.eq	ffffffffea81358c <memmove+0x15c>  // b.none
			if ((((long)d ^ (long)s) & lmask) || (count <= lsize))
ffffffffea813534:	ca010083 	eor	x3, x4, x1
				len = count;
ffffffffea813538:	12000885 	and	w5, w4, #0x7
			if ((((long)d ^ (long)s) & lmask) || (count <= lsize))
ffffffffea81353c:	f240087f 	tst	x3, #0x7
				len = count;
ffffffffea813540:	fa480840 	ccmp	x2, #0x8, #0x0, eq  // eq = none
ffffffffea813544:	1a859045 	csel	w5, w2, w5, ls  // ls = plast
			for (; len > 0; len--)
ffffffffea813548:	710000bf 	cmp	w5, #0x0
			count -= len;
ffffffffea81354c:	cb25c042 	sub	x2, x2, w5, sxtw
			for (; len > 0; len--)
ffffffffea813550:	540001ed 	b.le	ffffffffea81358c <memmove+0x15c>
ffffffffea813554:	510004a3 	sub	w3, w5, #0x1
ffffffffea813558:	92800027 	mov	x7, #0xfffffffffffffffe    	// #-2
ffffffffea81355c:	cb0300e7 	sub	x7, x7, x3
ffffffffea813560:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
ffffffffea813564:	d503201f 	nop
				*--d = *--s;
ffffffffea813568:	38636826 	ldrb	w6, [x1, x3]
ffffffffea81356c:	38236886 	strb	w6, [x4, x3]
ffffffffea813570:	d1000463 	sub	x3, x3, #0x1
			for (; len > 0; len--)
ffffffffea813574:	eb07007f 	cmp	x3, x7
ffffffffea813578:	54ffff81 	b.ne	ffffffffea813568 <memmove+0x138>  // b.any
ffffffffea81357c:	4b0503e5 	neg	w5, w5
ffffffffea813580:	93407ca5 	sxtw	x5, w5
ffffffffea813584:	8b050084 	add	x4, x4, x5
ffffffffea813588:	8b050021 	add	x1, x1, x5
		for (len = count / lsize; len > 0; len--) {
ffffffffea81358c:	d343fc43 	lsr	x3, x2, #3
ffffffffea813590:	7100007f 	cmp	w3, #0x0
ffffffffea813594:	5400022d 	b.le	ffffffffea8135d8 <memmove+0x1a8>
ffffffffea813598:	51000467 	sub	w7, w3, #0x1
ffffffffea81359c:	928000e3 	mov	x3, #0xfffffffffffffff8    	// #-8
ffffffffea8135a0:	aa0703e6 	mov	x6, x7
ffffffffea8135a4:	cb070fe7 	neg	x7, x7, lsl #3
ffffffffea8135a8:	d10040e7 	sub	x7, x7, #0x10
ffffffffea8135ac:	d503201f 	nop
			*(word *)d = *(word *)s;
ffffffffea8135b0:	f8636825 	ldr	x5, [x1, x3]
ffffffffea8135b4:	f8236885 	str	x5, [x4, x3]
ffffffffea8135b8:	d1002063 	sub	x3, x3, #0x8
		for (len = count / lsize; len > 0; len--) {
ffffffffea8135bc:	eb07007f 	cmp	x3, x7
ffffffffea8135c0:	54ffff81 	b.ne	ffffffffea8135b0 <memmove+0x180>  // b.any
ffffffffea8135c4:	93407cc3 	sxtw	x3, w6
ffffffffea8135c8:	aa2303e3 	mvn	x3, x3
ffffffffea8135cc:	d37df063 	lsl	x3, x3, #3
ffffffffea8135d0:	8b030084 	add	x4, x4, x3
ffffffffea8135d4:	8b030021 	add	x1, x1, x3
		for (len = count & lmask; len > 0; len--)
ffffffffea8135d8:	72000842 	ands	w2, w2, #0x7
ffffffffea8135dc:	54fffa00 	b.eq	ffffffffea81351c <memmove+0xec>  // b.none
ffffffffea8135e0:	51000442 	sub	w2, w2, #0x1
ffffffffea8135e4:	92800025 	mov	x5, #0xfffffffffffffffe    	// #-2
ffffffffea8135e8:	cb0200a5 	sub	x5, x5, x2
ffffffffea8135ec:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
			*--d = *--s;
ffffffffea8135f0:	38626823 	ldrb	w3, [x1, x2]
ffffffffea8135f4:	38226883 	strb	w3, [x4, x2]
ffffffffea8135f8:	d1000442 	sub	x2, x2, #0x1
		for (len = count & lmask; len > 0; len--)
ffffffffea8135fc:	eb05005f 	cmp	x2, x5
ffffffffea813600:	54ffff81 	b.ne	ffffffffea8135f0 <memmove+0x1c0>  // b.any
}
ffffffffea813604:	d65f03c0 	ret
				len = lsize - ((long)d & lmask); // move the ptrs up to a word boundary
ffffffffea813608:	12000804 	and	w4, w0, #0x7
ffffffffea81360c:	52800103 	mov	w3, #0x8                   	// #8
ffffffffea813610:	4b040063 	sub	w3, w3, w4
			count -= len;
ffffffffea813614:	cb23c042 	sub	x2, x2, w3, sxtw
ffffffffea813618:	17ffff97 	b	ffffffffea813474 <memmove+0x44>
ffffffffea81361c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813620 <memset>:

void *
memset(void *s, int c, size_t count)
{
	char *xs = (char *) s;
	size_t len = (-(size_t)s) & (sizeof(size_t)-1);
ffffffffea813620:	cb0003e5 	neg	x5, x0
	char *xs = (char *) s;
ffffffffea813624:	aa0003e3 	mov	x3, x0
	size_t len = (-(size_t)s) & (sizeof(size_t)-1);
ffffffffea813628:	924008a5 	and	x5, x5, #0x7
	size_t cc = c & 0xff;

	if ( count > len ) {
ffffffffea81362c:	eb0200bf 	cmp	x5, x2
ffffffffea813630:	54000282 	b.cs	ffffffffea813680 <memset+0x60>  // b.hs, b.nlast
	size_t cc = c & 0xff;
ffffffffea813634:	92401c24 	and	x4, x1, #0xff
		count -= len;
ffffffffea813638:	cb050042 	sub	x2, x2, x5
		cc |= cc << 8;
ffffffffea81363c:	aa042084 	orr	x4, x4, x4, lsl #8
		cc |= cc << 16;
ffffffffea813640:	aa044084 	orr	x4, x4, x4, lsl #16
		if (sizeof(size_t) == 8)
			cc |= (uint64_t)cc << 32; // should be optimized out on 32 bit machines
ffffffffea813644:	aa048084 	orr	x4, x4, x4, lsl #32

		// write to non-aligned memory byte-wise
		for ( ; len > 0; len-- )
ffffffffea813648:	b40000e5 	cbz	x5, ffffffffea813664 <memset+0x44>
ffffffffea81364c:	12001c26 	and	w6, w1, #0xff
ffffffffea813650:	8b050005 	add	x5, x0, x5
ffffffffea813654:	d503201f 	nop
			*xs++ = c;
ffffffffea813658:	38001466 	strb	w6, [x3], #1
		for ( ; len > 0; len-- )
ffffffffea81365c:	eb0300bf 	cmp	x5, x3
ffffffffea813660:	54ffffc1 	b.ne	ffffffffea813658 <memset+0x38>  // b.any

		// write to aligned memory dword-wise
		for ( len = count/sizeof(size_t); len > 0; len-- ) {
ffffffffea813664:	d343fc45 	lsr	x5, x2, #3
ffffffffea813668:	b40000a5 	cbz	x5, ffffffffea81367c <memset+0x5c>
ffffffffea81366c:	8b050c65 	add	x5, x3, x5, lsl #3
			*((size_t *)xs) = (size_t)cc;
ffffffffea813670:	f8008464 	str	x4, [x3], #8
		for ( len = count/sizeof(size_t); len > 0; len-- ) {
ffffffffea813674:	eb0300bf 	cmp	x5, x3
ffffffffea813678:	54ffffc1 	b.ne	ffffffffea813670 <memset+0x50>  // b.any
			xs += sizeof(size_t);
		}

		count &= sizeof(size_t)-1;
ffffffffea81367c:	92400842 	and	x2, x2, #0x7
	}

	// write remaining bytes
	for ( ; count > 0; count-- )
ffffffffea813680:	b40000e2 	cbz	x2, ffffffffea81369c <memset+0x7c>
ffffffffea813684:	12001c21 	and	w1, w1, #0xff
ffffffffea813688:	8b020062 	add	x2, x3, x2
ffffffffea81368c:	d503201f 	nop
		*xs++ = c;
ffffffffea813690:	38001461 	strb	w1, [x3], #1
	for ( ; count > 0; count-- )
ffffffffea813694:	eb03005f 	cmp	x2, x3
ffffffffea813698:	54ffffc1 	b.ne	ffffffffea813690 <memset+0x70>  // b.any

	return s;
}
ffffffffea81369c:	d65f03c0 	ret

ffffffffea8136a0 <strcmp>:
#include <string.h>
#include <sys/types.h>

int
strcmp(char const *cs, char const *ct)
{
ffffffffea8136a0:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea8136a4:	14000002 	b	ffffffffea8136ac <strcmp+0xc>
	signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
ffffffffea8136a8:	34000124 	cbz	w4, ffffffffea8136cc <strcmp+0x2c>
ffffffffea8136ac:	38636804 	ldrb	w4, [x0, x3]
ffffffffea8136b0:	38636822 	ldrb	w2, [x1, x3]
ffffffffea8136b4:	91000463 	add	x3, x3, #0x1
ffffffffea8136b8:	4b020082 	sub	w2, w4, w2
ffffffffea8136bc:	13001c42 	sxtb	w2, w2
ffffffffea8136c0:	34ffff42 	cbz	w2, ffffffffea8136a8 <strcmp+0x8>
ffffffffea8136c4:	2a0203e0 	mov	w0, w2
			break;
	}

	return __res;
}
ffffffffea8136c8:	d65f03c0 	ret
ffffffffea8136cc:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8136d0:	d65f03c0 	ret
ffffffffea8136d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8136d8 <strdup>:
#include <stdlib.h>
#include <string.h>

char *
strdup(const char *str)
{
ffffffffea8136d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8136dc:	910003fd 	mov	x29, sp
ffffffffea8136e0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8136e4:	f90013f5 	str	x21, [sp, #32]
ffffffffea8136e8:	aa0003f5 	mov	x21, x0
	size_t len;
	char *copy;

	len = strlen(str) + 1;
ffffffffea8136ec:	9400002f 	bl	ffffffffea8137a8 <strlen>
ffffffffea8136f0:	91000414 	add	x20, x0, #0x1
	copy = malloc(len);
ffffffffea8136f4:	aa1403e0 	mov	x0, x20
ffffffffea8136f8:	97fffef6 	bl	ffffffffea8132d0 <malloc>
ffffffffea8136fc:	aa0003f3 	mov	x19, x0
	if (copy == NULL)
ffffffffea813700:	b4000080 	cbz	x0, ffffffffea813710 <strdup+0x38>
		return NULL;
	memcpy(copy, str, len);
ffffffffea813704:	aa1403e2 	mov	x2, x20
ffffffffea813708:	aa1503e1 	mov	x1, x21
ffffffffea81370c:	97ffff09 	bl	ffffffffea813330 <memcpy>
	return copy;
}
ffffffffea813710:	aa1303e0 	mov	x0, x19
ffffffffea813714:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea813718:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81371c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea813720:	d65f03c0 	ret
ffffffffea813724:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813728 <strlcpy>:
size_t
strlcpy(char *dst, char const *src, size_t s)
{
	size_t i= 0;

	if (!s) {
ffffffffea813728:	b4000362 	cbz	x2, ffffffffea813794 <strlcpy+0x6c>
{
ffffffffea81372c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
		return strlen(src);
	}

	for (i= 0; ((i< s-1) && src[i]); i++) {
ffffffffea813730:	f1000442 	subs	x2, x2, #0x1
{
ffffffffea813734:	910003fd 	mov	x29, sp
ffffffffea813738:	f9000bf3 	str	x19, [sp, #16]
	for (i= 0; ((i< s-1) && src[i]); i++) {
ffffffffea81373c:	54000300 	b.eq	ffffffffea81379c <strlcpy+0x74>  // b.none
ffffffffea813740:	aa0103e3 	mov	x3, x1
ffffffffea813744:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea813748:	aa0003e5 	mov	x5, x0
ffffffffea81374c:	38401464 	ldrb	w4, [x3], #1
ffffffffea813750:	35000084 	cbnz	w4, ffffffffea813760 <strlcpy+0x38>
ffffffffea813754:	14000009 	b	ffffffffea813778 <strlcpy+0x50>
ffffffffea813758:	38401464 	ldrb	w4, [x3], #1
ffffffffea81375c:	340000e4 	cbz	w4, ffffffffea813778 <strlcpy+0x50>
		dst[i]= src[i];
ffffffffea813760:	38336804 	strb	w4, [x0, x19]
	for (i= 0; ((i< s-1) && src[i]); i++) {
ffffffffea813764:	91000673 	add	x19, x19, #0x1
ffffffffea813768:	aa0303e1 	mov	x1, x3
ffffffffea81376c:	8b130005 	add	x5, x0, x19
ffffffffea813770:	eb02027f 	cmp	x19, x2
ffffffffea813774:	54ffff21 	b.ne	ffffffffea813758 <strlcpy+0x30>  // b.any
	}

	dst[i]= 0;
ffffffffea813778:	390000bf 	strb	wzr, [x5]

	return i + strlen(src+i);
ffffffffea81377c:	aa0103e0 	mov	x0, x1
ffffffffea813780:	9400000a 	bl	ffffffffea8137a8 <strlen>
}
ffffffffea813784:	8b130000 	add	x0, x0, x19
ffffffffea813788:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea81378c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea813790:	d65f03c0 	ret
		return strlen(src);
ffffffffea813794:	aa0103e0 	mov	x0, x1
ffffffffea813798:	14000004 	b	ffffffffea8137a8 <strlen>
	for (i= 0; ((i< s-1) && src[i]); i++) {
ffffffffea81379c:	aa0003e5 	mov	x5, x0
ffffffffea8137a0:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea8137a4:	17fffff5 	b	ffffffffea813778 <strlcpy+0x50>

ffffffffea8137a8 <strlen>:
#include <string.h>
#include <sys/types.h>

size_t
strlen(char const *s)
{
ffffffffea8137a8:	aa0003e2 	mov	x2, x0
	size_t i;

	i= 0;
	while (s[i]) {
ffffffffea8137ac:	39400000 	ldrb	w0, [x0]
ffffffffea8137b0:	340000c0 	cbz	w0, ffffffffea8137c8 <strlen+0x20>
	i= 0;
ffffffffea8137b4:	d2800000 	mov	x0, #0x0                   	// #0
		i+= 1;
ffffffffea8137b8:	91000400 	add	x0, x0, #0x1
	while (s[i]) {
ffffffffea8137bc:	38606841 	ldrb	w1, [x2, x0]
ffffffffea8137c0:	35ffffc1 	cbnz	w1, ffffffffea8137b8 <strlen+0x10>
	}

	return i;
}
ffffffffea8137c4:	d65f03c0 	ret
	i= 0;
ffffffffea8137c8:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea8137cc:	d65f03c0 	ret

ffffffffea8137d0 <strncpy>:
char *
strncpy(char *dest, char const *src, size_t count)
{
	char *tmp = dest;

	while (count-- && (*dest++ = *src++) != '\0')
ffffffffea8137d0:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea8137d4:	14000005 	b	ffffffffea8137e8 <strncpy+0x18>
ffffffffea8137d8:	38636824 	ldrb	w4, [x1, x3]
ffffffffea8137dc:	38236804 	strb	w4, [x0, x3]
ffffffffea8137e0:	91000463 	add	x3, x3, #0x1
ffffffffea8137e4:	34000064 	cbz	w4, ffffffffea8137f0 <strncpy+0x20>
ffffffffea8137e8:	eb02007f 	cmp	x3, x2
ffffffffea8137ec:	54ffff61 	b.ne	ffffffffea8137d8 <strncpy+0x8>  // b.any
		;

	return tmp;
}
ffffffffea8137f0:	d65f03c0 	ret
ffffffffea8137f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8137f8 <strncmp>:
int
strncmp(char const *cs, char const *ct, size_t count)
{
	signed char __res = 0;

	while (count > 0) {
ffffffffea8137f8:	b4000242 	cbz	x2, ffffffffea813840 <strncmp+0x48>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
ffffffffea8137fc:	39400004 	ldrb	w4, [x0]
ffffffffea813800:	39400023 	ldrb	w3, [x1]
ffffffffea813804:	4b030083 	sub	w3, w4, w3
ffffffffea813808:	13001c63 	sxtb	w3, w3
ffffffffea81380c:	350001e3 	cbnz	w3, ffffffffea813848 <strncmp+0x50>
ffffffffea813810:	34000184 	cbz	w4, ffffffffea813840 <strncmp+0x48>
ffffffffea813814:	d2800024 	mov	x4, #0x1                   	// #1
ffffffffea813818:	14000008 	b	ffffffffea813838 <strncmp+0x40>
ffffffffea81381c:	38646805 	ldrb	w5, [x0, x4]
ffffffffea813820:	38646823 	ldrb	w3, [x1, x4]
ffffffffea813824:	91000484 	add	x4, x4, #0x1
ffffffffea813828:	4b0300a3 	sub	w3, w5, w3
ffffffffea81382c:	13001c63 	sxtb	w3, w3
ffffffffea813830:	350000c3 	cbnz	w3, ffffffffea813848 <strncmp+0x50>
ffffffffea813834:	34000065 	cbz	w5, ffffffffea813840 <strncmp+0x48>
	while (count > 0) {
ffffffffea813838:	eb04005f 	cmp	x2, x4
ffffffffea81383c:	54ffff01 	b.ne	ffffffffea81381c <strncmp+0x24>  // b.any
ffffffffea813840:	52800000 	mov	w0, #0x0                   	// #0
			break;
		count--;
	}

	return __res;
}
ffffffffea813844:	d65f03c0 	ret
ffffffffea813848:	2a0303e0 	mov	w0, w3
ffffffffea81384c:	d65f03c0 	ret

ffffffffea813850 <strnlen>:
#include <string.h>
#include <sys/types.h>

size_t
strnlen(char const *s, size_t count)
{
ffffffffea813850:	aa0003e3 	mov	x3, x0
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
ffffffffea813854:	b4000181 	cbz	x1, ffffffffea813884 <strnlen+0x34>
ffffffffea813858:	39400002 	ldrb	w2, [x0]
ffffffffea81385c:	34000142 	cbz	w2, ffffffffea813884 <strnlen+0x34>
ffffffffea813860:	8b010001 	add	x1, x0, x1
ffffffffea813864:	14000003 	b	ffffffffea813870 <strnlen+0x20>
ffffffffea813868:	39400002 	ldrb	w2, [x0]
ffffffffea81386c:	34000082 	cbz	w2, ffffffffea81387c <strnlen+0x2c>
ffffffffea813870:	91000400 	add	x0, x0, #0x1
ffffffffea813874:	eb01001f 	cmp	x0, x1
ffffffffea813878:	54ffff81 	b.ne	ffffffffea813868 <strnlen+0x18>  // b.any
ffffffffea81387c:	cb030000 	sub	x0, x0, x3
		;
	return sc - s;
}
ffffffffea813880:	d65f03c0 	ret
	for (sc = s; count-- && *sc != '\0'; ++sc)
ffffffffea813884:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea813888:	d65f03c0 	ret
ffffffffea81388c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813890 <arm64_syscall>:
 * r0-r1/x0    = return value (r0 only if 32-bit retval)
 * r12/x12     = syscall number, expected to be trashed.
 * syscalls run with interrupts enabled
 */
FUNCTION (arm64_syscall)
	push	x0, x30
ffffffffea813890:	a9bf7be0 	stp	x0, x30, [sp, #-16]!
	ldr	w12, [x0, #(12 << 3)]
ffffffffea813894:	b940600c 	ldr	w12, [x0, #96]

	msr	daifclr, #DAIF_MASK_IAF
ffffffffea813898:	d50347ff 	msr	daifclr, #0x7

	ldr	x14, =nr_syscalls
ffffffffea81389c:	580001ee 	ldr	x14, ffffffffea8138d8 <arm64_syscall+0x48>
	ldr	x14, [x14]
ffffffffea8138a0:	f94001ce 	ldr	x14, [x14]
	cmp	x12, x14
ffffffffea8138a4:	eb0e019f 	cmp	x12, x14
	b.hs	.Lundefined
ffffffffea8138a8:	54000082 	b.cs	ffffffffea8138b8 <arm64_syscall+0x28>  // b.hs, b.nlast
	ldr	x14, =syscall_table
ffffffffea8138ac:	580001ae 	ldr	x14, ffffffffea8138e0 <arm64_syscall+0x50>
	ldr	x14, [x14, x12, lsl#3]
ffffffffea8138b0:	f86c79ce 	ldr	x14, [x14, x12, lsl #3]
	cbnz	x14, .Ldefined
ffffffffea8138b4:	b500004e 	cbnz	x14, ffffffffea8138bc <arm64_syscall+0x2c>
.Lundefined:
	ldr	x14,=sys_undefined
ffffffffea8138b8:	5800018e 	ldr	x14, ffffffffea8138e8 <arm64_syscall+0x58>
.Ldefined:
	ldp	x2, x3, [x0, #16]
ffffffffea8138bc:	a9410c02 	ldp	x2, x3, [x0, #16]
	ldp	x0, x1, [x0]
ffffffffea8138c0:	a9400400 	ldp	x0, x1, [x0]
	blr	x14
ffffffffea8138c4:	d63f01c0 	blr	x14

	msr	daifset, #DAIF_MASK_IAF
ffffffffea8138c8:	d50347df 	msr	daifset, #0x7

	pop	x1, x30
ffffffffea8138cc:	a8c17be1 	ldp	x1, x30, [sp], #16

	str	x0, [x1, 0]
ffffffffea8138d0:	f9000020 	str	x0, [x1]

	ret
ffffffffea8138d4:	d65f03c0 	ret
ffffffffea8138d8:	ea819fc0 	.word	0xea819fc0
ffffffffea8138dc:	ffffffff 	.word	0xffffffff
ffffffffea8138e0:	ea817e08 	.word	0xea817e08
ffffffffea8138e4:	ffffffff 	.word	0xffffffff
ffffffffea8138e8:	ea8138f0 	.word	0xea8138f0
ffffffffea8138ec:	ffffffff 	.word	0xffffffff

ffffffffea8138f0 <sys_undefined>:
#include <kernel/thread.h>
#include <uthread.h>
#include <trusty_std.h>

long sys_undefined(int num)
{
ffffffffea8138f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea8138f4:	910003fd 	mov	x29, sp
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea8138f8:	d538d081 	mrs	x1, tpidr_el1
	dprintf(SPEW, "%p invalid syscall %d requested\n", get_current_thread(), num);
ffffffffea8138fc:	90000023 	adrp	x3, ffffffffea817000 <__func__.2428+0x420>
ffffffffea813900:	2a0003e2 	mov	w2, w0
ffffffffea813904:	91378060 	add	x0, x3, #0xde0
ffffffffea813908:	97fff866 	bl	ffffffffea811aa0 <_dprintf>
	return ERR_NOT_SUPPORTED;
}
ffffffffea81390c:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
ffffffffea813910:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea813914:	d65f03c0 	ret

ffffffffea813918 <arch_copy_to_user>:
#include <arch/asm_macros.h>
#include <err.h>

/* status_t arch_copy_to_user(user_addr_t udest, const void *ksrc, size_t len) */
FUNCTION(arch_copy_to_user)
	cbz	x2, .Larch_copy_to_user_done
ffffffffea813918:	b40000c2 	cbz	x2, ffffffffea813930 <arch_copy_to_user+0x18>
.Larch_copy_to_user_loop:
	ldrb	w9, [x1], #1
ffffffffea81391c:	38401429 	ldrb	w9, [x1], #1

	set_fault_handler	.Larch_copy_to_user_fault
	sttrb	w9, [x0]
ffffffffea813920:	38000809 	sttrb	w9, [x0]

	add	x0, x0, #1
ffffffffea813924:	91000400 	add	x0, x0, #0x1
	subs	x2, x2, #1
ffffffffea813928:	f1000442 	subs	x2, x2, #0x1
	b.hi	.Larch_copy_to_user_loop
ffffffffea81392c:	54ffff88 	b.hi	ffffffffea81391c <arch_copy_to_user+0x4>  // b.pmore
.Larch_copy_to_user_done:
	mov	x0, #0
ffffffffea813930:	d2800000 	mov	x0, #0x0                   	// #0
	ret
ffffffffea813934:	d65f03c0 	ret

ffffffffea813938 <arch_copy_from_user>:

/* status_t arch_copy_from_user(void *kdest, user_addr_t usrc, size_t len) */
FUNCTION(arch_copy_from_user)
	cbz	x2, .Larch_copy_to_user_done
ffffffffea813938:	b4ffffc2 	cbz	x2, ffffffffea813930 <arch_copy_to_user+0x18>
.Larch_copy_from_user_loop:
	set_fault_handler	.Larch_copy_from_user_fault
	ldtrb	w9, [x1]
ffffffffea81393c:	38400829 	ldtrb	w9, [x1]

	add	x1, x1, #1
ffffffffea813940:	91000421 	add	x1, x1, #0x1
	strb	w9, [x0], #1
ffffffffea813944:	38001409 	strb	w9, [x0], #1
	subs	x2, x2, #1
ffffffffea813948:	f1000442 	subs	x2, x2, #0x1
	b.hi	.Larch_copy_from_user_loop
ffffffffea81394c:	54ffff88 	b.hi	ffffffffea81393c <arch_copy_from_user+0x4>  // b.pmore
.Larch_copy_from_user_done:
	mov	x0, #0
ffffffffea813950:	d2800000 	mov	x0, #0x0                   	// #0
	ret
ffffffffea813954:	d65f03c0 	ret

ffffffffea813958 <arch_strlcpy_from_user>:

/* ssize_t arch_strlcpy_from_user(char *kdst, user_addr_t usrc, size_t len) */
FUNCTION(arch_strlcpy_from_user)
	mov	x10, x1
ffffffffea813958:	aa0103ea 	mov	x10, x1
.Larch_strlcpy_from_user_loop:
	set_fault_handler	.Larch_strlcpy_from_user_fault
	ldtrb	w9, [x1]
ffffffffea81395c:	38400829 	ldtrb	w9, [x1]

	cmp	w9, #0
ffffffffea813960:	7100013f 	cmp	w9, #0x0
	cinc	x1, x1, ne
ffffffffea813964:	9a810421 	cinc	x1, x1, ne  // ne = any

	cbz	x2, .Larch_strlcpy_from_user_dst_full
ffffffffea813968:	b4000082 	cbz	x2, ffffffffea813978 <arch_strlcpy_from_user+0x20>
	subs	x2, x2, #1
ffffffffea81396c:	f1000442 	subs	x2, x2, #0x1
	csel	w11, w9, wzr, hi
ffffffffea813970:	1a9f812b 	csel	w11, w9, wzr, hi  // hi = pmore
	strb	w11, [x0], #1
ffffffffea813974:	3800140b 	strb	w11, [x0], #1
.Larch_strlcpy_from_user_dst_full:
	cbnz	w9, .Larch_strlcpy_from_user_loop
ffffffffea813978:	35ffff29 	cbnz	w9, ffffffffea81395c <arch_strlcpy_from_user+0x4>

	sub	x0, x1, x10
ffffffffea81397c:	cb0a0020 	sub	x0, x1, x10
	ret
ffffffffea813980:	d65f03c0 	ret

.Larch_strlcpy_from_user_fault:
	cbz	x2, .Larch_copy_to_user_fault
ffffffffea813984:	b4000082 	cbz	x2, ffffffffea813994 <arch_strlcpy_from_user+0x3c>
.Larch_copy_from_user_fault:
	strb	wzr, [x0], #1
ffffffffea813988:	3800141f 	strb	wzr, [x0], #1
	subs	x2, x2, #1
ffffffffea81398c:	f1000442 	subs	x2, x2, #0x1
	b.hi	.Larch_copy_from_user_fault
ffffffffea813990:	54ffffc8 	b.hi	ffffffffea813988 <arch_strlcpy_from_user+0x30>  // b.pmore
.Larch_copy_to_user_fault:
	mov	x0, #ERR_FAULT
ffffffffea813994:	928004e0 	mov	x0, #0xffffffffffffffd8    	// #-40
	ret
ffffffffea813998:	d65f03c0 	ret
ffffffffea81399c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8139a0 <uthread_find_va_space_ns>:
{
}


static vaddr_t uthread_find_va_space_ns(uthread_t *ut, size_t size, u_int align)
{
ffffffffea8139a0:	aa0003e9 	mov	x9, x0
	vaddr_t start, end;
	uthread_map_t *mp;

	/* get first suitable address */
	start = ROUNDDOWN(MAX_USR_VA - size, align);
ffffffffea8139a4:	4b0203e2 	neg	w2, w2
ffffffffea8139a8:	d2a04003 	mov	x3, #0x2000000             	// #33554432
ffffffffea8139ac:	cb010063 	sub	x3, x3, x1
	end = start + size;

	mp = list_peek_tail_type (&ut->map_list, uthread_map_t, node);
ffffffffea8139b0:	91006007 	add	x7, x0, #0x18
	start = ROUNDDOWN(MAX_USR_VA - size, align);
ffffffffea8139b4:	8a020060 	and	x0, x3, x2
	if (list->prev != list) {
ffffffffea8139b8:	f9400d24 	ldr	x4, [x9, #24]
	end = start + size;
ffffffffea8139bc:	8b000028 	add	x8, x1, x0
	mp = list_peek_tail_type (&ut->map_list, uthread_map_t, node);
ffffffffea8139c0:	f100009f 	cmp	x4, #0x0
ffffffffea8139c4:	fa4410e4 	ccmp	x7, x4, #0x4, ne  // ne = any
ffffffffea8139c8:	540000c1 	b.ne	ffffffffea8139e0 <uthread_find_va_space_ns+0x40>  // b.any

		/* get prev list item */
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
	}

	if (start < ut->start_stack || start > end) {
ffffffffea8139cc:	f9400121 	ldr	x1, [x9]
ffffffffea8139d0:	eb00003f 	cmp	x1, x0
		return (vaddr_t) NULL;
ffffffffea8139d4:	fa489002 	ccmp	x0, x8, #0x2, ls  // ls = plast
ffffffffea8139d8:	9a9f9000 	csel	x0, x0, xzr, ls  // ls = plast
	}
	return start;
}
ffffffffea8139dc:	d65f03c0 	ret
	while (mp) {
ffffffffea8139e0:	f1006086 	subs	x6, x4, #0x18
ffffffffea8139e4:	54ffff40 	b.eq	ffffffffea8139cc <uthread_find_va_space_ns+0x2c>  // b.none
		if (start >= mp->vaddr + mp->size) { /* found gap */
ffffffffea8139e8:	a97e9483 	ldp	x3, x5, [x4, #-24]
ffffffffea8139ec:	8b050065 	add	x5, x3, x5
ffffffffea8139f0:	eb05001f 	cmp	x0, x5
ffffffffea8139f4:	54000243 	b.cc	ffffffffea813a3c <uthread_find_va_space_ns+0x9c>  // b.lo, b.ul, b.last
ffffffffea8139f8:	14000015 	b	ffffffffea813a4c <uthread_find_va_space_ns+0xac>
		start = MIN(start, ROUNDDOWN((mp->vaddr - size), align));
ffffffffea8139fc:	cb010063 	sub	x3, x3, x1
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
ffffffffea813a00:	f9400cc4 	ldr	x4, [x6, #24]
		start = MIN(start, ROUNDDOWN((mp->vaddr - size), align));
ffffffffea813a04:	8a020063 	and	x3, x3, x2
ffffffffea813a08:	eb03001f 	cmp	x0, x3
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
ffffffffea813a0c:	d1006086 	sub	x6, x4, #0x18
		start = MIN(start, ROUNDDOWN((mp->vaddr - size), align));
ffffffffea813a10:	9a839000 	csel	x0, x0, x3, ls  // ls = plast
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
ffffffffea813a14:	f100009f 	cmp	x4, #0x0
		end = start + size;
ffffffffea813a18:	8b000028 	add	x8, x1, x0
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
ffffffffea813a1c:	fa4410e4 	ccmp	x7, x4, #0x4, ne  // ne = any
ffffffffea813a20:	54fffd60 	b.eq	ffffffffea8139cc <uthread_find_va_space_ns+0x2c>  // b.none
	while (mp) {
ffffffffea813a24:	f100609f 	cmp	x4, #0x18
ffffffffea813a28:	54fffd20 	b.eq	ffffffffea8139cc <uthread_find_va_space_ns+0x2c>  // b.none
		if (start >= mp->vaddr + mp->size) { /* found gap */
ffffffffea813a2c:	a97e9483 	ldp	x3, x5, [x4, #-24]
ffffffffea813a30:	8b050065 	add	x5, x3, x5
ffffffffea813a34:	eb0000bf 	cmp	x5, x0
ffffffffea813a38:	540000a9 	b.ls	ffffffffea813a4c <uthread_find_va_space_ns+0xac>  // b.plast
		if (!(mp->flags & UTM_NS_MEM)) {
ffffffffea813a3c:	b85f8084 	ldur	w4, [x4, #-8]
ffffffffea813a40:	3737fde4 	tbnz	w4, #6, ffffffffea8139fc <uthread_find_va_space_ns+0x5c>
		return (vaddr_t) NULL;
ffffffffea813a44:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea813a48:	d65f03c0 	ret
			if (start >= ut->ns_va_bottom) {
ffffffffea813a4c:	f9403121 	ldr	x1, [x9, #96]
ffffffffea813a50:	eb00003f 	cmp	x1, x0
ffffffffea813a54:	54fffbc9 	b.ls	ffffffffea8139cc <uthread_find_va_space_ns+0x2c>  // b.plast
			if (ROUNDDOWN(start, UT_MAP_ALIGN_1MB) < mp->vaddr + mp->size) {
ffffffffea813a58:	926cac01 	and	x1, x0, #0xfffffffffff00000
ffffffffea813a5c:	eb05003f 	cmp	x1, x5
ffffffffea813a60:	54fffb62 	b.cs	ffffffffea8139cc <uthread_find_va_space_ns+0x2c>  // b.hs, b.nlast
		return (vaddr_t) NULL;
ffffffffea813a64:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea813a68:	17fffff8 	b	ffffffffea813a48 <uthread_find_va_space_ns+0xa8>
ffffffffea813a6c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813a70 <uthread_find_va_space_sec>:
static vaddr_t uthread_find_va_space_sec(uthread_t *ut, size_t size, u_int align)
{
	vaddr_t start, end;
	uthread_map_t *mp;

	start = ROUNDUP(ut->start_stack, align);
ffffffffea813a70:	f9400004 	ldr	x4, [x0]
ffffffffea813a74:	51000448 	sub	w8, w2, #0x1
	end = start + size;

	/* find first fit */
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea813a78:	f9401006 	ldr	x6, [x0, #32]
	start = ROUNDUP(ut->start_stack, align);
ffffffffea813a7c:	4b0203e2 	neg	w2, w2
ffffffffea813a80:	8b040104 	add	x4, x8, x4
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea813a84:	d10060c5 	sub	x5, x6, #0x18
	start = ROUNDUP(ut->start_stack, align);
ffffffffea813a88:	8a020084 	and	x4, x4, x2
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea813a8c:	eb05001f 	cmp	x0, x5
	end = start + size;
ffffffffea813a90:	8b010083 	add	x3, x4, x1
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea813a94:	54000260 	b.eq	ffffffffea813ae0 <uthread_find_va_space_sec+0x70>  // b.none
		if (end <= mp->vaddr) {
ffffffffea813a98:	f85e80c6 	ldur	x6, [x6, #-24]
ffffffffea813a9c:	eb06007f 	cmp	x3, x6
ffffffffea813aa0:	540000a8 	b.hi	ffffffffea813ab4 <uthread_find_va_space_sec+0x44>  // b.pmore
ffffffffea813aa4:	1400000f 	b	ffffffffea813ae0 <uthread_find_va_space_sec+0x70>
ffffffffea813aa8:	f85e80e6 	ldur	x6, [x7, #-24]
ffffffffea813aac:	eb0300df 	cmp	x6, x3
ffffffffea813ab0:	54000182 	b.cs	ffffffffea813ae0 <uthread_find_va_space_sec+0x70>  // b.hs, b.nlast
			break;
		}
		start = MAX(start, ROUNDUP((mp->vaddr + mp->size), align));
ffffffffea813ab4:	f94004a3 	ldr	x3, [x5, #8]
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea813ab8:	f94010a7 	ldr	x7, [x5, #32]
		start = MAX(start, ROUNDUP((mp->vaddr + mp->size), align));
ffffffffea813abc:	8b030103 	add	x3, x8, x3
ffffffffea813ac0:	8b060063 	add	x3, x3, x6
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea813ac4:	d10060e5 	sub	x5, x7, #0x18
		start = MAX(start, ROUNDUP((mp->vaddr + mp->size), align));
ffffffffea813ac8:	8a020063 	and	x3, x3, x2
ffffffffea813acc:	eb03009f 	cmp	x4, x3
ffffffffea813ad0:	9a832084 	csel	x4, x4, x3, cs  // cs = hs, nlast
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea813ad4:	eb05001f 	cmp	x0, x5
		end = start + size;
ffffffffea813ad8:	8b040023 	add	x3, x1, x4
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea813adc:	54fffe61 	b.ne	ffffffffea813aa8 <uthread_find_va_space_sec+0x38>  // b.any
	}

	if (end > ut->ns_va_bottom || start > end) {
ffffffffea813ae0:	f9403000 	ldr	x0, [x0, #96]
ffffffffea813ae4:	eb03001f 	cmp	x0, x3
		return (vaddr_t) NULL;
ffffffffea813ae8:	fa442060 	ccmp	x3, x4, #0x0, cs  // cs = hs, nlast
	}
	return start;
}
ffffffffea813aec:	9a9f2080 	csel	x0, x4, xzr, cs  // cs = hs, nlast
ffffffffea813af0:	d65f03c0 	ret
ffffffffea813af4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813af8 <uthread_free_maps>:
}

static void uthread_free_maps(uthread_t *ut)
{
	uthread_map_t *mp, *tmp;
	list_for_every_entry_safe(&ut->map_list, mp, tmp,
ffffffffea813af8:	f9401001 	ldr	x1, [x0, #32]
ffffffffea813afc:	d1006021 	sub	x1, x1, #0x18
ffffffffea813b00:	f9401022 	ldr	x2, [x1, #32]
ffffffffea813b04:	eb01001f 	cmp	x0, x1
ffffffffea813b08:	540002a0 	b.eq	ffffffffea813b5c <uthread_free_maps+0x64>  // b.none
{
ffffffffea813b0c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea813b10:	910003fd 	mov	x29, sp
ffffffffea813b14:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea813b18:	aa0003f4 	mov	x20, x0
ffffffffea813b1c:	d1006053 	sub	x19, x2, #0x18
	item->next->prev = item->prev;
ffffffffea813b20:	f9400c23 	ldr	x3, [x1, #24]
			uthread_map_t, node) {
		list_delete(&mp->node);
		free(mp);
ffffffffea813b24:	aa0103e0 	mov	x0, x1
ffffffffea813b28:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea813b2c:	f9400c23 	ldr	x3, [x1, #24]
ffffffffea813b30:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea813b34:	a901fc3f 	stp	xzr, xzr, [x1, #24]
ffffffffea813b38:	97fffdfc 	bl	ffffffffea813328 <free>
	list_for_every_entry_safe(&ut->map_list, mp, tmp,
ffffffffea813b3c:	f9401262 	ldr	x2, [x19, #32]
ffffffffea813b40:	aa1303e1 	mov	x1, x19
ffffffffea813b44:	eb13029f 	cmp	x20, x19
ffffffffea813b48:	d1006053 	sub	x19, x2, #0x18
ffffffffea813b4c:	54fffea1 	b.ne	ffffffffea813b20 <uthread_free_maps+0x28>  // b.any
	}
}
ffffffffea813b50:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea813b54:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea813b58:	d65f03c0 	ret
ffffffffea813b5c:	d65f03c0 	ret

ffffffffea813b60 <uthread_map_alloc>:
{
ffffffffea813b60:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	ASSERT(!(size & (PAGE_SIZE - 1)));
ffffffffea813b64:	f2402c9f 	tst	x4, #0xfff
{
ffffffffea813b68:	910003fd 	mov	x29, sp
	ASSERT(!(size & (PAGE_SIZE - 1)));
ffffffffea813b6c:	54000f01 	b.ne	ffffffffea813d4c <uthread_map_alloc+0x1ec>  // b.any
ffffffffea813b70:	f9000fb4 	str	x20, [x29, #24]
ffffffffea813b74:	aa0003f4 	mov	x20, x0
ffffffffea813b78:	a902dfb6 	stp	x22, x23, [x29, #40]
	if (vaddr + size <= vaddr) {
ffffffffea813b7c:	8b020080 	add	x0, x4, x2
ffffffffea813b80:	aa0403f6 	mov	x22, x4
ffffffffea813b84:	aa0203f7 	mov	x23, x2
ffffffffea813b88:	eb02001f 	cmp	x0, x2
ffffffffea813b8c:	54000fc9 	b.ls	ffffffffea813d84 <uthread_map_alloc+0x224>  // b.plast
ffffffffea813b90:	f9000bb3 	str	x19, [x29, #16]
ffffffffea813b94:	f90013b5 	str	x21, [x29, #32]
ffffffffea813b98:	aa0103f5 	mov	x21, x1
ffffffffea813b9c:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea813ba0:	aa0303f9 	mov	x25, x3
ffffffffea813ba4:	a904efba 	stp	x26, x27, [x29, #72]
ffffffffea813ba8:	2a0503f8 	mov	w24, w5
ffffffffea813bac:	2a0603fa 	mov	w26, w6
	if (flags & UTM_PHYS_CONTIG) {
ffffffffea813bb0:	372807d8 	tbnz	w24, #5, ffffffffea813ca8 <uthread_map_alloc+0x148>
ffffffffea813bb4:	d34cac9b 	ubfx	x27, x4, #12, #32
ffffffffea813bb8:	91001760 	add	x0, x27, #0x5
ffffffffea813bbc:	d37df000 	lsl	x0, x0, #3
	mp = malloc(sizeof(uthread_map_t) + (npages * sizeof(mp->pfn_list[0])));
ffffffffea813bc0:	97fffdc4 	bl	ffffffffea8132d0 <malloc>
ffffffffea813bc4:	aa0003f3 	mov	x19, x0
	if (!mp) {
ffffffffea813bc8:	b40007a0 	cbz	x0, ffffffffea813cbc <uthread_map_alloc+0x15c>
	mp->size = size;
ffffffffea813bcc:	a9005a77 	stp	x23, x22, [x19]
	memcpy(mp->pfn_list, pfn_list, npages*sizeof(paddr_t));
ffffffffea813bd0:	d37df362 	lsl	x2, x27, #3
	mp->align = align;
ffffffffea813bd4:	29026a78 	stp	w24, w26, [x19, #16]
	memcpy(mp->pfn_list, pfn_list, npages*sizeof(paddr_t));
ffffffffea813bd8:	aa1903e1 	mov	x1, x25
ffffffffea813bdc:	9100a000 	add	x0, x0, #0x28
ffffffffea813be0:	97fffdd4 	bl	ffffffffea813330 <memcpy>
	if ((mp->flags & UTM_NS_MEM) && (mp->vaddr < ut->ns_va_bottom)) {
ffffffffea813be4:	b9401260 	ldr	w0, [x19, #16]
	new_ns = ut->ns_va_bottom;
ffffffffea813be8:	f9403284 	ldr	x4, [x20, #96]
	if ((mp->flags & UTM_NS_MEM) && (mp->vaddr < ut->ns_va_bottom)) {
ffffffffea813bec:	363000a0 	tbz	w0, #6, ffffffffea813c00 <uthread_map_alloc+0xa0>
ffffffffea813bf0:	f9400260 	ldr	x0, [x19]
		new_ns = ROUNDDOWN(mp->vaddr, UT_MAP_ALIGN_1MB);
ffffffffea813bf4:	926cac01 	and	x1, x0, #0xfffffffffff00000
ffffffffea813bf8:	eb04001f 	cmp	x0, x4
ffffffffea813bfc:	9a843024 	csel	x4, x1, x4, cc  // cc = lo, ul, last
	list_for_every_entry(&ut->map_list, mp_lst, uthread_map_t, node) {
ffffffffea813c00:	f9401281 	ldr	x1, [x20, #32]
ffffffffea813c04:	d1006022 	sub	x2, x1, #0x18
ffffffffea813c08:	eb02029f 	cmp	x20, x2
ffffffffea813c0c:	540002a0 	b.eq	ffffffffea813c60 <uthread_map_alloc+0x100>  // b.none
		if (mp_lst->vaddr > mp->vaddr) {
ffffffffea813c10:	f85e8020 	ldur	x0, [x1, #-24]
ffffffffea813c14:	f9400263 	ldr	x3, [x19]
ffffffffea813c18:	eb03001f 	cmp	x0, x3
ffffffffea813c1c:	540007e8 	b.hi	ffffffffea813d18 <uthread_map_alloc+0x1b8>  // b.pmore
			if (mp->vaddr < (mp_lst->vaddr + mp_lst->size)) {
ffffffffea813c20:	f85f0021 	ldur	x1, [x1, #-16]
ffffffffea813c24:	8b010000 	add	x0, x0, x1
ffffffffea813c28:	eb03001f 	cmp	x0, x3
ffffffffea813c2c:	54000129 	b.ls	ffffffffea813c50 <uthread_map_alloc+0xf0>  // b.plast
ffffffffea813c30:	14000036 	b	ffffffffea813d08 <uthread_map_alloc+0x1a8>
		if (mp_lst->vaddr > mp->vaddr) {
ffffffffea813c34:	f85e8020 	ldur	x0, [x1, #-24]
ffffffffea813c38:	eb00007f 	cmp	x3, x0
ffffffffea813c3c:	540006e3 	b.cc	ffffffffea813d18 <uthread_map_alloc+0x1b8>  // b.lo, b.ul, b.last
			if (mp->vaddr < (mp_lst->vaddr + mp_lst->size)) {
ffffffffea813c40:	f85f0021 	ldur	x1, [x1, #-16]
ffffffffea813c44:	8b010000 	add	x0, x0, x1
ffffffffea813c48:	eb00007f 	cmp	x3, x0
ffffffffea813c4c:	540005e3 	b.cc	ffffffffea813d08 <uthread_map_alloc+0x1a8>  // b.lo, b.ul, b.last
	list_for_every_entry(&ut->map_list, mp_lst, uthread_map_t, node) {
ffffffffea813c50:	f9401041 	ldr	x1, [x2, #32]
ffffffffea813c54:	d1006022 	sub	x2, x1, #0x18
ffffffffea813c58:	eb02029f 	cmp	x20, x2
ffffffffea813c5c:	54fffec1 	b.ne	ffffffffea813c34 <uthread_map_alloc+0xd4>  // b.any
	item->prev = list->prev;
ffffffffea813c60:	aa1403e1 	mov	x1, x20
	list_add_tail(&ut->map_list, &mp->node);
ffffffffea813c64:	91006260 	add	x0, x19, #0x18
ffffffffea813c68:	f8418c22 	ldr	x2, [x1, #24]!
	item->next = list;
ffffffffea813c6c:	a9018662 	stp	x2, x1, [x19, #24]
	ut->ns_va_bottom = new_ns;
ffffffffea813c70:	f9003284 	str	x4, [x20, #96]
	list->prev->next = item;
ffffffffea813c74:	f9000440 	str	x0, [x2, #8]
	list->prev = item;
ffffffffea813c78:	f9000e80 	str	x0, [x20, #24]
	return NO_ERROR;
ffffffffea813c7c:	52800000 	mov	w0, #0x0                   	// #0
	if (mpp) {
ffffffffea813c80:	b4000355 	cbz	x21, ffffffffea813ce8 <uthread_map_alloc+0x188>
ffffffffea813c84:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea813c88:	a944efba 	ldp	x26, x27, [x29, #72]
		*mpp = mp;
ffffffffea813c8c:	f90002b3 	str	x19, [x21]
ffffffffea813c90:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea813c94:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea813c98:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea813c9c:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea813ca0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea813ca4:	d65f03c0 	ret
ffffffffea813ca8:	d2800600 	mov	x0, #0x30                  	// #48
ffffffffea813cac:	d280003b 	mov	x27, #0x1                   	// #1
	mp = malloc(sizeof(uthread_map_t) + (npages * sizeof(mp->pfn_list[0])));
ffffffffea813cb0:	97fffd88 	bl	ffffffffea8132d0 <malloc>
ffffffffea813cb4:	aa0003f3 	mov	x19, x0
	if (!mp) {
ffffffffea813cb8:	b5fff8a0 	cbnz	x0, ffffffffea813bcc <uthread_map_alloc+0x6c>
		err = ERR_NO_MEMORY;
ffffffffea813cbc:	12800080 	mov	w0, #0xfffffffb            	// #-5
	if (mpp) {
ffffffffea813cc0:	b4000155 	cbz	x21, ffffffffea813ce8 <uthread_map_alloc+0x188>
ffffffffea813cc4:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea813cc8:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea813ccc:	a944efba 	ldp	x26, x27, [x29, #72]
		*mpp = NULL;
ffffffffea813cd0:	f90002bf 	str	xzr, [x21]
ffffffffea813cd4:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea813cd8:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea813cdc:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea813ce0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea813ce4:	d65f03c0 	ret
ffffffffea813ce8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea813cec:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea813cf0:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea813cf4:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea813cf8:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea813cfc:	a944efba 	ldp	x26, x27, [x29, #72]
ffffffffea813d00:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea813d04:	d65f03c0 	ret
	free(mp);
ffffffffea813d08:	aa1303e0 	mov	x0, x19
ffffffffea813d0c:	97fffd87 	bl	ffffffffea813328 <free>
ffffffffea813d10:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea813d14:	17ffffeb 	b	ffffffffea813cc0 <uthread_map_alloc+0x160>
			if((mp->vaddr + mp->size) > mp_lst->vaddr) {
ffffffffea813d18:	f9400661 	ldr	x1, [x19, #8]
ffffffffea813d1c:	8b010063 	add	x3, x3, x1
ffffffffea813d20:	eb00007f 	cmp	x3, x0
ffffffffea813d24:	54ffff28 	b.hi	ffffffffea813d08 <uthread_map_alloc+0x1a8>  // b.pmore
	item->prev = list->prev;
ffffffffea813d28:	aa0203e1 	mov	x1, x2
			list_add_before(&mp_lst->node, &mp->node);
ffffffffea813d2c:	91006260 	add	x0, x19, #0x18
ffffffffea813d30:	f8418c23 	ldr	x3, [x1, #24]!
	item->next = list;
ffffffffea813d34:	a9018663 	stp	x3, x1, [x19, #24]
	list->prev->next = item;
ffffffffea813d38:	f9400c41 	ldr	x1, [x2, #24]
			ut->ns_va_bottom = new_ns;
ffffffffea813d3c:	f9003284 	str	x4, [x20, #96]
ffffffffea813d40:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea813d44:	f9000c40 	str	x0, [x2, #24]
ffffffffea813d48:	17ffffcd 	b	ffffffffea813c7c <uthread_map_alloc+0x11c>
	ASSERT(!(size & (PAGE_SIZE - 1)));
ffffffffea813d4c:	90000024 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea813d50:	90000022 	adrp	x2, ffffffffea817000 <__func__.2428+0x420>
ffffffffea813d54:	d0000001 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea813d58:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea813d5c:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea813d60:	913e8084 	add	x4, x4, #0xfa0
ffffffffea813d64:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea813d68:	52801463 	mov	w3, #0xa3                  	// #163
ffffffffea813d6c:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea813d70:	913f0042 	add	x2, x2, #0xfc0
ffffffffea813d74:	9135a021 	add	x1, x1, #0xd68
ffffffffea813d78:	aa1e03e0 	mov	x0, x30
ffffffffea813d7c:	f9002bbb 	str	x27, [x29, #80]
ffffffffea813d80:	97fff7c6 	bl	ffffffffea811c98 <_panic>
		return ERR_INVALID_ARGS;
ffffffffea813d84:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea813d88:	17ffffd4 	b	ffffffffea813cd8 <uthread_map_alloc+0x178>
ffffffffea813d8c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813d90 <uthread_init>:
	list->prev = list->next = list;
ffffffffea813d90:	d0000241 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea813d94:	913f4020 	add	x0, x1, #0xfd0
ffffffffea813d98:	f907e820 	str	x0, [x1, #4048]
ffffffffea813d9c:	f9000400 	str	x0, [x0, #8]
#endif

static void uthread_init(uint level)
{
	list_initialize(&uthread_list);
	arch_uthread_init();
ffffffffea813da0:	14000248 	b	ffffffffea8146c0 <arch_uthread_init>
ffffffffea813da4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813da8 <uthread_start>:
	if (!ut || !ut->thread) {
ffffffffea813da8:	b4000080 	cbz	x0, ffffffffea813db8 <uthread_start+0x10>
ffffffffea813dac:	f9403c00 	ldr	x0, [x0, #120]
ffffffffea813db0:	b4000040 	cbz	x0, ffffffffea813db8 <uthread_start+0x10>
	return thread_resume(ut->thread);
ffffffffea813db4:	17ffc979 	b	ffffffffea806398 <thread_resume>
}
ffffffffea813db8:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea813dbc:	d65f03c0 	ret

ffffffffea813dc0 <uthread_exit>:
{
ffffffffea813dc0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea813dc4:	910003fd 	mov	x29, sp
ffffffffea813dc8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea813dcc:	2a0003f4 	mov	w20, w0
ffffffffea813dd0:	d538d080 	mrs	x0, tpidr_el1
#define THREAD_UNLOCK(state) spin_unlock_irqrestore(&thread_lock, state)

/* thread local storage */
static inline __ALWAYS_INLINE uintptr_t tls_get(uint entry)
{
	return get_current_thread()->tls[entry];
ffffffffea813dd4:	f9415813 	ldr	x19, [x0, #688]
	if (ut) {
ffffffffea813dd8:	b4000173 	cbz	x19, ffffffffea813e04 <uthread_exit+0x44>
		uthread_free_maps(ut);
ffffffffea813ddc:	aa1303e0 	mov	x0, x19
ffffffffea813de0:	97ffff46 	bl	ffffffffea813af8 <uthread_free_maps>
		free(ut->stack);
ffffffffea813de4:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea813de8:	97fffd50 	bl	ffffffffea813328 <free>
		arch_uthread_free(ut);
ffffffffea813dec:	aa1303e0 	mov	x0, x19
ffffffffea813df0:	9400026e 	bl	ffffffffea8147a8 <arch_uthread_free>
		free(ut);
ffffffffea813df4:	aa1303e0 	mov	x0, x19
ffffffffea813df8:	97fffd4c 	bl	ffffffffea813328 <free>
	thread_exit(retcode);
ffffffffea813dfc:	2a1403e0 	mov	w0, w20
ffffffffea813e00:	97ffcc6a 	bl	ffffffffea806fa8 <thread_exit>
ffffffffea813e04:	d538d083 	mrs	x3, tpidr_el1
		TRACEF("WARNING: unexpected call on kernel thread %s!",
ffffffffea813e08:	90000021 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea813e0c:	90000020 	adrp	x0, ffffffffea817000 <__func__.2428+0x420>
ffffffffea813e10:	910ae063 	add	x3, x3, #0x2b8
ffffffffea813e14:	52802f42 	mov	w2, #0x17a                 	// #378
ffffffffea813e18:	913ca021 	add	x1, x1, #0xf28
ffffffffea813e1c:	913da000 	add	x0, x0, #0xf68
ffffffffea813e20:	97fffd04 	bl	ffffffffea813230 <_printf>
ffffffffea813e24:	17fffff6 	b	ffffffffea813dfc <uthread_exit+0x3c>

ffffffffea813e28 <uthread_context_switch>:
	arch_uthread_context_switch(old_ut, new_ut);
ffffffffea813e28:	f9415800 	ldr	x0, [x0, #688]
ffffffffea813e2c:	f9415821 	ldr	x1, [x1, #688]
ffffffffea813e30:	14000236 	b	ffffffffea814708 <arch_uthread_context_switch>
ffffffffea813e34:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813e38 <uthread_map>:
{
ffffffffea813e38:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea813e3c:	910003fd 	mov	x29, sp
ffffffffea813e40:	a9025bf5 	stp	x21, x22, [sp, #32]
	mutex_acquire(&ut->mmap_lock);
ffffffffea813e44:	9100a016 	add	x22, x0, #0x28
{
ffffffffea813e48:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea813e4c:	2a0403f5 	mov	w21, w4
ffffffffea813e50:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea813e54:	aa0003f3 	mov	x19, x0
ffffffffea813e58:	aa0103f7 	mov	x23, x1
ffffffffea813e5c:	aa0203f8 	mov	x24, x2
ffffffffea813e60:	f90023f9 	str	x25, [sp, #64]
ffffffffea813e64:	aa0303f4 	mov	x20, x3
ffffffffea813e68:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea813e6c:	aa1603e0 	mov	x0, x22
ffffffffea813e70:	2a0503f9 	mov	w25, w5
ffffffffea813e74:	97ffc6d1 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	if (!ut || !pfn_list || !vaddrp) {
ffffffffea813e78:	f100031f 	cmp	x24, #0x0
	uthread_map_t *mp = NULL;
ffffffffea813e7c:	f9002fbf 	str	xzr, [x29, #88]
	if (!ut || !pfn_list || !vaddrp) {
ffffffffea813e80:	fa401ae4 	ccmp	x23, #0x0, #0x4, ne  // ne = any
ffffffffea813e84:	fa401a64 	ccmp	x19, #0x0, #0x4, ne  // ne = any
ffffffffea813e88:	54000500 	b.eq	ffffffffea813f28 <uthread_map+0xf0>  // b.none
	if((size & (PAGE_SIZE - 1))) {
ffffffffea813e8c:	f2402e9f 	tst	x20, #0xfff
ffffffffea813e90:	54000501 	b.ne	ffffffffea813f30 <uthread_map+0xf8>  // b.any
	if(!(flags & UTM_FIXED)) {
ffffffffea813e94:	36400315 	tbz	w21, #8, ffffffffea813ef4 <uthread_map+0xbc>
ffffffffea813e98:	f94002e2 	ldr	x2, [x23]
	err = uthread_map_alloc(ut, &mp, *vaddrp, pfn_list, size, flags, align);
ffffffffea813e9c:	aa1403e4 	mov	x4, x20
ffffffffea813ea0:	2a1903e6 	mov	w6, w25
ffffffffea813ea4:	2a1503e5 	mov	w5, w21
ffffffffea813ea8:	aa1803e3 	mov	x3, x24
ffffffffea813eac:	910163a1 	add	x1, x29, #0x58
ffffffffea813eb0:	aa1303e0 	mov	x0, x19
ffffffffea813eb4:	97ffff2b 	bl	ffffffffea813b60 <uthread_map_alloc>
ffffffffea813eb8:	2a0003f4 	mov	w20, w0
	if(err) {
ffffffffea813ebc:	350000a0 	cbnz	w0, ffffffffea813ed0 <uthread_map+0x98>
	err = arch_uthread_map(ut, mp);
ffffffffea813ec0:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea813ec4:	aa1303e0 	mov	x0, x19
ffffffffea813ec8:	9400025c 	bl	ffffffffea814838 <arch_uthread_map>
ffffffffea813ecc:	2a0003f4 	mov	w20, w0
	mutex_release(&ut->mmap_lock);
ffffffffea813ed0:	aa1603e0 	mov	x0, x22
ffffffffea813ed4:	97ffc6e5 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea813ed8:	2a1403e0 	mov	w0, w20
ffffffffea813edc:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea813ee0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea813ee4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea813ee8:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea813eec:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea813ef0:	d65f03c0 	ret
		return uthread_find_va_space_ns(ut, size, align);
ffffffffea813ef4:	2a1903e2 	mov	w2, w25
ffffffffea813ef8:	aa1403e1 	mov	x1, x20
ffffffffea813efc:	aa1303e0 	mov	x0, x19
	if (flags & UTM_NS_MEM) {
ffffffffea813f00:	373000f5 	tbnz	w21, #6, ffffffffea813f1c <uthread_map+0xe4>
		return uthread_find_va_space_sec(ut, size, align);
ffffffffea813f04:	97fffedb 	bl	ffffffffea813a70 <uthread_find_va_space_sec>
ffffffffea813f08:	aa0003e2 	mov	x2, x0
		*vaddrp = uthread_find_va_space(ut, size, flags, align);
ffffffffea813f0c:	f90002e2 	str	x2, [x23]
		if (!(*vaddrp)) {
ffffffffea813f10:	b5fffc62 	cbnz	x2, ffffffffea813e9c <uthread_map+0x64>
			err = ERR_NO_MEMORY;
ffffffffea813f14:	12800094 	mov	w20, #0xfffffffb            	// #-5
ffffffffea813f18:	17ffffee 	b	ffffffffea813ed0 <uthread_map+0x98>
		return uthread_find_va_space_ns(ut, size, align);
ffffffffea813f1c:	97fffea1 	bl	ffffffffea8139a0 <uthread_find_va_space_ns>
ffffffffea813f20:	aa0003e2 	mov	x2, x0
ffffffffea813f24:	17fffffa 	b	ffffffffea813f0c <uthread_map+0xd4>
		err = ERR_INVALID_ARGS;
ffffffffea813f28:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea813f2c:	17ffffe9 	b	ffffffffea813ed0 <uthread_map+0x98>
		err = ERR_NOT_VALID;
ffffffffea813f30:	128000d4 	mov	w20, #0xfffffff9            	// #-7
ffffffffea813f34:	17ffffe7 	b	ffffffffea813ed0 <uthread_map+0x98>

ffffffffea813f38 <uthread_create>:
{
ffffffffea813f38:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea813f3c:	910003fd 	mov	x29, sp
ffffffffea813f40:	f9000bf3 	str	x19, [sp, #16]
ffffffffea813f44:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea813f48:	aa0303f7 	mov	x23, x3
ffffffffea813f4c:	a903e7f8 	stp	x24, x25, [sp, #56]
ffffffffea813f50:	aa0403f6 	mov	x22, x4
ffffffffea813f54:	a904effa 	stp	x26, x27, [sp, #72]
ffffffffea813f58:	aa0003f8 	mov	x24, x0
ffffffffea813f5c:	aa0103fb 	mov	x27, x1
ffffffffea813f60:	2a0203f9 	mov	w25, w2
ffffffffea813f64:	aa0503fa 	mov	x26, x5
	ut = (uthread_t *)calloc(1, sizeof(uthread_t));
ffffffffea813f68:	d2801501 	mov	x1, #0xa8                  	// #168
ffffffffea813f6c:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea813f70:	97fffcde 	bl	ffffffffea8132e8 <calloc>
ffffffffea813f74:	aa0003f3 	mov	x19, x0
	if (!ut) {
ffffffffea813f78:	b40009a0 	cbz	x0, ffffffffea8140ac <uthread_create+0x174>
ffffffffea813f7c:	a901d7b4 	stp	x20, x21, [x29, #24]
	list_initialize(&ut->map_list);
ffffffffea813f80:	91006000 	add	x0, x0, #0x18
ffffffffea813f84:	f9002fbc 	str	x28, [x29, #88]
ffffffffea813f88:	a9018260 	stp	x0, x0, [x19, #24]
	mutex_init(&ut->mmap_lock);
ffffffffea813f8c:	9100a260 	add	x0, x19, #0x28
ffffffffea813f90:	97ffc67e 	bl	ffffffffea805988 <mutex_init>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea813f94:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea813f98:	37380980 	tbnz	w0, #7, ffffffffea8140c8 <uthread_create+0x190>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea813f9c:	d50342df 	msr	daifset, #0x2
	next_utid++;
ffffffffea813fa0:	d0000255 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
    arch_spin_lock(lock);
ffffffffea813fa4:	d0000254 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea813fa8:	913f829c 	add	x28, x20, #0xfe0
ffffffffea813fac:	aa1c03e0 	mov	x0, x28
ffffffffea813fb0:	97ffba3a 	bl	ffffffffea802898 <arch_spin_lock>
ffffffffea813fb4:	b94fcea1 	ldr	w1, [x21, #4044]
    arch_spin_unlock(lock);
ffffffffea813fb8:	aa1c03e0 	mov	x0, x28
ffffffffea813fbc:	11000421 	add	w1, w1, #0x1
ffffffffea813fc0:	b90fcea1 	str	w1, [x21, #4044]
ffffffffea813fc4:	97ffba3d 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea813fc8:	d50342ff 	msr	daifclr, #0x2
	ut->id = uthread_alloc_utid();
ffffffffea813fcc:	b94fcea0 	ldr	w0, [x21, #4044]
	ut->stack = memalign(PAGE_SIZE, stack_size);
ffffffffea813fd0:	aa1603e1 	mov	x1, x22
	ut->entry = entry;
ffffffffea813fd4:	f900067b 	str	x27, [x19, #8]
	ut->id = uthread_alloc_utid();
ffffffffea813fd8:	b9006a60 	str	w0, [x19, #104]
	ut->ns_va_bottom = MAX_USR_VA;
ffffffffea813fdc:	d2a04000 	mov	x0, #0x2000000             	// #33554432
ffffffffea813fe0:	f9003260 	str	x0, [x19, #96]
	ut->stack = memalign(PAGE_SIZE, stack_size);
ffffffffea813fe4:	d2820000 	mov	x0, #0x1000                	// #4096
	ut->private_data = private_data;
ffffffffea813fe8:	f9004a7a 	str	x26, [x19, #144]
	ut->stack = memalign(PAGE_SIZE, stack_size);
ffffffffea813fec:	97fffcbb 	bl	ffffffffea8132d8 <memalign>
ffffffffea813ff0:	f9000a60 	str	x0, [x19, #16]
	if(!ut->stack) {
ffffffffea813ff4:	b4000b00 	cbz	x0, ffffffffea814154 <uthread_create+0x21c>
	stack_bot = start_stack - stack_size;
ffffffffea813ff8:	cb1602e1 	sub	x1, x23, x22
ffffffffea813ffc:	f90033a1 	str	x1, [x29, #96]
ffffffffea814000:	97fff3a6 	bl	ffffffffea810e98 <kvaddr_to_paddr>
ffffffffea814004:	9101c3a2 	add	x2, x29, #0x70
	return uthread_map(ut, vaddrp, &paddr, size, flags, align);
ffffffffea814008:	52820005 	mov	w5, #0x1000                	// #4096
ffffffffea81400c:	52802664 	mov	w4, #0x133                 	// #307
ffffffffea814010:	aa1603e3 	mov	x3, x22
ffffffffea814014:	910183a1 	add	x1, x29, #0x60
ffffffffea814018:	f81f8c40 	str	x0, [x2, #-8]!
ffffffffea81401c:	aa1303e0 	mov	x0, x19
ffffffffea814020:	97ffff86 	bl	ffffffffea813e38 <uthread_map>
	if (err) {
ffffffffea814024:	35000940 	cbnz	w0, ffffffffea81414c <uthread_create+0x214>
	ut->start_stack = start_stack;
ffffffffea814028:	f9000277 	str	x23, [x19]
	ut->thread = thread_create(name,
ffffffffea81402c:	90000001 	adrp	x1, ffffffffea814000 <uthread_create+0xc8>
ffffffffea814030:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea814034:	2a1903e3 	mov	w3, w25
ffffffffea814038:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea81403c:	911b2021 	add	x1, x1, #0x6c8
ffffffffea814040:	aa1803e0 	mov	x0, x24
ffffffffea814044:	97ffc875 	bl	ffffffffea806218 <thread_create>
ffffffffea814048:	f9003e60 	str	x0, [x19, #120]
	if (!ut->thread) {
ffffffffea81404c:	b40007c0 	cbz	x0, ffffffffea814144 <uthread_create+0x20c>
	err = arch_uthread_create(ut);
ffffffffea814050:	aa1303e0 	mov	x0, x19
ffffffffea814054:	940001cf 	bl	ffffffffea814790 <arch_uthread_create>
	if (err) {
ffffffffea814058:	35000760 	cbnz	w0, ffffffffea814144 <uthread_create+0x20c>
	ut->thread->tls[TLS_ENTRY_UTHREAD] = (uintptr_t) ut;
ffffffffea81405c:	f9403e60 	ldr	x0, [x19, #120]
ffffffffea814060:	f9015813 	str	x19, [x0, #688]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea814064:	d53b4220 	mrs	x0, daif
ffffffffea814068:	91020275 	add	x21, x19, #0x80
ffffffffea81406c:	37380440 	tbnz	w0, #7, ffffffffea8140f4 <uthread_create+0x1bc>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea814070:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea814074:	913f8294 	add	x20, x20, #0xfe0
ffffffffea814078:	aa1403e0 	mov	x0, x20
ffffffffea81407c:	97ffba07 	bl	ffffffffea802898 <arch_spin_lock>
	item->next = list->next;
ffffffffea814080:	b0000241 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea814084:	913f4021 	add	x1, x1, #0xfd0
    arch_spin_unlock(lock);
ffffffffea814088:	aa1403e0 	mov	x0, x20
ffffffffea81408c:	f9400422 	ldr	x2, [x1, #8]
ffffffffea814090:	a9080a61 	stp	x1, x2, [x19, #128]
	list->next->prev = item;
ffffffffea814094:	f9000055 	str	x21, [x2]
	list->next = item;
ffffffffea814098:	f9000435 	str	x21, [x1, #8]
ffffffffea81409c:	97ffba07 	bl	ffffffffea8028b8 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8140a0:	d50342ff 	msr	daifclr, #0x2
ffffffffea8140a4:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea8140a8:	f9402fbc 	ldr	x28, [x29, #88]
}
ffffffffea8140ac:	aa1303e0 	mov	x0, x19
ffffffffea8140b0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8140b4:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea8140b8:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea8140bc:	a944effa 	ldp	x26, x27, [sp, #72]
ffffffffea8140c0:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea8140c4:	d65f03c0 	ret
	next_utid++;
ffffffffea8140c8:	b0000255 	adrp	x21, ffffffffea85d000 <idle_threads+0xeb0>
    arch_spin_lock(lock);
ffffffffea8140cc:	b0000254 	adrp	x20, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea8140d0:	913f829c 	add	x28, x20, #0xfe0
ffffffffea8140d4:	aa1c03e0 	mov	x0, x28
ffffffffea8140d8:	97ffb9f0 	bl	ffffffffea802898 <arch_spin_lock>
ffffffffea8140dc:	b94fcea1 	ldr	w1, [x21, #4044]
    arch_spin_unlock(lock);
ffffffffea8140e0:	aa1c03e0 	mov	x0, x28
ffffffffea8140e4:	11000421 	add	w1, w1, #0x1
ffffffffea8140e8:	b90fcea1 	str	w1, [x21, #4044]
ffffffffea8140ec:	97ffb9f3 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea8140f0:	17ffffb7 	b	ffffffffea813fcc <uthread_create+0x94>
    arch_spin_lock(lock);
ffffffffea8140f4:	913f8294 	add	x20, x20, #0xfe0
ffffffffea8140f8:	aa1403e0 	mov	x0, x20
ffffffffea8140fc:	97ffb9e7 	bl	ffffffffea802898 <arch_spin_lock>
	item->next = list->next;
ffffffffea814100:	b0000241 	adrp	x1, ffffffffea85d000 <idle_threads+0xeb0>
ffffffffea814104:	913f4021 	add	x1, x1, #0xfd0
    arch_spin_unlock(lock);
ffffffffea814108:	aa1403e0 	mov	x0, x20
ffffffffea81410c:	f9400422 	ldr	x2, [x1, #8]
ffffffffea814110:	a9080a61 	stp	x1, x2, [x19, #128]
	list->next->prev = item;
ffffffffea814114:	f9000055 	str	x21, [x2]
	list->next = item;
ffffffffea814118:	f9000435 	str	x21, [x1, #8]
ffffffffea81411c:	97ffb9e7 	bl	ffffffffea8028b8 <arch_spin_unlock>
ffffffffea814120:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea814124:	a941d7b4 	ldp	x20, x21, [x29, #24]
}
ffffffffea814128:	aa1303e0 	mov	x0, x19
ffffffffea81412c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea814130:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea814134:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea814138:	a944effa 	ldp	x26, x27, [sp, #72]
ffffffffea81413c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea814140:	d65f03c0 	ret
	uthread_free_maps(ut);
ffffffffea814144:	aa1303e0 	mov	x0, x19
ffffffffea814148:	97fffe6c 	bl	ffffffffea813af8 <uthread_free_maps>
	free(ut->stack);
ffffffffea81414c:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea814150:	97fffc76 	bl	ffffffffea813328 <free>
	free(ut);
ffffffffea814154:	aa1303e0 	mov	x0, x19
	return NULL;
ffffffffea814158:	d2800013 	mov	x19, #0x0                   	// #0
	free(ut);
ffffffffea81415c:	97fffc73 	bl	ffffffffea813328 <free>
ffffffffea814160:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea814164:	a941d7b4 	ldp	x20, x21, [x29, #24]
}
ffffffffea814168:	aa1303e0 	mov	x0, x19
ffffffffea81416c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea814170:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea814174:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea814178:	a944effa 	ldp	x26, x27, [sp, #72]
ffffffffea81417c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea814180:	d65f03c0 	ret
ffffffffea814184:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814188 <uthread_pmm_alloc_and_map>:
{
ffffffffea814188:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea81418c:	910003fd 	mov	x29, sp
ffffffffea814190:	a90153f3 	stp	x19, x20, [sp, #16]
	struct list_node page_list = LIST_INITIAL_VALUE(page_list);
ffffffffea814194:	9101c3b4 	add	x20, x29, #0x70
ffffffffea814198:	a90753b4 	stp	x20, x20, [x29, #112]
	if (vaddr == NULL)
ffffffffea81419c:	b4000e41 	cbz	x1, ffffffffea814364 <uthread_pmm_alloc_and_map+0x1dc>
ffffffffea8141a0:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8141a4:	aa0103f5 	mov	x21, x1
ffffffffea8141a8:	113ffc42 	add	w2, w2, #0xfff
ffffffffea8141ac:	f90023b9 	str	x25, [x29, #64]
ffffffffea8141b0:	12144c56 	and	w22, w2, #0xfffff000
	allocated = pmm_alloc_pages(count, &page_list);
ffffffffea8141b4:	aa1403e1 	mov	x1, x20
	*vaddr = NULL;
ffffffffea8141b8:	f90002bf 	str	xzr, [x21]
ffffffffea8141bc:	2a0303f9 	mov	w25, w3
ffffffffea8141c0:	530c7ed3 	lsr	w19, w22, #12
ffffffffea8141c4:	b90067a4 	str	w4, [x29, #100]
ffffffffea8141c8:	f90037a0 	str	x0, [x29, #104]
	allocated = pmm_alloc_pages(count, &page_list);
ffffffffea8141cc:	2a1303e0 	mov	w0, w19
ffffffffea8141d0:	97fff1c4 	bl	ffffffffea8108e0 <pmm_alloc_pages>
	if (allocated != count) {
ffffffffea8141d4:	6b00027f 	cmp	w19, w0
ffffffffea8141d8:	54000220 	b.eq	ffffffffea81421c <uthread_pmm_alloc_and_map+0x94>  // b.none
		dprintf(ALWAYS, "%s: Failed to allocate enough pages (allocated %d, needed %d)\n",
ffffffffea8141dc:	f0000004 	adrp	x4, ffffffffea817000 <__func__.2428+0x420>
ffffffffea8141e0:	f0000001 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea8141e4:	2a1303e3 	mov	w3, w19
ffffffffea8141e8:	2a0003e2 	mov	w2, w0
ffffffffea8141ec:	913ce021 	add	x1, x1, #0xf38
ffffffffea8141f0:	913f8080 	add	x0, x4, #0xfe0
	status_t sts = -1;
ffffffffea8141f4:	12800013 	mov	w19, #0xffffffff            	// #-1
		dprintf(ALWAYS, "%s: Failed to allocate enough pages (allocated %d, needed %d)\n",
ffffffffea8141f8:	97fff62a 	bl	ffffffffea811aa0 <_dprintf>
	pmm_free(&page_list);
ffffffffea8141fc:	aa1403e0 	mov	x0, x20
ffffffffea814200:	97fff25a 	bl	ffffffffea810b68 <pmm_free>
	return sts;
ffffffffea814204:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea814208:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea81420c:	2a1303e0 	mov	w0, w19
ffffffffea814210:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814214:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea814218:	d65f03c0 	ret
	pfn_list = malloc(count * sizeof(*pfn_list));
ffffffffea81421c:	d37d4e73 	ubfiz	x19, x19, #3, #20
ffffffffea814220:	f90027ba 	str	x26, [x29, #72]
ffffffffea814224:	aa1303e0 	mov	x0, x19
ffffffffea814228:	97fffc2a 	bl	ffffffffea8132d0 <malloc>
ffffffffea81422c:	aa0003fa 	mov	x26, x0
	if (pfn_list == NULL) {
ffffffffea814230:	b4000880 	cbz	x0, ffffffffea814340 <uthread_pmm_alloc_and_map+0x1b8>
	list_for_every_entry(&page_list, page, vm_page_t, node) {
ffffffffea814234:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea814238:	eb14027f 	cmp	x19, x20
ffffffffea81423c:	540002e0 	b.eq	ffffffffea814298 <uthread_pmm_alloc_and_map+0x110>  // b.none
ffffffffea814240:	a90573bb 	stp	x27, x28, [x29, #80]
ffffffffea814244:	f000001c 	adrp	x28, ffffffffea817000 <__func__.2428+0x420>
ffffffffea814248:	9000003b 	adrp	x27, ffffffffea818000 <__func__.2340+0xc8>
		dprintf(SPEW, "%s: Page address %lx\n", __func__, pfn_list[i]);
ffffffffea81424c:	913ce39c 	add	x28, x28, #0xf38
ffffffffea814250:	9101637b 	add	x27, x27, #0x58
ffffffffea814254:	a90363b7 	stp	x23, x24, [x29, #48]
	i = 0;
ffffffffea814258:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea81425c:	d503201f 	nop
		pfn_list[i] = page_to_address(page);
ffffffffea814260:	2a1703f8 	mov	w24, w23
ffffffffea814264:	aa1303e0 	mov	x0, x19
ffffffffea814268:	97fff126 	bl	ffffffffea810700 <page_to_address>
		dprintf(SPEW, "%s: Page address %lx\n", __func__, pfn_list[i]);
ffffffffea81426c:	aa0003e2 	mov	x2, x0
ffffffffea814270:	aa1c03e1 	mov	x1, x28
		i++;
ffffffffea814274:	110006f7 	add	w23, w23, #0x1
		pfn_list[i] = page_to_address(page);
ffffffffea814278:	f8387b40 	str	x0, [x26, x24, lsl #3]
		dprintf(SPEW, "%s: Page address %lx\n", __func__, pfn_list[i]);
ffffffffea81427c:	aa1b03e0 	mov	x0, x27
ffffffffea814280:	97fff608 	bl	ffffffffea811aa0 <_dprintf>
	list_for_every_entry(&page_list, page, vm_page_t, node) {
ffffffffea814284:	f9400673 	ldr	x19, [x19, #8]
ffffffffea814288:	eb14027f 	cmp	x19, x20
ffffffffea81428c:	54fffea1 	b.ne	ffffffffea814260 <uthread_pmm_alloc_and_map+0xd8>  // b.any
ffffffffea814290:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea814294:	a94573bb 	ldp	x27, x28, [x29, #80]
	if (flags & MMAP_FLAG_DEVICE_MEM)
ffffffffea814298:	360801d9 	tbz	w25, #1, ffffffffea8142d0 <uthread_pmm_alloc_and_map+0x148>
	sts = uthread_map(ut, vaddr, pfn_list, alloc_size,
ffffffffea81429c:	b94067a5 	ldr	w5, [x29, #100]
ffffffffea8142a0:	52804064 	mov	w4, #0x203                 	// #515
ffffffffea8142a4:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea8142a8:	aa1603e3 	mov	x3, x22
ffffffffea8142ac:	aa1a03e2 	mov	x2, x26
ffffffffea8142b0:	aa1503e1 	mov	x1, x21
ffffffffea8142b4:	97fffee1 	bl	ffffffffea813e38 <uthread_map>
ffffffffea8142b8:	2a0003f3 	mov	w19, w0
	if (sts) {
ffffffffea8142bc:	350002e0 	cbnz	w0, ffffffffea814318 <uthread_pmm_alloc_and_map+0x190>
		arch_clean_cache_range(*vaddr, alloc_size);
ffffffffea8142c0:	f94002a0 	ldr	x0, [x21]
ffffffffea8142c4:	aa1603e1 	mov	x1, x22
ffffffffea8142c8:	97ffb97e 	bl	ffffffffea8028c0 <arch_clean_cache_range>
ffffffffea8142cc:	1400000a 	b	ffffffffea8142f4 <uthread_pmm_alloc_and_map+0x16c>
	sts = uthread_map(ut, vaddr, pfn_list, alloc_size,
ffffffffea8142d0:	b94067a5 	ldr	w5, [x29, #100]
ffffffffea8142d4:	52800064 	mov	w4, #0x3                   	// #3
ffffffffea8142d8:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea8142dc:	aa1603e3 	mov	x3, x22
ffffffffea8142e0:	aa1a03e2 	mov	x2, x26
ffffffffea8142e4:	aa1503e1 	mov	x1, x21
ffffffffea8142e8:	97fffed4 	bl	ffffffffea813e38 <uthread_map>
ffffffffea8142ec:	2a0003f3 	mov	w19, w0
	if (sts) {
ffffffffea8142f0:	35000140 	cbnz	w0, ffffffffea814318 <uthread_pmm_alloc_and_map+0x190>
	free(pfn_list);
ffffffffea8142f4:	aa1a03e0 	mov	x0, x26
	return 0;
ffffffffea8142f8:	52800013 	mov	w19, #0x0                   	// #0
	free(pfn_list);
ffffffffea8142fc:	97fffc0b 	bl	ffffffffea813328 <free>
}
ffffffffea814300:	2a1303e0 	mov	w0, w19
	return 0;
ffffffffea814304:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea814308:	a9446bb9 	ldp	x25, x26, [x29, #64]
}
ffffffffea81430c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814310:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea814314:	d65f03c0 	ret
		dprintf(ALWAYS, "%s: Mapping failed with Error: %x\n",
ffffffffea814318:	2a1303e2 	mov	w2, w19
ffffffffea81431c:	f0000001 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea814320:	913ce021 	add	x1, x1, #0xf38
ffffffffea814324:	90000020 	adrp	x0, ffffffffea818000 <__func__.2340+0xc8>
ffffffffea814328:	9101c000 	add	x0, x0, #0x70
ffffffffea81432c:	97fff5dd 	bl	ffffffffea811aa0 <_dprintf>
	free(pfn_list);
ffffffffea814330:	aa1a03e0 	mov	x0, x26
ffffffffea814334:	97fffbfd 	bl	ffffffffea813328 <free>
ffffffffea814338:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea81433c:	17ffffb0 	b	ffffffffea8141fc <uthread_pmm_alloc_and_map+0x74>
		dprintf(ALWAYS, "%s: malloc failed. Unable to allocate pfn (size %lu)\n",
ffffffffea814340:	aa1303e2 	mov	x2, x19
ffffffffea814344:	f0000001 	adrp	x1, ffffffffea817000 <__func__.2428+0x420>
ffffffffea814348:	90000020 	adrp	x0, ffffffffea818000 <__func__.2340+0xc8>
ffffffffea81434c:	913ce021 	add	x1, x1, #0xf38
ffffffffea814350:	91008000 	add	x0, x0, #0x20
	status_t sts = -1;
ffffffffea814354:	12800013 	mov	w19, #0xffffffff            	// #-1
		dprintf(ALWAYS, "%s: malloc failed. Unable to allocate pfn (size %lu)\n",
ffffffffea814358:	97fff5d2 	bl	ffffffffea811aa0 <_dprintf>
		goto err_free_pages;
ffffffffea81435c:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea814360:	17ffffa7 	b	ffffffffea8141fc <uthread_pmm_alloc_and_map+0x74>
		return ERR_INVALID_ARGS;
ffffffffea814364:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea814368:	17ffffa9 	b	ffffffffea81420c <uthread_pmm_alloc_and_map+0x84>
ffffffffea81436c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814370 <uthread_unmap>:
{
ffffffffea814370:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea814374:	910003fd 	mov	x29, sp
ffffffffea814378:	a9025bf5 	stp	x21, x22, [sp, #32]
	mutex_acquire(&ut->mmap_lock);
ffffffffea81437c:	9100a016 	add	x22, x0, #0x28
{
ffffffffea814380:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea814384:	aa0003f5 	mov	x21, x0
ffffffffea814388:	aa0103f4 	mov	x20, x1
ffffffffea81438c:	aa0203f3 	mov	x19, x2
ffffffffea814390:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea814394:	aa1603e0 	mov	x0, x22
ffffffffea814398:	f9001bf7 	str	x23, [sp, #48]
ffffffffea81439c:	97ffc587 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	if (!ut || !vaddr) {
ffffffffea8143a0:	f10002bf 	cmp	x21, #0x0
ffffffffea8143a4:	fa401a84 	ccmp	x20, #0x0, #0x4, ne  // ne = any
ffffffffea8143a8:	54000b20 	b.eq	ffffffffea81450c <uthread_unmap+0x19c>  // b.none
	if (vaddr + size < vaddr) {
ffffffffea8143ac:	8b130282 	add	x2, x20, x19
ffffffffea8143b0:	eb02029f 	cmp	x20, x2
ffffffffea8143b4:	54000228 	b.hi	ffffffffea8143f8 <uthread_unmap+0x88>  // b.pmore
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8143b8:	f94012b3 	ldr	x19, [x21, #32]
ffffffffea8143bc:	d1006273 	sub	x19, x19, #0x18
ffffffffea8143c0:	eb1302bf 	cmp	x21, x19
ffffffffea8143c4:	540001a0 	b.eq	ffffffffea8143f8 <uthread_unmap+0x88>  // b.none
		if ((mp->vaddr <= vaddr) &&
ffffffffea8143c8:	f9400260 	ldr	x0, [x19]
ffffffffea8143cc:	eb00029f 	cmp	x20, x0
ffffffffea8143d0:	540000c3 	b.cc	ffffffffea8143e8 <uthread_unmap+0x78>  // b.lo, b.ul, b.last
		    (vaddr < mp->vaddr + mp->size) &&
ffffffffea8143d4:	f9400661 	ldr	x1, [x19, #8]
ffffffffea8143d8:	8b010000 	add	x0, x0, x1
ffffffffea8143dc:	eb00029f 	cmp	x20, x0
ffffffffea8143e0:	fa403042 	ccmp	x2, x0, #0x2, cc  // cc = lo, ul, last
ffffffffea8143e4:	540001c9 	b.ls	ffffffffea81441c <uthread_unmap+0xac>  // b.plast
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8143e8:	f9401273 	ldr	x19, [x19, #32]
ffffffffea8143ec:	d1006273 	sub	x19, x19, #0x18
ffffffffea8143f0:	eb1302bf 	cmp	x21, x19
ffffffffea8143f4:	54fffea1 	b.ne	ffffffffea8143c8 <uthread_unmap+0x58>  // b.any
		err = ERR_NOT_FOUND;
ffffffffea8143f8:	12800037 	mov	w23, #0xfffffffe            	// #-2
	mutex_release(&ut->mmap_lock);
ffffffffea8143fc:	aa1603e0 	mov	x0, x22
ffffffffea814400:	97ffc59a 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea814404:	2a1703e0 	mov	w0, w23
ffffffffea814408:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea81440c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814410:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea814414:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea814418:	d65f03c0 	ret
	err = arch_uthread_unmap(ut, mp);
ffffffffea81441c:	aa1303e1 	mov	x1, x19
ffffffffea814420:	aa1503e0 	mov	x0, x21
ffffffffea814424:	94000197 	bl	ffffffffea814a80 <arch_uthread_unmap>
ffffffffea814428:	2a0003f7 	mov	w23, w0
	if (err) {
ffffffffea81442c:	35fffe80 	cbnz	w0, ffffffffea8143fc <uthread_unmap+0x8c>
	if (mp->flags & MMAP_FLAG_DEVICE_MEM) {
ffffffffea814430:	b9401262 	ldr	w2, [x19, #16]
ffffffffea814434:	36080242 	tbz	w2, #1, ffffffffea81447c <uthread_unmap+0x10c>
		for (i = 0; i < (mp->size / PAGE_SIZE); i++) {
ffffffffea814438:	f9400660 	ldr	x0, [x19, #8]
ffffffffea81443c:	eb4033ff 	negs	xzr, x0, lsr #12
ffffffffea814440:	540001e0 	b.eq	ffffffffea81447c <uthread_unmap+0x10c>  // b.none
ffffffffea814444:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea814448:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea81444c:	d503201f 	nop
			vm_page_t *page = address_to_page(mp->pfn_list[i]);
ffffffffea814450:	8b000e60 	add	x0, x19, x0, lsl #3
		for (i = 0; i < (mp->size / PAGE_SIZE); i++) {
ffffffffea814454:	11000694 	add	w20, w20, #0x1
			vm_page_t *page = address_to_page(mp->pfn_list[i]);
ffffffffea814458:	f9401400 	ldr	x0, [x0, #40]
ffffffffea81445c:	97fff0c5 	bl	ffffffffea810770 <address_to_page>
			if (page) {
ffffffffea814460:	b4000040 	cbz	x0, ffffffffea814468 <uthread_unmap+0xf8>
				pmm_free_page(page);
ffffffffea814464:	97fff1fd 	bl	ffffffffea810c58 <pmm_free_page>
		for (i = 0; i < (mp->size / PAGE_SIZE); i++) {
ffffffffea814468:	f9400661 	ldr	x1, [x19, #8]
ffffffffea81446c:	2a1403e0 	mov	w0, w20
ffffffffea814470:	eb41301f 	cmp	x0, x1, lsr #12
ffffffffea814474:	54fffee3 	b.cc	ffffffffea814450 <uthread_unmap+0xe0>  // b.lo, b.ul, b.last
ffffffffea814478:	b9401262 	ldr	w2, [x19, #16]
ffffffffea81447c:	a9418660 	ldp	x0, x1, [x19, #24]
	if (mp->flags & UTM_NS_MEM) {
ffffffffea814480:	36300142 	tbz	w2, #6, ffffffffea8144a8 <uthread_unmap+0x138>
		item = list_prev_type(&ut->map_list, &mp->node,
ffffffffea814484:	910062a2 	add	x2, x21, #0x18
ffffffffea814488:	f100001f 	cmp	x0, #0x0
ffffffffea81448c:	fa401044 	ccmp	x2, x0, #0x4, ne  // ne = any
ffffffffea814490:	54000281 	b.ne	ffffffffea8144e0 <uthread_unmap+0x170>  // b.any
			item = list_next_type(&ut->map_list, &mp->node,
ffffffffea814494:	f100003f 	cmp	x1, #0x0
ffffffffea814498:	fa411044 	ccmp	x2, x1, #0x4, ne  // ne = any
ffffffffea81449c:	540002c1 	b.ne	ffffffffea8144f4 <uthread_unmap+0x184>  // b.any
				ut->ns_va_bottom = MAX_USR_VA;
ffffffffea8144a0:	d2a04002 	mov	x2, #0x2000000             	// #33554432
ffffffffea8144a4:	f90032a2 	str	x2, [x21, #96]
	item->next->prev = item->prev;
ffffffffea8144a8:	f9000020 	str	x0, [x1]
	free(mp);
ffffffffea8144ac:	aa1303e0 	mov	x0, x19
	item->prev->next = item->next;
ffffffffea8144b0:	f9400e62 	ldr	x2, [x19, #24]
ffffffffea8144b4:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea8144b8:	a901fe7f 	stp	xzr, xzr, [x19, #24]
ffffffffea8144bc:	97fffb9b 	bl	ffffffffea813328 <free>
	mutex_release(&ut->mmap_lock);
ffffffffea8144c0:	aa1603e0 	mov	x0, x22
ffffffffea8144c4:	97ffc569 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea8144c8:	2a1703e0 	mov	w0, w23
ffffffffea8144cc:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea8144d0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8144d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8144d8:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8144dc:	d65f03c0 	ret
		if (!item || (item->flags & UTM_NS_MEM) == 0) {
ffffffffea8144e0:	f100601f 	cmp	x0, #0x18
ffffffffea8144e4:	54fffd80 	b.eq	ffffffffea814494 <uthread_unmap+0x124>  // b.none
ffffffffea8144e8:	b85f8003 	ldur	w3, [x0, #-8]
ffffffffea8144ec:	3637fd43 	tbz	w3, #6, ffffffffea814494 <uthread_unmap+0x124>
ffffffffea8144f0:	17ffffee 	b	ffffffffea8144a8 <uthread_unmap+0x138>
			if (item) {
ffffffffea8144f4:	f100603f 	cmp	x1, #0x18
ffffffffea8144f8:	54fffd40 	b.eq	ffffffffea8144a0 <uthread_unmap+0x130>  // b.none
				ut->ns_va_bottom = ROUNDDOWN(item->vaddr,
ffffffffea8144fc:	f85e8022 	ldur	x2, [x1, #-24]
ffffffffea814500:	926cac42 	and	x2, x2, #0xfffffffffff00000
ffffffffea814504:	f90032a2 	str	x2, [x21, #96]
ffffffffea814508:	17ffffe8 	b	ffffffffea8144a8 <uthread_unmap+0x138>
		err = ERR_INVALID_ARGS;
ffffffffea81450c:	128000f7 	mov	w23, #0xfffffff8            	// #-8
ffffffffea814510:	17ffffbb 	b	ffffffffea8143fc <uthread_unmap+0x8c>
ffffffffea814514:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814518 <uthread_is_valid_range>:
{
ffffffffea814518:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea81451c:	910003fd 	mov	x29, sp
ffffffffea814520:	a9025bf5 	stp	x21, x22, [sp, #32]
	mutex_acquire(&ut->mmap_lock);
ffffffffea814524:	9100a016 	add	x22, x0, #0x28
{
ffffffffea814528:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81452c:	aa0003f5 	mov	x21, x0
ffffffffea814530:	aa0103f4 	mov	x20, x1
ffffffffea814534:	aa0203f3 	mov	x19, x2
ffffffffea814538:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea81453c:	aa1603e0 	mov	x0, x22
ffffffffea814540:	97ffc51e 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	if (vaddr + size < vaddr) {
ffffffffea814544:	8b130282 	add	x2, x20, x19
ffffffffea814548:	eb02029f 	cmp	x20, x2
ffffffffea81454c:	54000288 	b.hi	ffffffffea81459c <uthread_is_valid_range+0x84>  // b.pmore
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea814550:	f94012a1 	ldr	x1, [x21, #32]
ffffffffea814554:	d1006021 	sub	x1, x1, #0x18
ffffffffea814558:	eb0102bf 	cmp	x21, x1
ffffffffea81455c:	54000200 	b.eq	ffffffffea81459c <uthread_is_valid_range+0x84>  // b.none
		if ((mp->vaddr <= vaddr) &&
ffffffffea814560:	f9400020 	ldr	x0, [x1]
ffffffffea814564:	eb00029f 	cmp	x20, x0
ffffffffea814568:	54000123 	b.cc	ffffffffea81458c <uthread_is_valid_range+0x74>  // b.lo, b.ul, b.last
		    (vaddr < mp->vaddr + mp->size) &&
ffffffffea81456c:	f9400423 	ldr	x3, [x1, #8]
ffffffffea814570:	8b030000 	add	x0, x0, x3
ffffffffea814574:	eb00005f 	cmp	x2, x0
ffffffffea814578:	1a9f87e3 	cset	w3, ls  // ls = plast
		if ((mp->vaddr <= vaddr) &&
ffffffffea81457c:	eb00029f 	cmp	x20, x0
ffffffffea814580:	1a9f27f3 	cset	w19, cc  // cc = lo, ul, last
		    (vaddr < mp->vaddr + mp->size) &&
ffffffffea814584:	6a130073 	ands	w19, w3, w19
ffffffffea814588:	540000c1 	b.ne	ffffffffea8145a0 <uthread_is_valid_range+0x88>  // b.any
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea81458c:	f9401021 	ldr	x1, [x1, #32]
ffffffffea814590:	d1006021 	sub	x1, x1, #0x18
ffffffffea814594:	eb0102bf 	cmp	x21, x1
ffffffffea814598:	54fffe41 	b.ne	ffffffffea814560 <uthread_is_valid_range+0x48>  // b.any
ffffffffea81459c:	52800013 	mov	w19, #0x0                   	// #0
	mutex_release(&ut->mmap_lock);
ffffffffea8145a0:	aa1603e0 	mov	x0, x22
ffffffffea8145a4:	97ffc531 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea8145a8:	2a1303e0 	mov	w0, w19
ffffffffea8145ac:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8145b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8145b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8145b8:	d65f03c0 	ret
ffffffffea8145bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8145c0 <uthread_virt_to_phys>:
{
ffffffffea8145c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8145c4:	910003fd 	mov	x29, sp
ffffffffea8145c8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8145cc:	aa0003f5 	mov	x21, x0
	mutex_acquire(&ut->mmap_lock);
ffffffffea8145d0:	9100a016 	add	x22, x0, #0x28
{
ffffffffea8145d4:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8145d8:	aa1603e0 	mov	x0, x22
ffffffffea8145dc:	aa0103f3 	mov	x19, x1
ffffffffea8145e0:	aa0203f4 	mov	x20, x2
ffffffffea8145e4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8145e8:	97ffc4f4 	bl	ffffffffea8059b8 <mutex_acquire_timeout>
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8145ec:	f94012a0 	ldr	x0, [x21, #32]
ffffffffea8145f0:	d1006000 	sub	x0, x0, #0x18
ffffffffea8145f4:	eb0002bf 	cmp	x21, x0
ffffffffea8145f8:	540001a0 	b.eq	ffffffffea81462c <uthread_virt_to_phys+0x6c>  // b.none
ffffffffea8145fc:	d503201f 	nop
		if ((mp->vaddr <= vaddr) &&
ffffffffea814600:	f9400001 	ldr	x1, [x0]
ffffffffea814604:	eb01027f 	cmp	x19, x1
ffffffffea814608:	540000a3 	b.cc	ffffffffea81461c <uthread_virt_to_phys+0x5c>  // b.lo, b.ul, b.last
		    (vaddr < mp->vaddr + mp->size) &&
ffffffffea81460c:	f9400403 	ldr	x3, [x0, #8]
ffffffffea814610:	8b030023 	add	x3, x1, x3
		if ((mp->vaddr <= vaddr) &&
ffffffffea814614:	eb03027f 	cmp	x19, x3
ffffffffea814618:	540001a3 	b.cc	ffffffffea81464c <uthread_virt_to_phys+0x8c>  // b.lo, b.ul, b.last
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea81461c:	f9401000 	ldr	x0, [x0, #32]
ffffffffea814620:	d1006000 	sub	x0, x0, #0x18
ffffffffea814624:	eb0002bf 	cmp	x21, x0
ffffffffea814628:	54fffec1 	b.ne	ffffffffea814600 <uthread_virt_to_phys+0x40>  // b.any
		err = ERR_INVALID_ARGS;
ffffffffea81462c:	128000f5 	mov	w21, #0xfffffff8            	// #-8
	mutex_release(&ut->mmap_lock);
ffffffffea814630:	aa1603e0 	mov	x0, x22
ffffffffea814634:	97ffc50d 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea814638:	2a1503e0 	mov	w0, w21
ffffffffea81463c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814640:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea814644:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea814648:	d65f03c0 	ret
	if (mp->flags & UTM_PHYS_CONTIG) {
ffffffffea81464c:	b9401002 	ldr	w2, [x0, #16]
ffffffffea814650:	37280202 	tbnz	w2, #5, ffffffffea814690 <uthread_virt_to_phys+0xd0>
		uint32_t pg = (vaddr - mp->vaddr) / PAGE_SIZE;
ffffffffea814654:	cb010261 	sub	x1, x19, x1
		*paddr = mp->pfn_list[pg] + offset;
ffffffffea814658:	92402e73 	and	x19, x19, #0xfff
	err = NO_ERROR;
ffffffffea81465c:	52800015 	mov	w21, #0x0                   	// #0
		*paddr = mp->pfn_list[pg] + offset;
ffffffffea814660:	d34cac21 	ubfx	x1, x1, #12, #32
ffffffffea814664:	8b010c00 	add	x0, x0, x1, lsl #3
ffffffffea814668:	f9401400 	ldr	x0, [x0, #40]
ffffffffea81466c:	8b130013 	add	x19, x0, x19
ffffffffea814670:	f9000293 	str	x19, [x20]
	mutex_release(&ut->mmap_lock);
ffffffffea814674:	aa1603e0 	mov	x0, x22
ffffffffea814678:	97ffc4fc 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea81467c:	2a1503e0 	mov	w0, w21
ffffffffea814680:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814684:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea814688:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea81468c:	d65f03c0 	ret
		*paddr = mp->pfn_list[0] + (vaddr - mp->vaddr);
ffffffffea814690:	f9401400 	ldr	x0, [x0, #40]
	err = NO_ERROR;
ffffffffea814694:	52800015 	mov	w21, #0x0                   	// #0
		*paddr = mp->pfn_list[0] + (vaddr - mp->vaddr);
ffffffffea814698:	cb010001 	sub	x1, x0, x1
	mutex_release(&ut->mmap_lock);
ffffffffea81469c:	aa1603e0 	mov	x0, x22
		*paddr = mp->pfn_list[0] + (vaddr - mp->vaddr);
ffffffffea8146a0:	8b130033 	add	x19, x1, x19
ffffffffea8146a4:	f9000293 	str	x19, [x20]
	mutex_release(&ut->mmap_lock);
ffffffffea8146a8:	97ffc4f0 	bl	ffffffffea805a68 <mutex_release>
}
ffffffffea8146ac:	2a1503e0 	mov	w0, w21
ffffffffea8146b0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8146b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8146b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8146bc:	d65f03c0 	ret

ffffffffea8146c0 <arch_uthread_init>:

#define USER_PAGE_MASK	(USER_PAGE_SIZE - 1)

void arch_uthread_init(void)
{
}
ffffffffea8146c0:	d65f03c0 	ret
ffffffffea8146c4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8146c8 <arch_uthread_startup>:
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea8146c8:	d538d080 	mrs	x0, tpidr_el1

void arch_uthread_startup(void)
{
	struct uthread *ut = (struct uthread *) tls_get(TLS_ENTRY_UTHREAD);
ffffffffea8146cc:	f9415800 	ldr	x0, [x0, #688]
	register uint64_t sp_usr asm("x2") = ROUNDDOWN(ut->start_stack, 8);
ffffffffea8146d0:	a9400c02 	ldp	x2, x3, [x0]
ffffffffea8146d4:	927df042 	and	x2, x2, #0xfffffffffffffff8
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8146d8:	d50342df 	msr	daifset, #0x2
	register uint64_t entry asm("x3") = ut->entry;

	arch_disable_ints();
	__asm__ volatile(
ffffffffea8146dc:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea8146e0:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8146e4:	aa0203ed 	mov	x13, x2
ffffffffea8146e8:	aa0303ee 	mov	x14, x3
ffffffffea8146ec:	d2800209 	mov	x9, #0x10                  	// #16
ffffffffea8146f0:	d5184009 	msr	spsr_el1, x9
ffffffffea8146f4:	d5184023 	msr	elr_el1, x3
ffffffffea8146f8:	d69f03e0 	eret
ffffffffea8146fc:	d503379f 	dsb	nsh
ffffffffea814700:	d5033fdf 	isb
		"isb\n"
		:
		: [stack]"r" (sp_usr), [entry]"r" (entry)
		: "x0", "x1", "memory"
	);
}
ffffffffea814704:	d65f03c0 	ret

ffffffffea814708 <arch_uthread_context_switch>:

void arch_uthread_context_switch(struct uthread *old_ut, struct uthread *new_ut)
{
	paddr_t pgd;

	if (old_ut && !new_ut) {
ffffffffea814708:	f100001f 	cmp	x0, #0x0
ffffffffea81470c:	fa401820 	ccmp	x1, #0x0, #0x0, ne  // ne = any
ffffffffea814710:	540000e1 	b.ne	ffffffffea81472c <arch_uthread_context_switch+0x24>  // b.any
		ARM64_WRITE_SYSREG(tcr_el1, MMU_TCR_FLAGS_KERNEL);
ffffffffea814714:	d286b4e0 	mov	x0, #0x35a7                	// #13735
ffffffffea814718:	f2b6a460 	movk	x0, #0xb523, lsl #16
ffffffffea81471c:	f2c00040 	movk	x0, #0x2, lsl #32
ffffffffea814720:	d5182040 	msr	tcr_el1, x0
ffffffffea814724:	d5033fdf 	isb
ffffffffea814728:	d65f03c0 	ret
	}

	if (new_ut) {
ffffffffea81472c:	b4000301 	cbz	x1, ffffffffea81478c <arch_uthread_context_switch+0x84>
{
ffffffffea814730:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea814734:	910003fd 	mov	x29, sp
ffffffffea814738:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81473c:	aa0003f4 	mov	x20, x0
ffffffffea814740:	f9403820 	ldr	x0, [x1, #112]
ffffffffea814744:	aa0103f3 	mov	x19, x1
ffffffffea814748:	97fff1d4 	bl	ffffffffea810e98 <kvaddr_to_paddr>
		pgd = vaddr_to_paddr(new_ut->page_table);
		ARM64_WRITE_SYSREG(ttbr0_el1, (paddr_t)new_ut->arch.asid << 48 | pgd);
ffffffffea81474c:	b9409a61 	ldr	w1, [x19, #152]
ffffffffea814750:	aa01c000 	orr	x0, x0, x1, lsl #48
ffffffffea814754:	d5182000 	msr	ttbr0_el1, x0
ffffffffea814758:	d5033fdf 	isb
		if (!old_ut)
ffffffffea81475c:	b4000094 	cbz	x20, ffffffffea81476c <arch_uthread_context_switch+0x64>
			ARM64_WRITE_SYSREG(tcr_el1, MMU_TCR_FLAGS_USER);
	}
}
ffffffffea814760:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814764:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea814768:	d65f03c0 	ret
			ARM64_WRITE_SYSREG(tcr_el1, MMU_TCR_FLAGS_USER);
ffffffffea81476c:	d286a4e0 	mov	x0, #0x3527                	// #13607
ffffffffea814770:	f2b6a460 	movk	x0, #0xb523, lsl #16
ffffffffea814774:	f2c00040 	movk	x0, #0x2, lsl #32
ffffffffea814778:	d5182040 	msr	tcr_el1, x0
ffffffffea81477c:	d5033fdf 	isb
}
ffffffffea814780:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814784:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea814788:	d65f03c0 	ret
ffffffffea81478c:	d65f03c0 	ret

ffffffffea814790 <arch_uthread_create>:

status_t arch_uthread_create(struct uthread *ut)
{
ffffffffea814790:	aa0003e1 	mov	x1, x0

	ut->arch.asid = ut->id;
	ut->arch.uthread = ut;

	return err;
}
ffffffffea814794:	52800000 	mov	w0, #0x0                   	// #0
	ut->arch.asid = ut->id;
ffffffffea814798:	b9406822 	ldr	w2, [x1, #104]
ffffffffea81479c:	b9009822 	str	w2, [x1, #152]
	ut->arch.uthread = ut;
ffffffffea8147a0:	f9005021 	str	x1, [x1, #160]
}
ffffffffea8147a4:	d65f03c0 	ret

ffffffffea8147a8 <arch_uthread_free>:

void arch_uthread_free(struct uthread *ut)
{
ffffffffea8147a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	arm64_mmu_unmap(0, 1UL << MMU_USER_SIZE_SHIFT,
ffffffffea8147ac:	52800185 	mov	w5, #0xc                   	// #12
ffffffffea8147b0:	528002a4 	mov	w4, #0x15                  	// #21
ffffffffea8147b4:	52800323 	mov	w3, #0x19                  	// #25
{
ffffffffea8147b8:	910003fd 	mov	x29, sp
ffffffffea8147bc:	f9000bf3 	str	x19, [sp, #16]
ffffffffea8147c0:	aa0003f3 	mov	x19, x0
	arm64_mmu_unmap(0, 1UL << MMU_USER_SIZE_SHIFT,
ffffffffea8147c4:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea8147c8:	d2a04001 	mov	x1, #0x2000000             	// #33554432
ffffffffea8147cc:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea8147d0:	b9409a67 	ldr	w7, [x19, #152]
ffffffffea8147d4:	f9403a66 	ldr	x6, [x19, #112]
ffffffffea8147d8:	97ffbcac 	bl	ffffffffea803a88 <arm64_mmu_unmap>
	                0, MMU_USER_SIZE_SHIFT,
	                MMU_USER_TOP_SHIFT, MMU_USER_PAGE_SIZE_SHIFT,
	                ut->page_table, ut->arch.asid);

	free(ut->page_table);
ffffffffea8147dc:	f9403a60 	ldr	x0, [x19, #112]
}
ffffffffea8147e0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8147e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(ut->page_table);
ffffffffea8147e8:	17fffad0 	b	ffffffffea813328 <free>
ffffffffea8147ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8147f0 <arm64_uthread_allocate_page_table>:

status_t arm64_uthread_allocate_page_table(struct uthread *ut)
{
ffffffffea8147f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	size_t page_table_size;

	page_table_size = MMU_USER_PAGE_TABLE_ENTRIES_TOP * sizeof(pte_t);

	ut->page_table = memalign(page_table_size, page_table_size);
ffffffffea8147f4:	d2801001 	mov	x1, #0x80                  	// #128
{
ffffffffea8147f8:	910003fd 	mov	x29, sp
ffffffffea8147fc:	f9000bf3 	str	x19, [sp, #16]
ffffffffea814800:	aa0003f3 	mov	x19, x0
	ut->page_table = memalign(page_table_size, page_table_size);
ffffffffea814804:	aa0103e0 	mov	x0, x1
ffffffffea814808:	97fffab4 	bl	ffffffffea8132d8 <memalign>
ffffffffea81480c:	f9003a60 	str	x0, [x19, #112]
	if (!ut->page_table) {
ffffffffea814810:	b4000100 	cbz	x0, ffffffffea814830 <arm64_uthread_allocate_page_table+0x40>
		return ERR_NO_MEMORY;
	}
	memset(ut->page_table, 0, page_table_size);
ffffffffea814814:	d2801002 	mov	x2, #0x80                  	// #128
ffffffffea814818:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea81481c:	97fffb81 	bl	ffffffffea813620 <memset>

	LTRACEF("id %d, user page table %p, size %ld\n",
	        ut->id, ut->page_table, page_table_size);

	return NO_ERROR;
ffffffffea814820:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea814824:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea814828:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea81482c:	d65f03c0 	ret
		return ERR_NO_MEMORY;
ffffffffea814830:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea814834:	17fffffc 	b	ffffffffea814824 <arm64_uthread_allocate_page_table+0x34>

ffffffffea814838 <arch_uthread_map>:

status_t arch_uthread_map(struct uthread *ut, struct uthread_map *mp)
{
ffffffffea814838:	d101c3ff 	sub	sp, sp, #0x70
ffffffffea81483c:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea814840:	910043fd 	add	x29, sp, #0x10
ffffffffea814844:	f9001ff6 	str	x22, [sp, #56]
ffffffffea814848:	aa0103f6 	mov	x22, x1
	paddr_t pg, pte_attr;
	size_t entry_size;
	status_t err = NO_ERROR;

	if (!ut->page_table) {
ffffffffea81484c:	f9403801 	ldr	x1, [x0, #112]
{
ffffffffea814850:	a902d7f4 	stp	x20, x21, [sp, #40]
ffffffffea814854:	aa0003f5 	mov	x21, x0
ffffffffea814858:	f90033fb 	str	x27, [sp, #96]
ffffffffea81485c:	aa1e03f4 	mov	x20, x30
	if (!ut->page_table) {
ffffffffea814860:	b4000de1 	cbz	x1, ffffffffea814a1c <arch_uthread_map+0x1e4>
ffffffffea814864:	f9000bb3 	str	x19, [x29, #16]
ffffffffea814868:	f90027ba 	str	x26, [x29, #72]
		if (err) {
			return err;
		}
	}

	ASSERT(!(mp->size & USER_PAGE_MASK));
ffffffffea81486c:	f94006d3 	ldr	x19, [x22, #8]
ffffffffea814870:	f2402e7a 	ands	x26, x19, #0xfff
ffffffffea814874:	54000dc1 	b.ne	ffffffffea814a2c <arch_uthread_map+0x1f4>  // b.any

	pte_attr = MMU_PTE_ATTR_NON_GLOBAL | MMU_PTE_ATTR_AF;

	pte_attr |= (mp->flags & UTM_NS_MEM) ? MMU_PTE_ATTR_NON_SECURE : 0;
ffffffffea814878:	b94012c1 	ldr	w1, [x22, #16]

	pte_attr |= (mp->flags & UTM_W) ? MMU_PTE_ATTR_AP_P_RW_U_RW :
ffffffffea81487c:	d2801802 	mov	x2, #0xc0                  	// #192
ffffffffea814880:	f90023b9 	str	x25, [x29, #64]
ffffffffea814884:	d2800819 	mov	x25, #0x40                  	// #64
	pte_attr |= (mp->flags & UTM_NS_MEM) ? MMU_PTE_ATTR_NON_SECURE : 0;
ffffffffea814888:	53017c20 	lsr	w0, w1, #1
	pte_attr |= (mp->flags & UTM_W) ? MMU_PTE_ATTR_AP_P_RW_U_RW :
ffffffffea81488c:	f27f003f 	tst	x1, #0x2
	pte_attr |= (mp->flags & UTM_NS_MEM) ? MMU_PTE_ATTR_NON_SECURE : 0;
ffffffffea814890:	121b0000 	and	w0, w0, #0x20
	pte_attr |= (mp->flags & UTM_W) ? MMU_PTE_ATTR_AP_P_RW_U_RW :
ffffffffea814894:	9a821339 	csel	x25, x25, x2, ne  // ne = any
	pte_attr |= (mp->flags & UTM_NS_MEM) ? MMU_PTE_ATTR_NON_SECURE : 0;
ffffffffea814898:	32160400 	orr	w0, w0, #0xc00
	pte_attr |= (mp->flags & UTM_W) ? MMU_PTE_ATTR_AP_P_RW_U_RW :
ffffffffea81489c:	aa000339 	orr	x25, x25, x0
	 * is not speculatively prefeched as an instruction,
	 * these mappings should always be tagged as execute-never.
	 *
	 * The code block below always asserts this
	 */
	if (mp->flags & UTM_IO) {
ffffffffea8148a0:	36380841 	tbz	w1, #7, ffffffffea8149a8 <arch_uthread_map+0x170>
		pte_attr |= MMU_PTE_ATTR_STRONGLY_ORDERED;
		/* Explictly check that IO mem is not tagged as executable */
		ASSERT(!(mp->flags & UTM_X));
ffffffffea8148a4:	37100da1 	tbnz	w1, #2, ffffffffea814a58 <arch_uthread_map+0x220>

	/*
	 * Mark execute-never unless explicitly flagged as UTM_X.
	 * Mark NS memory as execute-never always.
	 */
	if ( !(mp->flags & UTM_X) || (mp->flags & UTM_NS_MEM) )
ffffffffea8148a8:	52800880 	mov	w0, #0x44                  	// #68
ffffffffea8148ac:	0a000020 	and	w0, w1, w0
	    pte_attr |= (MMU_PTE_ATTR_UXN | MMU_PTE_ATTR_PXN);
ffffffffea8148b0:	7100101f 	cmp	w0, #0x4
ffffffffea8148b4:	b24b0720 	orr	x0, x25, #0x60000000000000
ffffffffea8148b8:	9a991019 	csel	x25, x0, x25, ne  // ne = any

	entry_size = (mp->flags & UTM_PHYS_CONTIG) ? mp->size : USER_PAGE_SIZE;
ffffffffea8148bc:	37280a61 	tbnz	w1, #5, ffffffffea814a08 <arch_uthread_map+0x1d0>
	for (pg = 0; pg < (mp->size / entry_size); pg++) {
ffffffffea8148c0:	f13ffe7f 	cmp	x19, #0xfff
ffffffffea8148c4:	540008e9 	b.ls	ffffffffea8149e0 <arch_uthread_map+0x1a8>  // b.plast
ffffffffea8148c8:	a90363b7 	stp	x23, x24, [x29, #48]
	entry_size = (mp->flags & UTM_PHYS_CONTIG) ? mp->size : USER_PAGE_SIZE;
ffffffffea8148cc:	d2820013 	mov	x19, #0x1000                	// #4096
ffffffffea8148d0:	9100a2d8 	add	x24, x22, #0x28
ffffffffea8148d4:	d2800017 	mov	x23, #0x0                   	// #0
ffffffffea8148d8:	d2800014 	mov	x20, #0x0                   	// #0
ffffffffea8148dc:	14000008 	b	ffffffffea8148fc <arch_uthread_map+0xc4>
	for (pg = 0; pg < (mp->size / entry_size); pg++) {
ffffffffea8148e0:	f94006c0 	ldr	x0, [x22, #8]
ffffffffea8148e4:	91000694 	add	x20, x20, #0x1
ffffffffea8148e8:	8b1302f7 	add	x23, x23, x19
ffffffffea8148ec:	91002318 	add	x24, x24, #0x8
ffffffffea8148f0:	9ad30800 	udiv	x0, x0, x19
ffffffffea8148f4:	eb14001f 	cmp	x0, x20
ffffffffea8148f8:	54000729 	b.ls	ffffffffea8149dc <arch_uthread_map+0x1a4>  // b.plast
		err = arm64_mmu_map(mp->vaddr + pg * entry_size,
ffffffffea8148fc:	f9400301 	ldr	x1, [x24]
ffffffffea814900:	52800187 	mov	w7, #0xc                   	// #12
ffffffffea814904:	b9409aa2 	ldr	w2, [x21, #152]
ffffffffea814908:	528002a6 	mov	w6, #0x15                  	// #21
ffffffffea81490c:	f9403aa3 	ldr	x3, [x21, #112]
ffffffffea814910:	52800325 	mov	w5, #0x19                  	// #25
ffffffffea814914:	f94002c0 	ldr	x0, [x22]
ffffffffea814918:	d2800004 	mov	x4, #0x0                   	// #0
ffffffffea81491c:	f90003e3 	str	x3, [sp]
ffffffffea814920:	aa1903e3 	mov	x3, x25
ffffffffea814924:	b9000be2 	str	w2, [sp, #8]
ffffffffea814928:	8b0002e0 	add	x0, x23, x0
ffffffffea81492c:	aa1303e2 	mov	x2, x19
ffffffffea814930:	97ffbc28 	bl	ffffffffea8039d0 <arm64_mmu_map>
ffffffffea814934:	2a0003fb 	mov	w27, w0
		                    mp->pfn_list[pg], entry_size, pte_attr,
		                    0, MMU_USER_SIZE_SHIFT, MMU_USER_TOP_SHIFT,
		                    MMU_USER_PAGE_SIZE_SHIFT,
		                    ut->page_table, ut->arch.asid);
		if (err) {
ffffffffea814938:	34fffd40 	cbz	w0, ffffffffea8148e0 <arch_uthread_map+0xa8>
	}

	return NO_ERROR;

err_undo_maps:
	for(u_int p = 0; p < pg; p++) {
ffffffffea81493c:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea814940:	b4000214 	cbz	x20, ffffffffea814980 <arch_uthread_map+0x148>
ffffffffea814944:	d503201f 	nop
		arm64_mmu_unmap(mp->vaddr + p * entry_size, entry_size,
ffffffffea814948:	f94002c0 	ldr	x0, [x22]
	for(u_int p = 0; p < pg; p++) {
ffffffffea81494c:	110006f7 	add	w23, w23, #0x1
		arm64_mmu_unmap(mp->vaddr + p * entry_size, entry_size,
ffffffffea814950:	b9409aa7 	ldr	w7, [x21, #152]
ffffffffea814954:	52800185 	mov	w5, #0xc                   	// #12
ffffffffea814958:	f9403aa6 	ldr	x6, [x21, #112]
ffffffffea81495c:	528002a4 	mov	w4, #0x15                  	// #21
ffffffffea814960:	52800323 	mov	w3, #0x19                  	// #25
ffffffffea814964:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea814968:	9b1a0260 	madd	x0, x19, x26, x0
ffffffffea81496c:	aa1303e1 	mov	x1, x19
	for(u_int p = 0; p < pg; p++) {
ffffffffea814970:	2a1703fa 	mov	w26, w23
		arm64_mmu_unmap(mp->vaddr + p * entry_size, entry_size,
ffffffffea814974:	97ffbc45 	bl	ffffffffea803a88 <arm64_mmu_unmap>
	for(u_int p = 0; p < pg; p++) {
ffffffffea814978:	eb14035f 	cmp	x26, x20
ffffffffea81497c:	54fffe63 	b.cc	ffffffffea814948 <arch_uthread_map+0x110>  // b.lo, b.ul, b.last
ffffffffea814980:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea814984:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea814988:	a9446bb9 	ldp	x25, x26, [x29, #64]
		                MMU_USER_TOP_SHIFT, MMU_USER_PAGE_SIZE_SHIFT,
		                ut->page_table, ut->arch.asid);
	}

	return err;
}
ffffffffea81498c:	2a1b03e0 	mov	w0, w27
ffffffffea814990:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea814994:	a942d7f4 	ldp	x20, x21, [sp, #40]
ffffffffea814998:	f9401ff6 	ldr	x22, [sp, #56]
ffffffffea81499c:	f94033fb 	ldr	x27, [sp, #96]
ffffffffea8149a0:	9101c3ff 	add	sp, sp, #0x70
ffffffffea8149a4:	d65f03c0 	ret
	} else if (mp->flags & UTM_DEVICE) {
ffffffffea8149a8:	36480341 	tbz	w1, #9, ffffffffea814a10 <arch_uthread_map+0x1d8>
		pte_attr |= MMU_PTE_ATTR_DEVICE;
ffffffffea8149ac:	b27e0339 	orr	x25, x25, #0x4
		ASSERT(!(mp->flags & UTM_X));
ffffffffea8149b0:	3617f7c1 	tbz	w1, #2, ffffffffea8148a8 <arch_uthread_map+0x70>
ffffffffea8149b4:	90000024 	adrp	x4, ffffffffea818000 <__func__.2340+0xc8>
ffffffffea8149b8:	90000022 	adrp	x2, ffffffffea818000 <__func__.2340+0xc8>
ffffffffea8149bc:	b0000001 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8149c0:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea8149c4:	9103a084 	add	x4, x4, #0xe8
ffffffffea8149c8:	52801423 	mov	w3, #0xa1                  	// #161
ffffffffea8149cc:	9102e042 	add	x2, x2, #0xb8
ffffffffea8149d0:	9135a021 	add	x1, x1, #0xd68
ffffffffea8149d4:	aa1403e0 	mov	x0, x20
ffffffffea8149d8:	97fff4b0 	bl	ffffffffea811c98 <_panic>
ffffffffea8149dc:	a94363b7 	ldp	x23, x24, [x29, #48]
	return NO_ERROR;
ffffffffea8149e0:	5280001b 	mov	w27, #0x0                   	// #0
ffffffffea8149e4:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea8149e8:	2a1b03e0 	mov	w0, w27
ffffffffea8149ec:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea8149f0:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea8149f4:	a942d7f4 	ldp	x20, x21, [sp, #40]
ffffffffea8149f8:	f9401ff6 	ldr	x22, [sp, #56]
ffffffffea8149fc:	f94033fb 	ldr	x27, [sp, #96]
ffffffffea814a00:	9101c3ff 	add	sp, sp, #0x70
ffffffffea814a04:	d65f03c0 	ret
ffffffffea814a08:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea814a0c:	17ffffb1 	b	ffffffffea8148d0 <arch_uthread_map+0x98>
		pte_attr |= MMU_PTE_ATTR_NORMAL_MEMORY;
ffffffffea814a10:	d2806100 	mov	x0, #0x308                 	// #776
ffffffffea814a14:	aa000339 	orr	x25, x25, x0
ffffffffea814a18:	17ffffa4 	b	ffffffffea8148a8 <arch_uthread_map+0x70>
		err = arm64_uthread_allocate_page_table(ut);
ffffffffea814a1c:	97ffff75 	bl	ffffffffea8147f0 <arm64_uthread_allocate_page_table>
ffffffffea814a20:	2a0003fb 	mov	w27, w0
		if (err) {
ffffffffea814a24:	34fff200 	cbz	w0, ffffffffea814864 <arch_uthread_map+0x2c>
ffffffffea814a28:	17ffffd9 	b	ffffffffea81498c <arch_uthread_map+0x154>
	ASSERT(!(mp->size & USER_PAGE_MASK));
ffffffffea814a2c:	90000024 	adrp	x4, ffffffffea818000 <__func__.2340+0xc8>
ffffffffea814a30:	90000022 	adrp	x2, ffffffffea818000 <__func__.2340+0xc8>
ffffffffea814a34:	b0000001 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea814a38:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea814a3c:	91026084 	add	x4, x4, #0x98
ffffffffea814a40:	52801103 	mov	w3, #0x88                  	// #136
ffffffffea814a44:	9102e042 	add	x2, x2, #0xb8
ffffffffea814a48:	9135a021 	add	x1, x1, #0xd68
ffffffffea814a4c:	aa1403e0 	mov	x0, x20
ffffffffea814a50:	f90023b9 	str	x25, [x29, #64]
ffffffffea814a54:	97fff491 	bl	ffffffffea811c98 <_panic>
		ASSERT(!(mp->flags & UTM_X));
ffffffffea814a58:	90000024 	adrp	x4, ffffffffea818000 <__func__.2340+0xc8>
ffffffffea814a5c:	90000022 	adrp	x2, ffffffffea818000 <__func__.2340+0xc8>
ffffffffea814a60:	b0000001 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea814a64:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea814a68:	9103a084 	add	x4, x4, #0xe8
ffffffffea814a6c:	528013a3 	mov	w3, #0x9d                  	// #157
ffffffffea814a70:	9102e042 	add	x2, x2, #0xb8
ffffffffea814a74:	9135a021 	add	x1, x1, #0xd68
ffffffffea814a78:	aa1403e0 	mov	x0, x20
ffffffffea814a7c:	97fff487 	bl	ffffffffea811c98 <_panic>

ffffffffea814a80 <arch_uthread_unmap>:

status_t arch_uthread_unmap(struct uthread *ut, struct uthread_map *mp)
{
	return arm64_mmu_unmap(mp->vaddr, mp->size, 0, MMU_USER_SIZE_SHIFT,
ffffffffea814a80:	b9409807 	ldr	w7, [x0, #152]
ffffffffea814a84:	52800185 	mov	w5, #0xc                   	// #12
ffffffffea814a88:	f9403806 	ldr	x6, [x0, #112]
ffffffffea814a8c:	528002a4 	mov	w4, #0x15                  	// #21
ffffffffea814a90:	a9400420 	ldp	x0, x1, [x1]
ffffffffea814a94:	52800323 	mov	w3, #0x19                  	// #25
ffffffffea814a98:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea814a9c:	17ffbbfb 	b	ffffffffea803a88 <arm64_mmu_unmap>
