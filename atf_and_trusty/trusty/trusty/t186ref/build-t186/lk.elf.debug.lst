
t186ref/build-t186/lk.elf:     file format elf64-littleaarch64


Disassembly of section .text:

ffffffffea800000 <_start>:

.section .text.boot
FUNCTION(_start)
#if WITH_KERNEL_VM
    /* enable caches so atomics and spinlocks work */
    mrs     tmp, sctlr_el1
ffffffffea800000:	d5381009 	mrs	x9, sctlr_el1
    orr     tmp, tmp, #(1<<12) /* Enable icache */
ffffffffea800004:	b2740129 	orr	x9, x9, #0x1000
    orr     tmp, tmp, #(1<<2)  /* Enable dcache/ucache */
ffffffffea800008:	b27e0129 	orr	x9, x9, #0x4
    bic     tmp, tmp, #(1<<3)  /* Disable Stack Alignment Check */ /* TODO: don't use unaligned stacks */
ffffffffea80000c:	927cf929 	and	x9, x9, #0xfffffffffffffff7
    msr     sctlr_el1, tmp
ffffffffea800010:	d5181009 	msr	sctlr_el1, x9

    /* set up the mmu according to mmu_initial_mappings */

    /* load the base of the translation table and clear the table */
    adrp    page_table1, arm64_kernel_translation_table
ffffffffea800014:	b0000275 	adrp	x21, ffffffffea84d000 <arm64_kernel_translation_table>
    add     page_table1, page_table1, #:lo12:arm64_kernel_translation_table
ffffffffea800018:	910002b5 	add	x21, x21, #0x0

    /* Prepare tt_trampoline page table */
    /* Calculate pagetable physical addresses */
    adrp    page_table0, tt_trampoline
ffffffffea80001c:	d0000274 	adrp	x20, ffffffffea84e000 <tt_trampoline>
    add     page_table0, page_table0, #:lo12:tt_trampoline
ffffffffea800020:	91000294 	add	x20, x20, #0x0

#if WITH_SMP
    mov     tmp, x0
ffffffffea800024:	aa0003e9 	mov	x9, x0
    mov     tmp2,x1
ffffffffea800028:	aa0103ea 	mov	x10, x1
    mov     tmp3,x2
ffffffffea80002c:	aa0203f0 	mov	x16, x2
    mov     tmp4,x3
ffffffffea800030:	aa0303f1 	mov	x17, x3
    /* NV: read cpuid by arch_curr_cpu_num */
    bl      arch_curr_cpu_num
ffffffffea800034:	94000acf 	bl	ffffffffea802b70 <arch_curr_cpu_num>
    mov     cpuid, x0
ffffffffea800038:	aa0003f3 	mov	x19, x0
    mov     x3, tmp4
ffffffffea80003c:	aa1103e3 	mov	x3, x17
    mov     x2, tmp3
ffffffffea800040:	aa1003e2 	mov	x2, x16
    mov     x1, tmp2
ffffffffea800044:	aa0a03e1 	mov	x1, x10
    mov     x0, tmp
ffffffffea800048:	aa0903e0 	mov	x0, x9
    cbnz    cpuid, .Lmmu_enable_secondary
ffffffffea80004c:	b5000eb3 	cbnz	x19, ffffffffea800220 <_start+0x220>
#endif

    mov     tmp, #0
ffffffffea800050:	d2800009 	mov	x9, #0x0                   	// #0

    /* walk through all the entries in the translation table, setting them up */
.Lclear_top_page_table_loop:
    str     xzr, [page_table1, tmp, lsl #3]
ffffffffea800054:	f8297abf 	str	xzr, [x21, x9, lsl #3]
    add     tmp, tmp, #1
ffffffffea800058:	91000529 	add	x9, x9, #0x1
    cmp     tmp, #MMU_KERNEL_PAGE_TABLE_ENTRIES_TOP
ffffffffea80005c:	f104013f 	cmp	x9, #0x100
    bne     .Lclear_top_page_table_loop
ffffffffea800060:	54ffffa1 	b.ne	ffffffffea800054 <_start+0x54>  // b.any

    /* load the address of the mmu_initial_mappings table and start processing */
    adrp    mmu_initial_mapping, mmu_initial_mappings
ffffffffea800064:	900000d6 	adrp	x22, ffffffffea818000 <_mem_phys_base>
    add     mmu_initial_mapping, mmu_initial_mapping, #:lo12:mmu_initial_mappings
ffffffffea800068:	910062d6 	add	x22, x22, #0x18

.Linitial_mapping_loop:
    ldp     paddr, vaddr, [mmu_initial_mapping, #__MMU_INITIAL_MAPPING_PHYS_OFFSET]
ffffffffea80006c:	a9405ed8 	ldp	x24, x23, [x22]
    ldp     size, tmp, [mmu_initial_mapping, #__MMU_INITIAL_MAPPING_SIZE_OFFSET]
ffffffffea800070:	a94126da 	ldp	x26, x9, [x22, #16]

    tbzmask tmp, MMU_INITIAL_MAPPING_FLAG_DYNAMIC, .Lnot_dynamic
ffffffffea800074:	361800a9 	tbz	w9, #3, ffffffffea800088 <_start+0x88>
    adr     paddr, _start
ffffffffea800078:	10fffc58 	adr	x24, ffffffffea800000 <_start>
    mov     size, x0
ffffffffea80007c:	aa0003fa 	mov	x26, x0
    str     paddr, [mmu_initial_mapping, #__MMU_INITIAL_MAPPING_PHYS_OFFSET]
ffffffffea800080:	f90002d8 	str	x24, [x22]
    str     size, [mmu_initial_mapping, #__MMU_INITIAL_MAPPING_SIZE_OFFSET]
ffffffffea800084:	f9000ada 	str	x26, [x22, #16]

.Lnot_dynamic:
    /* if size == 0, end of list */
    cbz     size, .Linitial_mapping_done
ffffffffea800088:	b4000b3a 	cbz	x26, ffffffffea8001ec <_start+0x1ec>
    mov     mapping_size, size
ffffffffea80008c:	aa1a03f9 	mov	x25, x26

    /* set up the flags */
    tbzmask tmp, MMU_INITIAL_MAPPING_FLAG_UNCACHED, .Lnot_uncached
ffffffffea800090:	36080069 	tbz	w9, #1, ffffffffea80009c <_start+0x9c>
    ldr     attr, =MMU_INITIAL_MAP_STRONGLY_ORDERED
ffffffffea800094:	580012fb 	ldr	x27, ffffffffea8002f0 <_start+0x2f0>
    b       .Lmem_type_done
ffffffffea800098:	14000013 	b	ffffffffea8000e4 <_start+0xe4>
.Lnot_uncached:
    tbzmask tmp, MMU_INITIAL_MAPPING_FLAG_DEVICE, .Lnot_device
ffffffffea80009c:	36100069 	tbz	w9, #2, ffffffffea8000a8 <_start+0xa8>
    ldr     attr, =MMU_INITIAL_MAP_DEVICE
ffffffffea8000a0:	580012db 	ldr	x27, ffffffffea8002f8 <_start+0x2f8>
    b       .Lmem_type_done
ffffffffea8000a4:	14000010 	b	ffffffffea8000e4 <_start+0xe4>
.Lnot_device:

.Lmapping_size_loop:
    ldr     attr, =MMU_PTE_KERNEL_RO_FLAGS
ffffffffea8000a8:	580012db 	ldr	x27, ffffffffea800300 <_start+0x300>
    ldr     tmp, =__rodata_start
ffffffffea8000ac:	580012e9 	ldr	x9, ffffffffea800308 <_start+0x308>
    subs    size, tmp, vaddr
ffffffffea8000b0:	eb17013a 	subs	x26, x9, x23
    b.hi    .Lmem_type_done
ffffffffea8000b4:	54000188 	b.hi	ffffffffea8000e4 <_start+0xe4>  // b.pmore
    orr     attr, attr, #MMU_PTE_ATTR_PXN
ffffffffea8000b8:	b24b037b 	orr	x27, x27, #0x20000000000000
    ldr     tmp, =__data_start
ffffffffea8000bc:	580012a9 	ldr	x9, ffffffffea800310 <_start+0x310>
    subs    size, tmp, vaddr
ffffffffea8000c0:	eb17013a 	subs	x26, x9, x23
    b.hi    .Lmem_type_done
ffffffffea8000c4:	54000108 	b.hi	ffffffffea8000e4 <_start+0xe4>  // b.pmore
    ldr     attr, =MMU_PTE_KERNEL_DATA_FLAGS
ffffffffea8000c8:	5800129b 	ldr	x27, ffffffffea800318 <_start+0x318>
    ldr     tmp, =_end
ffffffffea8000cc:	580012a9 	ldr	x9, ffffffffea800320 <_start+0x320>
    subs    size, tmp, vaddr
ffffffffea8000d0:	eb17013a 	subs	x26, x9, x23
    b.lo    . /* Error: _end < vaddr */
ffffffffea8000d4:	54000003 	b.cc	ffffffffea8000d4 <_start+0xd4>  // b.lo, b.ul, b.last
    cmp     mapping_size, size
ffffffffea8000d8:	eb1a033f 	cmp	x25, x26
    b.lo    . /* Error: mapping_size < size => RAM size too small for data/bss */
ffffffffea8000dc:	54000003 	b.cc	ffffffffea8000dc <_start+0xdc>  // b.lo, b.ul, b.last
    mov     size, mapping_size
ffffffffea8000e0:	aa1903fa 	mov	x26, x25

.Lmem_type_done:
    subs    mapping_size, mapping_size, size
ffffffffea8000e4:	eb1a0339 	subs	x25, x25, x26
    b.lo    . /* Error: mapping_size < size (RAM size too small for code/rodata?) */
ffffffffea8000e8:	54000003 	b.cc	ffffffffea8000e8 <_start+0xe8>  // b.lo, b.ul, b.last

    /* Check that paddr, vaddr and size are page aligned */
    orr     tmp, vaddr, paddr
ffffffffea8000ec:	aa1802e9 	orr	x9, x23, x24
    orr     tmp, tmp, size
ffffffffea8000f0:	aa1a0129 	orr	x9, x9, x26
    tst     tmp, #(1 << MMU_KERNEL_PAGE_SIZE_SHIFT) - 1
ffffffffea8000f4:	f2402d3f 	tst	x9, #0xfff
    bne     . /* Error: not page aligned */
ffffffffea8000f8:	54000001 	b.ne	ffffffffea8000f8 <_start+0xf8>  // b.any

    /* Clear top bits of virtual address (should be all set) */
    eor     vaddr, vaddr, #(~0 << MMU_KERNEL_SIZE_SHIFT)
ffffffffea8000fc:	d2638af7 	eor	x23, x23, #0xffffffffe0000000

    /* Check that top bits were all set */
    tst     vaddr, #(~0 << MMU_KERNEL_SIZE_SHIFT)
ffffffffea800100:	f2638aff 	tst	x23, #0xffffffffe0000000
    bne     . /* Error: vaddr out of range */
ffffffffea800104:	54000001 	b.ne	ffffffffea800104 <_start+0x104>  // b.any

.Lmap_range_top_loop:
    /* Select top level page table */
    mov     page_table, page_table1
ffffffffea800108:	aa1503ed 	mov	x13, x21
    mov     idx_shift, #MMU_KERNEL_TOP_SHIFT
ffffffffea80010c:	d28002ac 	mov	x12, #0x15                  	// #21

    lsr     idx, vaddr, idx_shift
ffffffffea800110:	9acc26eb 	lsr	x11, x23, x12

.Lmap_range_one_table_loop:
    /* Check if current level allow block descriptors */
    cmp     idx_shift, #MMU_PTE_DESCRIPTOR_BLOCK_MAX_SHIFT
ffffffffea800114:	f100799f 	cmp	x12, #0x1e
    b.hi    .Lmap_range_need_page_table
ffffffffea800118:	54000308 	b.hi	ffffffffea800178 <_start+0x178>  // b.pmore

    /* Check if paddr and vaddr alignment allows a block descriptor */
    orr     tmp2, vaddr, paddr
ffffffffea80011c:	aa1802ea 	orr	x10, x23, x24
    lsr     tmp, tmp2, idx_shift
ffffffffea800120:	9acc2549 	lsr	x9, x10, x12
    lsl     tmp, tmp, idx_shift
ffffffffea800124:	9acc2129 	lsl	x9, x9, x12
    cmp     tmp, tmp2
ffffffffea800128:	eb0a013f 	cmp	x9, x10
    b.ne    .Lmap_range_need_page_table
ffffffffea80012c:	54000261 	b.ne	ffffffffea800178 <_start+0x178>  // b.any

    /* Check if size is large enough for a block mapping */
    lsr     tmp, size, idx_shift
ffffffffea800130:	9acc2749 	lsr	x9, x26, x12
    cbz     tmp, .Lmap_range_need_page_table
ffffffffea800134:	b4000229 	cbz	x9, ffffffffea800178 <_start+0x178>

    /* Select descriptor type, page for level 3, block for level 0-2 */
    orr     tmp, attr, #MMU_PTE_L3_DESCRIPTOR_PAGE
ffffffffea800138:	b2400769 	orr	x9, x27, #0x3
    cmp     idx_shift, MMU_KERNEL_PAGE_SIZE_SHIFT
ffffffffea80013c:	f100319f 	cmp	x12, #0xc
    beq     .Lmap_range_l3
ffffffffea800140:	54000040 	b.eq	ffffffffea800148 <_start+0x148>  // b.none
    orr     tmp, attr, #MMU_PTE_L012_DESCRIPTOR_BLOCK
ffffffffea800144:	b2400369 	orr	x9, x27, #0x1
.Lmap_range_l3:

    /* Write page table entry */
    orr     tmp, tmp, paddr
ffffffffea800148:	aa180129 	orr	x9, x9, x24
    str     tmp, [page_table, idx, lsl #3]
ffffffffea80014c:	f82b79a9 	str	x9, [x13, x11, lsl #3]

    /* Move to next page table entry */
    mov     tmp, #1
ffffffffea800150:	d2800029 	mov	x9, #0x1                   	// #1
    lsl     tmp, tmp, idx_shift
ffffffffea800154:	9acc2129 	lsl	x9, x9, x12
    add     vaddr, vaddr, tmp
ffffffffea800158:	8b0902f7 	add	x23, x23, x9
    add     paddr, paddr, tmp
ffffffffea80015c:	8b090318 	add	x24, x24, x9
    subs    size, size, tmp
ffffffffea800160:	eb09035a 	subs	x26, x26, x9
    /* TODO: add local loop if next entry is in the same page table */
    b.ne    .Lmap_range_top_loop /* size != 0 */
ffffffffea800164:	54fffd21 	b.ne	ffffffffea800108 <_start+0x108>  // b.any

    /* Restore top bits of virtual address (should be all set) */
    eor     vaddr, vaddr, #(~0 << MMU_KERNEL_SIZE_SHIFT)
ffffffffea800168:	d2638af7 	eor	x23, x23, #0xffffffffe0000000
    /* Move to next subtype of ram mmu_initial_mappings entry */
    cbnz     mapping_size, .Lmapping_size_loop
ffffffffea80016c:	b5fff9f9 	cbnz	x25, ffffffffea8000a8 <_start+0xa8>

    /* Move to next mmu_initial_mappings entry */
    add     mmu_initial_mapping, mmu_initial_mapping, __MMU_INITIAL_MAPPING_SIZE
ffffffffea800170:	9100a2d6 	add	x22, x22, #0x28
    b       .Linitial_mapping_loop
ffffffffea800174:	17ffffbe 	b	ffffffffea80006c <_start+0x6c>

.Lmap_range_need_page_table:
    /* Check if page table entry is unused */
    ldr     new_page_table, [page_table, idx, lsl #3]
ffffffffea800178:	f86b79ae 	ldr	x14, [x13, x11, lsl #3]
    cbnz    new_page_table, .Lmap_range_has_page_table
ffffffffea80017c:	b500024e 	cbnz	x14, ffffffffea8001c4 <_start+0x1c4>

    /* Calculate phys offset (needed for memory allocation) */
.Lphys_offset:
    adr     phys_offset, .Lphys_offset /* phys */
ffffffffea800180:	1000000f 	adr	x15, ffffffffea800180 <_start+0x180>
    ldr     tmp, =.Lphys_offset /* virt */
ffffffffea800184:	58000d29 	ldr	x9, ffffffffea800328 <_start+0x328>
    sub     phys_offset, tmp, phys_offset
ffffffffea800188:	cb0f012f 	sub	x15, x9, x15

    /* Allocate new page table */
    calloc_bootmem_aligned new_page_table, tmp, tmp2, MMU_KERNEL_PAGE_SIZE_SHIFT, phys_offset
ffffffffea80018c:	900000ca 	adrp	x10, ffffffffea818000 <_mem_phys_base>
ffffffffea800190:	f947514e 	ldr	x14, [x10, #3744]
ffffffffea800194:	913ffdce 	add	x14, x14, #0xfff
ffffffffea800198:	9274cdce 	and	x14, x14, #0xfffffffffffff000
ffffffffea80019c:	914005c9 	add	x9, x14, #0x1, lsl #12
ffffffffea8001a0:	f9075149 	str	x9, [x10, #3744]
ffffffffea8001a4:	cb0f01ce 	sub	x14, x14, x15
ffffffffea8001a8:	cb0f0129 	sub	x9, x9, x15
ffffffffea8001ac:	aa0e03ea 	mov	x10, x14
ffffffffea8001b0:	a8817d5f 	stp	xzr, xzr, [x10], #16
ffffffffea8001b4:	eb09015f 	cmp	x10, x9
ffffffffea8001b8:	54ffffc3 	b.cc	ffffffffea8001b0 <_start+0x1b0>  // b.lo, b.ul, b.last

    /* Write page table entry (with allocated page table) */
    orr     new_page_table, new_page_table, #MMU_PTE_L012_DESCRIPTOR_TABLE
ffffffffea8001bc:	b24005ce 	orr	x14, x14, #0x3
    str     new_page_table, [page_table, idx, lsl #3]
ffffffffea8001c0:	f82b79ae 	str	x14, [x13, x11, lsl #3]

.Lmap_range_has_page_table:
    /* Check descriptor type */
    and     tmp, new_page_table, #MMU_PTE_DESCRIPTOR_MASK
ffffffffea8001c4:	924005c9 	and	x9, x14, #0x3
    cmp     tmp, #MMU_PTE_L012_DESCRIPTOR_TABLE
ffffffffea8001c8:	f1000d3f 	cmp	x9, #0x3
    b.ne    . /* Error: entry already in use (as a block entry) */
ffffffffea8001cc:	54000001 	b.ne	ffffffffea8001cc <_start+0x1cc>  // b.any

    /* switch to next page table level */
    bic     page_table, new_page_table, #MMU_PTE_DESCRIPTOR_MASK
ffffffffea8001d0:	927ef5cd 	and	x13, x14, #0xfffffffffffffffc
    mov     tmp, #~0
ffffffffea8001d4:	92800009 	mov	x9, #0xffffffffffffffff    	// #-1
    lsl     tmp, tmp, idx_shift
ffffffffea8001d8:	9acc2129 	lsl	x9, x9, x12
    bic     tmp, vaddr, tmp
ffffffffea8001dc:	8a2902e9 	bic	x9, x23, x9
    sub     idx_shift, idx_shift, #(MMU_KERNEL_PAGE_SIZE_SHIFT - 3)
ffffffffea8001e0:	d100258c 	sub	x12, x12, #0x9
    lsr     idx, tmp, idx_shift
ffffffffea8001e4:	9acc252b 	lsr	x11, x9, x12

    b       .Lmap_range_one_table_loop
ffffffffea8001e8:	17ffffcb 	b	ffffffffea800114 <_start+0x114>
.Linitial_mapping_done:

    /* Prepare tt_trampoline page table */

    /* Zero tt_trampoline translation tables */
    mov     tmp, #0
ffffffffea8001ec:	d2800009 	mov	x9, #0x0                   	// #0
.Lclear_tt_trampoline:
    str     xzr, [page_table0, tmp, lsl#3]
ffffffffea8001f0:	f8297a9f 	str	xzr, [x20, x9, lsl #3]
    add     tmp, tmp, #1
ffffffffea8001f4:	91000529 	add	x9, x9, #0x1
    cmp     tmp, #MMU_PAGE_TABLE_ENTRIES_IDENT
ffffffffea8001f8:	f108013f 	cmp	x9, #0x200
    blt     .Lclear_tt_trampoline
ffffffffea8001fc:	54ffffab 	b.lt	ffffffffea8001f0 <_start+0x1f0>  // b.tstop

    /* Setup mapping at phys -> phys */
    adr     tmp, .Lmmu_on_pc
ffffffffea800200:	10000329 	adr	x9, ffffffffea800264 <_start+0x264>
    lsr     tmp, tmp, #MMU_IDENT_TOP_SHIFT    /* tmp = paddr index */
ffffffffea800204:	d35efd29 	lsr	x9, x9, #30
    ldr     tmp2, =MMU_PTE_IDENT_FLAGS
ffffffffea800208:	5800094a 	ldr	x10, ffffffffea800330 <_start+0x330>
    add     tmp2, tmp2, tmp, lsl #MMU_IDENT_TOP_SHIFT  /* tmp2 = pt entry */
ffffffffea80020c:	8b09794a 	add	x10, x10, x9, lsl #30

    str     tmp2, [page_table0, tmp, lsl #3]     /* tt_trampoline[paddr index] = pt entry */
ffffffffea800210:	f8297a8a 	str	x10, [x20, x9, lsl #3]

#if WITH_SMP
    adr     tmp, page_tables_not_ready
ffffffffea800214:	100bfce9 	adr	x9, ffffffffea8181b0 <page_tables_not_ready>
    str     wzr, [tmp]
ffffffffea800218:	b900013f 	str	wzr, [x9]
    b       .Lpage_tables_ready
ffffffffea80021c:	14000004 	b	ffffffffea80022c <_start+0x22c>

.Lmmu_enable_secondary:
    adr     tmp, page_tables_not_ready
ffffffffea800220:	100bfc89 	adr	x9, ffffffffea8181b0 <page_tables_not_ready>
.Lpage_tables_not_ready:
    ldr     wtmp2, [tmp]
ffffffffea800224:	b940012a 	ldr	w10, [x9]
    cbnz    wtmp2, .Lpage_tables_not_ready
ffffffffea800228:	35ffffea 	cbnz	w10, ffffffffea800224 <_start+0x224>
#endif

    /* set up the mmu */

    /* Invalidate TLB */
    tlbi    vmalle1is
ffffffffea80022c:	d508831f 	tlbi	vmalle1is
    isb
ffffffffea800230:	d5033fdf 	isb
    dsb     sy
ffffffffea800234:	d5033f9f 	dsb	sy

    /* Initialize Memory Attribute Indirection Register */
    ldr     tmp, =MMU_MAIR_VAL
ffffffffea800238:	58000809 	ldr	x9, ffffffffea800338 <_start+0x338>
    msr     mair_el1, tmp
ffffffffea80023c:	d518a209 	msr	mair_el1, x9

    /* Initialize TCR_EL1 */
    /* set cacheable attributes on translation walk */
    /* (SMP extensions) non-shareable, inner write-back write-allocate */
    ldr     tmp, =MMU_TCR_FLAGS_IDENT
ffffffffea800240:	58000809 	ldr	x9, ffffffffea800340 <_start+0x340>
    msr     tcr_el1, tmp
ffffffffea800244:	d5182049 	msr	tcr_el1, x9

    isb
ffffffffea800248:	d5033fdf 	isb

    /* Write ttbr with phys addr of the translation table */
    msr     ttbr0_el1, page_table0
ffffffffea80024c:	d5182014 	msr	ttbr0_el1, x20
    msr     ttbr1_el1, page_table1
ffffffffea800250:	d5182035 	msr	ttbr1_el1, x21
    isb
ffffffffea800254:	d5033fdf 	isb

    /* Read SCTLR */
    mrs     tmp, sctlr_el1
ffffffffea800258:	d5381009 	mrs	x9, sctlr_el1

    /* Turn on the MMU */
    orr     tmp, tmp, #0x1
ffffffffea80025c:	b2400129 	orr	x9, x9, #0x1

    /* Write back SCTLR */
    msr     sctlr_el1, tmp
ffffffffea800260:	d5181009 	msr	sctlr_el1, x9
.Lmmu_on_pc:
    isb
ffffffffea800264:	d5033fdf 	isb

    /* Jump to virtual code address */
    ldr     tmp, =.Lmmu_on_vaddr
ffffffffea800268:	58000709 	ldr	x9, ffffffffea800348 <_start+0x348>
    br      tmp
ffffffffea80026c:	d61f0120 	br	x9

.Lmmu_on_vaddr:

    /* Disable trampoline page-table in ttbr0 */
    ldr     tmp, =MMU_TCR_FLAGS_KERNEL
ffffffffea800270:	58000709 	ldr	x9, ffffffffea800350 <_start+0x350>
    msr     tcr_el1, tmp
ffffffffea800274:	d5182049 	msr	tcr_el1, x9
    isb
ffffffffea800278:	d5033fdf 	isb


    /* Invalidate TLB */
    tlbi    vmalle1
ffffffffea80027c:	d508871f 	tlbi	vmalle1
    isb
ffffffffea800280:	d5033fdf 	isb

#if WITH_SMP
    cbnz    cpuid, .Lsecondary_boot
ffffffffea800284:	b5000193 	cbnz	x19, ffffffffea8002b4 <_start+0x2b4>
#endif
#endif /* WITH_KERNEL_VM */

    ldr tmp, =__stack_end
ffffffffea800288:	58000689 	ldr	x9, ffffffffea800358 <_start+0x358>
    mov sp, tmp
ffffffffea80028c:	9100013f 	mov	sp, x9

    /* clear bss */
.L__do_bss:
    /* clear out the bss */
    /* NOTE: relies on __bss_start and __bss_end being 8 byte aligned */
    ldr     tmp, =__bss_start
ffffffffea800290:	58000689 	ldr	x9, ffffffffea800360 <_start+0x360>
    ldr     tmp2, =__bss_end
ffffffffea800294:	580006aa 	ldr	x10, ffffffffea800368 <_start+0x368>
    sub     tmp2, tmp2, tmp
ffffffffea800298:	cb09014a 	sub	x10, x10, x9
    cbz     tmp2, .L__bss_loop_done
ffffffffea80029c:	b400008a 	cbz	x10, ffffffffea8002ac <_start+0x2ac>
.L__bss_loop:
    sub     tmp2, tmp2, #8
ffffffffea8002a0:	d100214a 	sub	x10, x10, #0x8
    str     xzr, [tmp], #8
ffffffffea8002a4:	f800853f 	str	xzr, [x9], #8
    cbnz    tmp2, .L__bss_loop
ffffffffea8002a8:	b5ffffca 	cbnz	x10, ffffffffea8002a0 <_start+0x2a0>
.L__bss_loop_done:

    bl  lk_main
ffffffffea8002ac:	94000f11 	bl	ffffffffea803ef0 <lk_main>
    b   .
ffffffffea8002b0:	14000000 	b	ffffffffea8002b0 <_start+0x2b0>

#if WITH_SMP
.Lsecondary_boot:
    and     tmp, cpuid, #0xff
ffffffffea8002b4:	92401e69 	and	x9, x19, #0xff
    cmp     tmp, #(1 << SMP_CPU_CLUSTER_SHIFT)
ffffffffea8002b8:	f104013f 	cmp	x9, #0x100
    bge     .Lunsupported_cpu_trap
ffffffffea8002bc:	5400016a 	b.ge	ffffffffea8002e8 <_start+0x2e8>  // b.tcont
    bic     cpuid, cpuid, #0xff
ffffffffea8002c0:	9278de73 	and	x19, x19, #0xffffffffffffff00
    orr     cpuid, tmp, cpuid, LSR #(8 - SMP_CPU_CLUSTER_SHIFT)
ffffffffea8002c4:	aa530133 	orr	x19, x9, x19, lsr #0

    cmp     cpuid, #SMP_MAX_CPUS
ffffffffea8002c8:	f100227f 	cmp	x19, #0x8
    bge     .Lunsupported_cpu_trap
ffffffffea8002cc:	540000ea 	b.ge	ffffffffea8002e8 <_start+0x2e8>  // b.tcont

    /* Set up the stack */
    ldr     tmp, =__stack_end
ffffffffea8002d0:	58000449 	ldr	x9, ffffffffea800358 <_start+0x358>
    mov     tmp2, #ARCH_DEFAULT_STACK_SIZE
ffffffffea8002d4:	d282000a 	mov	x10, #0x1000                	// #4096
    mul     tmp2, tmp2, cpuid
ffffffffea8002d8:	9b137d4a 	mul	x10, x10, x19
    sub     sp, tmp, tmp2
ffffffffea8002dc:	cb2a613f 	sub	sp, x9, x10

    mov     x0, cpuid
ffffffffea8002e0:	aa1303e0 	mov	x0, x19
    bl      arm64_secondary_entry
ffffffffea8002e4:	94000a49 	bl	ffffffffea802c08 <arm64_secondary_entry>

.Lunsupported_cpu_trap:
    wfe
ffffffffea8002e8:	d503205f 	wfe
    b       .Lunsupported_cpu_trap
ffffffffea8002ec:	17ffffff 	b	ffffffffea8002e8 <_start+0x2e8>
ffffffffea8002f0:	00000400 	.word	0x00000400
ffffffffea8002f4:	00600000 	.word	0x00600000
ffffffffea8002f8:	00000404 	.word	0x00000404
ffffffffea8002fc:	00600000 	.word	0x00600000
ffffffffea800300:	00000788 	.word	0x00000788
ffffffffea800304:	00400000 	.word	0x00400000
ffffffffea800308:	ea815000 	.word	0xea815000
ffffffffea80030c:	ffffffff 	.word	0xffffffff
ffffffffea800310:	ea818000 	.word	0xea818000
ffffffffea800314:	ffffffff 	.word	0xffffffff
ffffffffea800318:	00000708 	.word	0x00000708
ffffffffea80031c:	00600000 	.word	0x00600000
ffffffffea800320:	ea85d128 	.word	0xea85d128
ffffffffea800324:	ffffffff 	.word	0xffffffff
ffffffffea800328:	ea800180 	.word	0xea800180
ffffffffea80032c:	ffffffff 	.word	0xffffffff
ffffffffea800330:	00000709 	.word	0x00000709
ffffffffea800334:	00000000 	.word	0x00000000
ffffffffea800338:	00ff0400 	.word	0x00ff0400
ffffffffea80033c:	00000000 	.word	0x00000000
ffffffffea800340:	b5233519 	.word	0xb5233519
ffffffffea800344:	00000002 	.word	0x00000002
ffffffffea800348:	ea800270 	.word	0xea800270
ffffffffea80034c:	ffffffff 	.word	0xffffffff
ffffffffea800350:	b52335a7 	.word	0xb52335a7
ffffffffea800354:	00000002 	.word	0x00000002
ffffffffea800358:	ea857000 	.word	0xea857000
ffffffffea80035c:	ffffffff 	.word	0xffffffff
ffffffffea800360:	ea857000 	.word	0xea857000
ffffffffea800364:	ffffffff 	.word	0xffffffff
ffffffffea800368:	ea85d128 	.word	0xea85d128
ffffffffea80036c:	ffffffff 	.word	0xffffffff
	...

ffffffffea801000 <arm64_exception_base>:

FUNCTION(arm64_exception_base)

/* exceptions from current EL, using SP0 */
LOCAL_FUNCTION(arm64_sync_exc_current_el_SP0)
    invalid_exception 0
ffffffffea801000:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801004:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801008:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80100c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801010:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801014:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801018:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80101c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801020:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801024:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801028:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80102c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801030:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801034:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801038:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80103c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801040:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801044:	d5384021 	mrs	x1, elr_el1
ffffffffea801048:	d5384002 	mrs	x2, spsr_el1
ffffffffea80104c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801050:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea801054:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea801058:	910003e0 	mov	x0, sp
ffffffffea80105c:	940007a9 	bl	ffffffffea802f00 <arm64_invalid_exception>
ffffffffea801060:	14000000 	b	ffffffffea801060 <arm64_exception_base+0x60>
	...

ffffffffea801080 <arm64_irq_current_el_SP0>:

.org 0x080
LOCAL_FUNCTION(arm64_irq_current_el_SP0)
    invalid_exception 1
ffffffffea801080:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801084:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801088:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80108c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801090:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801094:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801098:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80109c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8010a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8010a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8010a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8010ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8010b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8010b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8010b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8010bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8010c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8010c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8010c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8010cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8010d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8010d4:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8010d8:	910003e0 	mov	x0, sp
ffffffffea8010dc:	94000789 	bl	ffffffffea802f00 <arm64_invalid_exception>
ffffffffea8010e0:	14000000 	b	ffffffffea8010e0 <arm64_irq_current_el_SP0+0x60>
	...

ffffffffea801100 <arm64_fiq_current_el_SP0>:

.org 0x100
LOCAL_FUNCTION(arm64_fiq_current_el_SP0)
    invalid_exception 2
ffffffffea801100:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801104:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801108:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80110c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801110:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801114:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801118:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80111c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801120:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801124:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801128:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80112c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801130:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801134:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801138:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80113c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801140:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801144:	d5384021 	mrs	x1, elr_el1
ffffffffea801148:	d5384002 	mrs	x2, spsr_el1
ffffffffea80114c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801150:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea801154:	d2800041 	mov	x1, #0x2                   	// #2
ffffffffea801158:	910003e0 	mov	x0, sp
ffffffffea80115c:	94000769 	bl	ffffffffea802f00 <arm64_invalid_exception>
ffffffffea801160:	14000000 	b	ffffffffea801160 <arm64_fiq_current_el_SP0+0x60>
	...

ffffffffea801180 <arm64_err_exc_current_el_SP0>:

.org 0x180
LOCAL_FUNCTION(arm64_err_exc_current_el_SP0)
    invalid_exception 3
ffffffffea801180:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801184:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801188:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80118c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801190:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801194:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801198:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80119c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8011a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8011a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8011a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8011ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8011b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8011b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8011b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8011bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8011c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8011c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8011c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8011cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8011d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8011d4:	d2800061 	mov	x1, #0x3                   	// #3
ffffffffea8011d8:	910003e0 	mov	x0, sp
ffffffffea8011dc:	94000749 	bl	ffffffffea802f00 <arm64_invalid_exception>
ffffffffea8011e0:	14000000 	b	ffffffffea8011e0 <arm64_err_exc_current_el_SP0+0x60>
	...

ffffffffea801200 <arm64_sync_exc_current_el_SPx>:

/* exceptions from current EL, using SPx */
.org 0x200
LOCAL_FUNCTION(arm64_sync_exc_current_el_SPx)
    regsave_long
ffffffffea801200:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801204:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801208:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80120c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801210:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801214:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801218:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80121c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801220:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801224:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801228:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80122c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801230:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801234:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801238:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80123c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801240:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801244:	d5384021 	mrs	x1, elr_el1
ffffffffea801248:	d5384002 	mrs	x2, spsr_el1
ffffffffea80124c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801250:	a9100be1 	stp	x1, x2, [sp, #256]
    mov x0, sp
ffffffffea801254:	910003e0 	mov	x0, sp
    bl  arm64_sync_exception
ffffffffea801258:	940006d0 	bl	ffffffffea802d98 <arm64_sync_exception>
    b  arm64_exc_shared_restore_long
ffffffffea80125c:	14000162 	b	ffffffffea8017e4 <arm64_exc_shared_restore_long>
	...

ffffffffea801280 <arm64_irq_current_el_SPx>:

.org 0x280
LOCAL_FUNCTION(arm64_irq_current_el_SPx)
    irq_exception
ffffffffea801280:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801284:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801288:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea80128c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801290:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea801294:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801298:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea80129c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8012a0:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8012a4:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8012a8:	910243e0 	add	x0, sp, #0x90
ffffffffea8012ac:	d5384021 	mrs	x1, elr_el1
ffffffffea8012b0:	d5384002 	mrs	x2, spsr_el1
ffffffffea8012b4:	a90903fe 	stp	x30, x0, [sp, #144]
ffffffffea8012b8:	a90a0be1 	stp	x1, x2, [sp, #160]
ffffffffea8012bc:	d50341ff 	msr	daifclr, #0x1
ffffffffea8012c0:	910003e0 	mov	x0, sp
ffffffffea8012c4:	94000d77 	bl	ffffffffea8048a0 <platform_irq>
ffffffffea8012c8:	b4000040 	cbz	x0, ffffffffea8012d0 <arm64_irq_current_el_SPx+0x50>
ffffffffea8012cc:	94001433 	bl	ffffffffea806398 <thread_preempt>
ffffffffea8012d0:	d50341df 	msr	daifset, #0x1
ffffffffea8012d4:	1400015b 	b	ffffffffea801840 <arm64_exc_shared_restore_short>
	...

ffffffffea801300 <arm64_fiq_current_el_SPx>:

.org 0x300
LOCAL_FUNCTION(arm64_fiq_current_el_SPx)
    regsave_short
ffffffffea801300:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801304:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801308:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea80130c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801310:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea801314:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801318:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea80131c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801320:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea801324:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801328:	910243e0 	add	x0, sp, #0x90
ffffffffea80132c:	d5384021 	mrs	x1, elr_el1
ffffffffea801330:	d5384002 	mrs	x2, spsr_el1
ffffffffea801334:	a90903fe 	stp	x30, x0, [sp, #144]
ffffffffea801338:	a90a0be1 	stp	x1, x2, [sp, #160]
    mov x0, sp
ffffffffea80133c:	910003e0 	mov	x0, sp
    bl  platform_fiq
ffffffffea801340:	94000dbe 	bl	ffffffffea804a38 <platform_fiq>
    b  arm64_exc_shared_restore_short
ffffffffea801344:	1400013f 	b	ffffffffea801840 <arm64_exc_shared_restore_short>
	...

ffffffffea801380 <arm64_err_exc_current_el_SPx>:

.org 0x380
LOCAL_FUNCTION(arm64_err_exc_current_el_SPx)
    invalid_exception 0x13
ffffffffea801380:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801384:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801388:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80138c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801390:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801394:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801398:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80139c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8013a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8013a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8013a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8013ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8013b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8013b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8013b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8013bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8013c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8013c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8013c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8013cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8013d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8013d4:	d2800261 	mov	x1, #0x13                  	// #19
ffffffffea8013d8:	910003e0 	mov	x0, sp
ffffffffea8013dc:	940006c9 	bl	ffffffffea802f00 <arm64_invalid_exception>
ffffffffea8013e0:	14000000 	b	ffffffffea8013e0 <arm64_err_exc_current_el_SPx+0x60>
	...

ffffffffea801400 <arm64_sync_exc_lower_el_64>:

/* exceptions from lower EL, running arm64 */
.org 0x400
LOCAL_FUNCTION(arm64_sync_exc_lower_el_64)
    invalid_exception 0x20
ffffffffea801400:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801404:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801408:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80140c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801410:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801414:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801418:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80141c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801420:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801424:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801428:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80142c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801430:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801434:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801438:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80143c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801440:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801444:	d5384021 	mrs	x1, elr_el1
ffffffffea801448:	d5384002 	mrs	x2, spsr_el1
ffffffffea80144c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801450:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea801454:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea801458:	910003e0 	mov	x0, sp
ffffffffea80145c:	940006a9 	bl	ffffffffea802f00 <arm64_invalid_exception>
ffffffffea801460:	14000000 	b	ffffffffea801460 <arm64_sync_exc_lower_el_64+0x60>
	...

ffffffffea801480 <arm64_irq_lower_el_64>:

.org 0x480
LOCAL_FUNCTION(arm64_irq_lower_el_64)
    invalid_exception 0x21
ffffffffea801480:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801484:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801488:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80148c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801490:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801494:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801498:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80149c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8014a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8014a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8014a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8014ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8014b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8014b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8014b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8014bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8014c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8014c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8014c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8014cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8014d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8014d4:	d2800421 	mov	x1, #0x21                  	// #33
ffffffffea8014d8:	910003e0 	mov	x0, sp
ffffffffea8014dc:	94000689 	bl	ffffffffea802f00 <arm64_invalid_exception>
ffffffffea8014e0:	14000000 	b	ffffffffea8014e0 <arm64_irq_lower_el_64+0x60>
	...

ffffffffea801500 <arm64_fiq_lower_el_64>:

.org 0x500
LOCAL_FUNCTION(arm64_fiq_lower_el_64)
    invalid_exception 0x22
ffffffffea801500:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801504:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801508:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80150c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801510:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801514:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801518:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80151c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801520:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801524:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801528:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80152c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801530:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801534:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801538:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80153c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801540:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801544:	d5384021 	mrs	x1, elr_el1
ffffffffea801548:	d5384002 	mrs	x2, spsr_el1
ffffffffea80154c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801550:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea801554:	d2800441 	mov	x1, #0x22                  	// #34
ffffffffea801558:	910003e0 	mov	x0, sp
ffffffffea80155c:	94000669 	bl	ffffffffea802f00 <arm64_invalid_exception>
ffffffffea801560:	14000000 	b	ffffffffea801560 <arm64_fiq_lower_el_64+0x60>
	...

ffffffffea801580 <arm64_err_exc_lower_el_64>:

.org 0x580
LOCAL_FUNCTION(arm64_err_exc_lower_el_64)
    invalid_exception 0x23
ffffffffea801580:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801584:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801588:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80158c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801590:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801594:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801598:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80159c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8015a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8015a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8015a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8015ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8015b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8015b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8015b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8015bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8015c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8015c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8015c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8015cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8015d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8015d4:	d2800461 	mov	x1, #0x23                  	// #35
ffffffffea8015d8:	910003e0 	mov	x0, sp
ffffffffea8015dc:	94000649 	bl	ffffffffea802f00 <arm64_invalid_exception>
ffffffffea8015e0:	14000000 	b	ffffffffea8015e0 <arm64_err_exc_lower_el_64+0x60>
	...

ffffffffea801600 <arm64_sync_exc_lower_el_32>:

/* exceptions from lower EL, running arm32 */
.org 0x600
LOCAL_FUNCTION(arm64_sync_exc_lower_el_32)
    regsave_long
ffffffffea801600:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801604:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801608:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80160c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801610:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801614:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801618:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80161c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801620:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801624:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801628:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80162c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801630:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801634:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801638:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80163c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801640:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801644:	d5384021 	mrs	x1, elr_el1
ffffffffea801648:	d5384002 	mrs	x2, spsr_el1
ffffffffea80164c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801650:	a9100be1 	stp	x1, x2, [sp, #256]
    mov x0, sp
ffffffffea801654:	910003e0 	mov	x0, sp
    bl  arm64_sync_exception
ffffffffea801658:	940005d0 	bl	ffffffffea802d98 <arm64_sync_exception>
    b  arm64_exc_shared_restore_long
ffffffffea80165c:	14000062 	b	ffffffffea8017e4 <arm64_exc_shared_restore_long>
	...

ffffffffea801680 <arm64_irq_lower_el_32>:

.org 0x680
LOCAL_FUNCTION(arm64_irq_lower_el_32)
    irq_exception
ffffffffea801680:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801684:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801688:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea80168c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801690:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea801694:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801698:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea80169c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8016a0:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8016a4:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8016a8:	910243e0 	add	x0, sp, #0x90
ffffffffea8016ac:	d5384021 	mrs	x1, elr_el1
ffffffffea8016b0:	d5384002 	mrs	x2, spsr_el1
ffffffffea8016b4:	a90903fe 	stp	x30, x0, [sp, #144]
ffffffffea8016b8:	a90a0be1 	stp	x1, x2, [sp, #160]
ffffffffea8016bc:	d50341ff 	msr	daifclr, #0x1
ffffffffea8016c0:	910003e0 	mov	x0, sp
ffffffffea8016c4:	94000c77 	bl	ffffffffea8048a0 <platform_irq>
ffffffffea8016c8:	b4000040 	cbz	x0, ffffffffea8016d0 <arm64_irq_lower_el_32+0x50>
ffffffffea8016cc:	94001333 	bl	ffffffffea806398 <thread_preempt>
ffffffffea8016d0:	d50341df 	msr	daifset, #0x1
ffffffffea8016d4:	1400005b 	b	ffffffffea801840 <arm64_exc_shared_restore_short>
	...

ffffffffea801700 <arm64_fiq_lower_el_32>:

.org 0x700
LOCAL_FUNCTION(arm64_fiq_lower_el_32)
    regsave_short
ffffffffea801700:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801704:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801708:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea80170c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801710:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea801714:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801718:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea80171c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801720:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea801724:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801728:	910243e0 	add	x0, sp, #0x90
ffffffffea80172c:	d5384021 	mrs	x1, elr_el1
ffffffffea801730:	d5384002 	mrs	x2, spsr_el1
ffffffffea801734:	a90903fe 	stp	x30, x0, [sp, #144]
ffffffffea801738:	a90a0be1 	stp	x1, x2, [sp, #160]
    mov x0, sp
ffffffffea80173c:	910003e0 	mov	x0, sp
    bl  platform_fiq
ffffffffea801740:	94000cbe 	bl	ffffffffea804a38 <platform_fiq>
    b  arm64_exc_shared_restore_short
ffffffffea801744:	1400003f 	b	ffffffffea801840 <arm64_exc_shared_restore_short>
	...

ffffffffea801780 <arm64_err_exc_lower_el_32>:

.org 0x780
LOCAL_FUNCTION(arm64_err_exc_lower_el_32)
    invalid_exception 0x33
ffffffffea801780:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801784:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801788:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80178c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801790:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801794:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801798:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80179c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8017a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8017a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8017a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8017ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8017b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8017b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8017b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8017bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8017c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8017c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8017c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8017cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8017d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8017d4:	d2800661 	mov	x1, #0x33                  	// #51
ffffffffea8017d8:	910003e0 	mov	x0, sp
ffffffffea8017dc:	940005c9 	bl	ffffffffea802f00 <arm64_invalid_exception>
ffffffffea8017e0:	14000000 	b	ffffffffea8017e0 <arm64_err_exc_lower_el_32+0x60>

ffffffffea8017e4 <arm64_exc_shared_restore_long>:

LOCAL_FUNCTION(arm64_exc_shared_restore_long)
    regrestore_long
ffffffffea8017e4:	f9407bfe 	ldr	x30, [sp, #240]
ffffffffea8017e8:	a9500be1 	ldp	x1, x2, [sp, #256]
ffffffffea8017ec:	d5184021 	msr	elr_el1, x1
ffffffffea8017f0:	d5184002 	msr	spsr_el1, x2
ffffffffea8017f4:	a8c107e0 	ldp	x0, x1, [sp], #16
ffffffffea8017f8:	a8c10fe2 	ldp	x2, x3, [sp], #16
ffffffffea8017fc:	a8c117e4 	ldp	x4, x5, [sp], #16
ffffffffea801800:	a8c11fe6 	ldp	x6, x7, [sp], #16
ffffffffea801804:	a8c127e8 	ldp	x8, x9, [sp], #16
ffffffffea801808:	a8c12fea 	ldp	x10, x11, [sp], #16
ffffffffea80180c:	a8c137ec 	ldp	x12, x13, [sp], #16
ffffffffea801810:	a8c13fee 	ldp	x14, x15, [sp], #16
ffffffffea801814:	a8c147f0 	ldp	x16, x17, [sp], #16
ffffffffea801818:	a8c14ff2 	ldp	x18, x19, [sp], #16
ffffffffea80181c:	a8c157f4 	ldp	x20, x21, [sp], #16
ffffffffea801820:	a8c15ff6 	ldp	x22, x23, [sp], #16
ffffffffea801824:	a8c167f8 	ldp	x24, x25, [sp], #16
ffffffffea801828:	a8c16ffa 	ldp	x26, x27, [sp], #16
ffffffffea80182c:	a8c177fc 	ldp	x28, x29, [sp], #16
ffffffffea801830:	910083ff 	add	sp, sp, #0x20
    exception_return
ffffffffea801834:	d69f03e0 	eret
ffffffffea801838:	d503379f 	dsb	nsh
ffffffffea80183c:	d5033fdf 	isb

ffffffffea801840 <arm64_exc_shared_restore_short>:

LOCAL_FUNCTION(arm64_exc_shared_restore_short)
       regrestore_short
ffffffffea801840:	f9404bfe 	ldr	x30, [sp, #144]
ffffffffea801844:	a94a0be1 	ldp	x1, x2, [sp, #160]
ffffffffea801848:	d5184021 	msr	elr_el1, x1
ffffffffea80184c:	d5184002 	msr	spsr_el1, x2
ffffffffea801850:	a8c107e0 	ldp	x0, x1, [sp], #16
ffffffffea801854:	a8c10fe2 	ldp	x2, x3, [sp], #16
ffffffffea801858:	a8c117e4 	ldp	x4, x5, [sp], #16
ffffffffea80185c:	a8c11fe6 	ldp	x6, x7, [sp], #16
ffffffffea801860:	a8c127e8 	ldp	x8, x9, [sp], #16
ffffffffea801864:	a8c12fea 	ldp	x10, x11, [sp], #16
ffffffffea801868:	a8c137ec 	ldp	x12, x13, [sp], #16
ffffffffea80186c:	a8c13fee 	ldp	x14, x15, [sp], #16
ffffffffea801870:	a8c147f0 	ldp	x16, x17, [sp], #16
ffffffffea801874:	910083ff 	add	sp, sp, #0x20
       exception_return
ffffffffea801878:	d69f03e0 	eret
ffffffffea80187c:	d503379f 	dsb	nsh
ffffffffea801880:	d5033fdf 	isb
ffffffffea801884:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801888 <platform_secondary_init>:
#if WITH_SMP

static void platform_secondary_init(uint level)
{
	// DEBUG_TX2: Modified here to identify changes in bootlogs
	platform_init_secure_port(uart_c);
ffffffffea801888:	f00000a0 	adrp	x0, ffffffffea818000 <_mem_phys_base>
ffffffffea80188c:	b9418000 	ldr	w0, [x0, #384]
ffffffffea801890:	140003fa 	b	ffffffffea802878 <platform_init_secure_port>
ffffffffea801894:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801898 <platform_prevent_ssb>:
 * by disabling memory disambiguation and speculative store buffering in
 * S-EL1 and S-EL0.
 *
 * This mitigation is only ran on Denver and Carmel (DENVER_PN4) cpus.
 */
static void platform_prevent_ssb(uint level) {
ffffffffea801898:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80189c:	910003fd 	mov	x29, sp
ffffffffea8018a0:	f9000bf3 	str	x19, [sp, #16]
	uint64_t midr = ARM64_READ_SYSREG(midr_el1);
ffffffffea8018a4:	d5380013 	mrs	x19, midr_el1
	uint64_t actlr = 0;
	uint64_t mask = 0;

	/* Only apply workaround on Denver cores */
	if (!platform_is_denver_cpu())
ffffffffea8018a8:	940002d4 	bl	ffffffffea8023f8 <platform_is_denver_cpu>
ffffffffea8018ac:	72001c1f 	tst	w0, #0xff
ffffffffea8018b0:	54000260 	b.eq	ffffffffea8018fc <platform_prevent_ssb+0x64>  // b.none
	/*
	 * Denver CPUs with DENVER_MIDR_PN3 or earlier, use different
	 * bits in the ACTLR_EL1/ACTLR_EL0 registers to disable
	 * speculative store buffer and memory disambiguation.
	 */
	switch(midr) {
ffffffffea8018b4:	d2800400 	mov	x0, #0x20                  	// #32
ffffffffea8018b8:	f2a9c1e0 	movk	x0, #0x4e0f, lsl #16
ffffffffea8018bc:	eb00027f 	cmp	x19, x0
ffffffffea8018c0:	54000680 	b.eq	ffffffffea801990 <platform_prevent_ssb+0xf8>  // b.none
ffffffffea8018c4:	54000229 	b.ls	ffffffffea801908 <platform_prevent_ssb+0x70>  // b.plast
ffffffffea8018c8:	d2800600 	mov	x0, #0x30                  	// #48
ffffffffea8018cc:	f2a9c1e0 	movk	x0, #0x4e0f, lsl #16
ffffffffea8018d0:	eb00027f 	cmp	x19, x0
ffffffffea8018d4:	540005e0 	b.eq	ffffffffea801990 <platform_prevent_ssb+0xf8>  // b.none
ffffffffea8018d8:	d2800801 	mov	x1, #0x40                  	// #64
		mask = DENVER_CPU_DIS_MD_EL0 | DENVER_CPU_DIS_MD_EL1
			| DENVER_CPU_DIS_SSB_EL0 | DENVER_CPU_DIS_SSB_EL1;
		break;

	case DENVER_MIDR_PN4:
		mask = DENVER_PN4_CPU_DIS_MD_EL0 | DENVER_PN4_CPU_DIS_MD_EL1
ffffffffea8018dc:	d2807800 	mov	x0, #0x3c0                 	// #960
	switch(midr) {
ffffffffea8018e0:	f2a9c1e1 	movk	x1, #0x4e0f, lsl #16
ffffffffea8018e4:	eb01027f 	cmp	x19, x1
ffffffffea8018e8:	540001c1 	b.ne	ffffffffea801920 <platform_prevent_ssb+0x88>  // b.any
			__func__, plat_arch_curr_cpu_num(), midr);
		break;
	}

	/* update actlr_el1 */
	actlr = ARM64_READ_SYSREG(actlr_el1);
ffffffffea8018ec:	d5381021 	mrs	x1, actlr_el1
	actlr |= mask;
ffffffffea8018f0:	aa010000 	orr	x0, x0, x1
	ARM64_WRITE_SYSREG(actlr_el1, actlr);
ffffffffea8018f4:	d5181020 	msr	actlr_el1, x0
ffffffffea8018f8:	d5033fdf 	isb
}
ffffffffea8018fc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801900:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea801904:	d65f03c0 	ret
	switch(midr) {
ffffffffea801908:	d2a9c1e0 	mov	x0, #0x4e0f0000            	// #1309605888
ffffffffea80190c:	eb00027f 	cmp	x19, x0
ffffffffea801910:	54000400 	b.eq	ffffffffea801990 <platform_prevent_ssb+0xf8>  // b.none
ffffffffea801914:	91004000 	add	x0, x0, #0x10
ffffffffea801918:	eb00027f 	cmp	x19, x0
ffffffffea80191c:	540003a0 	b.eq	ffffffffea801990 <platform_prevent_ssb+0xf8>  // b.none
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801920:	d53800a1 	mrs	x1, mpidr_el1
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea801924:	d53800a0 	mrs	x0, mpidr_el1
	if (boot_cpu == 0xFF)
ffffffffea801928:	f00000a3 	adrp	x3, ffffffffea818000 <_mem_phys_base>
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea80192c:	d348fc00 	lsr	x0, x0, #8
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801930:	12001c21 	and	w1, w1, #0xff
	if (boot_cpu == 0xFF)
ffffffffea801934:	b9400c62 	ldr	w2, [x3, #12]
	uint curr_cpu_num = (cpu_num + (cluster_num << 2));
ffffffffea801938:	0b200820 	add	w0, w1, w0, uxtb #2
	if (boot_cpu == 0xFF)
ffffffffea80193c:	7103fc5f 	cmp	w2, #0xff
ffffffffea801940:	54000061 	b.ne	ffffffffea80194c <platform_prevent_ssb+0xb4>  // b.any
		boot_cpu = curr_cpu_num;
ffffffffea801944:	2a0003e2 	mov	w2, w0
ffffffffea801948:	b9000c60 	str	w0, [x3, #12]
	if (boot_cpu == A57_0)
ffffffffea80194c:	7100105f 	cmp	w2, #0x4
ffffffffea801950:	540002c0 	b.eq	ffffffffea8019a8 <platform_prevent_ssb+0x110>  // b.none
		return denver_boot_map[curr_cpu_num];
ffffffffea801954:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801958:	9101a021 	add	x1, x1, #0x68
ffffffffea80195c:	b8607822 	ldr	w2, [x1, x0, lsl #2]
		dprintf(CRITICAL, "%s: unable to apply cve_2018_3639 TZ"
ffffffffea801960:	aa1303e3 	mov	x3, x19
ffffffffea801964:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801968:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80196c:	9100c021 	add	x1, x1, #0x30
ffffffffea801970:	91036000 	add	x0, x0, #0xd8
ffffffffea801974:	94003fa7 	bl	ffffffffea811810 <_dprintf>
	uint64_t mask = 0;
ffffffffea801978:	d2800000 	mov	x0, #0x0                   	// #0
	actlr = ARM64_READ_SYSREG(actlr_el1);
ffffffffea80197c:	d5381021 	mrs	x1, actlr_el1
	actlr |= mask;
ffffffffea801980:	aa010000 	orr	x0, x0, x1
	ARM64_WRITE_SYSREG(actlr_el1, actlr);
ffffffffea801984:	d5181020 	msr	actlr_el1, x0
ffffffffea801988:	d5033fdf 	isb
ffffffffea80198c:	17ffffdc 	b	ffffffffea8018fc <platform_prevent_ssb+0x64>
		mask = DENVER_CPU_DIS_MD_EL0 | DENVER_CPU_DIS_MD_EL1
ffffffffea801990:	d283c000 	mov	x0, #0x1e00                	// #7680
	actlr = ARM64_READ_SYSREG(actlr_el1);
ffffffffea801994:	d5381021 	mrs	x1, actlr_el1
	actlr |= mask;
ffffffffea801998:	aa010000 	orr	x0, x0, x1
	ARM64_WRITE_SYSREG(actlr_el1, actlr);
ffffffffea80199c:	d5181020 	msr	actlr_el1, x0
ffffffffea8019a0:	d5033fdf 	isb
ffffffffea8019a4:	17ffffd6 	b	ffffffffea8018fc <platform_prevent_ssb+0x64>
		return a57_boot_map[curr_cpu_num];
ffffffffea8019a8:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8019ac:	91012021 	add	x1, x1, #0x48
ffffffffea8019b0:	b8607822 	ldr	w2, [x1, x0, lsl #2]
ffffffffea8019b4:	17ffffeb 	b	ffffffffea801960 <platform_prevent_ssb+0xc8>

ffffffffea8019b8 <plat_arch_curr_cpu_num>:
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea8019b8:	d53800a1 	mrs	x1, mpidr_el1
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea8019bc:	d53800a0 	mrs	x0, mpidr_el1
	if (boot_cpu == 0xFF)
ffffffffea8019c0:	f00000a3 	adrp	x3, ffffffffea818000 <_mem_phys_base>
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea8019c4:	d348fc00 	lsr	x0, x0, #8
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea8019c8:	12001c21 	and	w1, w1, #0xff
	if (boot_cpu == 0xFF)
ffffffffea8019cc:	b9400c62 	ldr	w2, [x3, #12]
	uint curr_cpu_num = (cpu_num + (cluster_num << 2));
ffffffffea8019d0:	0b200820 	add	w0, w1, w0, uxtb #2
	if (boot_cpu == 0xFF)
ffffffffea8019d4:	7103fc5f 	cmp	w2, #0xff
ffffffffea8019d8:	54000061 	b.ne	ffffffffea8019e4 <plat_arch_curr_cpu_num+0x2c>  // b.any
		boot_cpu = curr_cpu_num;
ffffffffea8019dc:	2a0003e2 	mov	w2, w0
ffffffffea8019e0:	b9000c60 	str	w0, [x3, #12]
	if (boot_cpu == A57_0)
ffffffffea8019e4:	7100105f 	cmp	w2, #0x4
ffffffffea8019e8:	540000a0 	b.eq	ffffffffea8019fc <plat_arch_curr_cpu_num+0x44>  // b.none
		return denver_boot_map[curr_cpu_num];
ffffffffea8019ec:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8019f0:	9101a021 	add	x1, x1, #0x68
ffffffffea8019f4:	b8607820 	ldr	w0, [x1, x0, lsl #2]
}
ffffffffea8019f8:	d65f03c0 	ret
		return a57_boot_map[curr_cpu_num];
ffffffffea8019fc:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801a00:	91012021 	add	x1, x1, #0x48
ffffffffea801a04:	b8607820 	ldr	w0, [x1, x0, lsl #2]
}
ffffffffea801a08:	d65f03c0 	ret
ffffffffea801a0c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801a10 <arch_sync_cache_range>:
}
ffffffffea801a10:	d65f03c0 	ret
ffffffffea801a14:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801a18 <platform_app_bootloader_epilog>:
{
ffffffffea801a18:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	asm volatile (
ffffffffea801a1c:	529fe172 	mov	w18, #0xff0b                	// #65291
ffffffffea801a20:	72b05ff2 	movk	w18, #0x82ff, lsl #16
{
ffffffffea801a24:	910003fd 	mov	x29, sp
	asm volatile (
ffffffffea801a28:	910043be 	add	x30, x29, #0x10
ffffffffea801a2c:	aa1203e0 	mov	x0, x18
ffffffffea801a30:	a9400bc1 	ldp	x1, x2, [x30]
ffffffffea801a34:	a94113c3 	ldp	x3, x4, [x30, #16]
ffffffffea801a38:	a9421bc5 	ldp	x5, x6, [x30, #32]
ffffffffea801a3c:	d5033fdf 	isb
ffffffffea801a40:	d4000003 	smc	#0x0
ffffffffea801a44:	aa0003f2 	mov	x18, x0
ffffffffea801a48:	a90007c0 	stp	x0, x1, [x30]
ffffffffea801a4c:	a9010fc2 	stp	x2, x3, [x30, #16]
}
ffffffffea801a50:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea801a54:	d65f03c0 	ret

ffffffffea801a58 <platform_early_init>:
	arm_generic_timer_init(ARM_GENERIC_TIMER_INT, 0);
ffffffffea801a58:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea801a5c:	528003a0 	mov	w0, #0x1d                  	// #29
ffffffffea801a60:	14000e64 	b	ffffffffea8053f0 <arm_generic_timer_init>
ffffffffea801a64:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801a68 <platform_init>:
{
ffffffffea801a68:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea801a6c:	910003fd 	mov	x29, sp
ffffffffea801a70:	f9000bf3 	str	x19, [sp, #16]
ffffffffea801a74:	aa1e03f3 	mov	x19, x30
	if ((err = process_boot_params()) != NO_ERROR) {
ffffffffea801a78:	940000b4 	bl	ffffffffea801d48 <process_boot_params>
ffffffffea801a7c:	35000120 	cbnz	w0, ffffffffea801aa0 <platform_init+0x38>
	platform_init_debug_port(debug_uart_id);
ffffffffea801a80:	f00000a0 	adrp	x0, ffffffffea818000 <_mem_phys_base>
ffffffffea801a84:	b9401000 	ldr	w0, [x0, #16]
ffffffffea801a88:	940001ae 	bl	ffffffffea802140 <platform_init_debug_port>
}
ffffffffea801a8c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801a90:	a8c27bfd 	ldp	x29, x30, [sp], #32
	dprintf(0, "Check if it is working or not\n");
ffffffffea801a94:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801a98:	9102e000 	add	x0, x0, #0xb8
ffffffffea801a9c:	14003f5d 	b	ffffffffea811810 <_dprintf>
		panic("Fatal error: Failed to process boot params\n");
ffffffffea801aa0:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801aa4:	aa1303e0 	mov	x0, x19
ffffffffea801aa8:	91022021 	add	x1, x1, #0x88
ffffffffea801aac:	94003fd7 	bl	ffffffffea811a08 <_panic>

ffffffffea801ab0 <platform_init_mmu_mappings>:
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801ab0:	d53800a1 	mrs	x1, mpidr_el1
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea801ab4:	d53800a0 	mrs	x0, mpidr_el1
	if (boot_cpu == 0xFF)
ffffffffea801ab8:	f00000a3 	adrp	x3, ffffffffea818000 <_mem_phys_base>
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea801abc:	d348fc00 	lsr	x0, x0, #8
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801ac0:	12001c21 	and	w1, w1, #0xff
	if (boot_cpu == 0xFF)
ffffffffea801ac4:	b9400c62 	ldr	w2, [x3, #12]
	uint curr_cpu_num = (cpu_num + (cluster_num << 2));
ffffffffea801ac8:	0b200820 	add	w0, w1, w0, uxtb #2
	if (boot_cpu == 0xFF)
ffffffffea801acc:	7103fc5f 	cmp	w2, #0xff
ffffffffea801ad0:	54000061 	b.ne	ffffffffea801adc <platform_init_mmu_mappings+0x2c>  // b.any
		boot_cpu = curr_cpu_num;
ffffffffea801ad4:	2a0003e2 	mov	w2, w0
ffffffffea801ad8:	b9000c60 	str	w0, [x3, #12]
	if (boot_cpu == A57_0)
ffffffffea801adc:	7100105f 	cmp	w2, #0x4
ffffffffea801ae0:	540003e0 	b.eq	ffffffffea801b5c <platform_init_mmu_mappings+0xac>  // b.none
		return denver_boot_map[curr_cpu_num];
ffffffffea801ae4:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801ae8:	9101a021 	add	x1, x1, #0x68
ffffffffea801aec:	b8607820 	ldr	w0, [x1, x0, lsl #2]
	if (plat_arch_curr_cpu_num() == 0) {
ffffffffea801af0:	35000340 	cbnz	w0, ffffffffea801b58 <platform_init_mmu_mappings+0xa8>
{
ffffffffea801af4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea801af8:	910003fd 	mov	x29, sp
ffffffffea801afc:	a9025bf5 	stp	x21, x22, [sp, #32]
			if (strcmp(m->name, ram_arena.name) == 0) {
ffffffffea801b00:	f00000b6 	adrp	x22, ffffffffea818000 <_mem_phys_base>
ffffffffea801b04:	9104c2c0 	add	x0, x22, #0x130
{
ffffffffea801b08:	a90153f3 	stp	x19, x20, [sp, #16]
		struct mmu_initial_mapping *m = mmu_initial_mappings;
ffffffffea801b0c:	f00000b3 	adrp	x19, ffffffffea818000 <_mem_phys_base>
ffffffffea801b10:	91006273 	add	x19, x19, #0x18
		for (uint i = 0; i < countof(mmu_initial_mappings); i++, m++) {
ffffffffea801b14:	91046275 	add	x21, x19, #0x118
			if (strcmp(m->name, ram_arena.name) == 0) {
ffffffffea801b18:	f9400814 	ldr	x20, [x0, #16]
ffffffffea801b1c:	d503201f 	nop
			if (!(m->flags & MMU_INITIAL_MAPPING_FLAG_DYNAMIC))
ffffffffea801b20:	b9401a60 	ldr	w0, [x19, #24]
			if (strcmp(m->name, ram_arena.name) == 0) {
ffffffffea801b24:	aa1403e1 	mov	x1, x20
			if (!(m->flags & MMU_INITIAL_MAPPING_FLAG_DYNAMIC))
ffffffffea801b28:	36180080 	tbz	w0, #3, ffffffffea801b38 <platform_init_mmu_mappings+0x88>
			if (strcmp(m->name, ram_arena.name) == 0) {
ffffffffea801b2c:	f9401260 	ldr	x0, [x19, #32]
ffffffffea801b30:	94004638 	bl	ffffffffea813410 <strcmp>
ffffffffea801b34:	340001c0 	cbz	w0, ffffffffea801b6c <platform_init_mmu_mappings+0xbc>
		for (uint i = 0; i < countof(mmu_initial_mappings); i++, m++) {
ffffffffea801b38:	9100a273 	add	x19, x19, #0x28
ffffffffea801b3c:	eb15027f 	cmp	x19, x21
ffffffffea801b40:	54ffff01 	b.ne	ffffffffea801b20 <platform_init_mmu_mappings+0x70>  // b.any
		pmm_add_arena(&ram_arena);
ffffffffea801b44:	9104c2c0 	add	x0, x22, #0x130
}
ffffffffea801b48:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801b4c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801b50:	a8c37bfd 	ldp	x29, x30, [sp], #48
		pmm_add_arena(&ram_arena);
ffffffffea801b54:	14003a7d 	b	ffffffffea810548 <pmm_add_arena>
ffffffffea801b58:	d65f03c0 	ret
		return a57_boot_map[curr_cpu_num];
ffffffffea801b5c:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801b60:	91012021 	add	x1, x1, #0x48
ffffffffea801b64:	b8607820 	ldr	w0, [x1, x0, lsl #2]
ffffffffea801b68:	17ffffe2 	b	ffffffffea801af0 <platform_init_mmu_mappings+0x40>
				ram_arena.base = m->phys;
ffffffffea801b6c:	9104c2c0 	add	x0, x22, #0x130
ffffffffea801b70:	f9400261 	ldr	x1, [x19]
				ram_arena.size = m->size;
ffffffffea801b74:	f9400a62 	ldr	x2, [x19, #16]
				ram_arena.flags = PMM_ARENA_FLAG_KMAP;
ffffffffea801b78:	52800025 	mov	w5, #0x1                   	// #1
}
ffffffffea801b7c:	a94153f3 	ldp	x19, x20, [sp, #16]
				ram_arena.flags = PMM_ARENA_FLAG_KMAP;
ffffffffea801b80:	b9001805 	str	w5, [x0, #24]
				ram_arena.size = m->size;
ffffffffea801b84:	a9020801 	stp	x1, x2, [x0, #32]
		pmm_add_arena(&ram_arena);
ffffffffea801b88:	9104c2c0 	add	x0, x22, #0x130
}
ffffffffea801b8c:	a9425bf5 	ldp	x21, x22, [sp, #32]
				_mem_size = m->size;
ffffffffea801b90:	f00000a4 	adrp	x4, ffffffffea818000 <_mem_phys_base>
}
ffffffffea801b94:	a8c37bfd 	ldp	x29, x30, [sp], #48
				_mem_phys_base = m->phys;
ffffffffea801b98:	f00000a3 	adrp	x3, ffffffffea818000 <_mem_phys_base>
				_mem_size = m->size;
ffffffffea801b9c:	b9000882 	str	w2, [x4, #8]
				_mem_phys_base = m->phys;
ffffffffea801ba0:	f9000061 	str	x1, [x3]
		pmm_add_arena(&ram_arena);
ffffffffea801ba4:	14003a69 	b	ffffffffea810548 <pmm_add_arena>

ffffffffea801ba8 <comb_uart_putc>:
 * Indicates that we're only sending one byte at a time.
 */
#define MBOX_BYTE_COUNT	(1 << 24)

static void comb_uart_putc(char c)
{
ffffffffea801ba8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea801bac:	910003fd 	mov	x29, sp
ffffffffea801bb0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea801bb4:	12001c13 	and	w19, w0, #0xff
ffffffffea801bb8:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (c == '\n')
		msg |= MBOX_FLUSH;
	while (readl(TEGRA_COMBUART_BASE) & (MBOX_INTR_TRIGGER)) {
		if (timed_out)
			return;
		if (current_time_hires() - start >= TX_TIMEOUT_US) {
ffffffffea801bbc:	d29423f5 	mov	x21, #0xa11f                	// #41247
{
ffffffffea801bc0:	a90363f7 	stp	x23, x24, [sp, #48]
	start = current_time_hires();
ffffffffea801bc4:	94000def 	bl	ffffffffea805380 <current_time_hires>
	uint32_t msg = MBOX_INTR_TRIGGER | MBOX_BYTE_COUNT | (uint8_t)(c & 0xff);
ffffffffea801bc8:	52b02017 	mov	w23, #0x81000000            	// #-2130706432
ffffffffea801bcc:	2a170277 	orr	w23, w19, w23
		msg |= MBOX_FLUSH;
ffffffffea801bd0:	71002a7f 	cmp	w19, #0xa
	start = current_time_hires();
ffffffffea801bd4:	aa0003f6 	mov	x22, x0
	while (readl(TEGRA_COMBUART_BASE) & (MBOX_INTR_TRIGGER)) {
ffffffffea801bd8:	929ffff3 	mov	x19, #0xffffffffffff0000    	// #-65536
		msg |= MBOX_FLUSH;
ffffffffea801bdc:	320602e0 	orr	w0, w23, #0x4000000
ffffffffea801be0:	d00002b8 	adrp	x24, ffffffffea857000 <__bss_start>
ffffffffea801be4:	1a970017 	csel	w23, w0, w23, eq  // eq = none
	while (readl(TEGRA_COMBUART_BASE) & (MBOX_INTR_TRIGGER)) {
ffffffffea801be8:	f2be3813 	movk	x19, #0xf1c0, lsl #16
		if (timed_out)
ffffffffea801bec:	91000314 	add	x20, x24, #0x0
		if (current_time_hires() - start >= TX_TIMEOUT_US) {
ffffffffea801bf0:	f2a000f5 	movk	x21, #0x7, lsl #16
ffffffffea801bf4:	14000007 	b	ffffffffea801c10 <comb_uart_putc+0x68>
		if (timed_out)
ffffffffea801bf8:	39400280 	ldrb	w0, [x20]
ffffffffea801bfc:	35000120 	cbnz	w0, ffffffffea801c20 <comb_uart_putc+0x78>
		if (current_time_hires() - start >= TX_TIMEOUT_US) {
ffffffffea801c00:	94000de0 	bl	ffffffffea805380 <current_time_hires>
ffffffffea801c04:	cb160000 	sub	x0, x0, x22
ffffffffea801c08:	eb15001f 	cmp	x0, x21
ffffffffea801c0c:	54000148 	b.hi	ffffffffea801c34 <comb_uart_putc+0x8c>  // b.pmore
	while (readl(TEGRA_COMBUART_BASE) & (MBOX_INTR_TRIGGER)) {
ffffffffea801c10:	b9400260 	ldr	w0, [x19]
ffffffffea801c14:	37ffff20 	tbnz	w0, #31, ffffffffea801bf8 <comb_uart_putc+0x50>
			timed_out = true;
			return;
		}
	}
	timed_out = false;
ffffffffea801c18:	3900031f 	strb	wzr, [x24]
	 *
	 * If EL3 does attempt to print debug messages at the same time as Trusty, messages might
	 * be corrupted. This is acceptable, because it should not cause any functional issues
	 * in Trusty or EL3.
	 */
	writel(msg, TEGRA_COMBUART_BASE);
ffffffffea801c1c:	b9000277 	str	w23, [x19]
}
ffffffffea801c20:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801c24:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801c28:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801c2c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea801c30:	d65f03c0 	ret
			timed_out = true;
ffffffffea801c34:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea801c38:	39000280 	strb	w0, [x20]
}
ffffffffea801c3c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801c40:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801c44:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801c48:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea801c4c:	d65f03c0 	ret

ffffffffea801c50 <platform_tegra_comb_uart_putc>:

void platform_tegra_comb_uart_putc(char c)
{
ffffffffea801c50:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea801c54:	910003fd 	mov	x29, sp
ffffffffea801c58:	f9000bf3 	str	x19, [sp, #16]
	if (c == '\0')
ffffffffea801c5c:	72001c13 	ands	w19, w0, #0xff
ffffffffea801c60:	540000e0 	b.eq	ffffffffea801c7c <platform_tegra_comb_uart_putc+0x2c>  // b.none
		return;
	if (c == '\n')
ffffffffea801c64:	71002a7f 	cmp	w19, #0xa
ffffffffea801c68:	54000100 	b.eq	ffffffffea801c88 <platform_tegra_comb_uart_putc+0x38>  // b.none
		comb_uart_putc('\r');
	comb_uart_putc(c);
ffffffffea801c6c:	2a1303e0 	mov	w0, w19
}
ffffffffea801c70:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801c74:	a8c27bfd 	ldp	x29, x30, [sp], #32
	comb_uart_putc(c);
ffffffffea801c78:	17ffffcc 	b	ffffffffea801ba8 <comb_uart_putc>
}
ffffffffea801c7c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801c80:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea801c84:	d65f03c0 	ret
		comb_uart_putc('\r');
ffffffffea801c88:	528001a0 	mov	w0, #0xd                   	// #13
ffffffffea801c8c:	97ffffc7 	bl	ffffffffea801ba8 <comb_uart_putc>
	comb_uart_putc(c);
ffffffffea801c90:	2a1303e0 	mov	w0, w19
}
ffffffffea801c94:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801c98:	a8c27bfd 	ldp	x29, x30, [sp], #32
	comb_uart_putc(c);
ffffffffea801c9c:	17ffffc3 	b	ffffffffea801ba8 <comb_uart_putc>
#include <sys/types.h>

__WEAK void platform_tegra_comb_uart_putc(char c)
{
	(void)c;
}
ffffffffea801ca0:	d65f03c0 	ret
ffffffffea801ca4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801ca8 <platform_tegra_comb_uart_getc>:

int platform_tegra_comb_uart_getc(bool wait)
{
	(void)wait;
	return -1;
}
ffffffffea801ca8:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea801cac:	d65f03c0 	ret

__WEAK int platform_tegra_comb_uart_getc(bool wait)
{
	(void)wait;
	return -1;
}
ffffffffea801cb0:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea801cb4:	d65f03c0 	ret

ffffffffea801cb8 <get_and_clear_eks_info>:

/* Structure to hold EKS information */
static eks_info_t eks_info;

status_t get_and_clear_eks_info(eks_info_t *info)
{
ffffffffea801cb8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea801cbc:	910003fd 	mov	x29, sp
ffffffffea801cc0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea801cc4:	aa0003f3 	mov	x19, x0
	if (!platform_is_bootstrapping()) {
ffffffffea801cc8:	9400012c 	bl	ffffffffea802178 <platform_is_bootstrapping>
ffffffffea801ccc:	72001c1f 	tst	w0, #0xff
ffffffffea801cd0:	540001c0 	b.eq	ffffffffea801d08 <get_and_clear_eks_info+0x50>  // b.none
		dprintf(CRITICAL, "%s: ERROR: Not allowed after boot\n", __func__);
		return ERR_NOT_ALLOWED;
	}
	if (info == NULL) {
ffffffffea801cd4:	b4000293 	cbz	x19, ffffffffea801d24 <get_and_clear_eks_info+0x6c>
		dprintf(CRITICAL, "%s: ERROR: Attempting to access NULL pointer\n", __func__);
		return ERR_INVALID_ARGS;
	}
	info->paddr = eks_info.paddr;
ffffffffea801cd8:	d00002a1 	adrp	x1, ffffffffea857000 <__bss_start>
ffffffffea801cdc:	91002022 	add	x2, x1, #0x8

	/* clear eks_info, so this method cannot be used again */
	eks_info.paddr = NULL;
	eks_info.blob_length = 0;

	return NO_ERROR;
ffffffffea801ce0:	52800000 	mov	w0, #0x0                   	// #0
	info->paddr = eks_info.paddr;
ffffffffea801ce4:	f9400423 	ldr	x3, [x1, #8]
	eks_info.paddr = NULL;
ffffffffea801ce8:	f900043f 	str	xzr, [x1, #8]
	info->blob_length = eks_info.blob_length;
ffffffffea801cec:	b9400841 	ldr	w1, [x2, #8]
	info->paddr = eks_info.paddr;
ffffffffea801cf0:	f9000263 	str	x3, [x19]
	eks_info.blob_length = 0;
ffffffffea801cf4:	b900085f 	str	wzr, [x2, #8]
	info->blob_length = eks_info.blob_length;
ffffffffea801cf8:	b9000a61 	str	w1, [x19, #8]
}
ffffffffea801cfc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801d00:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea801d04:	d65f03c0 	ret
		dprintf(CRITICAL, "%s: ERROR: Not allowed after boot\n", __func__);
ffffffffea801d08:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801d0c:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801d10:	91068021 	add	x1, x1, #0x1a0
ffffffffea801d14:	9106e000 	add	x0, x0, #0x1b8
ffffffffea801d18:	94003ebe 	bl	ffffffffea811810 <_dprintf>
		return ERR_NOT_ALLOWED;
ffffffffea801d1c:	12800200 	mov	w0, #0xffffffef            	// #-17
ffffffffea801d20:	17fffff7 	b	ffffffffea801cfc <get_and_clear_eks_info+0x44>
		dprintf(CRITICAL, "%s: ERROR: Attempting to access NULL pointer\n", __func__);
ffffffffea801d24:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801d28:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801d2c:	91068021 	add	x1, x1, #0x1a0
ffffffffea801d30:	91078000 	add	x0, x0, #0x1e0
ffffffffea801d34:	94003eb7 	bl	ffffffffea811810 <_dprintf>
		return ERR_INVALID_ARGS;
ffffffffea801d38:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea801d3c:	17fffff0 	b	ffffffffea801cfc <get_and_clear_eks_info+0x44>

ffffffffea801d40 <partner_process_boot_params>:
}

__WEAK status_t partner_process_boot_params(boot_params_t *boot_params)
{
	return NO_ERROR;
};
ffffffffea801d40:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea801d44:	d65f03c0 	ret

ffffffffea801d48 <process_boot_params>:

status_t process_boot_params(void)
{
ffffffffea801d48:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea801d4c:	910003fd 	mov	x29, sp
	key_params *keys_params;
	size_t total_length, keys_length;
	uint32_t offset;
	status_t ret;
	/* get boot args */
	if ((ret = sm_get_boot_args((void **)&boot_params, &total_length))
ffffffffea801d50:	910123a1 	add	x1, x29, #0x48
ffffffffea801d54:	910103a0 	add	x0, x29, #0x40
ffffffffea801d58:	940019ee 	bl	ffffffffea808510 <sm_get_boot_args>
ffffffffea801d5c:	35000180 	cbnz	w0, ffffffffea801d8c <process_boot_params+0x44>
ffffffffea801d60:	f9000bb3 	str	x19, [x29, #16]
			!= NO_ERROR) {
		LTRACEF("sm_get_boot_args failed: %d\n", ret);
		return ret;
	}

	if (!boot_params) {
ffffffffea801d64:	f94023b3 	ldr	x19, [x29, #64]
ffffffffea801d68:	b4000173 	cbz	x19, ffffffffea801d94 <process_boot_params+0x4c>
		ret = ERR_NOT_CONFIGURED;
		goto release_bootargs;
	}

	if (total_length < sizeof(boot_params_t)) {
ffffffffea801d6c:	f94027a1 	ldr	x1, [x29, #72]
		ret = ERR_BAD_LEN;
ffffffffea801d70:	128003e0 	mov	w0, #0xffffffe0            	// #-32
	if (total_length < sizeof(boot_params_t)) {
ffffffffea801d74:	f1023c3f 	cmp	x1, #0x8f
ffffffffea801d78:	54000128 	b.hi	ffffffffea801d9c <process_boot_params+0x54>  // b.pmore
ffffffffea801d7c:	b9003fa0 	str	w0, [x29, #60]
		return ret;
	}

release_bootargs:
	/* release boot args reference */
	sm_put_boot_args();
ffffffffea801d80:	94001a0a 	bl	ffffffffea8085a8 <sm_put_boot_args>
ffffffffea801d84:	b9403fa0 	ldr	w0, [x29, #60]
ffffffffea801d88:	f9400bb3 	ldr	x19, [x29, #16]

	return ret;
}
ffffffffea801d8c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea801d90:	d65f03c0 	ret
		ret = ERR_NOT_CONFIGURED;
ffffffffea801d94:	128004a0 	mov	w0, #0xffffffda            	// #-38
ffffffffea801d98:	17fffff9 	b	ffffffffea801d7c <process_boot_params+0x34>
	device_uid[0] = boot_params_ptr->chip_uid[0];
ffffffffea801d9c:	29409e63 	ldp	w3, w7, [x19, #4]
ffffffffea801da0:	900002e1 	adrp	x1, ffffffffea85d000 <rb_data+0x18>
	device_uid[2] = boot_params_ptr->chip_uid[2];
ffffffffea801da4:	29419666 	ldp	w6, w5, [x19, #12]
	device_uid[0] = boot_params_ptr->chip_uid[0];
ffffffffea801da8:	9100a020 	add	x0, x1, #0x28
	device_uid[3] = boot_params_ptr->chip_uid[3];
ffffffffea801dac:	b9401664 	ldr	w4, [x19, #20]
	debug_uart_id = boot_params_ptr->uart_id;
ffffffffea801db0:	f00000a2 	adrp	x2, ffffffffea818000 <_mem_phys_base>
ffffffffea801db4:	a901d7b4 	stp	x20, x21, [x29, #24]
	dest = memcpy((void *)&rb_data, (const void *)&(boot_params_ptr->rb_data),
ffffffffea801db8:	f00002d4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea801dbc:	913fa294 	add	x20, x20, #0xfe8
	device_uid[0] = boot_params_ptr->chip_uid[0];
ffffffffea801dc0:	b9002827 	str	w7, [x1, #40]
	debug_uart_id = boot_params_ptr->uart_id;
ffffffffea801dc4:	b9001043 	str	w3, [x2, #16]
	dest = memcpy((void *)&rb_data, (const void *)&(boot_params_ptr->rb_data),
ffffffffea801dc8:	91014261 	add	x1, x19, #0x50
	device_uid[2] = boot_params_ptr->chip_uid[2];
ffffffffea801dcc:	29009406 	stp	w6, w5, [x0, #4]
	dest = memcpy((void *)&rb_data, (const void *)&(boot_params_ptr->rb_data),
ffffffffea801dd0:	d2800802 	mov	x2, #0x40                  	// #64
	device_uid[3] = boot_params_ptr->chip_uid[3];
ffffffffea801dd4:	b9000c04 	str	w4, [x0, #12]
	keys_params = (key_params *)((uintptr_t)boot_params + offset);
ffffffffea801dd8:	91024275 	add	x21, x19, #0x90
	dest = memcpy((void *)&rb_data, (const void *)&(boot_params_ptr->rb_data),
ffffffffea801ddc:	aa1403e0 	mov	x0, x20
ffffffffea801de0:	940044b0 	bl	ffffffffea8130a0 <memcpy>
	if (dest != (void *)&rb_data) {
ffffffffea801de4:	eb00029f 	cmp	x20, x0
ffffffffea801de8:	540000e0 	b.eq	ffffffffea801e04 <process_boot_params+0xbc>  // b.none
		TRACEF("error while doing mem copy\n");
ffffffffea801dec:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801df0:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801df4:	52800a42 	mov	w2, #0x52                  	// #82
ffffffffea801df8:	9105e021 	add	x1, x1, #0x178
ffffffffea801dfc:	91084000 	add	x0, x0, #0x210
ffffffffea801e00:	94004468 	bl	ffffffffea812fa0 <_printf>
	keys_length = keys_params->encrypted_key_sz;
ffffffffea801e04:	b9409273 	ldr	w19, [x19, #144]
ffffffffea801e08:	2a1303e3 	mov	w3, w19
        if (keys_length > MAXIMUM_ENCRYPTED_KEYS_SIZE) {
ffffffffea801e0c:	f140807f 	cmp	x3, #0x20, lsl #12
ffffffffea801e10:	540001e9 	b.ls	ffffffffea801e4c <process_boot_params+0x104>  // b.plast
		TRACEF("encrypted key length (%zu) exceeds maximum key length (%lu)\n",
ffffffffea801e14:	52800fe2 	mov	w2, #0x7f                  	// #127
ffffffffea801e18:	900000a1 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801e1c:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801e20:	91062021 	add	x1, x1, #0x188
ffffffffea801e24:	d2a00044 	mov	x4, #0x20000               	// #131072
ffffffffea801e28:	9108e000 	add	x0, x0, #0x238
ffffffffea801e2c:	9400445d 	bl	ffffffffea812fa0 <_printf>
		eks_info.paddr = NULL;
ffffffffea801e30:	d00002a1 	adrp	x1, ffffffffea857000 <__bss_start>
ffffffffea801e34:	91002022 	add	x2, x1, #0x8
		goto release_bootargs;
ffffffffea801e38:	a941d7b4 	ldp	x20, x21, [x29, #24]
		ret = ERR_BAD_LEN;
ffffffffea801e3c:	128003e0 	mov	w0, #0xffffffe0            	// #-32
		eks_info.paddr = NULL;
ffffffffea801e40:	f900043f 	str	xzr, [x1, #8]
		eks_info.blob_length = 0;
ffffffffea801e44:	b900085f 	str	wzr, [x2, #8]
		goto release_bootargs;
ffffffffea801e48:	17ffffcd 	b	ffffffffea801d7c <process_boot_params+0x34>
	eks_info.paddr = kvaddr_to_paddr(keys_params);
ffffffffea801e4c:	aa1503e0 	mov	x0, x21
ffffffffea801e50:	94003b6e 	bl	ffffffffea810c08 <kvaddr_to_paddr>
ffffffffea801e54:	d00002a1 	adrp	x1, ffffffffea857000 <__bss_start>
ffffffffea801e58:	91002022 	add	x2, x1, #0x8
ffffffffea801e5c:	f9000420 	str	x0, [x1, #8]
	ret = partner_process_boot_params(boot_params);
ffffffffea801e60:	f94023a0 	ldr	x0, [x29, #64]
	eks_info.blob_length = keys_length;
ffffffffea801e64:	b9000853 	str	w19, [x2, #8]
	ret = partner_process_boot_params(boot_params);
ffffffffea801e68:	97ffffb6 	bl	ffffffffea801d40 <partner_process_boot_params>
 	if (ret != NO_ERROR) {
ffffffffea801e6c:	35000060 	cbnz	w0, ffffffffea801e78 <process_boot_params+0x130>
ffffffffea801e70:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea801e74:	17ffffc2 	b	ffffffffea801d7c <process_boot_params+0x34>
ffffffffea801e78:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea801e7c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea801e80:	17ffffc3 	b	ffffffffea801d8c <process_boot_params+0x44>
ffffffffea801e84:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801e88 <uart_putc>:
{
	return *REG8(uart_base[port] + (reg << 2));
}

static int uart_putc(int port, char c )
{
ffffffffea801e88:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea801e8c:	910003fd 	mov	x29, sp
ffffffffea801e90:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea801e94:	2a0003f3 	mov	w19, w0
ffffffffea801e98:	a9025bf5 	stp	x21, x22, [sp, #32]
	lk_bigtime_t start = current_time_hires();

	while (!(read_uart_reg(port, UART_LSR) & (1<<5))) {
		if (timed_out)
			return -1;
		if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea801e9c:	d29423f5 	mov	x21, #0xa11f                	// #41247
{
ffffffffea801ea0:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea801ea4:	12001c37 	and	w23, w1, #0xff
ffffffffea801ea8:	f90023f9 	str	x25, [sp, #64]
	lk_bigtime_t start = current_time_hires();
ffffffffea801eac:	94000d35 	bl	ffffffffea805380 <current_time_hires>
ffffffffea801eb0:	aa0003f6 	mov	x22, x0
ffffffffea801eb4:	900000a0 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea801eb8:	910a8000 	add	x0, x0, #0x2a0
ffffffffea801ebc:	d00002b8 	adrp	x24, ffffffffea857000 <__bss_start>
		if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea801ec0:	f2a000f5 	movk	x21, #0x7, lsl #16
		if (timed_out)
ffffffffea801ec4:	91006314 	add	x20, x24, #0x18
ffffffffea801ec8:	f873d819 	ldr	x25, [x0, w19, sxtw #3]
ffffffffea801ecc:	91005333 	add	x19, x25, #0x14
	while (!(read_uart_reg(port, UART_LSR) & (1<<5))) {
ffffffffea801ed0:	14000007 	b	ffffffffea801eec <uart_putc+0x64>
		if (timed_out)
ffffffffea801ed4:	39400280 	ldrb	w0, [x20]
ffffffffea801ed8:	35000200 	cbnz	w0, ffffffffea801f18 <uart_putc+0x90>
		if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea801edc:	94000d29 	bl	ffffffffea805380 <current_time_hires>
ffffffffea801ee0:	cb160000 	sub	x0, x0, x22
ffffffffea801ee4:	eb15001f 	cmp	x0, x21
ffffffffea801ee8:	54000268 	b.hi	ffffffffea801f34 <uart_putc+0xac>  // b.pmore
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea801eec:	39400260 	ldrb	w0, [x19]
	while (!(read_uart_reg(port, UART_LSR) & (1<<5))) {
ffffffffea801ef0:	362fff20 	tbz	w0, #5, ffffffffea801ed4 <uart_putc+0x4c>
	*REG8(uart_base[port] + (reg << 2)) = data;
ffffffffea801ef4:	39000337 	strb	w23, [x25]
	}

	timed_out = false;

	write_uart_reg(port, UART_THR, c);
	return 0;
ffffffffea801ef8:	52800000 	mov	w0, #0x0                   	// #0
	timed_out = false;
ffffffffea801efc:	3900631f 	strb	wzr, [x24, #24]
}
ffffffffea801f00:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801f04:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801f08:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801f0c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea801f10:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea801f14:	d65f03c0 	ret
			return -1;
ffffffffea801f18:	12800000 	mov	w0, #0xffffffff            	// #-1
}
ffffffffea801f1c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea801f20:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801f24:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801f28:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801f2c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea801f30:	d65f03c0 	ret
			timed_out = true;
ffffffffea801f34:	52800021 	mov	w1, #0x1                   	// #1
			return -1;
ffffffffea801f38:	12800000 	mov	w0, #0xffffffff            	// #-1
			timed_out = true;
ffffffffea801f3c:	39000281 	strb	w1, [x20]
}
ffffffffea801f40:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801f44:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801f48:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801f4c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea801f50:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea801f54:	d65f03c0 	ret

ffffffffea801f58 <platform_dputc>:

	return read_uart_reg(port, UART_RHR);
}

void platform_dputc(char c)
{
ffffffffea801f58:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea801f5c:	f00000a1 	adrp	x1, ffffffffea818000 <_mem_phys_base>
{
ffffffffea801f60:	910003fd 	mov	x29, sp
ffffffffea801f64:	f9000bf3 	str	x19, [sp, #16]
ffffffffea801f68:	12001c13 	and	w19, w0, #0xff
	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea801f6c:	b9418820 	ldr	w0, [x1, #392]
ffffffffea801f70:	35000200 	cbnz	w0, ffffffffea801fb0 <platform_dputc+0x58>
ffffffffea801f74:	f9000fb4 	str	x20, [x29, #24]
ffffffffea801f78:	f00000b4 	adrp	x20, ffffffffea818000 <_mem_phys_base>
ffffffffea801f7c:	b9418680 	ldr	w0, [x20, #388]
ffffffffea801f80:	34000160 	cbz	w0, ffffffffea801fac <platform_dputc+0x54>
		return;

	if (debug_port == TEGRA_COMBUART_ID) {
ffffffffea801f84:	7103f81f 	cmp	w0, #0xfe
ffffffffea801f88:	540001a0 	b.eq	ffffffffea801fbc <platform_dputc+0x64>  // b.none
		platform_tegra_comb_uart_putc(c);
		return;
	}

	if (c == '\n') {
ffffffffea801f8c:	71002a7f 	cmp	w19, #0xa
ffffffffea801f90:	54000200 	b.eq	ffffffffea801fd0 <platform_dputc+0x78>  // b.none
		uart_putc(debug_port, '\r');
	} else if (c == '\0') {
ffffffffea801f94:	340000d3 	cbz	w19, ffffffffea801fac <platform_dputc+0x54>
		return;
	}
	uart_putc(debug_port, c);
ffffffffea801f98:	2a1303e1 	mov	w1, w19
ffffffffea801f9c:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea801fa0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801fa4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	uart_putc(debug_port, c);
ffffffffea801fa8:	17ffffb8 	b	ffffffffea801e88 <uart_putc>
ffffffffea801fac:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea801fb0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801fb4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea801fb8:	d65f03c0 	ret
		platform_tegra_comb_uart_putc(c);
ffffffffea801fbc:	2a1303e0 	mov	w0, w19
ffffffffea801fc0:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea801fc4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801fc8:	a8c27bfd 	ldp	x29, x30, [sp], #32
		platform_tegra_comb_uart_putc(c);
ffffffffea801fcc:	17ffff21 	b	ffffffffea801c50 <platform_tegra_comb_uart_putc>
		uart_putc(debug_port, '\r');
ffffffffea801fd0:	528001a1 	mov	w1, #0xd                   	// #13
ffffffffea801fd4:	97ffffad 	bl	ffffffffea801e88 <uart_putc>
ffffffffea801fd8:	b9418680 	ldr	w0, [x20, #388]
ffffffffea801fdc:	17ffffef 	b	ffffffffea801f98 <platform_dputc+0x40>

ffffffffea801fe0 <platform_dgetc>:

int platform_dgetc(char *c, bool wait)
{
	int _c;

	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea801fe0:	f00000a2 	adrp	x2, ffffffffea818000 <_mem_phys_base>
ffffffffea801fe4:	b9418842 	ldr	w2, [x2, #392]
ffffffffea801fe8:	35000a62 	cbnz	w2, ffffffffea802134 <platform_dgetc+0x154>
{
ffffffffea801fec:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea801ff0:	f00000a2 	adrp	x2, ffffffffea818000 <_mem_phys_base>
{
ffffffffea801ff4:	910003fd 	mov	x29, sp
ffffffffea801ff8:	f9000ff4 	str	x20, [sp, #24]
	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea801ffc:	b9418454 	ldr	w20, [x2, #388]
ffffffffea802000:	34000694 	cbz	w20, ffffffffea8020d0 <platform_dgetc+0xf0>
ffffffffea802004:	f9000bb3 	str	x19, [x29, #16]
		return -1;

	if (debug_port == TEGRA_COMBUART_ID) {
ffffffffea802008:	7103fa9f 	cmp	w20, #0xfe
ffffffffea80200c:	f90017b6 	str	x22, [x29, #40]
ffffffffea802010:	aa0003f3 	mov	x19, x0
ffffffffea802014:	12001c36 	and	w22, w1, #0xff
ffffffffea802018:	54000520 	b.eq	ffffffffea8020bc <platform_dgetc+0xdc>  // b.none
ffffffffea80201c:	f90013b5 	str	x21, [x29, #32]
ffffffffea802020:	a903e7b8 	stp	x24, x25, [x29, #56]
	lk_bigtime_t start = current_time_hires();
ffffffffea802024:	94000cd7 	bl	ffffffffea805380 <current_time_hires>
ffffffffea802028:	aa0003f5 	mov	x21, x0
ffffffffea80202c:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802030:	910a8000 	add	x0, x0, #0x2a0
ffffffffea802034:	f874d819 	ldr	x25, [x0, w20, sxtw #3]
ffffffffea802038:	91005334 	add	x20, x25, #0x14
	if (wait) {
ffffffffea80203c:	35000216 	cbnz	w22, ffffffffea80207c <platform_dgetc+0x9c>
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea802040:	39405320 	ldrb	w0, [x25, #20]
		if (!(read_uart_reg(port, UART_LSR) & (1<<0)))
ffffffffea802044:	360006e0 	tbz	w0, #0, ffffffffea802120 <platform_dgetc+0x140>
ffffffffea802048:	b00002b8 	adrp	x24, ffffffffea857000 <__bss_start>
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea80204c:	39400320 	ldrb	w0, [x25]
	timed_out = false;
ffffffffea802050:	3900671f 	strb	wzr, [x24, #25]
ffffffffea802054:	f94013b5 	ldr	x21, [x29, #32]
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea802058:	12001c00 	and	w0, w0, #0xff
ffffffffea80205c:	a943e7b8 	ldp	x24, x25, [x29, #56]
	}

	if (_c < 0)
		return -1;

	*c = _c;
ffffffffea802060:	39000260 	strb	w0, [x19]
	return 0;
ffffffffea802064:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea802068:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80206c:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea802070:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea802074:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea802078:	d65f03c0 	ret
ffffffffea80207c:	f9001bb7 	str	x23, [x29, #48]
			if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea802080:	d29423f7 	mov	x23, #0xa11f                	// #41247
ffffffffea802084:	b00002b8 	adrp	x24, ffffffffea857000 <__bss_start>
ffffffffea802088:	f2a000f7 	movk	x23, #0x7, lsl #16
			if (timed_out)
ffffffffea80208c:	91006716 	add	x22, x24, #0x19
ffffffffea802090:	14000007 	b	ffffffffea8020ac <platform_dgetc+0xcc>
ffffffffea802094:	394002c1 	ldrb	w1, [x22]
ffffffffea802098:	35000241 	cbnz	w1, ffffffffea8020e0 <platform_dgetc+0x100>
			if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea80209c:	94000cb9 	bl	ffffffffea805380 <current_time_hires>
ffffffffea8020a0:	cb150000 	sub	x0, x0, x21
ffffffffea8020a4:	eb17001f 	cmp	x0, x23
ffffffffea8020a8:	54000288 	b.hi	ffffffffea8020f8 <platform_dgetc+0x118>  // b.pmore
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea8020ac:	39400281 	ldrb	w1, [x20]
		while (!(read_uart_reg(port, UART_LSR) & (1<<0))) {
ffffffffea8020b0:	3607ff21 	tbz	w1, #0, ffffffffea802094 <platform_dgetc+0xb4>
ffffffffea8020b4:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea8020b8:	17ffffe5 	b	ffffffffea80204c <platform_dgetc+0x6c>
		_c = platform_tegra_comb_uart_getc(wait);
ffffffffea8020bc:	2a1603e0 	mov	w0, w22
ffffffffea8020c0:	97fffefa 	bl	ffffffffea801ca8 <platform_tegra_comb_uart_getc>
	if (_c < 0)
ffffffffea8020c4:	36fffce0 	tbz	w0, #31, ffffffffea802060 <platform_dgetc+0x80>
ffffffffea8020c8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8020cc:	f94017b6 	ldr	x22, [x29, #40]
		return -1;
ffffffffea8020d0:	12800000 	mov	w0, #0xffffffff            	// #-1
}
ffffffffea8020d4:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea8020d8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8020dc:	d65f03c0 	ret
ffffffffea8020e0:	f9400bb3 	ldr	x19, [x29, #16]
		return -1;
ffffffffea8020e4:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea8020e8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8020ec:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea8020f0:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea8020f4:	17fffff8 	b	ffffffffea8020d4 <platform_dgetc+0xf4>
				timed_out = true;
ffffffffea8020f8:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8020fc:	390002c1 	strb	w1, [x22]
		return -1;
ffffffffea802100:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea802104:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea802108:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80210c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea802110:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea802114:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea802118:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80211c:	d65f03c0 	ret
ffffffffea802120:	f9400bb3 	ldr	x19, [x29, #16]
		return -1;
ffffffffea802124:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea802128:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80212c:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea802130:	17ffffe9 	b	ffffffffea8020d4 <platform_dgetc+0xf4>
ffffffffea802134:	12800000 	mov	w0, #0xffffffff            	// #-1
}
ffffffffea802138:	d65f03c0 	ret
ffffffffea80213c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802140 <platform_init_debug_port>:

void platform_init_debug_port(unsigned int dbg_port)
{
	
	debug_port = dbg_port;
ffffffffea802140:	d00000a3 	adrp	x3, ffffffffea818000 <_mem_phys_base>
	disable_debug = 1;
}

void platform_enable_debug_intf(void)
{
	disable_debug = 0;
ffffffffea802144:	d00000a2 	adrp	x2, ffffffffea818000 <_mem_phys_base>
{
ffffffffea802148:	2a0003e1 	mov	w1, w0
	dprintf(0, "DEBUG PORT ENABLED with %d\n", debug_port);
ffffffffea80214c:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
	debug_port = dbg_port;
ffffffffea802150:	b9018461 	str	w1, [x3, #388]
	dprintf(0, "DEBUG PORT ENABLED with %d\n", debug_port);
ffffffffea802154:	910a0000 	add	x0, x0, #0x280
	disable_debug = 0;
ffffffffea802158:	b901885f 	str	wzr, [x2, #392]
	dprintf(0, "DEBUG PORT ENABLED with %d\n", debug_port);
ffffffffea80215c:	14003dad 	b	ffffffffea811810 <_dprintf>

ffffffffea802160 <platform_disable_debug_intf>:
	disable_debug = 1;
ffffffffea802160:	d00000a0 	adrp	x0, ffffffffea818000 <_mem_phys_base>
ffffffffea802164:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea802168:	b9018801 	str	w1, [x0, #392]
}
ffffffffea80216c:	d65f03c0 	ret

ffffffffea802170 <tegra_platform_bootstrap_epilog>:
} platform_state = {
	.bootstrap_done = false,
};

// platform specific hook for epilog
__WEAK void tegra_platform_bootstrap_epilog(void) {}
ffffffffea802170:	d65f03c0 	ret
ffffffffea802174:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802178 <platform_is_bootstrapping>:
	.ns_dram_map_list_head = LIST_INITIAL_VALUE(platform_ctx.ns_dram_map_list_head)
};

bool platform_is_bootstrapping(void)
{
	return !platform_state.bootstrap_done;
ffffffffea802178:	b00002a0 	adrp	x0, ffffffffea857000 <__bss_start>
ffffffffea80217c:	39408000 	ldrb	w0, [x0, #32]
}
ffffffffea802180:	52000000 	eor	w0, w0, #0x1
ffffffffea802184:	d65f03c0 	ret

ffffffffea802188 <platform_bootstrap_epilog>:
/*
 * Defining a common platform_bootstrap_epilog handler. If platform specific
 * cleanups are required, implement a platform specific epilog handler.
 */
void platform_bootstrap_epilog(void)
{
ffffffffea802188:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	platform_state.bootstrap_done = true;
ffffffffea80218c:	b00002a0 	adrp	x0, ffffffffea857000 <__bss_start>
ffffffffea802190:	52800021 	mov	w1, #0x1                   	// #1
{
ffffffffea802194:	910003fd 	mov	x29, sp
	platform_state.bootstrap_done = true;
ffffffffea802198:	39008001 	strb	w1, [x0, #32]
	tegra_platform_bootstrap_epilog();
ffffffffea80219c:	97fffff5 	bl	ffffffffea802170 <tegra_platform_bootstrap_epilog>
	 * its impact on boot KPI
	 */
#if !defined(TRUSTY_TARGET_PLATFORM_EMBEDDED)
	dprintf(ALWAYS, "%s: trusty bootstrap complete\n", __func__);
#endif
}
ffffffffea8021a0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	dprintf(ALWAYS, "%s: trusty bootstrap complete\n", __func__);
ffffffffea8021a4:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8021a8:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8021ac:	910c0021 	add	x1, x1, #0x300
ffffffffea8021b0:	910d2000 	add	x0, x0, #0x348
ffffffffea8021b4:	14003d97 	b	ffffffffea811810 <_dprintf>

ffffffffea8021b8 <platform_arch_speculation_barrier>:

void platform_arch_speculation_barrier(void) {

#if defined(INSERT_SPECULATION_BARRIER)
	mb();
ffffffffea8021b8:	d5033f9f 	dsb	sy
	ISB;
ffffffffea8021bc:	d5033fdf 	isb
#endif

	return;
}
ffffffffea8021c0:	d65f03c0 	ret
ffffffffea8021c4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8021c8 <platform_register_ns_dram_ranges>:

long platform_register_ns_dram_ranges(paddr_t ns_base, uint64_t ns_size)
{
ffffffffea8021c8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea8021cc:	910003fd 	mov	x29, sp
ffffffffea8021d0:	a9025bf5 	stp	x21, x22, [sp, #32]
#define TOS_NS_MEM_MAP_MAGIC_VALUE (0xfeedbeef)
#define TOS_NS_MEM_MAP_CUR_VERSION (0x1)
	dprintf(SPEW, "%s: ns_base: %lx, ns_size: %llu\n", __func__, ns_base, ns_size);

	/*Register DRAM ranges only once*/
	if (platform_ctx.ns_dram_range_available)
ffffffffea8021d4:	d00000b5 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea8021d8:	394642a2 	ldrb	w2, [x21, #400]
ffffffffea8021dc:	35001082 	cbnz	w2, ffffffffea8023ec <platform_register_ns_dram_ranges+0x224>
	vaddr_t vptr;
	long ret = NO_ERROR;

	offset = ns_base & (PAGE_SIZE - 1);
	aligned_addr = ROUNDDOWN(ns_base, PAGE_SIZE);
	aligned_size = ROUNDUP(ns_size + offset, PAGE_SIZE);
ffffffffea8021e0:	913ffc22 	add	x2, x1, #0xfff
ffffffffea8021e4:	f9000bb3 	str	x19, [x29, #16]
	offset = ns_base & (PAGE_SIZE - 1);
ffffffffea8021e8:	92402c13 	and	x19, x0, #0xfff

	ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "cboot",
ffffffffea8021ec:	9274cc05 	and	x5, x0, #0xfffffffffffff000
	aligned_size = ROUNDUP(ns_size + offset, PAGE_SIZE);
ffffffffea8021f0:	8b130042 	add	x2, x2, x19
ffffffffea8021f4:	f9001fb8 	str	x24, [x29, #56]
	ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "cboot",
ffffffffea8021f8:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8021fc:	52800707 	mov	w7, #0x38                  	// #56
ffffffffea802200:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea802204:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea802208:	9101a3a3 	add	x3, x29, #0x68
ffffffffea80220c:	910da021 	add	x1, x1, #0x368
ffffffffea802210:	f00002d8 	adrp	x24, ffffffffea85d000 <rb_data+0x18>
ffffffffea802214:	9274cc42 	and	x2, x2, #0xfffffffffffff000
ffffffffea802218:	91034300 	add	x0, x24, #0xd0
ffffffffea80221c:	94003bbb 	bl	ffffffffea811108 <vmm_alloc_physical>
ffffffffea802220:	93407c16 	sxtw	x22, w0
			aligned_size, (void **)&vptr, PAGE_SIZE_SHIFT,
			aligned_addr, 0,
			ARCH_MMU_FLAG_NS | ARCH_MMU_FLAG_PERM_NO_EXECUTE |
			ARCH_MMU_FLAG_CACHED | ARCH_MMU_FLAG_PERM_RO);

	if (ret != NO_ERROR) {
ffffffffea802224:	b5000af6 	cbnz	x22, ffffffffea802380 <platform_register_ns_dram_ranges+0x1b8>
				"Trusty may fail to validate NS DRAM ranges\n"
				, __func__);
		return ret;
	}

	ns_mem_map = (tos_ns_mem_map_t *) (vptr + offset);
ffffffffea802228:	f94037a1 	ldr	x1, [x29, #104]

	/* Memory sanitization check */
	if (ns_mem_map->magic != TOS_NS_MEM_MAP_MAGIC_VALUE) {
ffffffffea80222c:	5297dde2 	mov	w2, #0xbeef                	// #48879
ffffffffea802230:	72bfdda2 	movk	w2, #0xfeed, lsl #16
ffffffffea802234:	b8736823 	ldr	w3, [x1, x19]
ffffffffea802238:	f9001bb7 	str	x23, [x29, #48]
	ns_mem_map = (tos_ns_mem_map_t *) (vptr + offset);
ffffffffea80223c:	8b130037 	add	x23, x1, x19
	if (ns_mem_map->magic != TOS_NS_MEM_MAP_MAGIC_VALUE) {
ffffffffea802240:	6b02007f 	cmp	w3, w2
ffffffffea802244:	54000801 	b.ne	ffffffffea802344 <platform_register_ns_dram_ranges+0x17c>  // b.any
		ret = ERR_INVALID_ARGS;
		goto lbl_free_vmm;
	}

	/* Check supported API version */
	if (ns_mem_map->ver != TOS_NS_MEM_MAP_CUR_VERSION) {
ffffffffea802248:	b94006e3 	ldr	w3, [x23, #4]
ffffffffea80224c:	7100047f 	cmp	w3, #0x1
ffffffffea802250:	54000ae1 	b.ne	ffffffffea8023ac <platform_register_ns_dram_ranges+0x1e4>  // b.any
				ns_mem_map->ver);
		ret = ERR_INVALID_ARGS;
		goto lbl_free_vmm;
	}

	for (map_index = 0; map_index < ns_mem_map->num; map_index++) {
ffffffffea802254:	b9400ae0 	ldr	w0, [x23, #8]
ffffffffea802258:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80225c:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea802260:	a9046bb9 	stp	x25, x26, [x29, #64]

#define list_add_after(entry, new_entry) list_add_head(entry, new_entry)

static inline void list_add_tail(struct list_node *list, struct list_node *item)
{
	item->prev = list->prev;
ffffffffea802264:	910642b9 	add	x25, x21, #0x190
ffffffffea802268:	f9002bbb 	str	x27, [x29, #80]
					"Trusty may fail to validate NS DRAM ranges\n",
					__func__);
			ret = ERR_NO_MEMORY;
			goto err_free_dram_map;
		}
		memcpy(&dram_map_node->ns_dram_entry, &ns_mem_map->mappings[map_index],
ffffffffea80226c:	d28001da 	mov	x26, #0xe                   	// #14
	item->next = list;
ffffffffea802270:	9100233b 	add	x27, x25, #0x8
	for (map_index = 0; map_index < ns_mem_map->num; map_index++) {
ffffffffea802274:	35000160 	cbnz	w0, ffffffffea8022a0 <platform_register_ns_dram_ranges+0xd8>
ffffffffea802278:	14000057 	b	ffffffffea8023d4 <platform_register_ns_dram_ranges+0x20c>
		memcpy(&dram_map_node->ns_dram_entry, &ns_mem_map->mappings[map_index],
ffffffffea80227c:	94004389 	bl	ffffffffea8130a0 <memcpy>
	item->prev = list->prev;
ffffffffea802280:	f9400720 	ldr	x0, [x25, #8]
	for (map_index = 0; map_index < ns_mem_map->num; map_index++) {
ffffffffea802284:	b9400ae1 	ldr	w1, [x23, #8]
	item->next = list;
ffffffffea802288:	a9016e60 	stp	x0, x27, [x19, #16]
		dprintf(SPEW, "%s: base: %llx size: %llu entry size: %zu\n", __func__,
				dram_map_node->ns_dram_entry.base,
				dram_map_node->ns_dram_entry.size,
				sizeof(tos_ns_mem_map_entry_t));

		list_add_tail(&platform_ctx.ns_dram_map_list_head, &dram_map_node->node);
ffffffffea80228c:	91004273 	add	x19, x19, #0x10
	list->prev->next = item;
ffffffffea802290:	f9000413 	str	x19, [x0, #8]
	for (map_index = 0; map_index < ns_mem_map->num; map_index++) {
ffffffffea802294:	6b14003f 	cmp	w1, w20
	list->prev = item;
ffffffffea802298:	f9000733 	str	x19, [x25, #8]
ffffffffea80229c:	540009a9 	b.ls	ffffffffea8023d0 <platform_register_ns_dram_ranges+0x208>  // b.plast
		tos_ns_dram_map_node_t *dram_map_node = calloc(1, sizeof(tos_ns_dram_map_node_t));
ffffffffea8022a0:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea8022a4:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea8022a8:	9400436c 	bl	ffffffffea813058 <calloc>
ffffffffea8022ac:	aa0003f3 	mov	x19, x0
		memcpy(&dram_map_node->ns_dram_entry, &ns_mem_map->mappings[map_index],
ffffffffea8022b0:	8b345341 	add	x1, x26, w20, uxtw #4
ffffffffea8022b4:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea8022b8:	8b0102e1 	add	x1, x23, x1
	for (map_index = 0; map_index < ns_mem_map->num; map_index++) {
ffffffffea8022bc:	11000694 	add	w20, w20, #0x1
		if (NULL == dram_map_node) {
ffffffffea8022c0:	b5fffde0 	cbnz	x0, ffffffffea80227c <platform_register_ns_dram_ranges+0xb4>

	platform_ctx.ns_dram_range_available = true;

	if (0) {
err_free_dram_map:
		list_for_every_entry_safe (&platform_ctx.ns_dram_map_list_head, map_node,
ffffffffea8022c4:	910642b5 	add	x21, x21, #0x190
			dprintf(CRITICAL, "%s: FATAL: unable to allocate memory. "
ffffffffea8022c8:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8022cc:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8022d0:	910c8021 	add	x1, x1, #0x320
ffffffffea8022d4:	9112a000 	add	x0, x0, #0x4a8
ffffffffea8022d8:	94003d4e 	bl	ffffffffea811810 <_dprintf>
		list_for_every_entry_safe (&platform_ctx.ns_dram_map_list_head, map_node,
ffffffffea8022dc:	f9400aa0 	ldr	x0, [x21, #16]
ffffffffea8022e0:	910022b4 	add	x20, x21, #0x8
ffffffffea8022e4:	d1004001 	sub	x1, x0, #0x10
ffffffffea8022e8:	eb14001f 	cmp	x0, x20
ffffffffea8022ec:	f9400c22 	ldr	x2, [x1, #24]
ffffffffea8022f0:	d1004053 	sub	x19, x2, #0x10
ffffffffea8022f4:	540001c0 	b.eq	ffffffffea80232c <platform_register_ns_dram_ranges+0x164>  // b.none

#define list_add_before(entry, new_entry) list_add_tail(entry, new_entry)

static inline void list_delete(struct list_node *item)
{
	item->next->prev = item->prev;
ffffffffea8022f8:	f9400823 	ldr	x3, [x1, #16]
				tmp_map_node, tos_ns_dram_map_node_t, node) {
			list_delete(&map_node->node);
			free(map_node);
ffffffffea8022fc:	aa0103e0 	mov	x0, x1
ffffffffea802300:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea802304:	f9400823 	ldr	x3, [x1, #16]
ffffffffea802308:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea80230c:	a9017c3f 	stp	xzr, xzr, [x1, #16]
ffffffffea802310:	94004362 	bl	ffffffffea813098 <free>
		list_for_every_entry_safe (&platform_ctx.ns_dram_map_list_head, map_node,
ffffffffea802314:	f9400e62 	ldr	x2, [x19, #24]
ffffffffea802318:	91004260 	add	x0, x19, #0x10
ffffffffea80231c:	aa1303e1 	mov	x1, x19
ffffffffea802320:	eb14001f 	cmp	x0, x20
ffffffffea802324:	d1004053 	sub	x19, x2, #0x10
ffffffffea802328:	54fffe81 	b.ne	ffffffffea8022f8 <platform_register_ns_dram_ranges+0x130>  // b.any
			ret = ERR_NO_MEMORY;
ffffffffea80232c:	92800096 	mov	x22, #0xfffffffffffffffb    	// #-5
ffffffffea802330:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea802334:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea802338:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea80233c:	f94037a1 	ldr	x1, [x29, #104]
ffffffffea802340:	14000008 	b	ffffffffea802360 <platform_register_ns_dram_ranges+0x198>
		dprintf(CRITICAL, "%s: FATAL: unable to locate magic value "
ffffffffea802344:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802348:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80234c:	910c8021 	add	x1, x1, #0x320
ffffffffea802350:	910f2000 	add	x0, x0, #0x3c8
ffffffffea802354:	94003d2f 	bl	ffffffffea811810 <_dprintf>
		ret = ERR_INVALID_ARGS;
ffffffffea802358:	928000f6 	mov	x22, #0xfffffffffffffff8    	// #-8
ffffffffea80235c:	f94037a1 	ldr	x1, [x29, #104]
			map_node = NULL;
		}
	}
lbl_free_vmm:
	vmm_free_region(vmm_get_kernel_aspace(), vptr);
ffffffffea802360:	91034300 	add	x0, x24, #0xd0
ffffffffea802364:	94003bcb 	bl	ffffffffea811290 <vmm_free_region>
	return ret;
ffffffffea802368:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80236c:	a94363b7 	ldp	x23, x24, [x29, #48]
}
ffffffffea802370:	aa1603e0 	mov	x0, x22
ffffffffea802374:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea802378:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80237c:	d65f03c0 	ret
		dprintf(CRITICAL, "%s: FATAL: unable to map shared memory. "
ffffffffea802380:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802384:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802388:	910c8021 	add	x1, x1, #0x320
ffffffffea80238c:	910dc000 	add	x0, x0, #0x370
ffffffffea802390:	94003d20 	bl	ffffffffea811810 <_dprintf>
		return ret;
ffffffffea802394:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea802398:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea80239c:	aa1603e0 	mov	x0, x22
ffffffffea8023a0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8023a4:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea8023a8:	d65f03c0 	ret
		dprintf(CRITICAL, "%s: FATAL: unsupported version "
ffffffffea8023ac:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8023b0:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8023b4:	910c8021 	add	x1, x1, #0x320
ffffffffea8023b8:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea8023bc:	91110000 	add	x0, x0, #0x440
ffffffffea8023c0:	94003d14 	bl	ffffffffea811810 <_dprintf>
		ret = ERR_INVALID_ARGS;
ffffffffea8023c4:	928000f6 	mov	x22, #0xfffffffffffffff8    	// #-8
ffffffffea8023c8:	f94037a1 	ldr	x1, [x29, #104]
		goto lbl_free_vmm;
ffffffffea8023cc:	17ffffe5 	b	ffffffffea802360 <platform_register_ns_dram_ranges+0x198>
ffffffffea8023d0:	f94037a1 	ldr	x1, [x29, #104]
	platform_ctx.ns_dram_range_available = true;
ffffffffea8023d4:	52800020 	mov	w0, #0x1                   	// #1
lbl_free_vmm:
ffffffffea8023d8:	f9400fb4 	ldr	x20, [x29, #24]
	platform_ctx.ns_dram_range_available = true;
ffffffffea8023dc:	390642a0 	strb	w0, [x21, #400]
lbl_free_vmm:
ffffffffea8023e0:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea8023e4:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea8023e8:	17ffffde 	b	ffffffffea802360 <platform_register_ns_dram_ranges+0x198>
		return ERR_ALREADY_EXISTS;
ffffffffea8023ec:	928001b6 	mov	x22, #0xfffffffffffffff2    	// #-14
ffffffffea8023f0:	17ffffe0 	b	ffffffffea802370 <platform_register_ns_dram_ranges+0x1a8>
ffffffffea8023f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8023f8 <platform_is_denver_cpu>:
 * - Returns true if the cpu is Denver (or Carmel)
 * - Returns false otherwise
 */
bool platform_is_denver_cpu(void)
{
	uint64_t midr = ARM64_READ_SYSREG(midr_el1);
ffffffffea8023f8:	d5380000 	mrs	x0, midr_el1
	uint64_t impl = (midr >> MIDR_IMPL_SHIFT) & MIDR_IMPL_MASK;
ffffffffea8023fc:	53187c00 	lsr	w0, w0, #24

	if (impl == DENVER_IMPL)
ffffffffea802400:	f101381f 	cmp	x0, #0x4e
		return true;
	else
		return false;
}
ffffffffea802404:	1a9f17e0 	cset	w0, eq  // eq = none
ffffffffea802408:	d65f03c0 	ret
ffffffffea80240c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802410 <ioctl_map_eks_to_user>:
{
	return uthread_is_valid_range(uthread_get_current(), addr, size);
}

int32_t ioctl_map_eks_to_user(ioctl_map_eks_params p)
{
ffffffffea802410:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
ffffffffea802414:	910003fd 	mov	x29, sp
ffffffffea802418:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea80241c:	aa0003f4 	mov	x20, x0
ffffffffea802420:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea802424:	aa0103f5 	mov	x21, x1
ffffffffea802428:	d360fc16 	lsr	x22, x0, #32
ffffffffea80242c:	d360fc37 	lsr	x23, x1, #32
ffffffffea802430:	f9001ff8 	str	x24, [sp, #56]
}

/* use the cpu local thread context pointer to store current_thread */
static inline struct thread *get_current_thread(void)
{
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea802434:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea802438:	f9415800 	ldr	x0, [x0, #688]
ffffffffea80243c:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802440:	2a1403e1 	mov	w1, w20
ffffffffea802444:	94004783 	bl	ffffffffea814250 <uthread_is_valid_range>
	if (!valid_address((vaddr_t)p.eks_addr_ptr, sizeof(uint32_t)))
ffffffffea802448:	72001c1f 	tst	w0, #0xff
ffffffffea80244c:	54000d40 	b.eq	ffffffffea8025f4 <ioctl_map_eks_to_user+0x1e4>  // b.none
ffffffffea802450:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea802454:	f9415800 	ldr	x0, [x0, #688]
ffffffffea802458:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea80245c:	aa1603e1 	mov	x1, x22
ffffffffea802460:	9400477c 	bl	ffffffffea814250 <uthread_is_valid_range>
		return ERR_INVALID_ARGS;
	if (!valid_address((vaddr_t)p.eks_size_ptr, sizeof(uint32_t)))
ffffffffea802464:	72001c1f 	tst	w0, #0xff
ffffffffea802468:	54000c60 	b.eq	ffffffffea8025f4 <ioctl_map_eks_to_user+0x1e4>  // b.none
ffffffffea80246c:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea802470:	f9415800 	ldr	x0, [x0, #688]
ffffffffea802474:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802478:	2a1503e1 	mov	w1, w21
ffffffffea80247c:	94004775 	bl	ffffffffea814250 <uthread_is_valid_range>
		return ERR_INVALID_ARGS;
	if (!valid_address((vaddr_t)p.map_addr_ptr, sizeof(uint32_t)))
ffffffffea802480:	72001c1f 	tst	w0, #0xff
ffffffffea802484:	54000b80 	b.eq	ffffffffea8025f4 <ioctl_map_eks_to_user+0x1e4>  // b.none
ffffffffea802488:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea80248c:	f9415800 	ldr	x0, [x0, #688]
ffffffffea802490:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802494:	aa1703e1 	mov	x1, x23
ffffffffea802498:	9400476e 	bl	ffffffffea814250 <uthread_is_valid_range>
		return ERR_INVALID_ARGS;
	if (!valid_address((vaddr_t)p.map_size_ptr, sizeof(uint32_t)))
ffffffffea80249c:	72001c1f 	tst	w0, #0xff
ffffffffea8024a0:	54000aa0 	b.eq	ffffffffea8025f4 <ioctl_map_eks_to_user+0x1e4>  // b.none
		return ERR_INVALID_ARGS;

	status_t ret = NO_ERROR;
	eks_info_t info = {0};
ffffffffea8024a4:	910243a0 	add	x0, x29, #0x90
ffffffffea8024a8:	a9bf7c1f 	stp	xzr, xzr, [x0, #-16]!

	/*
	 * Get eks struct's physical address and length
	 * saved in kernel context
	 */
	ret = get_and_clear_eks_info(&info);
ffffffffea8024ac:	97fffe03 	bl	ffffffffea801cb8 <get_and_clear_eks_info>
ffffffffea8024b0:	2a0003f8 	mov	w24, w0
	if (ret != NO_ERROR) {
ffffffffea8024b4:	350008a0 	cbnz	w0, ffffffffea8025c8 <ioctl_map_eks_to_user+0x1b8>
		dprintf(CRITICAL, "%s: ERROR: failed to retrieve eks info from kernel\n", __func__);
		return ret;
	}
	if (info.paddr == NULL) {
ffffffffea8024b8:	f94043a0 	ldr	x0, [x29, #128]
ffffffffea8024bc:	b4000aa0 	cbz	x0, ffffffffea802610 <ioctl_map_eks_to_user+0x200>
ffffffffea8024c0:	f9000bb3 	str	x19, [x29, #16]
ffffffffea8024c4:	f90023b9 	str	x25, [x29, #64]
		dprintf(CRITICAL, "%s: ERROR: ioctl called more than once\n", __func__);
		return ERR_NOT_ALLOWED;
	}

	/* map to userspace */
	vaddr_t vaddr = 0U;
ffffffffea8024c8:	f9002fbf 	str	xzr, [x29, #88]
ffffffffea8024cc:	d538d081 	mrs	x1, tpidr_el1
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea8024d0:	f9415821 	ldr	x1, [x1, #688]

	paddr_t paddr = ROUNDDOWN((paddr_t)info.paddr, PAGE_SIZE);
ffffffffea8024d4:	9274cc19 	and	x25, x0, #0xfffffffffffff000
	size_t offset = (paddr_t)info.paddr - paddr;
ffffffffea8024d8:	cb190013 	sub	x19, x0, x25
ffffffffea8024dc:	910243a2 	add	x2, x29, #0x90
	size_t size = ROUNDUP(info.blob_length + offset, PAGE_SIZE);
ffffffffea8024e0:	b9408ba3 	ldr	w3, [x29, #136]
static inline __ALWAYS_INLINE
status_t uthread_map_contig(uthread_t *ut, vaddr_t *vaddrp, paddr_t paddr,
		size_t size, u_int flags, u_int align)
{
	flags = flags | UTM_PHYS_CONTIG;
	return uthread_map(ut, vaddrp, &paddr, size, flags, align);
ffffffffea8024e4:	52820005 	mov	w5, #0x1000                	// #4096
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea8024e8:	f9404820 	ldr	x0, [x1, #144]
ffffffffea8024ec:	52800c24 	mov	w4, #0x61                  	// #97
ffffffffea8024f0:	f81e8c59 	str	x25, [x2, #-24]!
	size_t size = ROUNDUP(info.blob_length + offset, PAGE_SIZE);
ffffffffea8024f4:	913ffc63 	add	x3, x3, #0xfff
ffffffffea8024f8:	8b130063 	add	x3, x3, x19
ffffffffea8024fc:	910163a1 	add	x1, x29, #0x58

	ret = uthread_map_contig(trusty_app->ut, &vaddr,
ffffffffea802500:	f9402c00 	ldr	x0, [x0, #88]
	size_t size = ROUNDUP(info.blob_length + offset, PAGE_SIZE);
ffffffffea802504:	9274cc63 	and	x3, x3, #0xfffffffffffff000
ffffffffea802508:	f90033a3 	str	x3, [x29, #96]
ffffffffea80250c:	9400459f 	bl	ffffffffea813b88 <uthread_map>
ffffffffea802510:	2a0003f8 	mov	w24, w0
			paddr, size,
			(uint32_t)UTM_R | (uint32_t)UTM_NS_MEM,
			UT_MAP_ALIGN_4KB);

	if (ret != NO_ERROR) {
ffffffffea802514:	350003c0 	cbnz	w0, ffffffffea80258c <ioctl_map_eks_to_user+0x17c>
		dprintf(CRITICAL, "%s error: failed to map eks physical address: %x, %u\n", __func__,
			(unsigned int)paddr, (unsigned int)size);
		return ret;
	}

	key_params* keys_params = (key_params *)(vaddr + offset);
ffffffffea802518:	f9402fa4 	ldr	x4, [x29, #88]
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea80251c:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802520:	9101a3a1 	add	x1, x29, #0x68
ffffffffea802524:	2a1403e0 	mov	w0, w20
ffffffffea802528:	8b040263 	add	x3, x19, x4
	vaddr_t key_string_addr = (vaddr_t)keys_params->encrypted_keys;
	vaddr_t key_size = keys_params->encrypted_key_sz;
ffffffffea80252c:	b8646a64 	ldr	w4, [x19, x4]
	vaddr_t key_string_addr = (vaddr_t)keys_params->encrypted_keys;
ffffffffea802530:	8b020063 	add	x3, x3, x2
	vaddr_t key_size = keys_params->encrypted_key_sz;
ffffffffea802534:	a90693a3 	stp	x3, x4, [x29, #104]
ffffffffea802538:	9400444c 	bl	ffffffffea813668 <arch_copy_to_user>
ffffffffea80253c:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802540:	9101c3a1 	add	x1, x29, #0x70
ffffffffea802544:	2a1603e0 	mov	w0, w22
ffffffffea802548:	94004448 	bl	ffffffffea813668 <arch_copy_to_user>
ffffffffea80254c:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802550:	910163a1 	add	x1, x29, #0x58
ffffffffea802554:	2a1503e0 	mov	w0, w21
ffffffffea802558:	94004444 	bl	ffffffffea813668 <arch_copy_to_user>
ffffffffea80255c:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802560:	910183a1 	add	x1, x29, #0x60
ffffffffea802564:	2a1703e0 	mov	w0, w23
ffffffffea802568:	94004440 	bl	ffffffffea813668 <arch_copy_to_user>
ffffffffea80256c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea802570:	f94023b9 	ldr	x25, [x29, #64]
	copy_to_user((user_addr_t)p.eks_size_ptr, &key_size, sizeof(uint32_t));
	copy_to_user((user_addr_t)p.map_addr_ptr, &vaddr, sizeof(uint32_t));
	copy_to_user((user_addr_t)p.map_size_ptr, &size, sizeof(uint32_t));

	return NO_ERROR;
}
ffffffffea802574:	2a1803e0 	mov	w0, w24
ffffffffea802578:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea80257c:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea802580:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea802584:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea802588:	d65f03c0 	ret
		dprintf(CRITICAL, "%s error: failed to map eks physical address: %x, %u\n", __func__,
ffffffffea80258c:	b94063a3 	ldr	w3, [x29, #96]
ffffffffea802590:	2a1903e2 	mov	w2, w25
ffffffffea802594:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802598:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80259c:	91144021 	add	x1, x1, #0x510
ffffffffea8025a0:	91162000 	add	x0, x0, #0x588
ffffffffea8025a4:	94003c9b 	bl	ffffffffea811810 <_dprintf>
		return ret;
ffffffffea8025a8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8025ac:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea8025b0:	2a1803e0 	mov	w0, w24
ffffffffea8025b4:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8025b8:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea8025bc:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea8025c0:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea8025c4:	d65f03c0 	ret
		dprintf(CRITICAL, "%s: ERROR: failed to retrieve eks info from kernel\n", __func__);
ffffffffea8025c8:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8025cc:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8025d0:	91144021 	add	x1, x1, #0x510
ffffffffea8025d4:	9114a000 	add	x0, x0, #0x528
ffffffffea8025d8:	94003c8e 	bl	ffffffffea811810 <_dprintf>
}
ffffffffea8025dc:	2a1803e0 	mov	w0, w24
ffffffffea8025e0:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea8025e4:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8025e8:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea8025ec:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea8025f0:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea8025f4:	128000f8 	mov	w24, #0xfffffff8            	// #-8
}
ffffffffea8025f8:	2a1803e0 	mov	w0, w24
ffffffffea8025fc:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea802600:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea802604:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea802608:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80260c:	d65f03c0 	ret
		dprintf(CRITICAL, "%s: ERROR: ioctl called more than once\n", __func__);
ffffffffea802610:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802614:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802618:	91144021 	add	x1, x1, #0x510
		return ERR_NOT_ALLOWED;
ffffffffea80261c:	12800218 	mov	w24, #0xffffffef            	// #-17
		dprintf(CRITICAL, "%s: ERROR: ioctl called more than once\n", __func__);
ffffffffea802620:	91158000 	add	x0, x0, #0x560
ffffffffea802624:	94003c7b 	bl	ffffffffea811810 <_dprintf>
		return ERR_NOT_ALLOWED;
ffffffffea802628:	17ffffd3 	b	ffffffffea802574 <ioctl_map_eks_to_user+0x164>
ffffffffea80262c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802630 <sys_std_platform_ioctl_partner>:
}

int32_t sys_std_platform_ioctl_partner(uint32_t fd, uint32_t cmd, user_addr_t user_ptr);

int32_t __WEAK sys_std_platform_ioctl_partner(uint32_t fd, uint32_t cmd, user_addr_t user_ptr)
{
ffffffffea802630:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	dprintf(ALWAYS, "Unsupported IOCTL request: %d\n", cmd);
ffffffffea802634:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802638:	9117e000 	add	x0, x0, #0x5f8
{
ffffffffea80263c:	910003fd 	mov	x29, sp
	dprintf(ALWAYS, "Unsupported IOCTL request: %d\n", cmd);
ffffffffea802640:	94003c74 	bl	ffffffffea811810 <_dprintf>
	return ERR_NOT_SUPPORTED;
}
ffffffffea802644:	128002e0 	mov	w0, #0xffffffe8            	// #-24
ffffffffea802648:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80264c:	d65f03c0 	ret

ffffffffea802650 <sys_std_platform_ioctl>:

int32_t sys_std_platform_ioctl(uint32_t fd, uint32_t cmd, user_addr_t user_ptr)
{
ffffffffea802650:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	int32_t ret = 0;
	DEBUG_ASSERT( fd == 3 ); // sys_fd of ioctl

	switch ( cmd ) {
ffffffffea802654:	52800023 	mov	w3, #0x1                   	// #1
ffffffffea802658:	72a40003 	movk	w3, #0x2000, lsl #16
ffffffffea80265c:	6b03003f 	cmp	w1, w3
{
ffffffffea802660:	910003fd 	mov	x29, sp
	switch ( cmd ) {
ffffffffea802664:	540003e1 	b.ne	ffffffffea8026e0 <sys_std_platform_ioctl+0x90>  // b.any
ffffffffea802668:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80266c:	2a0203f3 	mov	w19, w2
ffffffffea802670:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea802674:	f9415800 	ldr	x0, [x0, #688]
ffffffffea802678:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80267c:	2a1303e1 	mov	w1, w19
ffffffffea802680:	940046f4 	bl	ffffffffea814250 <uthread_is_valid_range>
		case IOCTL_MAP_EKS_TO_USER:

			if (!valid_address((vaddr_t)user_ptr,
ffffffffea802684:	72001c1f 	tst	w0, #0xff
ffffffffea802688:	54000141 	b.ne	ffffffffea8026b0 <sys_std_platform_ioctl+0x60>  // b.any
					sizeof(ioctl_map_eks_params))) {
				dprintf(CRITICAL, "%s error: Invalid arguments\n",
ffffffffea80268c:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802690:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802694:	91170021 	add	x1, x1, #0x5c0
ffffffffea802698:	91176000 	add	x0, x0, #0x5d8
ffffffffea80269c:	94003c5d 	bl	ffffffffea811810 <_dprintf>
						__func__);
				return ERR_INVALID_ARGS;
ffffffffea8026a0:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8026a4:	128000e0 	mov	w0, #0xfffffff8            	// #-8

		default:
			ret = sys_std_platform_ioctl_partner(fd, cmd, user_ptr);
        }
	return ret;
}
ffffffffea8026a8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8026ac:	d65f03c0 	ret
			if (!platform_is_bootstrapping()) {
ffffffffea8026b0:	97fffeb2 	bl	ffffffffea802178 <platform_is_bootstrapping>
ffffffffea8026b4:	72001c1f 	tst	w0, #0xff
ffffffffea8026b8:	540001a1 	b.ne	ffffffffea8026ec <sys_std_platform_ioctl+0x9c>  // b.any
				dprintf(CRITICAL, "%s: ERROR: Not allowed after boot\n",
ffffffffea8026bc:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8026c0:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8026c4:	91170021 	add	x1, x1, #0x5c0
ffffffffea8026c8:	9106e000 	add	x0, x0, #0x1b8
ffffffffea8026cc:	94003c51 	bl	ffffffffea811810 <_dprintf>
				return ERR_NOT_ALLOWED;
ffffffffea8026d0:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8026d4:	12800200 	mov	w0, #0xffffffef            	// #-17
}
ffffffffea8026d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8026dc:	d65f03c0 	ret
			ret = sys_std_platform_ioctl_partner(fd, cmd, user_ptr);
ffffffffea8026e0:	97ffffd4 	bl	ffffffffea802630 <sys_std_platform_ioctl_partner>
}
ffffffffea8026e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8026e8:	d65f03c0 	ret
	return arch_copy_from_user(kdest, usrc, len);
ffffffffea8026ec:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea8026f0:	2a1303e1 	mov	w1, w19
ffffffffea8026f4:	910083a0 	add	x0, x29, #0x20
ffffffffea8026f8:	940043e4 	bl	ffffffffea813688 <arch_copy_from_user>
			return ioctl_map_eks_to_user(params);
ffffffffea8026fc:	a94207a0 	ldp	x0, x1, [x29, #32]
ffffffffea802700:	97ffff44 	bl	ffffffffea802410 <ioctl_map_eks_to_user>
ffffffffea802704:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea802708:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80270c:	d65f03c0 	ret

ffffffffea802710 <trusty_hyp_check_guest_pa_valid>:
	(void) buf_pa_start;
	(void) buf_size;
	(void) guest;

	return NO_ERROR;
}
ffffffffea802710:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea802714:	d65f03c0 	ret

ffffffffea802718 <trusty_hyp_check_guest_access>:
{
	(void) guest;
	(void) peer;

	return NO_ERROR;
}
ffffffffea802718:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80271c:	d65f03c0 	ret

ffffffffea802720 <secure_uart_putc>:
{
	return *REG8(uart_base[port] + (reg << 2));
}

static int secure_uart_putc(int port, char c )
{
ffffffffea802720:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea802724:	910003fd 	mov	x29, sp
ffffffffea802728:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80272c:	2a0003f3 	mov	w19, w0
ffffffffea802730:	a9025bf5 	stp	x21, x22, [sp, #32]
	lk_bigtime_t start = current_time_hires();

	while (!(secure_read_uart_reg(port, UART_LSR) & (1<<5))) {
		if (timed_out)
			return -1;
		if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea802734:	d29423f5 	mov	x21, #0xa11f                	// #41247
{
ffffffffea802738:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80273c:	12001c37 	and	w23, w1, #0xff
ffffffffea802740:	f90023f9 	str	x25, [sp, #64]
	lk_bigtime_t start = current_time_hires();
ffffffffea802744:	94000b0f 	bl	ffffffffea805380 <current_time_hires>
ffffffffea802748:	aa0003f6 	mov	x22, x0
ffffffffea80274c:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802750:	910b4000 	add	x0, x0, #0x2d0
ffffffffea802754:	b00002b8 	adrp	x24, ffffffffea857000 <__bss_start>
		if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea802758:	f2a000f5 	movk	x21, #0x7, lsl #16
		if (timed_out)
ffffffffea80275c:	91008714 	add	x20, x24, #0x21
ffffffffea802760:	f873d819 	ldr	x25, [x0, w19, sxtw #3]
ffffffffea802764:	91005333 	add	x19, x25, #0x14
	while (!(secure_read_uart_reg(port, UART_LSR) & (1<<5))) {
ffffffffea802768:	14000007 	b	ffffffffea802784 <secure_uart_putc+0x64>
		if (timed_out)
ffffffffea80276c:	39400280 	ldrb	w0, [x20]
ffffffffea802770:	35000200 	cbnz	w0, ffffffffea8027b0 <secure_uart_putc+0x90>
		if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea802774:	94000b03 	bl	ffffffffea805380 <current_time_hires>
ffffffffea802778:	cb160000 	sub	x0, x0, x22
ffffffffea80277c:	eb15001f 	cmp	x0, x21
ffffffffea802780:	54000268 	b.hi	ffffffffea8027cc <secure_uart_putc+0xac>  // b.pmore
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea802784:	39400260 	ldrb	w0, [x19]
	while (!(secure_read_uart_reg(port, UART_LSR) & (1<<5))) {
ffffffffea802788:	362fff20 	tbz	w0, #5, ffffffffea80276c <secure_uart_putc+0x4c>
	*REG8(uart_base[port] + (reg << 2)) = data;
ffffffffea80278c:	39000337 	strb	w23, [x25]
		}
	}

	timed_out = false;
	secure_write_uart_reg(port, UART_THR, c);
	return 0;
ffffffffea802790:	52800000 	mov	w0, #0x0                   	// #0
	timed_out = false;
ffffffffea802794:	3900871f 	strb	wzr, [x24, #33]
}
ffffffffea802798:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80279c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8027a0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8027a4:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea8027a8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8027ac:	d65f03c0 	ret
			return -1;
ffffffffea8027b0:	12800000 	mov	w0, #0xffffffff            	// #-1
}
ffffffffea8027b4:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea8027b8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8027bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8027c0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8027c4:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8027c8:	d65f03c0 	ret
			timed_out = true;
ffffffffea8027cc:	52800021 	mov	w1, #0x1                   	// #1
			return -1;
ffffffffea8027d0:	12800000 	mov	w0, #0xffffffff            	// #-1
			timed_out = true;
ffffffffea8027d4:	39000281 	strb	w1, [x20]
}
ffffffffea8027d8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8027dc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8027e0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8027e4:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea8027e8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8027ec:	d65f03c0 	ret

ffffffffea8027f0 <secure_platform_dputc>:

	return secure_read_uart_reg(port, UART_RHR);
}

void secure_platform_dputc(char c)
{
ffffffffea8027f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (disable_secure_port || (secure_port == TEGRA_UART_NONE))
ffffffffea8027f4:	d00000a1 	adrp	x1, ffffffffea818000 <_mem_phys_base>
{
ffffffffea8027f8:	910003fd 	mov	x29, sp
ffffffffea8027fc:	f9000bf3 	str	x19, [sp, #16]
ffffffffea802800:	12001c13 	and	w19, w0, #0xff
	if (disable_secure_port || (secure_port == TEGRA_UART_NONE))
ffffffffea802804:	b941a820 	ldr	w0, [x1, #424]
ffffffffea802808:	35000200 	cbnz	w0, ffffffffea802848 <secure_platform_dputc+0x58>
ffffffffea80280c:	f9000fb4 	str	x20, [x29, #24]
ffffffffea802810:	d00000b4 	adrp	x20, ffffffffea818000 <_mem_phys_base>
ffffffffea802814:	b941ae80 	ldr	w0, [x20, #428]
ffffffffea802818:	34000160 	cbz	w0, ffffffffea802844 <secure_platform_dputc+0x54>
		return;

	if (secure_port == TEGRA_COMBUART_ID) {
ffffffffea80281c:	7103f81f 	cmp	w0, #0xfe
ffffffffea802820:	540001a0 	b.eq	ffffffffea802854 <secure_platform_dputc+0x64>  // b.none
		platform_tegra_comb_uart_putc(c);
		return;
	}

	if (c == '\n') {
ffffffffea802824:	71002a7f 	cmp	w19, #0xa
ffffffffea802828:	54000200 	b.eq	ffffffffea802868 <secure_platform_dputc+0x78>  // b.none
		secure_uart_putc(secure_port, '\r');
	} else if (c == '\0') {
ffffffffea80282c:	340000d3 	cbz	w19, ffffffffea802844 <secure_platform_dputc+0x54>
		return;
	}
	secure_uart_putc(secure_port, c);
ffffffffea802830:	2a1303e1 	mov	w1, w19
ffffffffea802834:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea802838:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80283c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	secure_uart_putc(secure_port, c);
ffffffffea802840:	17ffffb8 	b	ffffffffea802720 <secure_uart_putc>
ffffffffea802844:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea802848:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80284c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea802850:	d65f03c0 	ret
		platform_tegra_comb_uart_putc(c);
ffffffffea802854:	2a1303e0 	mov	w0, w19
ffffffffea802858:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea80285c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802860:	a8c27bfd 	ldp	x29, x30, [sp], #32
		platform_tegra_comb_uart_putc(c);
ffffffffea802864:	17fffcfb 	b	ffffffffea801c50 <platform_tegra_comb_uart_putc>
		secure_uart_putc(secure_port, '\r');
ffffffffea802868:	528001a1 	mov	w1, #0xd                   	// #13
ffffffffea80286c:	97ffffad 	bl	ffffffffea802720 <secure_uart_putc>
ffffffffea802870:	b941ae80 	ldr	w0, [x20, #428]
ffffffffea802874:	17ffffef 	b	ffffffffea802830 <secure_platform_dputc+0x40>

ffffffffea802878 <platform_init_secure_port>:
	*c = _c;
	return 0;
}

void platform_init_secure_port(unsigned int dbg_port)
{
ffffffffea802878:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	
	secure_port = dbg_port;
ffffffffea80287c:	d00000a3 	adrp	x3, ffffffffea818000 <_mem_phys_base>
	disable_secure_port = 0;
ffffffffea802880:	d00000a2 	adrp	x2, ffffffffea818000 <_mem_phys_base>
{
ffffffffea802884:	2a0003e1 	mov	w1, w0
ffffffffea802888:	910003fd 	mov	x29, sp
	secure_port = dbg_port;
ffffffffea80288c:	b901ac61 	str	w1, [x3, #428]
	platform_enable_secure_intf();
	dprintf(0, "DEBUG PORT ENABLED with %d\n", secure_port);
ffffffffea802890:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
	disable_secure_port = 0;
ffffffffea802894:	b901a85f 	str	wzr, [x2, #424]
	dprintf(0, "DEBUG PORT ENABLED with %d\n", secure_port);
ffffffffea802898:	910a0000 	add	x0, x0, #0x280
ffffffffea80289c:	94003bdd 	bl	ffffffffea811810 <_dprintf>
	secure_platform_dputc('f');
}
ffffffffea8028a0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	secure_platform_dputc('f');
ffffffffea8028a4:	52800cc0 	mov	w0, #0x66                  	// #102
ffffffffea8028a8:	17ffffd2 	b	ffffffffea8027f0 <secure_platform_dputc>

ffffffffea8028ac <arm64_context_switch>:
#include <arch/asm_macros.h>

/* void arm64_context_switch(vaddr_t *old_sp, vaddr_t new_sp); */
FUNCTION(arm64_context_switch)
    /* save old frame */
    push x28, x29
ffffffffea8028ac:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
    push x26, x27
ffffffffea8028b0:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
    push x24, x25
ffffffffea8028b4:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
    push x22, x23
ffffffffea8028b8:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
    push x20, x21
ffffffffea8028bc:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
    push x18, x19
ffffffffea8028c0:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
    str  x30, [sp,#-8]!
ffffffffea8028c4:	f81f8ffe 	str	x30, [sp, #-8]!

    /* save old sp */
    mov  x15, sp
ffffffffea8028c8:	910003ef 	mov	x15, sp
    str  x15, [x0]
ffffffffea8028cc:	f900000f 	str	x15, [x0]

    /* load new sp */
    mov  sp, x1
ffffffffea8028d0:	9100003f 	mov	sp, x1

    /* restore new frame */
    ldr  x30, [sp], #8
ffffffffea8028d4:	f84087fe 	ldr	x30, [sp], #8
    pop  x18, x19
ffffffffea8028d8:	a8c14ff2 	ldp	x18, x19, [sp], #16
    pop  x20, x21
ffffffffea8028dc:	a8c157f4 	ldp	x20, x21, [sp], #16
    pop  x22, x23
ffffffffea8028e0:	a8c15ff6 	ldp	x22, x23, [sp], #16
    pop  x24, x25
ffffffffea8028e4:	a8c167f8 	ldp	x24, x25, [sp], #16
    pop  x26, x27
ffffffffea8028e8:	a8c16ffa 	ldp	x26, x27, [sp], #16
    pop  x28, x29
ffffffffea8028ec:	a8c177fc 	ldp	x28, x29, [sp], #16

    ret
ffffffffea8028f0:	d65f03c0 	ret

ffffffffea8028f4 <arm64_el3_to_el1>:

FUNCTION(arm64_el3_to_el1)
    /* set EL2 to 64bit */
    mrs x0, scr_el3
ffffffffea8028f4:	d53e1100 	mrs	x0, scr_el3
    orr x0, x0, #(1<<10)
ffffffffea8028f8:	b2760000 	orr	x0, x0, #0x400
    msr scr_el3, x0
ffffffffea8028fc:	d51e1100 	msr	scr_el3, x0

    /* set EL1 to 64bit */
    mov x0, #(1<<31)
ffffffffea802900:	d2b00000 	mov	x0, #0x80000000            	// #2147483648
    msr hcr_el2, x0
ffffffffea802904:	d51c1100 	msr	hcr_el2, x0

    /* disable EL2 coprocessor traps */
    mov x0, #0x33ff
ffffffffea802908:	d2867fe0 	mov	x0, #0x33ff                	// #13311
    msr cptr_el2, x0
ffffffffea80290c:	d51c1140 	msr	cptr_el2, x0

    /* disable EL1 FPU traps */
    mov x0, #(0b11<<20)
ffffffffea802910:	d2a00600 	mov	x0, #0x300000              	// #3145728
    msr cpacr_el1, x0
ffffffffea802914:	d5181040 	msr	cpacr_el1, x0

    /* set up the EL1 bounce interrupt */
    mov x0, sp
ffffffffea802918:	910003e0 	mov	x0, sp
    msr sp_el1, x0
ffffffffea80291c:	d51c4100 	msr	sp_el1, x0

    adr x0, .Ltarget
ffffffffea802920:	10000100 	adr	x0, ffffffffea802940 <arm64_el3_to_el1+0x4c>
    msr elr_el3, x0
ffffffffea802924:	d51e4020 	msr	elr_el3, x0

    mov x0, #((0b1111 << 6) | (0b0101)) /* EL1h runlevel */
ffffffffea802928:	d28078a0 	mov	x0, #0x3c5                 	// #965
    msr spsr_el3, x0
ffffffffea80292c:	d51e4000 	msr	spsr_el3, x0
    isb
ffffffffea802930:	d5033fdf 	isb

    exception_return
ffffffffea802934:	d69f03e0 	eret
ffffffffea802938:	d503379f 	dsb	nsh
ffffffffea80293c:	d5033fdf 	isb

.Ltarget:
    ret
ffffffffea802940:	d65f03c0 	ret

ffffffffea802944 <arch_spin_trylock>:
#include <asm.h>

.text

FUNCTION(arch_spin_trylock)
	mov	x2, x0
ffffffffea802944:	aa0003e2 	mov	x2, x0
	mov	x1, #1
ffffffffea802948:	d2800021 	mov	x1, #0x1                   	// #1
	ldaxr	x0, [x2]
ffffffffea80294c:	c85ffc40 	ldaxr	x0, [x2]
	cbnz	x0, 1f
ffffffffea802950:	b5000040 	cbnz	x0, ffffffffea802958 <arch_spin_trylock+0x14>
	stxr	w0, x1, [x2]
ffffffffea802954:	c8007c41 	stxr	w0, x1, [x2]
1:
	ret
ffffffffea802958:	d65f03c0 	ret

ffffffffea80295c <arch_spin_lock>:

FUNCTION(arch_spin_lock)
	mov	x1, #1
ffffffffea80295c:	d2800021 	mov	x1, #0x1                   	// #1
	sevl
ffffffffea802960:	d50320bf 	sevl
1:
	wfe
ffffffffea802964:	d503205f 	wfe
	ldaxr	x2, [x0]
ffffffffea802968:	c85ffc02 	ldaxr	x2, [x0]
	cbnz	x2, 1b
ffffffffea80296c:	b5ffffc2 	cbnz	x2, ffffffffea802964 <arch_spin_lock+0x8>
	stxr	w2, x1, [x0]
ffffffffea802970:	c8027c01 	stxr	w2, x1, [x0]
	cbnz	w2, 1b
ffffffffea802974:	35ffff82 	cbnz	w2, ffffffffea802964 <arch_spin_lock+0x8>
	ret
ffffffffea802978:	d65f03c0 	ret

ffffffffea80297c <arch_spin_unlock>:

FUNCTION(arch_spin_unlock)
	stlr	xzr, [x0]
ffffffffea80297c:	c89ffc1f 	stlr	xzr, [x0]
	ret
ffffffffea802980:	d65f03c0 	ret

ffffffffea802984 <arch_clean_cache_range>:
    dsb     sy
.endm

    /* void arch_flush_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_cache_range)
    cache_range_op dc cvac         // clean cache to PoC by MVA
ffffffffea802984:	8b010002 	add	x2, x0, x1
ffffffffea802988:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea80298c:	d50b7a23 	dc	cvac, x3
ffffffffea802990:	91008063 	add	x3, x3, #0x20
ffffffffea802994:	eb02007f 	cmp	x3, x2
ffffffffea802998:	54ffffa3 	b.cc	ffffffffea80298c <arch_clean_cache_range+0x8>  // b.lo, b.ul, b.last
ffffffffea80299c:	d5033f9f 	dsb	sy
    ret
ffffffffea8029a0:	d65f03c0 	ret

ffffffffea8029a4 <arch_clean_invalidate_cache_range>:

    /* void arch_flush_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_invalidate_cache_range)
    cache_range_op dc civac        // clean & invalidate dcache to PoC by MVA
ffffffffea8029a4:	8b010002 	add	x2, x0, x1
ffffffffea8029a8:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea8029ac:	d50b7e23 	dc	civac, x3
ffffffffea8029b0:	91008063 	add	x3, x3, #0x20
ffffffffea8029b4:	eb02007f 	cmp	x3, x2
ffffffffea8029b8:	54ffffa3 	b.cc	ffffffffea8029ac <arch_clean_invalidate_cache_range+0x8>  // b.lo, b.ul, b.last
ffffffffea8029bc:	d5033f9f 	dsb	sy
    ret
ffffffffea8029c0:	d65f03c0 	ret

ffffffffea8029c4 <arch_invalidate_cache_range>:

    /* void arch_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_invalidate_cache_range)
    cache_range_op dc ivac         // invalidate dcache to PoC by MVA
ffffffffea8029c4:	8b010002 	add	x2, x0, x1
ffffffffea8029c8:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea8029cc:	d5087623 	dc	ivac, x3
ffffffffea8029d0:	91008063 	add	x3, x3, #0x20
ffffffffea8029d4:	eb02007f 	cmp	x3, x2
ffffffffea8029d8:	54ffffa3 	b.cc	ffffffffea8029cc <arch_invalidate_cache_range+0x8>  // b.lo, b.ul, b.last
ffffffffea8029dc:	d5033f9f 	dsb	sy
    ret
ffffffffea8029e0:	d65f03c0 	ret

    /* void arch_sync_cache_range(addr_t start, size_t len); */
FUNCTION(arch_sync_cache_range)
    cache_range_op dc cvau         // clean dcache to PoU by MVA
ffffffffea8029e4:	8b010002 	add	x2, x0, x1
ffffffffea8029e8:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea8029ec:	d50b7b23 	dc	cvau, x3
ffffffffea8029f0:	91008063 	add	x3, x3, #0x20
ffffffffea8029f4:	eb02007f 	cmp	x3, x2
ffffffffea8029f8:	54ffffa3 	b.cc	ffffffffea8029ec <arch_invalidate_cache_range+0x28>  // b.lo, b.ul, b.last
ffffffffea8029fc:	d5033f9f 	dsb	sy
    cache_range_op ic ivau         // invalidate icache to PoU by MVA
ffffffffea802a00:	8b010002 	add	x2, x0, x1
ffffffffea802a04:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea802a08:	d50b7523 	ic	ivau, x3
ffffffffea802a0c:	91008063 	add	x3, x3, #0x20
ffffffffea802a10:	eb02007f 	cmp	x3, x2
ffffffffea802a14:	54ffffa3 	b.cc	ffffffffea802a08 <arch_invalidate_cache_range+0x44>  // b.lo, b.ul, b.last
ffffffffea802a18:	d5033f9f 	dsb	sy
    ret
ffffffffea802a1c:	d65f03c0 	ret

ffffffffea802a20 <arch_clean_dcache>:

FUNCTION(arch_clean_dcache)
    mrs x9, clidr_el1
ffffffffea802a20:	d5390029 	mrs	x9, clidr_el1
    lsl x3, x0, #LEVEL_SHIFT
ffffffffea802a24:	d37ff803 	lsl	x3, x0, #1
    sub x10, x3, #2
ffffffffea802a28:	d100086a 	sub	x10, x3, #0x2
    mov x0, #DCCSW
ffffffffea802a2c:	d2800040 	mov	x0, #0x2                   	// #2
    bl do_dcsw_op
ffffffffea802a30:	94000002 	bl	ffffffffea802a38 <do_dcsw_op>
    ret
ffffffffea802a34:	d65f03c0 	ret

ffffffffea802a38 <do_dcsw_op>:
	mov	x10, xzr
	b	do_dcsw_op
	.endm

FUNCTION(do_dcsw_op)
	cbz	x3, exit
ffffffffea802a38:	b40003c3 	cbz	x3, ffffffffea802ab0 <exit>
	adr	x14, dcsw_loop_table	// compute inner loop address
ffffffffea802a3c:	100003ce 	adr	x14, ffffffffea802ab4 <dcsw_loop_table>
	add	x14, x14, x0, lsl #5	// inner loop is 8x32-bit instructions
ffffffffea802a40:	8b0015ce 	add	x14, x14, x0, lsl #5
	mov	x0, x9
ffffffffea802a44:	aa0903e0 	mov	x0, x9
	mov	w8, #1
ffffffffea802a48:	52800028 	mov	w8, #0x1                   	// #1

ffffffffea802a4c <loop1>:
loop1:
	add	x2, x10, x10, lsr #1	// work out 3x current cache level
ffffffffea802a4c:	8b4a0542 	add	x2, x10, x10, lsr #1
	lsr	x1, x0, x2		// extract cache type bits from clidr
ffffffffea802a50:	9ac22401 	lsr	x1, x0, x2
	and	x1, x1, #7		// mask the bits for current cache only
ffffffffea802a54:	92400821 	and	x1, x1, #0x7
	cmp	x1, #2			// see what cache we have at this level
ffffffffea802a58:	f100083f 	cmp	x1, #0x2
	b.lt	level_done		// nothing to do if no cache or icache
ffffffffea802a5c:	540001eb 	b.lt	ffffffffea802a98 <level_done>  // b.tstop

	msr	csselr_el1, x10		// select current cache level in csselr
ffffffffea802a60:	d51a000a 	msr	csselr_el1, x10
	isb				// isb to sych the new cssr&csidr
ffffffffea802a64:	d5033fdf 	isb
	mrs	x1, ccsidr_el1		// read the new ccsidr
ffffffffea802a68:	d5390001 	mrs	x1, ccsidr_el1
	and	x2, x1, #7		// extract the length of the cache lines
ffffffffea802a6c:	92400822 	and	x2, x1, #0x7
	add	x2, x2, #4		// add 4 (line length offset)
ffffffffea802a70:	91001042 	add	x2, x2, #0x4
	ubfx	x4, x1, #3, #10		// maximum way number
ffffffffea802a74:	d3433024 	ubfx	x4, x1, #3, #10
	clz	w5, w4			// bit position of way size increment
ffffffffea802a78:	5ac01085 	clz	w5, w4
	lsl	w9, w4, w5		// w9 = aligned max way number
ffffffffea802a7c:	1ac52089 	lsl	w9, w4, w5
	lsl	w16, w8, w5		// w16 = way number loop decrement
ffffffffea802a80:	1ac52110 	lsl	w16, w8, w5
	orr	w9, w10, w9		// w9 = combine way and cache number
ffffffffea802a84:	2a090149 	orr	w9, w10, w9
	ubfx	w6, w1, #13, #15	// w6 = max set number
ffffffffea802a88:	530d6c26 	ubfx	w6, w1, #13, #15
	lsl	w17, w8, w2		// w17 = set number loop decrement
ffffffffea802a8c:	1ac22111 	lsl	w17, w8, w2
	dsb	sy			// barrier before we start this level
ffffffffea802a90:	d5033f9f 	dsb	sy
	br	x14			// jump to DC operation specific loop
ffffffffea802a94:	d61f01c0 	br	x14

ffffffffea802a98 <level_done>:

	b	level_done
	.endm

level_done:
	add	x10, x10, #2		// increment cache number
ffffffffea802a98:	9100094a 	add	x10, x10, #0x2
	cmp	x3, x10
ffffffffea802a9c:	eb0a007f 	cmp	x3, x10
	b.gt    loop1
ffffffffea802aa0:	54fffd6c 	b.gt	ffffffffea802a4c <loop1>
	msr	csselr_el1, xzr		// select cache level 0 in csselr
ffffffffea802aa4:	d51a001f 	msr	csselr_el1, xzr
	dsb	sy			// barrier to complete final cache operation
ffffffffea802aa8:	d5033f9f 	dsb	sy
	isb
ffffffffea802aac:	d5033fdf 	isb

ffffffffea802ab0 <exit>:
exit:
	ret
ffffffffea802ab0:	d65f03c0 	ret

ffffffffea802ab4 <dcsw_loop_table>:

dcsw_loop_table:
	dcsw_loop isw
ffffffffea802ab4:	1ac220c7 	lsl	w7, w6, w2

ffffffffea802ab8 <loop3_isw>:
ffffffffea802ab8:	2a07012b 	orr	w11, w9, w7
ffffffffea802abc:	d508764b 	dc	isw, x11
ffffffffea802ac0:	6b1100e7 	subs	w7, w7, w17
ffffffffea802ac4:	54ffffaa 	b.ge	ffffffffea802ab8 <loop3_isw>  // b.tcont
ffffffffea802ac8:	eb100129 	subs	x9, x9, x16
ffffffffea802acc:	54ffff4a 	b.ge	ffffffffea802ab4 <dcsw_loop_table>  // b.tcont
ffffffffea802ad0:	17fffff2 	b	ffffffffea802a98 <level_done>

ffffffffea802ad4 <loop2_cisw>:
	dcsw_loop cisw
ffffffffea802ad4:	1ac220c7 	lsl	w7, w6, w2

ffffffffea802ad8 <loop3_cisw>:
ffffffffea802ad8:	2a07012b 	orr	w11, w9, w7
ffffffffea802adc:	d5087e4b 	dc	cisw, x11
ffffffffea802ae0:	6b1100e7 	subs	w7, w7, w17
ffffffffea802ae4:	54ffffaa 	b.ge	ffffffffea802ad8 <loop3_cisw>  // b.tcont
ffffffffea802ae8:	eb100129 	subs	x9, x9, x16
ffffffffea802aec:	54ffff4a 	b.ge	ffffffffea802ad4 <loop2_cisw>  // b.tcont
ffffffffea802af0:	17ffffea 	b	ffffffffea802a98 <level_done>

ffffffffea802af4 <loop2_csw>:
	dcsw_loop csw
ffffffffea802af4:	1ac220c7 	lsl	w7, w6, w2

ffffffffea802af8 <loop3_csw>:
ffffffffea802af8:	2a07012b 	orr	w11, w9, w7
ffffffffea802afc:	d5087a4b 	dc	csw, x11
ffffffffea802b00:	6b1100e7 	subs	w7, w7, w17
ffffffffea802b04:	54ffffaa 	b.ge	ffffffffea802af8 <loop3_csw>  // b.tcont
ffffffffea802b08:	eb100129 	subs	x9, x9, x16
ffffffffea802b0c:	54ffff4a 	b.ge	ffffffffea802af4 <loop2_csw>  // b.tcont
ffffffffea802b10:	17ffffe2 	b	ffffffffea802a98 <level_done>

ffffffffea802b14 <dcsw_op_louis>:


FUNCTION(dcsw_op_louis)
	dcsw_op #LOUIS_SHIFT, #CLIDR_FIELD_WIDTH, #LEVEL_SHIFT
ffffffffea802b14:	d5390029 	mrs	x9, clidr_el1
ffffffffea802b18:	d3555d23 	ubfx	x3, x9, #21, #3
ffffffffea802b1c:	d37ff863 	lsl	x3, x3, #1
ffffffffea802b20:	aa1f03ea 	mov	x10, xzr
ffffffffea802b24:	17ffffc5 	b	ffffffffea802a38 <do_dcsw_op>

ffffffffea802b28 <dcsw_op_all>:


FUNCTION(dcsw_op_all)
	dcsw_op #LOC_SHIFT, #CLIDR_FIELD_WIDTH, #LEVEL_SHIFT
ffffffffea802b28:	d5390029 	mrs	x9, clidr_el1
ffffffffea802b2c:	d3586923 	ubfx	x3, x9, #24, #3
ffffffffea802b30:	d37ff863 	lsl	x3, x3, #1
ffffffffea802b34:	aa1f03ea 	mov	x10, xzr
ffffffffea802b38:	17ffffc0 	b	ffffffffea802a38 <do_dcsw_op>

ffffffffea802b3c <dcsw_op_level1>:
	 * The main function, do_dcsw_op requires:
	 * x0: The operation type (0-2), as defined in arch.h
	 * ---------------------------------------------------------------
	 */
FUNCTION(dcsw_op_level1)
	dcsw_op_level #(1 << LEVEL_SHIFT)
ffffffffea802b3c:	d5390029 	mrs	x9, clidr_el1
ffffffffea802b40:	d2800043 	mov	x3, #0x2                   	// #2
ffffffffea802b44:	d100086a 	sub	x10, x3, #0x2
ffffffffea802b48:	17ffffbc 	b	ffffffffea802a38 <do_dcsw_op>

ffffffffea802b4c <dcsw_op_level2>:
	 * The main function, do_dcsw_op requires:
	 * x0: The operation type (0-2), as defined in arch.h
	 * ---------------------------------------------------------------
	 */
FUNCTION(dcsw_op_level2)
	dcsw_op_level #(2 << LEVEL_SHIFT)
ffffffffea802b4c:	d5390029 	mrs	x9, clidr_el1
ffffffffea802b50:	d2800083 	mov	x3, #0x4                   	// #4
ffffffffea802b54:	d100086a 	sub	x10, x3, #0x2
ffffffffea802b58:	17ffffb8 	b	ffffffffea802a38 <do_dcsw_op>

ffffffffea802b5c <dcsw_op_level3>:
	 * The main function, do_dcsw_op requires:
	 * x0: The operation type (0-2), as defined in arch.h
	 * ---------------------------------------------------------------
	 */
FUNCTION(dcsw_op_level3)
	dcsw_op_level #(3 << LEVEL_SHIFT)
ffffffffea802b5c:	d5390029 	mrs	x9, clidr_el1
ffffffffea802b60:	d28000c3 	mov	x3, #0x6                   	// #6
ffffffffea802b64:	d100086a 	sub	x10, x3, #0x2
ffffffffea802b68:	17ffffb4 	b	ffffffffea802a38 <do_dcsw_op>
ffffffffea802b6c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802b70 <arch_curr_cpu_num>:
#endif
/* NV: Move this function from arch\arm64\include\arch\arch_ops.h */
inline uint arch_curr_cpu_num(void)
{
    /* NV: Define plat_arch_curr_cpu_num in platform code */
    return plat_arch_curr_cpu_num();
ffffffffea802b70:	17fffb92 	b	ffffffffea8019b8 <plat_arch_curr_cpu_num>
ffffffffea802b74:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802b78 <arch_early_init>:
}

static void arm64_cpu_early_init(void)
{
    /* set the vector base */
    ARM64_WRITE_SYSREG(VBAR_EL1, (uint64_t)&arm64_exception_base);
ffffffffea802b78:	f0ffffe0 	adrp	x0, ffffffffea801000 <arm64_exception_base>
ffffffffea802b7c:	91000000 	add	x0, x0, #0x0
ffffffffea802b80:	d518c000 	msr	vbar_el1, x0
ffffffffea802b84:	d5033fdf 	isb

    /* switch to EL1 */
    unsigned int current_el = ARM64_READ_SYSREG(CURRENTEL) >> 2;
ffffffffea802b88:	d5384240 	mrs	x0, currentel
ffffffffea802b8c:	d342fc00 	lsr	x0, x0, #2
    if (current_el > 1) {
ffffffffea802b90:	7100041f 	cmp	w0, #0x1
ffffffffea802b94:	540000e9 	b.ls	ffffffffea802bb0 <arch_early_init+0x38>  // b.plast

    arch_enable_fiqs();
}

void arch_early_init(void)
{
ffffffffea802b98:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea802b9c:	910003fd 	mov	x29, sp
        arm64_el3_to_el1();
ffffffffea802ba0:	97ffff55 	bl	ffffffffea8028f4 <arm64_el3_to_el1>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea802ba4:	d50341ff 	msr	daifclr, #0x1
    arm64_cpu_early_init();
    platform_init_mmu_mappings();
}
ffffffffea802ba8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    platform_init_mmu_mappings();
ffffffffea802bac:	17fffbc1 	b	ffffffffea801ab0 <platform_init_mmu_mappings>
ffffffffea802bb0:	d50341ff 	msr	daifclr, #0x1
ffffffffea802bb4:	17fffbbf 	b	ffffffffea801ab0 <platform_init_mmu_mappings>

ffffffffea802bb8 <arch_init>:

void arch_init(void)
{
ffffffffea802bb8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802bbc:	910003fd 	mov	x29, sp
ffffffffea802bc0:	f9000bf3 	str	x19, [sp, #16]
    arch_mp_init_percpu();
ffffffffea802bc4:	940001e9 	bl	ffffffffea803368 <arch_mp_init_percpu>

#if WITH_SMP
    LTRACEF("midr_el1 0x%llx\n", ARM64_READ_SYSREG(midr_el1));

    secondaries_to_init = SMP_MAX_CPUS - 1; /* TODO: get count from somewhere else, or add cpus as they boot */
ffffffffea802bc8:	b00002a0 	adrp	x0, ffffffffea857000 <__bss_start>
ffffffffea802bcc:	528000e1 	mov	w1, #0x7                   	// #7
}

/* interrupts should already be disabled */
static inline void spin_unlock(spin_lock_t *lock)
{
    arch_spin_unlock(lock);
ffffffffea802bd0:	d00000b3 	adrp	x19, ffffffffea818000 <_mem_phys_base>
ffffffffea802bd4:	9106e273 	add	x19, x19, #0x1b8
ffffffffea802bd8:	b9002401 	str	w1, [x0, #36]

    lk_init_secondary_cpus(secondaries_to_init);
ffffffffea802bdc:	b9402400 	ldr	w0, [x0, #36]
ffffffffea802be0:	94000542 	bl	ffffffffea8040e8 <lk_init_secondary_cpus>
ffffffffea802be4:	aa1303e0 	mov	x0, x19
ffffffffea802be8:	97ffff65 	bl	ffffffffea80297c <arch_spin_unlock>

    /* release the secondary cpus */
    spin_unlock(&arm_boot_cpu_lock);

    /* flush the release of the lock, since the secondary cpus are running without cache on */
    arch_clean_cache_range((addr_t)&arm_boot_cpu_lock, sizeof(arm_boot_cpu_lock));
ffffffffea802bec:	aa1303e0 	mov	x0, x19
#endif
}
ffffffffea802bf0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802bf4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    arch_clean_cache_range((addr_t)&arm_boot_cpu_lock, sizeof(arm_boot_cpu_lock));
ffffffffea802bf8:	d2800101 	mov	x1, #0x8                   	// #8
ffffffffea802bfc:	17ffff62 	b	ffffffffea802984 <arch_clean_cache_range>

ffffffffea802c00 <arch_idle>:
{
}

void arch_idle(void)
{
    __asm__ volatile("wfi");
ffffffffea802c00:	d503207f 	wfi
}
ffffffffea802c04:	d65f03c0 	ret

ffffffffea802c08 <arm64_secondary_entry>:
    PANIC_UNIMPLEMENTED;
}

#if WITH_SMP
void arm64_secondary_entry(ulong asm_cpu_num)
{
ffffffffea802c08:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802c0c:	910003fd 	mov	x29, sp
ffffffffea802c10:	f9000bf3 	str	x19, [sp, #16]
ffffffffea802c14:	aa0003f3 	mov	x19, x0
    return plat_arch_curr_cpu_num();
ffffffffea802c18:	97fffb68 	bl	ffffffffea8019b8 <plat_arch_curr_cpu_num>
    uint cpu = arch_curr_cpu_num();
    if (cpu != asm_cpu_num)
ffffffffea802c1c:	eb20427f 	cmp	x19, w0, uxtw
ffffffffea802c20:	54000080 	b.eq	ffffffffea802c30 <arm64_secondary_entry+0x28>  // b.none
    /* we're done, tell the main cpu we're up */
    atomic_add(&secondaries_to_init, -1);
    __asm__ volatile("sev");

    lk_secondary_cpu_entry();
}
ffffffffea802c24:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802c28:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea802c2c:	d65f03c0 	ret
    ARM64_WRITE_SYSREG(VBAR_EL1, (uint64_t)&arm64_exception_base);
ffffffffea802c30:	f0ffffe0 	adrp	x0, ffffffffea801000 <arm64_exception_base>
ffffffffea802c34:	91000000 	add	x0, x0, #0x0
ffffffffea802c38:	d518c000 	msr	vbar_el1, x0
ffffffffea802c3c:	d5033fdf 	isb
    unsigned int current_el = ARM64_READ_SYSREG(CURRENTEL) >> 2;
ffffffffea802c40:	d5384240 	mrs	x0, currentel
ffffffffea802c44:	d342fc00 	lsr	x0, x0, #2
    if (current_el > 1) {
ffffffffea802c48:	7100041f 	cmp	w0, #0x1
ffffffffea802c4c:	54000049 	b.ls	ffffffffea802c54 <arm64_secondary_entry+0x4c>  // b.plast
        arm64_el3_to_el1();
ffffffffea802c50:	97ffff29 	bl	ffffffffea8028f4 <arm64_el3_to_el1>
ffffffffea802c54:	d50341ff 	msr	daifclr, #0x1
    arch_spin_lock(lock);
ffffffffea802c58:	d00000b3 	adrp	x19, ffffffffea818000 <_mem_phys_base>
ffffffffea802c5c:	9106e273 	add	x19, x19, #0x1b8
ffffffffea802c60:	aa1303e0 	mov	x0, x19
ffffffffea802c64:	97ffff3e 	bl	ffffffffea80295c <arch_spin_lock>
    arch_spin_unlock(lock);
ffffffffea802c68:	aa1303e0 	mov	x0, x19
ffffffffea802c6c:	97ffff44 	bl	ffffffffea80297c <arch_spin_unlock>
    lk_init_level(LK_INIT_FLAG_SECONDARY_CPUS, LK_INIT_LEVEL_EARLIEST, LK_INIT_LEVEL_THREADING - 1);
ffffffffea802c70:	52800040 	mov	w0, #0x2                   	// #2
ffffffffea802c74:	12bfff22 	mov	w2, #0x6ffff               	// #458751
ffffffffea802c78:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea802c7c:	9400041d 	bl	ffffffffea803cf0 <lk_init_level>
    arch_mp_init_percpu();
ffffffffea802c80:	940001ba 	bl	ffffffffea803368 <arch_mp_init_percpu>
    return __atomic_fetch_add(ptr, val, __ATOMIC_RELAXED);
ffffffffea802c84:	b00002a0 	adrp	x0, ffffffffea857000 <__bss_start>
ffffffffea802c88:	91009000 	add	x0, x0, #0x24
ffffffffea802c8c:	885f7c01 	ldxr	w1, [x0]
ffffffffea802c90:	51000421 	sub	w1, w1, #0x1
ffffffffea802c94:	88027c01 	stxr	w2, w1, [x0]
ffffffffea802c98:	35ffffa2 	cbnz	w2, ffffffffea802c8c <arm64_secondary_entry+0x84>
    __asm__ volatile("sev");
ffffffffea802c9c:	d503209f 	sev
}
ffffffffea802ca0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802ca4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    lk_secondary_cpu_entry();
ffffffffea802ca8:	140004fa 	b	ffffffffea804090 <lk_secondary_cpu_entry>
ffffffffea802cac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802cb0 <dump_iframe>:
#if HAVE_STACKTRACE
void arm64_print_stacktrace(struct arm64_iframe_long *iframe);
#endif

static void dump_iframe(const struct arm64_iframe_long *iframe)
{
ffffffffea802cb0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802cb4:	910003fd 	mov	x29, sp
ffffffffea802cb8:	f9000bf3 	str	x19, [sp, #16]
ffffffffea802cbc:	aa0003f3 	mov	x19, x0
    printf("iframe %p:\n", iframe);
ffffffffea802cc0:	aa1303e1 	mov	x1, x19
ffffffffea802cc4:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802cc8:	911b6000 	add	x0, x0, #0x6d8
ffffffffea802ccc:	940040b5 	bl	ffffffffea812fa0 <_printf>
    printf("x0  0x%16llx x1  0x%16llx x2  0x%16llx x3  0x%16llx\n", iframe->r[0], iframe->r[1], iframe->r[2], iframe->r[3]);
ffffffffea802cd0:	a9400a61 	ldp	x1, x2, [x19]
ffffffffea802cd4:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802cd8:	a9411263 	ldp	x3, x4, [x19, #16]
ffffffffea802cdc:	911ba000 	add	x0, x0, #0x6e8
ffffffffea802ce0:	940040b0 	bl	ffffffffea812fa0 <_printf>
    printf("x4  0x%16llx x5  0x%16llx x6  0x%16llx x7  0x%16llx\n", iframe->r[4], iframe->r[5], iframe->r[6], iframe->r[7]);
ffffffffea802ce4:	a9420a61 	ldp	x1, x2, [x19, #32]
ffffffffea802ce8:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802cec:	a9431263 	ldp	x3, x4, [x19, #48]
ffffffffea802cf0:	911c8000 	add	x0, x0, #0x720
ffffffffea802cf4:	940040ab 	bl	ffffffffea812fa0 <_printf>
    printf("x8  0x%16llx x9  0x%16llx x10 0x%16llx x11 0x%16llx\n", iframe->r[8], iframe->r[9], iframe->r[10], iframe->r[11]);
ffffffffea802cf8:	a9440a61 	ldp	x1, x2, [x19, #64]
ffffffffea802cfc:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802d00:	a9451263 	ldp	x3, x4, [x19, #80]
ffffffffea802d04:	911d6000 	add	x0, x0, #0x758
ffffffffea802d08:	940040a6 	bl	ffffffffea812fa0 <_printf>
    printf("x12 0x%16llx x13 0x%16llx x14 0x%16llx x15 0x%16llx\n", iframe->r[12], iframe->r[13], iframe->r[14], iframe->r[15]);
ffffffffea802d0c:	a9460a61 	ldp	x1, x2, [x19, #96]
ffffffffea802d10:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802d14:	a9471263 	ldp	x3, x4, [x19, #112]
ffffffffea802d18:	911e4000 	add	x0, x0, #0x790
ffffffffea802d1c:	940040a1 	bl	ffffffffea812fa0 <_printf>
    printf("x16 0x%16llx x17 0x%16llx x18 0x%16llx x19 0x%16llx\n", iframe->r[16], iframe->r[17], iframe->r[18], iframe->r[19]);
ffffffffea802d20:	a9480a61 	ldp	x1, x2, [x19, #128]
ffffffffea802d24:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802d28:	a9491263 	ldp	x3, x4, [x19, #144]
ffffffffea802d2c:	911f2000 	add	x0, x0, #0x7c8
ffffffffea802d30:	9400409c 	bl	ffffffffea812fa0 <_printf>
    printf("x20 0x%16llx x21 0x%16llx x22 0x%16llx x23 0x%16llx\n", iframe->r[20], iframe->r[21], iframe->r[22], iframe->r[23]);
ffffffffea802d34:	a94a0a61 	ldp	x1, x2, [x19, #160]
ffffffffea802d38:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802d3c:	a94b1263 	ldp	x3, x4, [x19, #176]
ffffffffea802d40:	91200000 	add	x0, x0, #0x800
ffffffffea802d44:	94004097 	bl	ffffffffea812fa0 <_printf>
    printf("x24 0x%16llx x25 0x%16llx x26 0x%16llx x27 0x%16llx\n", iframe->r[24], iframe->r[25], iframe->r[26], iframe->r[27]);
ffffffffea802d48:	a94c0a61 	ldp	x1, x2, [x19, #192]
ffffffffea802d4c:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802d50:	a94d1263 	ldp	x3, x4, [x19, #208]
ffffffffea802d54:	9120e000 	add	x0, x0, #0x838
ffffffffea802d58:	94004092 	bl	ffffffffea812fa0 <_printf>
    printf("x28 0x%16llx x29 0x%16llx lr  0x%16llx sp  0x%16llx\n", iframe->r[28], iframe->r[29], iframe->r[30], iframe->r[31]);
ffffffffea802d5c:	a94e0a61 	ldp	x1, x2, [x19, #224]
ffffffffea802d60:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802d64:	a94f1263 	ldp	x3, x4, [x19, #240]
ffffffffea802d68:	9121c000 	add	x0, x0, #0x870
ffffffffea802d6c:	9400408d 	bl	ffffffffea812fa0 <_printf>
    printf("elr 0x%16llx\n", iframe->elr);
ffffffffea802d70:	f9408261 	ldr	x1, [x19, #256]
ffffffffea802d74:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802d78:	9122a000 	add	x0, x0, #0x8a8
ffffffffea802d7c:	94004089 	bl	ffffffffea812fa0 <_printf>
    printf("spsr 0x%16llx\n", iframe->spsr);
ffffffffea802d80:	f9408661 	ldr	x1, [x19, #264]
ffffffffea802d84:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
}
ffffffffea802d88:	f9400bf3 	ldr	x19, [sp, #16]
    printf("spsr 0x%16llx\n", iframe->spsr);
ffffffffea802d8c:	9122e000 	add	x0, x0, #0x8b8
}
ffffffffea802d90:	a8c27bfd 	ldp	x29, x30, [sp], #32
    printf("spsr 0x%16llx\n", iframe->spsr);
ffffffffea802d94:	14004083 	b	ffffffffea812fa0 <_printf>

ffffffffea802d98 <arm64_sync_exception>:

void arm64_sync_exception(struct arm64_iframe_long *iframe)
{
ffffffffea802d98:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea802d9c:	910003fd 	mov	x29, sp
ffffffffea802da0:	a90153f3 	stp	x19, x20, [sp, #16]
    struct fault_handler_table_entry *fault_handler;
    uint32_t esr = ARM64_READ_SYSREG(esr_el1);
ffffffffea802da4:	d5385214 	mrs	x20, esr_el1
    uint32_t ec = esr >> 26;
ffffffffea802da8:	531a7e93 	lsr	w19, w20, #26
    uint32_t il = (esr >> 25) & 0x1;
    uint32_t iss = esr & ((1<<24) - 1);

#ifdef WITH_LIB_SYSCALL
    if (ec == 0x15 || ec == 0x11) { // syscall 64/32
ffffffffea802dac:	121d7a61 	and	w1, w19, #0xfffffffb
ffffffffea802db0:	7100443f 	cmp	w1, #0x11
ffffffffea802db4:	540008c0 	b.eq	ffffffffea802ecc <arm64_sync_exception+0x134>  // b.none
        return;
    }
#endif

    /* floating point */
    if (ec == 0x07) {
ffffffffea802db8:	71001e7f 	cmp	w19, #0x7
ffffffffea802dbc:	54000940 	b.eq	ffffffffea802ee4 <arm64_sync_exception+0x14c>  // b.none
ffffffffea802dc0:	f90013b5 	str	x21, [x29, #32]
        arm64_fpu_exception(iframe);
        return;
    }

    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
ffffffffea802dc4:	f0000082 	adrp	x2, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802dc8:	f9001bb7 	str	x23, [x29, #48]
ffffffffea802dcc:	9100c042 	add	x2, x2, #0x30
ffffffffea802dd0:	aa0003f5 	mov	x21, x0
ffffffffea802dd4:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802dd8:	91000004 	add	x4, x0, #0x0
ffffffffea802ddc:	aa1e03f7 	mov	x23, x30
ffffffffea802de0:	eb02009f 	cmp	x4, x2
ffffffffea802de4:	54000242 	b.cs	ffffffffea802e2c <arm64_sync_exception+0x94>  // b.hs, b.nlast
        if (fault_handler->pc == iframe->elr) {
ffffffffea802de8:	f9400000 	ldr	x0, [x0]
ffffffffea802dec:	f94082a5 	ldr	x5, [x21, #256]
ffffffffea802df0:	eb0000bf 	cmp	x5, x0
ffffffffea802df4:	540005e0 	b.eq	ffffffffea802eb0 <arm64_sync_exception+0x118>  // b.none
ffffffffea802df8:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802dfc:	91003c42 	add	x2, x2, #0xf
ffffffffea802e00:	91004000 	add	x0, x0, #0x10
ffffffffea802e04:	cb000042 	sub	x2, x2, x0
ffffffffea802e08:	927cec42 	and	x2, x2, #0xfffffffffffffff0
ffffffffea802e0c:	8b000042 	add	x2, x2, x0
ffffffffea802e10:	14000004 	b	ffffffffea802e20 <arm64_sync_exception+0x88>
ffffffffea802e14:	f8410403 	ldr	x3, [x0], #16
ffffffffea802e18:	eb05007f 	cmp	x3, x5
ffffffffea802e1c:	540004a0 	b.eq	ffffffffea802eb0 <arm64_sync_exception+0x118>  // b.none
    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
ffffffffea802e20:	aa0003e4 	mov	x4, x0
ffffffffea802e24:	eb02001f 	cmp	x0, x2
ffffffffea802e28:	54ffff61 	b.ne	ffffffffea802e14 <arm64_sync_exception+0x7c>  // b.any
ffffffffea802e2c:	f90017b6 	str	x22, [x29, #40]
            iframe->elr = fault_handler->fault_handler;
            return;
        }
    }

    printf("sync_exception\n");
ffffffffea802e30:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>

#if HAVE_STACKTRACE
    printf("-----------------------------------------------\n");
ffffffffea802e34:	f0000096 	adrp	x22, ffffffffea815000 <__fault_handler_table_start>
    printf("sync_exception\n");
ffffffffea802e38:	9118e000 	add	x0, x0, #0x638
    printf("-----------------------------------------------\n");
ffffffffea802e3c:	911922d6 	add	x22, x22, #0x648
    printf("sync_exception\n");
ffffffffea802e40:	94004058 	bl	ffffffffea812fa0 <_printf>
    printf("-----------------------------------------------\n");
ffffffffea802e44:	aa1603e0 	mov	x0, x22
ffffffffea802e48:	94004056 	bl	ffffffffea812fa0 <_printf>
    printf(" [Stack Trace]\n\n");
ffffffffea802e4c:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802e50:	911a0000 	add	x0, x0, #0x680
ffffffffea802e54:	94004053 	bl	ffffffffea812fa0 <_printf>
    arm64_print_stacktrace(iframe);
ffffffffea802e58:	aa1503e0 	mov	x0, x21
ffffffffea802e5c:	94000129 	bl	ffffffffea803300 <arm64_print_stacktrace>
    printf("-----------------------------------------------\n");
ffffffffea802e60:	aa1603e0 	mov	x0, x22
ffffffffea802e64:	9400404f 	bl	ffffffffea812fa0 <_printf>
#endif

    dump_iframe(iframe);
ffffffffea802e68:	aa1503e0 	mov	x0, x21
ffffffffea802e6c:	97ffff91 	bl	ffffffffea802cb0 <dump_iframe>

    printf("ESR 0x%x: ec 0x%x, il 0x%x, iss 0x%x\n", esr, ec, il, iss);
ffffffffea802e70:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802e74:	12005e84 	and	w4, w20, #0xffffff
ffffffffea802e78:	53196683 	ubfx	w3, w20, #25, #1
ffffffffea802e7c:	2a1303e2 	mov	w2, w19
ffffffffea802e80:	2a1403e1 	mov	w1, w20
ffffffffea802e84:	911a6000 	add	x0, x0, #0x698
ffffffffea802e88:	94004046 	bl	ffffffffea812fa0 <_printf>

    if (ec == 0x15) { // syscall
ffffffffea802e8c:	7100567f 	cmp	w19, #0x15
ffffffffea802e90:	54000301 	b.ne	ffffffffea802ef0 <arm64_sync_exception+0x158>  // b.any
        printf("syscall\n");
ffffffffea802e94:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea802e98:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
        return;
    }

    panic("die\n");
}
ffffffffea802e9c:	a94153f3 	ldp	x19, x20, [sp, #16]
        printf("syscall\n");
ffffffffea802ea0:	911b0000 	add	x0, x0, #0x6c0
ffffffffea802ea4:	f9401bb7 	ldr	x23, [x29, #48]
}
ffffffffea802ea8:	a8c47bfd 	ldp	x29, x30, [sp], #64
        printf("syscall\n");
ffffffffea802eac:	1400403d 	b	ffffffffea812fa0 <_printf>
            iframe->elr = fault_handler->fault_handler;
ffffffffea802eb0:	f9400480 	ldr	x0, [x4, #8]
            return;
ffffffffea802eb4:	f9401bb7 	ldr	x23, [x29, #48]
            iframe->elr = fault_handler->fault_handler;
ffffffffea802eb8:	f90082a0 	str	x0, [x21, #256]
}
ffffffffea802ebc:	a94153f3 	ldp	x19, x20, [sp, #16]
            return;
ffffffffea802ec0:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea802ec4:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea802ec8:	d65f03c0 	ret
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea802ecc:	d50341ff 	msr	daifclr, #0x1
        arm64_syscall(iframe);
ffffffffea802ed0:	940041cc 	bl	ffffffffea813600 <arm64_syscall>
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea802ed4:	d50341df 	msr	daifset, #0x1
}
ffffffffea802ed8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea802edc:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea802ee0:	d65f03c0 	ret
ffffffffea802ee4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea802ee8:	a8c47bfd 	ldp	x29, x30, [sp], #64
        arm64_fpu_exception(iframe);
ffffffffea802eec:	14000029 	b	ffffffffea802f90 <arm64_fpu_exception>
    panic("die\n");
ffffffffea802ef0:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802ef4:	aa1703e0 	mov	x0, x23
ffffffffea802ef8:	911b4021 	add	x1, x1, #0x6d0
ffffffffea802efc:	94003ac3 	bl	ffffffffea811a08 <_panic>

ffffffffea802f00 <arm64_invalid_exception>:

void arm64_invalid_exception(struct arm64_iframe_long *iframe, unsigned int which)
{
ffffffffea802f00:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802f04:	910003fd 	mov	x29, sp
ffffffffea802f08:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea802f0c:	aa1e03f3 	mov	x19, x30
ffffffffea802f10:	aa0003f4 	mov	x20, x0
    printf("invalid exception, which 0x%x\n", which);
ffffffffea802f14:	f0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802f18:	91186000 	add	x0, x0, #0x618
ffffffffea802f1c:	94004021 	bl	ffffffffea812fa0 <_printf>
    dump_iframe(iframe);
ffffffffea802f20:	aa1403e0 	mov	x0, x20
ffffffffea802f24:	97ffff63 	bl	ffffffffea802cb0 <dump_iframe>

    panic("die\n");
ffffffffea802f28:	f0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea802f2c:	aa1303e0 	mov	x0, x19
ffffffffea802f30:	911b4021 	add	x1, x1, #0x6d0
ffffffffea802f34:	94003ab5 	bl	ffffffffea811a08 <_panic>

ffffffffea802f38 <arm64_fpu_save_state>:
                     :: "r"(fpstate), "r"(fpstate->fpcr), "r"(fpstate->fpsr));
}

void arm64_fpu_save_state(struct thread *t)
{
    struct fpstate *fpstate = &t->arch.fpstate;
ffffffffea802f38:	91016000 	add	x0, x0, #0x58
    __asm__ volatile("stp     q0, q1, [%2, #(0 * 32)]\n"
ffffffffea802f3c:	ad000400 	stp	q0, q1, [x0]
ffffffffea802f40:	ad010c02 	stp	q2, q3, [x0, #32]
ffffffffea802f44:	ad021404 	stp	q4, q5, [x0, #64]
ffffffffea802f48:	ad031c06 	stp	q6, q7, [x0, #96]
ffffffffea802f4c:	ad042408 	stp	q8, q9, [x0, #128]
ffffffffea802f50:	ad052c0a 	stp	q10, q11, [x0, #160]
ffffffffea802f54:	ad06340c 	stp	q12, q13, [x0, #192]
ffffffffea802f58:	ad073c0e 	stp	q14, q15, [x0, #224]
ffffffffea802f5c:	ad084410 	stp	q16, q17, [x0, #256]
ffffffffea802f60:	ad094c12 	stp	q18, q19, [x0, #288]
ffffffffea802f64:	ad0a5414 	stp	q20, q21, [x0, #320]
ffffffffea802f68:	ad0b5c16 	stp	q22, q23, [x0, #352]
ffffffffea802f6c:	ad0c6418 	stp	q24, q25, [x0, #384]
ffffffffea802f70:	ad0d6c1a 	stp	q26, q27, [x0, #416]
ffffffffea802f74:	ad0e741c 	stp	q28, q29, [x0, #448]
ffffffffea802f78:	ad0f7c1e 	stp	q30, q31, [x0, #480]
ffffffffea802f7c:	d53b4402 	mrs	x2, fpcr
ffffffffea802f80:	d53b4421 	mrs	x1, fpsr
ffffffffea802f84:	b9020002 	str	w2, [x0, #512]
ffffffffea802f88:	b9020401 	str	w1, [x0, #516]
                     "mrs     %1, fpsr\n"
                     : "=r"(fpstate->fpcr), "=r"(fpstate->fpsr)
                     : "r"(fpstate));

    LTRACEF("thread %s, fpcr %x, fpsr %x\n", t->name, fpstate->fpcr, fpstate->fpsr);
}
ffffffffea802f8c:	d65f03c0 	ret

ffffffffea802f90 <arm64_fpu_exception>:

void arm64_fpu_exception(struct arm64_iframe_long *iframe)
{
    uint32_t cpacr = ARM64_READ_SYSREG(cpacr_el1);
ffffffffea802f90:	d5381040 	mrs	x0, cpacr_el1
    if (((cpacr >> 20) & 3) != 3) {
ffffffffea802f94:	53145401 	ubfx	w1, w0, #20, #2
ffffffffea802f98:	71000c3f 	cmp	w1, #0x3
ffffffffea802f9c:	54000540 	b.eq	ffffffffea803044 <arm64_fpu_exception+0xb4>  // b.none
{
ffffffffea802fa0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
        cpacr |= 3 << 20;
ffffffffea802fa4:	320c0400 	orr	w0, w0, #0x300000
{
ffffffffea802fa8:	910003fd 	mov	x29, sp
ffffffffea802fac:	f9000bf3 	str	x19, [sp, #16]
        ARM64_WRITE_SYSREG(cpacr_el1, cpacr);
ffffffffea802fb0:	d5181040 	msr	cpacr_el1, x0
ffffffffea802fb4:	d5033fdf 	isb
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea802fb8:	d538d093 	mrs	x19, tpidr_el1
    uint cpu = arch_curr_cpu_num();
ffffffffea802fbc:	97fffeed 	bl	ffffffffea802b70 <arch_curr_cpu_num>
    if (fpstate == current_fpstate[cpu] && fpstate->current_cpu == cpu) {
ffffffffea802fc0:	2a0003e3 	mov	w3, w0
ffffffffea802fc4:	b00002a2 	adrp	x2, ffffffffea857000 <__bss_start>
ffffffffea802fc8:	9100a044 	add	x4, x2, #0x28
    struct fpstate *fpstate = &t->arch.fpstate;
ffffffffea802fcc:	91016261 	add	x1, x19, #0x58
    if (fpstate == current_fpstate[cpu] && fpstate->current_cpu == cpu) {
ffffffffea802fd0:	f8637884 	ldr	x4, [x4, x3, lsl #3]
ffffffffea802fd4:	eb04003f 	cmp	x1, x4
ffffffffea802fd8:	54000380 	b.eq	ffffffffea803048 <arm64_fpu_exception+0xb8>  // b.none
    current_fpstate[cpu] = fpstate;
ffffffffea802fdc:	9100a042 	add	x2, x2, #0x28
    fpstate->current_cpu = cpu;
ffffffffea802fe0:	b9020820 	str	w0, [x1, #520]
    __asm__ volatile("ldp     q0, q1, [%0, #(0 * 32)]\n"
ffffffffea802fe4:	b9420424 	ldr	w4, [x1, #516]
ffffffffea802fe8:	b9420020 	ldr	w0, [x1, #512]
    current_fpstate[cpu] = fpstate;
ffffffffea802fec:	f8237841 	str	x1, [x2, x3, lsl #3]
    __asm__ volatile("ldp     q0, q1, [%0, #(0 * 32)]\n"
ffffffffea802ff0:	ad400420 	ldp	q0, q1, [x1]
ffffffffea802ff4:	ad410c22 	ldp	q2, q3, [x1, #32]
ffffffffea802ff8:	ad421424 	ldp	q4, q5, [x1, #64]
ffffffffea802ffc:	ad431c26 	ldp	q6, q7, [x1, #96]
ffffffffea803000:	ad442428 	ldp	q8, q9, [x1, #128]
ffffffffea803004:	ad452c2a 	ldp	q10, q11, [x1, #160]
ffffffffea803008:	ad46342c 	ldp	q12, q13, [x1, #192]
ffffffffea80300c:	ad473c2e 	ldp	q14, q15, [x1, #224]
ffffffffea803010:	ad484430 	ldp	q16, q17, [x1, #256]
ffffffffea803014:	ad494c32 	ldp	q18, q19, [x1, #288]
ffffffffea803018:	ad4a5434 	ldp	q20, q21, [x1, #320]
ffffffffea80301c:	ad4b5c36 	ldp	q22, q23, [x1, #352]
ffffffffea803020:	ad4c6438 	ldp	q24, q25, [x1, #384]
ffffffffea803024:	ad4d6c3a 	ldp	q26, q27, [x1, #416]
ffffffffea803028:	ad4e743c 	ldp	q28, q29, [x1, #448]
ffffffffea80302c:	ad4f7c3e 	ldp	q30, q31, [x1, #480]
ffffffffea803030:	d51b4400 	msr	fpcr, x0
ffffffffea803034:	d51b4424 	msr	fpsr, x4
        arm64_fpu_load_state(get_current_thread());
        return;
    }
}
ffffffffea803038:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80303c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea803040:	d65f03c0 	ret
ffffffffea803044:	d65f03c0 	ret
    if (fpstate == current_fpstate[cpu] && fpstate->current_cpu == cpu) {
ffffffffea803048:	b9420824 	ldr	w4, [x1, #520]
ffffffffea80304c:	6b04001f 	cmp	w0, w4
ffffffffea803050:	54fffc61 	b.ne	ffffffffea802fdc <arm64_fpu_exception+0x4c>  // b.any
ffffffffea803054:	17fffff9 	b	ffffffffea803038 <arm64_fpu_exception+0xa8>

ffffffffea803058 <initial_thread_func>:

extern void arm64_context_switch(addr_t *old_sp, addr_t new_sp);

static void initial_thread_func(void) __NO_RETURN;
static void initial_thread_func(void)
{
ffffffffea803058:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80305c:	910003fd 	mov	x29, sp
ffffffffea803060:	f9000bf3 	str	x19, [sp, #16]
ffffffffea803064:	d538d093 	mrs	x19, tpidr_el1
ffffffffea803068:	b00002c0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea80306c:	912ea000 	add	x0, x0, #0xba8
ffffffffea803070:	97fffe43 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea803074:	d50342ff 	msr	daifclr, #0x2

    /* release the thread lock that was implicitly held across the reschedule */
    spin_unlock(&thread_lock);
    arch_enable_ints();

    ret = current_thread->entry(current_thread->arg);
ffffffffea803078:	f9413e61 	ldr	x1, [x19, #632]
ffffffffea80307c:	f9414260 	ldr	x0, [x19, #640]
ffffffffea803080:	d63f0020 	blr	x1

    LTRACEF("initial_thread_func: thread %p exiting with %d\n", current_thread, ret);

    thread_exit(ret);
ffffffffea803084:	94000f95 	bl	ffffffffea806ed8 <thread_exit>

ffffffffea803088 <arch_thread_initialize>:
}

void arch_thread_initialize(thread_t *t)
{
ffffffffea803088:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!

    struct context_switch_frame *frame = (struct context_switch_frame *)(stack_top);
    frame--;

    // fill it in
    memset(frame, 0, sizeof(*frame));
ffffffffea80308c:	d2800d02 	mov	x2, #0x68                  	// #104
ffffffffea803090:	52800001 	mov	w1, #0x0                   	// #0
{
ffffffffea803094:	910003fd 	mov	x29, sp
ffffffffea803098:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80309c:	aa0003f4 	mov	x20, x0
    vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
ffffffffea8030a0:	f9413413 	ldr	x19, [x0, #616]
ffffffffea8030a4:	f9413800 	ldr	x0, [x0, #624]
{
ffffffffea8030a8:	f90013f5 	str	x21, [sp, #32]
    vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
ffffffffea8030ac:	8b000273 	add	x19, x19, x0
    stack_top = ROUNDDOWN(stack_top, 16);
ffffffffea8030b0:	927cee73 	and	x19, x19, #0xfffffffffffffff0
    frame--;
ffffffffea8030b4:	d101a275 	sub	x21, x19, #0x68
    memset(frame, 0, sizeof(*frame));
ffffffffea8030b8:	aa1503e0 	mov	x0, x21
ffffffffea8030bc:	940040b5 	bl	ffffffffea813390 <memset>
    frame->lr = (vaddr_t)&initial_thread_func;
ffffffffea8030c0:	90000000 	adrp	x0, ffffffffea803000 <arm64_fpu_exception+0x70>
ffffffffea8030c4:	91016000 	add	x0, x0, #0x58
ffffffffea8030c8:	f8198260 	stur	x0, [x19, #-104]

    /* Set this to enable OS stack traces on exceptions */
    extern vaddr_t arch_stack_trace_epoch;
    arch_stack_trace_epoch = (vaddr_t)&initial_thread_func;
ffffffffea8030cc:	d00002c1 	adrp	x1, ffffffffea85d000 <rb_data+0x18>

    // set the stack pointer
    t->arch.sp = (vaddr_t)frame;
ffffffffea8030d0:	f9002a95 	str	x21, [x20, #80]
    arch_stack_trace_epoch = (vaddr_t)&initial_thread_func;
ffffffffea8030d4:	f9001c20 	str	x0, [x1, #56]
}
ffffffffea8030d8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8030dc:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8030e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8030e4:	d65f03c0 	ret

ffffffffea8030e8 <arch_context_switch>:

void arch_context_switch(thread_t *oldthread, thread_t *newthread)
{
ffffffffea8030e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8030ec:	910003fd 	mov	x29, sp
ffffffffea8030f0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8030f4:	aa0003f4 	mov	x20, x0
ffffffffea8030f8:	f90013f5 	str	x21, [sp, #32]
ffffffffea8030fc:	aa0103f5 	mov	x21, x1
void arm64_fpu_exception(struct arm64_iframe_long *iframe);
void arm64_fpu_save_state(struct thread *thread);

static inline void arm64_fpu_pre_context_switch(struct thread *thread)
{
    uint32_t cpacr = ARM64_READ_SYSREG(cpacr_el1);
ffffffffea803100:	d5381053 	mrs	x19, cpacr_el1
    if ((cpacr >> 20) & 3) {
ffffffffea803104:	720c067f 	tst	w19, #0x300000
ffffffffea803108:	540000a0 	b.eq	ffffffffea80311c <arch_context_switch+0x34>  // b.none
        arm64_fpu_save_state(thread);
ffffffffea80310c:	97ffff8b 	bl	ffffffffea802f38 <arm64_fpu_save_state>
        cpacr &= ~(3 << 20);
ffffffffea803110:	120a7673 	and	w19, w19, #0xffcfffff
        ARM64_WRITE_SYSREG(cpacr_el1, cpacr);
ffffffffea803114:	d5181053 	msr	cpacr_el1, x19
ffffffffea803118:	d5033fdf 	isb
    LTRACEF("old %p (%s), new %p (%s)\n", oldthread, oldthread->name, newthread, newthread->name);
    arm64_fpu_pre_context_switch(oldthread);
#if WITH_SMP
    DSB; /* broadcast tlb operations in case the thread moves to another cpu */
ffffffffea80311c:	d5033f9f 	dsb	sy
#endif
    arm64_context_switch(&oldthread->arch.sp, newthread->arch.sp);
ffffffffea803120:	91014280 	add	x0, x20, #0x50
ffffffffea803124:	f9402aa1 	ldr	x1, [x21, #80]
}
ffffffffea803128:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80312c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea803130:	a8c37bfd 	ldp	x29, x30, [sp], #48
    arm64_context_switch(&oldthread->arch.sp, newthread->arch.sp);
ffffffffea803134:	17fffdde 	b	ffffffffea8028ac <arm64_context_switch>

ffffffffea803138 <arch_print_stacktrace>:
/* For arm64 this is set in arm64/thread.c to the initial_thread_func function */
vaddr_t arch_stack_trace_epoch;
extern vaddr_t arch_stack_trace_epoch;

void arch_print_stacktrace(vaddr_t p_fp, vaddr_t p_sp, vaddr_t p_pc)
{
ffffffffea803138:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80313c:	910003fd 	mov	x29, sp
ffffffffea803140:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea803144:	aa0003f3 	mov	x19, x0
ffffffffea803148:	f90023f9 	str	x25, [sp, #64]
ffffffffea80314c:	aa0203f4 	mov	x20, x2
ffffffffea803150:	aa0103f9 	mov	x25, x1
	uint32_t tcount = 0U;
	vaddr_t fp = p_fp;
	vaddr_t sp = p_sp;
	vaddr_t pc = p_pc;

	if (0UL == pc) {
ffffffffea803154:	b40006c2 	cbz	x2, ffffffffea80322c <arch_print_stacktrace+0xf4>
		dprintf(CRITICAL, "[ PC value zero => potential corruption, tracing anyway ]\n");
	}

	if ((0UL == fp) || (0UL == sp)) {
ffffffffea803158:	f100027f 	cmp	x19, #0x0
ffffffffea80315c:	fa401b24 	ccmp	x25, #0x0, #0x4, ne  // ne = any
ffffffffea803160:	54000720 	b.eq	ffffffffea803244 <arch_print_stacktrace+0x10c>  // b.none
ffffffffea803164:	f9001fb8 	str	x24, [x29, #56]
		dprintf(CRITICAL, "[ => fp=0x%016lX, sp=0x%016lX, pc=0x%016lX ]\n",
			fp, sp, pc);
		goto fail;
	}

	if (0UL == arch_stack_trace_epoch) {
ffffffffea803168:	d00002d8 	adrp	x24, ffffffffea85d000 <rb_data+0x18>
ffffffffea80316c:	f9401f00 	ldr	x0, [x24, #56]
ffffffffea803170:	b4000500 	cbz	x0, ffffffffea803210 <arch_print_stacktrace+0xd8>
ffffffffea803174:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea803178:	aa1903f6 	mov	x22, x25
ffffffffea80317c:	f9001bb7 	str	x23, [x29, #48]
	uint32_t tcount = 0U;
ffffffffea803180:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea803184:	d0000097 	adrp	x23, ffffffffea815000 <__fault_handler_table_start>
		dprintf(CRITICAL, "[ Stack tracing disabled ]\n");
		goto fail;
	}

	while (tcount < MAX_STACK_TRACE_DEPTH) {
		dprintf(CRITICAL, "[ %02u ] => pc: 0x%016lX  sp: 0x%016lX\n", tcount, pc, sp);
ffffffffea803188:	9125c2f7 	add	x23, x23, #0x970
ffffffffea80318c:	1400000f 	b	ffffffffea8031c8 <arch_print_stacktrace+0x90>
		}

		/* ARM-64 stack && frame pointers aligned to 64 bit
		 * boundary, detect simple stack corruption
		 */
		if ((fp & 0xfUL) != 0UL) {
ffffffffea803190:	f2400e7f 	tst	x19, #0xf
ffffffffea803194:	54000801 	b.ne	ffffffffea803294 <arch_print_stacktrace+0x15c>  // b.any
		}

		/* Native Arm-64 instructions are aligned to 32 bit word
		 * boundary, detect simple PC corruption
		 */
		if ((pc & 0x3UL) != 0UL) {
ffffffffea803198:	f240069f 	tst	x20, #0x3
ffffffffea80319c:	54000861 	b.ne	ffffffffea8032a8 <arch_print_stacktrace+0x170>  // b.any
				      pc);
			break;
		}

		sp = fp;
		pc = *REG64(fp+8UL);
ffffffffea8031a0:	f9400660 	ldr	x0, [x19, #8]
ffffffffea8031a4:	aa1303f6 	mov	x22, x19

		if (pc != arch_stack_trace_epoch) {
			pc = pc - 4UL; /* LR = PC at function-call + 4 */
		}

		fp = *REG64(fp);
ffffffffea8031a8:	f9400262 	ldr	x2, [x19]
		if (pc != arch_stack_trace_epoch) {
ffffffffea8031ac:	f9401f14 	ldr	x20, [x24, #56]
			pc = pc - 4UL; /* LR = PC at function-call + 4 */
ffffffffea8031b0:	d1001001 	sub	x1, x0, #0x4
ffffffffea8031b4:	eb14001f 	cmp	x0, x20
ffffffffea8031b8:	9a941034 	csel	x20, x1, x20, ne  // ne = any
	while (tcount < MAX_STACK_TRACE_DEPTH) {
ffffffffea8031bc:	7100cabf 	cmp	w21, #0x32
ffffffffea8031c0:	540007e0 	b.eq	ffffffffea8032bc <arch_print_stacktrace+0x184>  // b.none
		fp = *REG64(fp);
ffffffffea8031c4:	aa0203f3 	mov	x19, x2
		dprintf(CRITICAL, "[ %02u ] => pc: 0x%016lX  sp: 0x%016lX\n", tcount, pc, sp);
ffffffffea8031c8:	2a1503e1 	mov	w1, w21
ffffffffea8031cc:	aa1603e3 	mov	x3, x22
ffffffffea8031d0:	aa1403e2 	mov	x2, x20
ffffffffea8031d4:	aa1703e0 	mov	x0, x23
ffffffffea8031d8:	9400398e 	bl	ffffffffea811810 <_dprintf>
		tcount++;
ffffffffea8031dc:	110006b5 	add	w21, w21, #0x1
		if ((0UL == fp) || (fp < sp)) {
ffffffffea8031e0:	f100027f 	cmp	x19, #0x0
ffffffffea8031e4:	fa5312c2 	ccmp	x22, x19, #0x2, ne  // ne = any
ffffffffea8031e8:	54fffd49 	b.ls	ffffffffea803190 <arch_print_stacktrace+0x58>  // b.plast
	}

	stack_size = sp - p_sp;
ffffffffea8031ec:	cb1902c1 	sub	x1, x22, x25
	if (stack_size >= (uint64_t)ARCH_DEFAULT_STACK_SIZE) {
ffffffffea8031f0:	f13ffc3f 	cmp	x1, #0xfff
ffffffffea8031f4:	54000408 	b.hi	ffffffffea803274 <arch_print_stacktrace+0x13c>  // b.pmore
ffffffffea8031f8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8031fc:	a94363b7 	ldp	x23, x24, [x29, #48]
		dprintf(CRITICAL, "\n [ Configured stack trace depth (%u) exeeded -- trace terminated ]\n",
			      MAX_STACK_TRACE_DEPTH);
	}
fail:
	return;
}
ffffffffea803200:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea803204:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea803208:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80320c:	d65f03c0 	ret
ffffffffea803210:	a94153f3 	ldp	x19, x20, [sp, #16]
		dprintf(CRITICAL, "[ Stack tracing disabled ]\n");
ffffffffea803214:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803218:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80321c:	912a8000 	add	x0, x0, #0xaa0
}
ffffffffea803220:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea803224:	a8c57bfd 	ldp	x29, x30, [sp], #80
		dprintf(CRITICAL, "[ Stack tracing disabled ]\n");
ffffffffea803228:	1400397a 	b	ffffffffea811810 <_dprintf>
		dprintf(CRITICAL, "[ PC value zero => potential corruption, tracing anyway ]\n");
ffffffffea80322c:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803230:	91232000 	add	x0, x0, #0x8c8
ffffffffea803234:	94003977 	bl	ffffffffea811810 <_dprintf>
	if ((0UL == fp) || (0UL == sp)) {
ffffffffea803238:	f100027f 	cmp	x19, #0x0
ffffffffea80323c:	fa401b24 	ccmp	x25, #0x0, #0x4, ne  // ne = any
ffffffffea803240:	54fff921 	b.ne	ffffffffea803164 <arch_print_stacktrace+0x2c>  // b.any
		dprintf(CRITICAL, "[ No frame/stack register values => no stack traces ]\n");
ffffffffea803244:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803248:	91242000 	add	x0, x0, #0x908
ffffffffea80324c:	94003971 	bl	ffffffffea811810 <_dprintf>
		dprintf(CRITICAL, "[ => fp=0x%016lX, sp=0x%016lX, pc=0x%016lX ]\n",
ffffffffea803250:	aa1403e3 	mov	x3, x20
ffffffffea803254:	aa1903e2 	mov	x2, x25
ffffffffea803258:	aa1303e1 	mov	x1, x19
}
ffffffffea80325c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea803260:	a94153f3 	ldp	x19, x20, [sp, #16]
		dprintf(CRITICAL, "[ => fp=0x%016lX, sp=0x%016lX, pc=0x%016lX ]\n",
ffffffffea803264:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
}
ffffffffea803268:	a8c57bfd 	ldp	x29, x30, [sp], #80
		dprintf(CRITICAL, "[ => fp=0x%016lX, sp=0x%016lX, pc=0x%016lX ]\n",
ffffffffea80326c:	91250000 	add	x0, x0, #0x940
ffffffffea803270:	14003968 	b	ffffffffea811810 <_dprintf>
		dprintf(CRITICAL, "\n Using %llu bytes - STACK OVERFLOW !!!\n",
ffffffffea803274:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea803278:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80327c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea803280:	9128a000 	add	x0, x0, #0xa28
}
ffffffffea803284:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea803288:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80328c:	a8c57bfd 	ldp	x29, x30, [sp], #80
		dprintf(CRITICAL, "\n Using %llu bytes - STACK OVERFLOW !!!\n",
ffffffffea803290:	14003960 	b	ffffffffea811810 <_dprintf>
			dprintf(CRITICAL,
ffffffffea803294:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803298:	aa1303e1 	mov	x1, x19
ffffffffea80329c:	91266000 	add	x0, x0, #0x998
ffffffffea8032a0:	9400395c 	bl	ffffffffea811810 <_dprintf>
ffffffffea8032a4:	17ffffd2 	b	ffffffffea8031ec <arch_print_stacktrace+0xb4>
			dprintf(CRITICAL,
ffffffffea8032a8:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8032ac:	aa1403e1 	mov	x1, x20
ffffffffea8032b0:	91278000 	add	x0, x0, #0x9e0
ffffffffea8032b4:	94003957 	bl	ffffffffea811810 <_dprintf>
ffffffffea8032b8:	17ffffcd 	b	ffffffffea8031ec <arch_print_stacktrace+0xb4>
	stack_size = sp - p_sp;
ffffffffea8032bc:	cb190261 	sub	x1, x19, x25
	if (stack_size >= (uint64_t)ARCH_DEFAULT_STACK_SIZE) {
ffffffffea8032c0:	f13ffc3f 	cmp	x1, #0xfff
ffffffffea8032c4:	54000148 	b.hi	ffffffffea8032ec <arch_print_stacktrace+0x1b4>  // b.pmore
		dprintf(CRITICAL, "\n [ Configured stack trace depth (%u) exeeded -- trace terminated ]\n",
ffffffffea8032c8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8032cc:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8032d0:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea8032d4:	52800641 	mov	w1, #0x32                  	// #50
}
ffffffffea8032d8:	a94153f3 	ldp	x19, x20, [sp, #16]
		dprintf(CRITICAL, "\n [ Configured stack trace depth (%u) exeeded -- trace terminated ]\n",
ffffffffea8032dc:	91296000 	add	x0, x0, #0xa58
}
ffffffffea8032e0:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea8032e4:	a8c57bfd 	ldp	x29, x30, [sp], #80
		dprintf(CRITICAL, "\n [ Configured stack trace depth (%u) exeeded -- trace terminated ]\n",
ffffffffea8032e8:	1400394a 	b	ffffffffea811810 <_dprintf>
		dprintf(CRITICAL, "\n Using %llu bytes - STACK OVERFLOW !!!\n",
ffffffffea8032ec:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8032f0:	9128a000 	add	x0, x0, #0xa28
ffffffffea8032f4:	94003947 	bl	ffffffffea811810 <_dprintf>
ffffffffea8032f8:	17fffff4 	b	ffffffffea8032c8 <arch_print_stacktrace+0x190>
ffffffffea8032fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803300 <arm64_print_stacktrace>:

/* Stack tracer for the Arm-64 exception handler */
void arm64_print_stacktrace(const struct arm64_iframe_long *iframe)
{
ffffffffea803300:	aa0003e2 	mov	x2, x0
	vaddr_t fp, sp, pc;

	if (NULL == iframe) {
ffffffffea803304:	b4000080 	cbz	x0, ffffffffea803314 <arm64_print_stacktrace+0x14>

	fp = iframe->r[29];
	sp = iframe->r[31];
	pc = iframe->elr;

	arch_print_stacktrace(fp, sp, pc);
ffffffffea803308:	f9407400 	ldr	x0, [x0, #232]
ffffffffea80330c:	a94f8841 	ldp	x1, x2, [x2, #248]
ffffffffea803310:	17ffff8a 	b	ffffffffea803138 <arch_print_stacktrace>
		dprintf(CRITICAL, "[ No iframe, no stack traces ]\n");
ffffffffea803314:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803318:	912b0000 	add	x0, x0, #0xac0
ffffffffea80331c:	1400393d 	b	ffffffffea811810 <_dprintf>

ffffffffea803320 <arm_ipi_generic_handler>:
enum handler_return arm_ipi_generic_handler(void *arg)
{
    LTRACEF("cpu %u, arg %p\n", arch_curr_cpu_num(), arg);

    return INT_NO_RESCHEDULE;
}
ffffffffea803320:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea803324:	d65f03c0 	ret

ffffffffea803328 <arm_ipi_reschedule_handler>:

enum handler_return arm_ipi_reschedule_handler(void *arg)
{
    LTRACEF("cpu %u, arg %p\n", arch_curr_cpu_num(), arg);

    return mp_mbx_reschedule_irq();
ffffffffea803328:	1400109e 	b	ffffffffea8075a0 <mp_mbx_reschedule_irq>
ffffffffea80332c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803330 <arch_mp_send_ipi>:
    if (target != 0) {
ffffffffea803330:	72001c02 	ands	w2, w0, #0xff
ffffffffea803334:	54000061 	b.ne	ffffffffea803340 <arch_mp_send_ipi+0x10>  // b.any
}
ffffffffea803338:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80333c:	d65f03c0 	ret
{
ffffffffea803340:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea803344:	2a0103e0 	mov	w0, w1
        arm_gic_sgi(gic_ipi_num, ARM_GIC_SGI_FLAG_NS, target);
ffffffffea803348:	11003800 	add	w0, w0, #0xe
ffffffffea80334c:	52800081 	mov	w1, #0x4                   	// #4
{
ffffffffea803350:	910003fd 	mov	x29, sp
        arm_gic_sgi(gic_ipi_num, ARM_GIC_SGI_FLAG_NS, target);
ffffffffea803354:	94000523 	bl	ffffffffea8047e0 <arm_gic_sgi>
}
ffffffffea803358:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80335c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea803360:	d65f03c0 	ret
ffffffffea803364:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803368 <arch_mp_init_percpu>:
}

void arch_mp_init_percpu(void)
{
ffffffffea803368:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    register_int_handler(MP_IPI_GENERIC + GIC_IPI_BASE, &arm_ipi_generic_handler, 0);
ffffffffea80336c:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea803370:	528001c0 	mov	w0, #0xe                   	// #14
ffffffffea803374:	90000001 	adrp	x1, ffffffffea803000 <arm64_fpu_exception+0x70>
{
ffffffffea803378:	910003fd 	mov	x29, sp
    register_int_handler(MP_IPI_GENERIC + GIC_IPI_BASE, &arm_ipi_generic_handler, 0);
ffffffffea80337c:	910c8021 	add	x1, x1, #0x320
ffffffffea803380:	9400045e 	bl	ffffffffea8044f8 <register_int_handler>
    register_int_handler(MP_IPI_RESCHEDULE + GIC_IPI_BASE, &arm_ipi_reschedule_handler, 0);

    //unmask_interrupt(MP_IPI_GENERIC);
    //unmask_interrupt(MP_IPI_RESCHEDULE);
}
ffffffffea803384:	a8c17bfd 	ldp	x29, x30, [sp], #16
    register_int_handler(MP_IPI_RESCHEDULE + GIC_IPI_BASE, &arm_ipi_reschedule_handler, 0);
ffffffffea803388:	90000001 	adrp	x1, ffffffffea803000 <arm64_fpu_exception+0x70>
ffffffffea80338c:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea803390:	910ca021 	add	x1, x1, #0x328
ffffffffea803394:	528001e0 	mov	w0, #0xf                   	// #15
ffffffffea803398:	14000458 	b	ffffffffea8044f8 <register_int_handler>
ffffffffea80339c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8033a0 <arm64_mmu_unmap_pt>:
    paddr_t page_table_paddr;

    LTRACEF("vaddr 0x%lx, vaddr_rel 0x%lx, size 0x%lx, index shift %d, page_size_shift %d, page_table %p\n",
            vaddr, vaddr_rel, size, index_shift, page_size_shift, page_table);

    while (size) {
ffffffffea8033a0:	b4000762 	cbz	x2, ffffffffea80348c <arm64_mmu_unmap_pt+0xec>
{
ffffffffea8033a4:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    int count = 1U << (page_size_shift - 3);
ffffffffea8033a8:	51000c8b 	sub	w11, w4, #0x3
        block_size = 1UL << index_shift;
ffffffffea8033ac:	d2800028 	mov	x8, #0x1                   	// #1
ffffffffea8033b0:	2a0603ea 	mov	w10, w6
    int count = 1U << (page_size_shift - 3);
ffffffffea8033b4:	1acb210b 	lsl	w11, w8, w11
{
ffffffffea8033b8:	910003fd 	mov	x29, sp
ffffffffea8033bc:	5100056c 	sub	w12, w11, #0x1
ffffffffea8033c0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8033c4:	aa0003f6 	mov	x22, x0
ffffffffea8033c8:	d2800100 	mov	x0, #0x8                   	// #8
ffffffffea8033cc:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8033d0:	a90363f7 	stp	x23, x24, [sp, #48]
        block_size = 1UL << index_shift;
ffffffffea8033d4:	9ac32107 	lsl	x7, x8, x3
{
ffffffffea8033d8:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea8033dc:	aa0103f5 	mov	x21, x1
ffffffffea8033e0:	a90573fb 	stp	x27, x28, [sp, #80]
ffffffffea8033e4:	aa1e03f9 	mov	x25, x30
ffffffffea8033e8:	aa0203f4 	mov	x20, x2
ffffffffea8033ec:	2a0303f7 	mov	w23, w3
ffffffffea8033f0:	2a0403fb 	mov	w27, w4
ffffffffea8033f4:	aa0503fc 	mov	x28, x5
        block_mask = block_size - 1;
ffffffffea8033f8:	d10004e9 	sub	x9, x7, #0x1
            page_table[index] = MMU_PTE_DESCRIPTOR_INVALID;
            CF;
            if (asid == MMU_ARM64_GLOBAL_ASID)
                ARM64_TLBI(vaae1is, vaddr >> 12);
            else
                ARM64_TLBI(vae1is, vaddr >> 12 | (vaddr_t)asid << 48);
ffffffffea8033fc:	d3503d4d 	lsl	x13, x10, #48
ffffffffea803400:	8b2c4c0c 	add	x12, x0, w12, uxtw #3
    size_t size = 1U << page_size_shift;
ffffffffea803404:	1ac42108 	lsl	w8, w8, w4
        vaddr_rem = vaddr_rel & block_mask;
ffffffffea803408:	8a15013a 	and	x26, x9, x21
        index = vaddr_rel >> index_shift;
ffffffffea80340c:	9ad726b8 	lsr	x24, x21, x23
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea803410:	cb1a00f3 	sub	x19, x7, x26
ffffffffea803414:	eb14027f 	cmp	x19, x20
        pte = page_table[index];
ffffffffea803418:	f8787b80 	ldr	x0, [x28, x24, lsl #3]
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea80341c:	9a949273 	csel	x19, x19, x20, ls  // ls = plast
        if (index_shift > page_size_shift &&
ffffffffea803420:	6b1b02ff 	cmp	w23, w27
ffffffffea803424:	54000089 	b.ls	ffffffffea803434 <arm64_mmu_unmap_pt+0x94>  // b.plast
            (pte & MMU_PTE_DESCRIPTOR_MASK) == MMU_PTE_L012_DESCRIPTOR_TABLE) {
ffffffffea803428:	92400403 	and	x3, x0, #0x3
        if (index_shift > page_size_shift &&
ffffffffea80342c:	f1000c7f 	cmp	x3, #0x3
ffffffffea803430:	54000300 	b.eq	ffffffffea803490 <arm64_mmu_unmap_pt+0xf0>  // b.none
        } else if (pte) {
ffffffffea803434:	b4000100 	cbz	x0, ffffffffea803454 <arm64_mmu_unmap_pt+0xb4>
            page_table[index] = MMU_PTE_DESCRIPTOR_INVALID;
ffffffffea803438:	f8387b9f 	str	xzr, [x28, x24, lsl #3]
            CF;
ffffffffea80343c:	d34cfec0 	lsr	x0, x22, #12
            if (asid == MMU_ARM64_GLOBAL_ASID)
ffffffffea803440:	3100055f 	cmn	w10, #0x1
ffffffffea803444:	540001e0 	b.eq	ffffffffea803480 <arm64_mmu_unmap_pt+0xe0>  // b.none
                ARM64_TLBI(vae1is, vaddr >> 12 | (vaddr_t)asid << 48);
ffffffffea803448:	aa0001a0 	orr	x0, x13, x0
ffffffffea80344c:	d5088320 	tlbi	vae1is, x0
ffffffffea803450:	d5033fdf 	isb
        } else {
            LTRACEF("pte %p[0x%lx] already clear\n", page_table, index);
        }
        vaddr += chunk_size;
ffffffffea803454:	8b1302d6 	add	x22, x22, x19
        vaddr_rel += chunk_size;
ffffffffea803458:	8b1302b5 	add	x21, x21, x19
    while (size) {
ffffffffea80345c:	eb130294 	subs	x20, x20, x19
ffffffffea803460:	54fffd41 	b.ne	ffffffffea803408 <arm64_mmu_unmap_pt+0x68>  // b.any
        size -= chunk_size;
    }
}
ffffffffea803464:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea803468:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80346c:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea803470:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea803474:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea803478:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea80347c:	d65f03c0 	ret
                ARM64_TLBI(vaae1is, vaddr >> 12);
ffffffffea803480:	d5088360 	tlbi	vaae1is, x0
ffffffffea803484:	d5033fdf 	isb
ffffffffea803488:	17fffff3 	b	ffffffffea803454 <arm64_mmu_unmap_pt+0xb4>
ffffffffea80348c:	d65f03c0 	ret
ffffffffea803490:	b9007ba8 	str	w8, [x29, #120]
            page_table_paddr = pte & MMU_PTE_OUTPUT_ADDR_MASK;
ffffffffea803494:	92748c00 	and	x0, x0, #0xfffffffff000
ffffffffea803498:	a906b3a0 	stp	x0, x12, [x29, #104]
ffffffffea80349c:	b90087ab 	str	w11, [x29, #132]
ffffffffea8034a0:	a9089fa9 	stp	x9, x7, [x29, #136]
ffffffffea8034a4:	a9098fad 	stp	x13, x3, [x29, #152]
ffffffffea8034a8:	b900abaa 	str	w10, [x29, #168]
            next_page_table = paddr_to_kvaddr(page_table_paddr);
ffffffffea8034ac:	940035c1 	bl	ffffffffea810bb0 <paddr_to_kvaddr>
            arm64_mmu_unmap_pt(vaddr, vaddr_rem, chunk_size,
ffffffffea8034b0:	b940abaa 	ldr	w10, [x29, #168]
            next_page_table = paddr_to_kvaddr(page_table_paddr);
ffffffffea8034b4:	aa0003ef 	mov	x15, x0
            arm64_mmu_unmap_pt(vaddr, vaddr_rem, chunk_size,
ffffffffea8034b8:	f94053a3 	ldr	x3, [x29, #160]
ffffffffea8034bc:	aa0f03e5 	mov	x5, x15
ffffffffea8034c0:	2a0a03e6 	mov	w6, w10
ffffffffea8034c4:	b900a3aa 	str	w10, [x29, #160]
ffffffffea8034c8:	4b1b0063 	sub	w3, w3, w27
ffffffffea8034cc:	f90057af 	str	x15, [x29, #168]
ffffffffea8034d0:	aa1603e0 	mov	x0, x22
ffffffffea8034d4:	aa1a03e1 	mov	x1, x26
ffffffffea8034d8:	2a1b03e4 	mov	w4, w27
ffffffffea8034dc:	aa1303e2 	mov	x2, x19
ffffffffea8034e0:	0b170063 	add	w3, w3, w23
ffffffffea8034e4:	97ffffaf 	bl	ffffffffea8033a0 <arm64_mmu_unmap_pt>
            if (chunk_size == block_size ||
ffffffffea8034e8:	a9489fa9 	ldp	x9, x7, [x29, #136]
ffffffffea8034ec:	b9407ba8 	ldr	w8, [x29, #120]
ffffffffea8034f0:	b94087ab 	ldr	w11, [x29, #132]
ffffffffea8034f4:	eb1300ff 	cmp	x7, x19
ffffffffea8034f8:	b940a3aa 	ldr	w10, [x29, #160]
ffffffffea8034fc:	f9403bac 	ldr	x12, [x29, #112]
ffffffffea803500:	f9404fad 	ldr	x13, [x29, #152]
ffffffffea803504:	f94057af 	ldr	x15, [x29, #168]
ffffffffea803508:	54000180 	b.eq	ffffffffea803538 <arm64_mmu_unmap_pt+0x198>  // b.none
    for (i = 0; i < count; i++) {
ffffffffea80350c:	7100017f 	cmp	w11, #0x0
ffffffffea803510:	5400014d 	b.le	ffffffffea803538 <arm64_mmu_unmap_pt+0x198>
        if (pte != MMU_PTE_DESCRIPTOR_INVALID) {
ffffffffea803514:	f94001e0 	ldr	x0, [x15]
ffffffffea803518:	b5fff9e0 	cbnz	x0, ffffffffea803454 <arm64_mmu_unmap_pt+0xb4>
ffffffffea80351c:	910021e0 	add	x0, x15, #0x8
ffffffffea803520:	8b0c01e2 	add	x2, x15, x12
ffffffffea803524:	14000003 	b	ffffffffea803530 <arm64_mmu_unmap_pt+0x190>
ffffffffea803528:	f8408401 	ldr	x1, [x0], #8
ffffffffea80352c:	b5fff941 	cbnz	x1, ffffffffea803454 <arm64_mmu_unmap_pt+0xb4>
    for (i = 0; i < count; i++) {
ffffffffea803530:	eb00005f 	cmp	x2, x0
ffffffffea803534:	54ffffa1 	b.ne	ffffffffea803528 <arm64_mmu_unmap_pt+0x188>  // b.any
                page_table[index] = MMU_PTE_DESCRIPTOR_INVALID;
ffffffffea803538:	f8387b9f 	str	xzr, [x28, x24, lsl #3]
                __asm__ volatile("dmb ishst" ::: "memory");
ffffffffea80353c:	d5033abf 	dmb	ishst
ffffffffea803540:	f9003fac 	str	x12, [x29, #120]
    if (size >= PAGE_SIZE) {
ffffffffea803544:	713ffd1f 	cmp	w8, #0xfff
ffffffffea803548:	2910a3aa 	stp	w10, w8, [x29, #132]
ffffffffea80354c:	b90093ab 	str	w11, [x29, #144]
ffffffffea803550:	a9099fa9 	stp	x9, x7, [x29, #152]
ffffffffea803554:	f90057ad 	str	x13, [x29, #168]
ffffffffea803558:	54000209 	b.ls	ffffffffea803598 <arm64_mmu_unmap_pt+0x1f8>  // b.plast
        page = address_to_page(paddr);
ffffffffea80355c:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea803560:	940033e0 	bl	ffffffffea8104e0 <address_to_page>
        if (!page)
ffffffffea803564:	2950a3aa 	ldp	w10, w8, [x29, #132]
ffffffffea803568:	b94093ab 	ldr	w11, [x29, #144]
ffffffffea80356c:	f9403fac 	ldr	x12, [x29, #120]
ffffffffea803570:	a9499fa9 	ldp	x9, x7, [x29, #152]
ffffffffea803574:	f94057ad 	ldr	x13, [x29, #168]
ffffffffea803578:	b4000200 	cbz	x0, ffffffffea8035b8 <arm64_mmu_unmap_pt+0x218>
ffffffffea80357c:	f9003fac 	str	x12, [x29, #120]
ffffffffea803580:	2910a3aa 	stp	w10, w8, [x29, #132]
ffffffffea803584:	b90093ab 	str	w11, [x29, #144]
ffffffffea803588:	a9099fa9 	stp	x9, x7, [x29, #152]
ffffffffea80358c:	f90057ad 	str	x13, [x29, #168]
        pmm_free_page(page);
ffffffffea803590:	9400350e 	bl	ffffffffea8109c8 <pmm_free_page>
ffffffffea803594:	14000003 	b	ffffffffea8035a0 <arm64_mmu_unmap_pt+0x200>
        heap_free(vaddr);
ffffffffea803598:	aa0f03e0 	mov	x0, x15
ffffffffea80359c:	94003aab 	bl	ffffffffea812048 <heap_free>
ffffffffea8035a0:	2950a3aa 	ldp	w10, w8, [x29, #132]
ffffffffea8035a4:	b94093ab 	ldr	w11, [x29, #144]
ffffffffea8035a8:	f9403fac 	ldr	x12, [x29, #120]
ffffffffea8035ac:	a9499fa9 	ldp	x9, x7, [x29, #152]
ffffffffea8035b0:	f94057ad 	ldr	x13, [x29, #168]
ffffffffea8035b4:	17ffffa8 	b	ffffffffea803454 <arm64_mmu_unmap_pt+0xb4>
            panic("bad page table paddr 0x%lx\n", paddr);
ffffffffea8035b8:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea8035bc:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8035c0:	aa1903e0 	mov	x0, x25
ffffffffea8035c4:	9131e021 	add	x1, x1, #0xc78
ffffffffea8035c8:	94003910 	bl	ffffffffea811a08 <_panic>
ffffffffea8035cc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8035d0 <arch_mmu_query>:
{
ffffffffea8035d0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    if (vaddr < kernel_base) {
ffffffffea8035d4:	92a40003 	mov	x3, #0xffffffffdfffffff    	// #-536870913
ffffffffea8035d8:	eb03001f 	cmp	x0, x3
{
ffffffffea8035dc:	910003fd 	mov	x29, sp
    if (vaddr < kernel_base) {
ffffffffea8035e0:	54000c09 	b.ls	ffffffffea803760 <arch_mmu_query+0x190>  // b.plast
ffffffffea8035e4:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea8035e8:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8035ec:	aa0103f6 	mov	x22, x1
    vaddr_rem = vaddr - kernel_base;
ffffffffea8035f0:	d2a40001 	mov	x1, #0x20000000            	// #536870912
ffffffffea8035f4:	8b010013 	add	x19, x0, x1
        pte = page_table[index];
ffffffffea8035f8:	d0000240 	adrp	x0, ffffffffea84d000 <arm64_kernel_translation_table>
ffffffffea8035fc:	91000000 	add	x0, x0, #0x0
        index = vaddr_rem >> index_shift;
ffffffffea803600:	d355fe61 	lsr	x1, x19, #21
ffffffffea803604:	aa0203f5 	mov	x21, x2
ffffffffea803608:	92405274 	and	x20, x19, #0x1fffff
        pte = page_table[index];
ffffffffea80360c:	f8617801 	ldr	x1, [x0, x1, lsl #3]
        pte_addr = pte & MMU_PTE_OUTPUT_ADDR_MASK;
ffffffffea803610:	92748c20 	and	x0, x1, #0xfffffffff000
        if (descriptor_type == MMU_PTE_DESCRIPTOR_INVALID)
ffffffffea803614:	72000422 	ands	w2, w1, #0x3
ffffffffea803618:	54000460 	b.eq	ffffffffea8036a4 <arch_mmu_query+0xd4>  // b.none
ffffffffea80361c:	f9001bb7 	str	x23, [x29, #48]
        if (descriptor_type == ((index_shift > MMU_KERNEL_PAGE_SIZE_SHIFT) ?
ffffffffea803620:	7100045f 	cmp	w2, #0x1
ffffffffea803624:	aa1e03f7 	mov	x23, x30
ffffffffea803628:	54000180 	b.eq	ffffffffea803658 <arch_mmu_query+0x88>  // b.none
        if (index_shift <= MMU_KERNEL_PAGE_SIZE_SHIFT ||
ffffffffea80362c:	71000c5f 	cmp	w2, #0x3
ffffffffea803630:	540002c1 	b.ne	ffffffffea803688 <arch_mmu_query+0xb8>  // b.any
        page_table = paddr_to_kvaddr(pte_addr);
ffffffffea803634:	9400355f 	bl	ffffffffea810bb0 <paddr_to_kvaddr>
ffffffffea803638:	d34c5261 	ubfx	x1, x19, #12, #9
        vaddr_rem -= (vaddr_t)index << index_shift;
ffffffffea80363c:	cb013294 	sub	x20, x20, x1, lsl #12
        pte = page_table[index];
ffffffffea803640:	f8617801 	ldr	x1, [x0, x1, lsl #3]
        pte_addr = pte & MMU_PTE_OUTPUT_ADDR_MASK;
ffffffffea803644:	92748c20 	and	x0, x1, #0xfffffffff000
        if (descriptor_type == MMU_PTE_DESCRIPTOR_INVALID)
ffffffffea803648:	72000422 	ands	w2, w1, #0x3
ffffffffea80364c:	540002a0 	b.eq	ffffffffea8036a0 <arch_mmu_query+0xd0>  // b.none
        if (descriptor_type == ((index_shift > MMU_KERNEL_PAGE_SIZE_SHIFT) ?
ffffffffea803650:	71000c5f 	cmp	w2, #0x3
ffffffffea803654:	540001a1 	b.ne	ffffffffea803688 <arch_mmu_query+0xb8>  // b.any
    if (paddr)
ffffffffea803658:	b4000076 	cbz	x22, ffffffffea803664 <arch_mmu_query+0x94>
        *paddr = pte_addr + vaddr_rem;
ffffffffea80365c:	8b000294 	add	x20, x20, x0
ffffffffea803660:	f90002d4 	str	x20, [x22]
    if (flags) {
ffffffffea803664:	b40005d5 	cbz	x21, ffffffffea80371c <arch_mmu_query+0x14c>
            *flags |= ARCH_MMU_FLAG_NS;
ffffffffea803668:	121b0020 	and	w0, w1, #0x20
ffffffffea80366c:	b90002a0 	str	w0, [x21]
        switch (pte & MMU_PTE_ATTR_ATTR_INDEX_MASK) {
ffffffffea803670:	927e0822 	and	x2, x1, #0x1c
ffffffffea803674:	f100105f 	cmp	x2, #0x4
ffffffffea803678:	54000660 	b.eq	ffffffffea803744 <arch_mmu_query+0x174>  // b.none
ffffffffea80367c:	f100205f 	cmp	x2, #0x8
ffffffffea803680:	54000200 	b.eq	ffffffffea8036c0 <arch_mmu_query+0xf0>  // b.none
ffffffffea803684:	b40001a2 	cbz	x2, ffffffffea8036b8 <arch_mmu_query+0xe8>
                PANIC_UNIMPLEMENTED;
ffffffffea803688:	d0000082 	adrp	x2, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80368c:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803690:	912b8042 	add	x2, x2, #0xae0
ffffffffea803694:	912dc021 	add	x1, x1, #0xb70
ffffffffea803698:	aa1703e0 	mov	x0, x23
ffffffffea80369c:	940038db 	bl	ffffffffea811a08 <_panic>
ffffffffea8036a0:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea8036a4:	a94153b3 	ldp	x19, x20, [x29, #16]
            return ERR_NOT_FOUND;
ffffffffea8036a8:	12800020 	mov	w0, #0xfffffffe            	// #-2
ffffffffea8036ac:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea8036b0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8036b4:	d65f03c0 	ret
                *flags |= ARCH_MMU_FLAG_UNCACHED;
ffffffffea8036b8:	32000000 	orr	w0, w0, #0x1
ffffffffea8036bc:	b90002a0 	str	w0, [x21]
        switch (pte & MMU_PTE_ATTR_AP_MASK) {
ffffffffea8036c0:	927a0420 	and	x0, x1, #0xc0
ffffffffea8036c4:	f102001f 	cmp	x0, #0x80
ffffffffea8036c8:	54000440 	b.eq	ffffffffea803750 <arch_mmu_query+0x180>  // b.none
ffffffffea8036cc:	f103001f 	cmp	x0, #0xc0
ffffffffea8036d0:	54000320 	b.eq	ffffffffea803734 <arch_mmu_query+0x164>  // b.none
ffffffffea8036d4:	f101001f 	cmp	x0, #0x40
ffffffffea8036d8:	54000081 	b.ne	ffffffffea8036e8 <arch_mmu_query+0x118>  // b.any
                *flags |= ARCH_MMU_FLAG_PERM_USER;
ffffffffea8036dc:	b94002a0 	ldr	w0, [x21]
ffffffffea8036e0:	321e0000 	orr	w0, w0, #0x4
ffffffffea8036e4:	b90002a0 	str	w0, [x21]
        if ((pte & MMU_PTE_ATTR_UXN) && (pte & MMU_PTE_ATTR_PXN)) {
ffffffffea8036e8:	924b0421 	and	x1, x1, #0x60000000000000
ffffffffea8036ec:	d2e00c00 	mov	x0, #0x60000000000000      	// #27021597764222976
ffffffffea8036f0:	eb00003f 	cmp	x1, x0
ffffffffea8036f4:	54000141 	b.ne	ffffffffea80371c <arch_mmu_query+0x14c>  // b.any
            *flags |= ARCH_MMU_FLAG_PERM_NO_EXECUTE;
ffffffffea8036f8:	b94002a1 	ldr	w1, [x21]
    return 0;
ffffffffea8036fc:	52800000 	mov	w0, #0x0                   	// #0
            *flags |= ARCH_MMU_FLAG_PERM_NO_EXECUTE;
ffffffffea803700:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea803704:	321c0021 	orr	w1, w1, #0x10
ffffffffea803708:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80370c:	b90002a1 	str	w1, [x21]
ffffffffea803710:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea803714:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea803718:	d65f03c0 	ret
    return 0;
ffffffffea80371c:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea803720:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea803724:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea803728:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea80372c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea803730:	d65f03c0 	ret
                *flags |= ARCH_MMU_FLAG_PERM_USER | ARCH_MMU_FLAG_PERM_RO;
ffffffffea803734:	b94002a0 	ldr	w0, [x21]
ffffffffea803738:	321e0400 	orr	w0, w0, #0xc
ffffffffea80373c:	b90002a0 	str	w0, [x21]
                break;
ffffffffea803740:	17ffffea 	b	ffffffffea8036e8 <arch_mmu_query+0x118>
                *flags |= ARCH_MMU_FLAG_UNCACHED_DEVICE;
ffffffffea803744:	321f0000 	orr	w0, w0, #0x2
ffffffffea803748:	b90002a0 	str	w0, [x21]
                break;
ffffffffea80374c:	17ffffdd 	b	ffffffffea8036c0 <arch_mmu_query+0xf0>
                *flags |= ARCH_MMU_FLAG_PERM_RO;
ffffffffea803750:	b94002a0 	ldr	w0, [x21]
ffffffffea803754:	321d0000 	orr	w0, w0, #0x8
ffffffffea803758:	b90002a0 	str	w0, [x21]
                break;
ffffffffea80375c:	17ffffe3 	b	ffffffffea8036e8 <arch_mmu_query+0x118>
        TRACEF("vaddr 0x%lx < base 0x%lx\n", vaddr, kernel_base);
ffffffffea803760:	d0000085 	adrp	x5, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803764:	aa0003e3 	mov	x3, x0
ffffffffea803768:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80376c:	b2638be4 	mov	x4, #0xffffffffe0000000    	// #-536870912
ffffffffea803770:	52800d02 	mov	w2, #0x68                  	// #104
ffffffffea803774:	912b8021 	add	x1, x1, #0xae0
ffffffffea803778:	912d20a0 	add	x0, x5, #0xb48
ffffffffea80377c:	94003e09 	bl	ffffffffea812fa0 <_printf>
        return ERR_INVALID_ARGS;
ffffffffea803780:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803784:	17ffffcb 	b	ffffffffea8036b0 <arch_mmu_query+0xe0>

ffffffffea803788 <arm64_mmu_map_pt>:
static int arm64_mmu_map_pt(vaddr_t vaddr_in, vaddr_t vaddr_rel_in,
                            paddr_t paddr_in,
                            size_t size_in, pte_t attrs,
                            uint index_shift, uint page_size_shift,
                            pte_t *page_table, uint asid)
{
ffffffffea803788:	d10383ff 	sub	sp, sp, #0xe0
ffffffffea80378c:	aa0103e8 	mov	x8, x1
ffffffffea803790:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea803794:	910043fd 	add	x29, sp, #0x10
ffffffffea803798:	f90037be 	str	x30, [x29, #104]
ffffffffea80379c:	a90887a3 	stp	x3, x1, [x29, #136]

    LTRACEF("vaddr 0x%lx, vaddr_rel 0x%lx, paddr 0x%lx, size 0x%lx, attrs 0x%llx, index shift %d, page_size_shift %d, page_table %p\n",
            vaddr, vaddr_rel, paddr, size, attrs,
            index_shift, page_size_shift, page_table);

    if ((vaddr_rel | paddr | size) & ((1UL << page_size_shift) - 1)) {
ffffffffea8037a0:	aa030041 	orr	x1, x2, x3
{
ffffffffea8037a4:	f9002ffa 	str	x26, [sp, #88]
    if ((vaddr_rel | paddr | size) & ((1UL << page_size_shift) - 1)) {
ffffffffea8037a8:	aa080021 	orr	x1, x1, x8
{
ffffffffea8037ac:	f9004fa0 	str	x0, [x29, #152]
ffffffffea8037b0:	aa0203fa 	mov	x26, x2
ffffffffea8037b4:	a90b1fa4 	stp	x4, x7, [x29, #176]
    if ((vaddr_rel | paddr | size) & ((1UL << page_size_shift) - 1)) {
ffffffffea8037b8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
ffffffffea8037bc:	9ac62042 	lsl	x2, x2, x6
ffffffffea8037c0:	ea22003f 	bics	xzr, x1, x2
ffffffffea8037c4:	540014c1 	b.ne	ffffffffea803a5c <arm64_mmu_map_pt+0x2d4>  // b.any
        TRACEF("not page aligned\n");
        return ERR_INVALID_ARGS;
    }

    while (size) {
ffffffffea8037c8:	b40012a3 	cbz	x3, ffffffffea803a1c <arm64_mmu_map_pt+0x294>
ffffffffea8037cc:	a9025bb5 	stp	x21, x22, [x29, #32]
        block_size = 1UL << index_shift;
ffffffffea8037d0:	d2800035 	mov	x21, #0x1                   	// #1
ffffffffea8037d4:	a90573bb 	stp	x27, x28, [x29, #80]
    size_t size = 1U << page_size_shift;
ffffffffea8037d8:	1ac622a0 	lsl	w0, w21, w6
    vaddr_t vaddr_rel = vaddr_rel_in;
ffffffffea8037dc:	a948efbc 	ldp	x28, x27, [x29, #136]
    size_t size = 1U << page_size_shift;
ffffffffea8037e0:	f90053a0 	str	x0, [x29, #160]
ffffffffea8037e4:	b900aba0 	str	w0, [x29, #168]
        count = size / PAGE_SIZE;
ffffffffea8037e8:	d34cfc00 	lsr	x0, x0, #12
ffffffffea8037ec:	f90023b9 	str	x25, [x29, #64]
            next_page_table = arm64_mmu_get_page_table(index, page_size_shift,
                                                       page_table);
            if (!next_page_table)
                goto err;

            ret = arm64_mmu_map_pt(vaddr, vaddr_rem, paddr, chunk_size, attrs,
ffffffffea8037f0:	11000cb9 	add	w25, w5, #0x3
        count = size / PAGE_SIZE;
ffffffffea8037f4:	290e03a0 	stp	w0, w0, [x29, #112]
        ret = arch_mmu_query((vaddr_t)vaddr, paddrp, NULL);
ffffffffea8037f8:	aa1c03e0 	mov	x0, x28
ffffffffea8037fc:	a90153b3 	stp	x19, x20, [x29, #16]
        block_size = 1UL << index_shift;
ffffffffea803800:	9ac522b5 	lsl	x21, x21, x5
ffffffffea803804:	a90363b7 	stp	x23, x24, [x29, #48]
            ret = arm64_mmu_map_pt(vaddr, vaddr_rem, paddr, chunk_size, attrs,
ffffffffea803808:	4b060321 	sub	w1, w25, w6
        ret = arch_mmu_query((vaddr_t)vaddr, paddrp, NULL);
ffffffffea80380c:	aa1b03fc 	mov	x28, x27
ffffffffea803810:	2a0603f7 	mov	w23, w6
ffffffffea803814:	2a0503f3 	mov	w19, w5
        block_mask = block_size - 1;
ffffffffea803818:	d10006b6 	sub	x22, x21, #0x1
    vaddr_t vaddr = vaddr_in;
ffffffffea80381c:	f9404fb4 	ldr	x20, [x29, #152]
        ret = arch_mmu_query((vaddr_t)vaddr, paddrp, NULL);
ffffffffea803820:	aa0003fb 	mov	x27, x0
            ret = arm64_mmu_map_pt(vaddr, vaddr_rem, paddr, chunk_size, attrs,
ffffffffea803824:	b900afa1 	str	w1, [x29, #172]
ffffffffea803828:	1400000f 	b	ffffffffea803864 <arm64_mmu_map_pt+0xdc>
                                   page_size_shift, next_page_table, asid);
            if (ret)
                goto err;
        } else {
            pte = page_table[index];
            if (pte) {
ffffffffea80382c:	b5001024 	cbnz	x4, ffffffffea803a30 <arm64_mmu_map_pt+0x2a8>
                TRACEF("page table entry already in use, index 0x%lx, 0x%llx\n",
                       index, pte);
                goto err;
            }

            pte = paddr | attrs;
ffffffffea803830:	f9405ba0 	ldr	x0, [x29, #176]
            if (index_shift > page_size_shift)
                pte |= MMU_PTE_L012_DESCRIPTOR_BLOCK;
ffffffffea803834:	6b1302ff 	cmp	w23, w19
            pte = paddr | attrs;
ffffffffea803838:	aa1a0000 	orr	x0, x0, x26
                pte |= MMU_PTE_L012_DESCRIPTOR_BLOCK;
ffffffffea80383c:	b2400001 	orr	x1, x0, #0x1
ffffffffea803840:	b2400400 	orr	x0, x0, #0x3
ffffffffea803844:	9a812000 	csel	x0, x0, x1, cs  // cs = hs, nlast
            else
                pte |= MMU_PTE_L3_DESCRIPTOR_PAGE;

            LTRACEF("pte %p[0x%lx] = 0x%llx\n", page_table, index, pte);
            page_table[index] = pte;
ffffffffea803848:	f9405fa1 	ldr	x1, [x29, #184]
ffffffffea80384c:	f8397820 	str	x0, [x1, x25, lsl #3]
        }
        vaddr += chunk_size;
ffffffffea803850:	8b180294 	add	x20, x20, x24
        vaddr_rel += chunk_size;
ffffffffea803854:	8b18039c 	add	x28, x28, x24
        paddr += chunk_size;
ffffffffea803858:	8b18035a 	add	x26, x26, x24
    while (size) {
ffffffffea80385c:	eb18037b 	subs	x27, x27, x24
ffffffffea803860:	54000d40 	b.eq	ffffffffea803a08 <arm64_mmu_map_pt+0x280>  // b.none
        vaddr_rem = vaddr_rel & block_mask;
ffffffffea803864:	8a1c02cc 	and	x12, x22, x28
ffffffffea803868:	f9405fa0 	ldr	x0, [x29, #184]
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea80386c:	cb0c02a8 	sub	x8, x21, x12
        index = vaddr_rel >> index_shift;
ffffffffea803870:	9ad32799 	lsr	x25, x28, x19
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea803874:	eb1b011f 	cmp	x8, x27
        if (((vaddr_rel | paddr) & block_mask) ||
ffffffffea803878:	aa1a0381 	orr	x1, x28, x26
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea80387c:	9a9b9118 	csel	x24, x8, x27, ls  // ls = plast
ffffffffea803880:	f8797804 	ldr	x4, [x0, x25, lsl #3]
        if (((vaddr_rel | paddr) & block_mask) ||
ffffffffea803884:	ea16003f 	tst	x1, x22
ffffffffea803888:	54000081 	b.ne	ffffffffea803898 <arm64_mmu_map_pt+0x110>  // b.any
            (chunk_size != block_size) ||
ffffffffea80388c:	eb1802bf 	cmp	x21, x24
ffffffffea803890:	7a5e0a62 	ccmp	w19, #0x1e, #0x2, eq  // eq = none
ffffffffea803894:	54fffcc9 	b.ls	ffffffffea80382c <arm64_mmu_map_pt+0xa4>  // b.plast
    switch (pte & MMU_PTE_DESCRIPTOR_MASK) {
ffffffffea803898:	92400480 	and	x0, x4, #0x3
ffffffffea80389c:	f100041f 	cmp	x0, #0x1
ffffffffea8038a0:	540002c0 	b.eq	ffffffffea8038f8 <arm64_mmu_map_pt+0x170>  // b.none
ffffffffea8038a4:	b4000520 	cbz	x0, ffffffffea803948 <arm64_mmu_map_pt+0x1c0>
ffffffffea8038a8:	f1000c1f 	cmp	x0, #0x3
ffffffffea8038ac:	54000e81 	b.ne	ffffffffea803a7c <arm64_mmu_map_pt+0x2f4>  // b.any
        paddr = pte & MMU_PTE_OUTPUT_ADDR_MASK;
ffffffffea8038b0:	92748c80 	and	x0, x4, #0xfffffffff000
ffffffffea8038b4:	f90043ac 	str	x12, [x29, #128]
ffffffffea8038b8:	f90067a0 	str	x0, [x29, #200]
        return paddr_to_kvaddr(paddr);
ffffffffea8038bc:	940034bd 	bl	ffffffffea810bb0 <paddr_to_kvaddr>
ffffffffea8038c0:	f94043ac 	ldr	x12, [x29, #128]
ffffffffea8038c4:	aa0003e7 	mov	x7, x0
            if (!next_page_table)
ffffffffea8038c8:	b4000187 	cbz	x7, ffffffffea8038f8 <arm64_mmu_map_pt+0x170>
            ret = arm64_mmu_map_pt(vaddr, vaddr_rem, paddr, chunk_size, attrs,
ffffffffea8038cc:	b940afa5 	ldr	w5, [x29, #172]
ffffffffea8038d0:	2a1703e6 	mov	w6, w23
ffffffffea8038d4:	f9405ba4 	ldr	x4, [x29, #176]
ffffffffea8038d8:	aa0c03e1 	mov	x1, x12
ffffffffea8038dc:	b940d3a0 	ldr	w0, [x29, #208]
ffffffffea8038e0:	aa1803e3 	mov	x3, x24
ffffffffea8038e4:	b90003e0 	str	w0, [sp]
ffffffffea8038e8:	aa1a03e2 	mov	x2, x26
ffffffffea8038ec:	aa1403e0 	mov	x0, x20
ffffffffea8038f0:	97ffffa6 	bl	ffffffffea803788 <arm64_mmu_map_pt>
            if (ret)
ffffffffea8038f4:	34fffae0 	cbz	w0, ffffffffea803850 <arm64_mmu_map_pt+0xc8>
ffffffffea8038f8:	aa1b03fc 	mov	x28, x27
    }

    return 0;

err:
    arm64_mmu_unmap_pt(vaddr_in, vaddr_rel_in, size_in - size,
ffffffffea8038fc:	a94887a0 	ldp	x0, x1, [x29, #136]
ffffffffea803900:	2a1703e4 	mov	w4, w23
ffffffffea803904:	b940d3a6 	ldr	w6, [x29, #208]
ffffffffea803908:	2a1303e3 	mov	w3, w19
ffffffffea80390c:	cb1c0002 	sub	x2, x0, x28
ffffffffea803910:	f9404fa0 	ldr	x0, [x29, #152]
ffffffffea803914:	f9405fa5 	ldr	x5, [x29, #184]
ffffffffea803918:	97fffea2 	bl	ffffffffea8033a0 <arm64_mmu_unmap_pt>
                       index_shift, page_size_shift, page_table, asid);
    DSB;
ffffffffea80391c:	d5033f9f 	dsb	sy
    return ERR_GENERIC;
ffffffffea803920:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea803924:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea803928:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80392c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea803930:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea803934:	a94573bb 	ldp	x27, x28, [x29, #80]
}
ffffffffea803938:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea80393c:	f9402ffa 	ldr	x26, [sp, #88]
ffffffffea803940:	910383ff 	add	sp, sp, #0xe0
ffffffffea803944:	d65f03c0 	ret
    if (size >= PAGE_SIZE) {
ffffffffea803948:	b940aba0 	ldr	w0, [x29, #168]
ffffffffea80394c:	713ffc1f 	cmp	w0, #0xfff
ffffffffea803950:	54000329 	b.ls	ffffffffea8039b4 <arm64_mmu_map_pt+0x22c>  // b.plast
        ret = pmm_alloc_contiguous(count, page_size_shift, paddrp, NULL);
ffffffffea803954:	b94073a0 	ldr	w0, [x29, #112]
ffffffffea803958:	2a1703e1 	mov	w1, w23
ffffffffea80395c:	f90043ac 	str	x12, [x29, #128]
ffffffffea803960:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea803964:	910323a2 	add	x2, x29, #0xc8
ffffffffea803968:	94003434 	bl	ffffffffea810a38 <pmm_alloc_contiguous>
        if (ret != count)
ffffffffea80396c:	b94077a1 	ldr	w1, [x29, #116]
ffffffffea803970:	f94043ac 	ldr	x12, [x29, #128]
ffffffffea803974:	6b00003f 	cmp	w1, w0
ffffffffea803978:	540006e1 	b.ne	ffffffffea803a54 <arm64_mmu_map_pt+0x2cc>  // b.any
        vaddr = paddr_to_kvaddr(paddr);
ffffffffea80397c:	f94067a0 	ldr	x0, [x29, #200]
ffffffffea803980:	f9003fac 	str	x12, [x29, #120]
ffffffffea803984:	9400348b 	bl	ffffffffea810bb0 <paddr_to_kvaddr>
ffffffffea803988:	f90043a0 	str	x0, [x29, #128]
        memset(vaddr, MMU_PTE_DESCRIPTOR_INVALID, 1U << page_size_shift);
ffffffffea80398c:	f94053a2 	ldr	x2, [x29, #160]
ffffffffea803990:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea803994:	94003e7f 	bl	ffffffffea813390 <memset>
        __asm__ volatile("dmb ishst" ::: "memory");
ffffffffea803998:	d5033abf 	dmb	ishst
        page_table[index] = pte;
ffffffffea80399c:	f9405fa1 	ldr	x1, [x29, #184]
        pte = paddr | MMU_PTE_L012_DESCRIPTOR_TABLE;
ffffffffea8039a0:	f94067a0 	ldr	x0, [x29, #200]
ffffffffea8039a4:	a9479fac 	ldp	x12, x7, [x29, #120]
ffffffffea8039a8:	b2400400 	orr	x0, x0, #0x3
        page_table[index] = pte;
ffffffffea8039ac:	f8397820 	str	x0, [x1, x25, lsl #3]
ffffffffea8039b0:	17ffffc6 	b	ffffffffea8038c8 <arm64_mmu_map_pt+0x140>
        vaddr = heap_alloc(size, size);
ffffffffea8039b4:	b940aba1 	ldr	w1, [x29, #168]
ffffffffea8039b8:	f94053a0 	ldr	x0, [x29, #160]
ffffffffea8039bc:	f9003fac 	str	x12, [x29, #120]
ffffffffea8039c0:	940038e0 	bl	ffffffffea811d40 <heap_alloc>
        if (!vaddr)
ffffffffea8039c4:	f90043a0 	str	x0, [x29, #128]
ffffffffea8039c8:	b4000460 	cbz	x0, ffffffffea803a54 <arm64_mmu_map_pt+0x2cc>
        ret = arch_mmu_query((vaddr_t)vaddr, paddrp, NULL);
ffffffffea8039cc:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea8039d0:	910323a1 	add	x1, x29, #0xc8
ffffffffea8039d4:	97fffeff 	bl	ffffffffea8035d0 <arch_mmu_query>
        if (ret) {
ffffffffea8039d8:	a9478fac 	ldp	x12, x3, [x29, #120]
ffffffffea8039dc:	34fffd00 	cbz	w0, ffffffffea80397c <arm64_mmu_map_pt+0x1f4>
ffffffffea8039e0:	aa1b03fc 	mov	x28, x27
            heap_free(vaddr);
ffffffffea8039e4:	aa0303e0 	mov	x0, x3
ffffffffea8039e8:	94003998 	bl	ffffffffea812048 <heap_free>
            TRACEF("failed to allocate page table\n");
ffffffffea8039ec:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8039f0:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8039f4:	52801da2 	mov	w2, #0xed                  	// #237
ffffffffea8039f8:	912bc021 	add	x1, x1, #0xaf0
ffffffffea8039fc:	91304000 	add	x0, x0, #0xc10
ffffffffea803a00:	94003d68 	bl	ffffffffea812fa0 <_printf>
ffffffffea803a04:	17ffffbe 	b	ffffffffea8038fc <arm64_mmu_map_pt+0x174>
ffffffffea803a08:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea803a0c:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea803a10:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea803a14:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea803a18:	a94573bb 	ldp	x27, x28, [x29, #80]
    return 0;
ffffffffea803a1c:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea803a20:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea803a24:	f9402ffa 	ldr	x26, [sp, #88]
ffffffffea803a28:	910383ff 	add	sp, sp, #0xe0
ffffffffea803a2c:	d65f03c0 	ret
ffffffffea803a30:	aa1b03fc 	mov	x28, x27
                TRACEF("page table entry already in use, index 0x%lx, 0x%llx\n",
ffffffffea803a34:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803a38:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803a3c:	aa1903e3 	mov	x3, x25
ffffffffea803a40:	528030e2 	mov	w2, #0x187                 	// #391
ffffffffea803a44:	912c4021 	add	x1, x1, #0xb10
ffffffffea803a48:	9130e000 	add	x0, x0, #0xc38
ffffffffea803a4c:	94003d55 	bl	ffffffffea812fa0 <_printf>
                goto err;
ffffffffea803a50:	17ffffab 	b	ffffffffea8038fc <arm64_mmu_map_pt+0x174>
ffffffffea803a54:	aa1b03fc 	mov	x28, x27
ffffffffea803a58:	17ffffe5 	b	ffffffffea8039ec <arm64_mmu_map_pt+0x264>
        TRACEF("not page aligned\n");
ffffffffea803a5c:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803a60:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803a64:	52802d62 	mov	w2, #0x16b                 	// #363
ffffffffea803a68:	912c4021 	add	x1, x1, #0xb10
ffffffffea803a6c:	912fc000 	add	x0, x0, #0xbf0
ffffffffea803a70:	94003d4c 	bl	ffffffffea812fa0 <_printf>
        return ERR_INVALID_ARGS;
ffffffffea803a74:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803a78:	17ffffb0 	b	ffffffffea803938 <arm64_mmu_map_pt+0x1b0>
        PANIC_UNIMPLEMENTED;
ffffffffea803a7c:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea803a80:	d0000082 	adrp	x2, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803a84:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803a88:	912bc042 	add	x2, x2, #0xaf0
ffffffffea803a8c:	912dc021 	add	x1, x1, #0xb70
ffffffffea803a90:	940037de 	bl	ffffffffea811a08 <_panic>
ffffffffea803a94:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803a98 <arm64_mmu_map>:

int arm64_mmu_map(vaddr_t vaddr, paddr_t paddr, size_t size, pte_t attrs,
                  vaddr_t vaddr_base, uint top_size_shift,
                  uint top_index_shift, uint page_size_shift,
                  pte_t *top_page_table, uint asid)
{
ffffffffea803a98:	d10083ff 	sub	sp, sp, #0x20
    int ret;
    vaddr_t vaddr_rel = vaddr - vaddr_base;
    vaddr_t vaddr_rel_max = 1UL << top_size_shift;
ffffffffea803a9c:	d2800028 	mov	x8, #0x1                   	// #1
ffffffffea803aa0:	9ac52108 	lsl	x8, x8, x5
    vaddr_t vaddr_rel = vaddr - vaddr_base;
ffffffffea803aa4:	cb040009 	sub	x9, x0, x4

    LTRACEF("vaddr 0x%lx, paddr 0x%lx, size 0x%lx, attrs 0x%llx, asid 0x%x\n",
            vaddr, paddr, size, attrs, asid);

    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803aa8:	cb020105 	sub	x5, x8, x2
{
ffffffffea803aac:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea803ab0:	910043fd 	add	x29, sp, #0x10
    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803ab4:	eb0900bf 	cmp	x5, x9
{
ffffffffea803ab8:	2a0603e5 	mov	w5, w6
ffffffffea803abc:	2a0703e6 	mov	w6, w7
    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803ac0:	fa422100 	ccmp	x8, x2, #0x0, cs  // cs = hs, nlast
{
ffffffffea803ac4:	f9400ba7 	ldr	x7, [x29, #16]
    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803ac8:	540001a3 	b.cc	ffffffffea803afc <arm64_mmu_map+0x64>  // b.lo, b.ul, b.last
        TRACEF("vaddr 0x%lx, size 0x%lx out of range vaddr 0x%lx, size 0x%lx\n",
               vaddr, size, vaddr_base, vaddr_rel_max);
        return ERR_INVALID_ARGS;
    }

    if (!top_page_table) {
ffffffffea803acc:	b4000327 	cbz	x7, ffffffffea803b30 <arm64_mmu_map+0x98>
        TRACEF("page table is NULL\n");
        return ERR_INVALID_ARGS;
    }

    ret = arm64_mmu_map_pt(vaddr, vaddr_rel, paddr, size, attrs,
ffffffffea803ad0:	b9401ba4 	ldr	w4, [x29, #24]
ffffffffea803ad4:	b90003e4 	str	w4, [sp]
ffffffffea803ad8:	aa0303e4 	mov	x4, x3
ffffffffea803adc:	aa0203e3 	mov	x3, x2
ffffffffea803ae0:	aa0103e2 	mov	x2, x1
ffffffffea803ae4:	aa0903e1 	mov	x1, x9
ffffffffea803ae8:	97ffff28 	bl	ffffffffea803788 <arm64_mmu_map_pt>
                           top_index_shift, page_size_shift, top_page_table, asid);
    DSB;
ffffffffea803aec:	d5033f9f 	dsb	sy
    return ret;
}
ffffffffea803af0:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea803af4:	910083ff 	add	sp, sp, #0x20
ffffffffea803af8:	d65f03c0 	ret
ffffffffea803afc:	aa0003ea 	mov	x10, x0
        TRACEF("vaddr 0x%lx, size 0x%lx out of range vaddr 0x%lx, size 0x%lx\n",
ffffffffea803b00:	aa0403e5 	mov	x5, x4
ffffffffea803b04:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803b08:	aa0203e4 	mov	x4, x2
ffffffffea803b0c:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803b10:	aa0803e6 	mov	x6, x8
ffffffffea803b14:	aa0a03e3 	mov	x3, x10
ffffffffea803b18:	52803622 	mov	w2, #0x1b1                 	// #433
ffffffffea803b1c:	912ca021 	add	x1, x1, #0xb28
ffffffffea803b20:	912e2000 	add	x0, x0, #0xb88
ffffffffea803b24:	94003d1f 	bl	ffffffffea812fa0 <_printf>
        return ERR_INVALID_ARGS;
ffffffffea803b28:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803b2c:	17fffff1 	b	ffffffffea803af0 <arm64_mmu_map+0x58>
        TRACEF("page table is NULL\n");
ffffffffea803b30:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803b34:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803b38:	528036c2 	mov	w2, #0x1b6                 	// #438
ffffffffea803b3c:	912ca021 	add	x1, x1, #0xb28
ffffffffea803b40:	912f4000 	add	x0, x0, #0xbd0
ffffffffea803b44:	94003d17 	bl	ffffffffea812fa0 <_printf>
ffffffffea803b48:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803b4c:	17ffffe9 	b	ffffffffea803af0 <arm64_mmu_map+0x58>

ffffffffea803b50 <arm64_mmu_unmap>:

int arm64_mmu_unmap(vaddr_t vaddr, size_t size,
                    vaddr_t vaddr_base, uint top_size_shift,
                    uint top_index_shift, uint page_size_shift,
                    pte_t *top_page_table, uint asid)
{
ffffffffea803b50:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    vaddr_t vaddr_rel = vaddr - vaddr_base;
    vaddr_t vaddr_rel_max = 1UL << top_size_shift;
ffffffffea803b54:	d2800028 	mov	x8, #0x1                   	// #1
ffffffffea803b58:	9ac32108 	lsl	x8, x8, x3
    vaddr_t vaddr_rel = vaddr - vaddr_base;
ffffffffea803b5c:	cb020009 	sub	x9, x0, x2

    LTRACEF("vaddr 0x%lx, size 0x%lx, asid 0x%x\n", vaddr, size, asid);

    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803b60:	cb01010b 	sub	x11, x8, x1
{
ffffffffea803b64:	910003fd 	mov	x29, sp
    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803b68:	eb09017f 	cmp	x11, x9
ffffffffea803b6c:	fa412100 	ccmp	x8, x1, #0x0, cs  // cs = hs, nlast
ffffffffea803b70:	540001a3 	b.cc	ffffffffea803ba4 <arm64_mmu_unmap+0x54>  // b.lo, b.ul, b.last
ffffffffea803b74:	2a0403e3 	mov	w3, w4
ffffffffea803b78:	2a0503e4 	mov	w4, w5
ffffffffea803b7c:	aa0603e5 	mov	x5, x6
        TRACEF("vaddr 0x%lx, size 0x%lx out of range vaddr 0x%lx, size 0x%lx\n",
               vaddr, size, vaddr_base, vaddr_rel_max);
        return ERR_INVALID_ARGS;
    }

    if (!top_page_table) {
ffffffffea803b80:	b40002c6 	cbz	x6, ffffffffea803bd8 <arm64_mmu_unmap+0x88>
        TRACEF("page table is NULL\n");
        return ERR_INVALID_ARGS;
    }

    arm64_mmu_unmap_pt(vaddr, vaddr_rel, size,
ffffffffea803b84:	aa0103e2 	mov	x2, x1
ffffffffea803b88:	2a0703e6 	mov	w6, w7
ffffffffea803b8c:	aa0903e1 	mov	x1, x9
ffffffffea803b90:	97fffe04 	bl	ffffffffea8033a0 <arm64_mmu_unmap_pt>
                       top_index_shift, page_size_shift, top_page_table, asid);
    DSB;
ffffffffea803b94:	d5033f9f 	dsb	sy
    return 0;
ffffffffea803b98:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea803b9c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea803ba0:	d65f03c0 	ret
ffffffffea803ba4:	aa0003ea 	mov	x10, x0
        TRACEF("vaddr 0x%lx, size 0x%lx out of range vaddr 0x%lx, size 0x%lx\n",
ffffffffea803ba8:	d0000087 	adrp	x7, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803bac:	aa0203e5 	mov	x5, x2
ffffffffea803bb0:	aa0103e4 	mov	x4, x1
ffffffffea803bb4:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803bb8:	aa0803e6 	mov	x6, x8
ffffffffea803bbc:	aa0a03e3 	mov	x3, x10
ffffffffea803bc0:	52803982 	mov	w2, #0x1cc                 	// #460
ffffffffea803bc4:	912ce0e1 	add	x1, x7, #0xb38
ffffffffea803bc8:	912e2000 	add	x0, x0, #0xb88
ffffffffea803bcc:	94003cf5 	bl	ffffffffea812fa0 <_printf>
        return ERR_INVALID_ARGS;
ffffffffea803bd0:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803bd4:	17fffff2 	b	ffffffffea803b9c <arm64_mmu_unmap+0x4c>
        TRACEF("page table is NULL\n");
ffffffffea803bd8:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803bdc:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803be0:	52803a22 	mov	w2, #0x1d1                 	// #465
ffffffffea803be4:	912ce021 	add	x1, x1, #0xb38
ffffffffea803be8:	912f4000 	add	x0, x0, #0xbd0
ffffffffea803bec:	94003ced 	bl	ffffffffea812fa0 <_printf>
ffffffffea803bf0:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803bf4:	17ffffea 	b	ffffffffea803b9c <arm64_mmu_unmap+0x4c>

ffffffffea803bf8 <arch_mmu_map>:

int arch_mmu_map(vaddr_t vaddr, paddr_t paddr, uint count, uint flags)
{
ffffffffea803bf8:	d10083ff 	sub	sp, sp, #0x20
ffffffffea803bfc:	2a0303e4 	mov	w4, w3
    switch (flags & ARCH_MMU_FLAG_CACHE_MASK) {
ffffffffea803c00:	12000463 	and	w3, w3, #0x3
    return arm64_mmu_map(vaddr, paddr, count * PAGE_SIZE,
ffffffffea803c04:	d3747c42 	ubfiz	x2, x2, #12, #32
    switch (flags & ARCH_MMU_FLAG_CACHE_MASK) {
ffffffffea803c08:	7100047f 	cmp	w3, #0x1
{
ffffffffea803c0c:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea803c10:	910043fd 	add	x29, sp, #0x10
    switch (flags & ARCH_MMU_FLAG_CACHE_MASK) {
ffffffffea803c14:	54000500 	b.eq	ffffffffea803cb4 <arch_mmu_map+0xbc>  // b.none
ffffffffea803c18:	34000423 	cbz	w3, ffffffffea803c9c <arch_mmu_map+0xa4>
ffffffffea803c1c:	7100087f 	cmp	w3, #0x2
ffffffffea803c20:	54000221 	b.ne	ffffffffea803c64 <arch_mmu_map+0x6c>  // b.any
            attr |= MMU_PTE_ATTR_DEVICE;
ffffffffea803c24:	d2808083 	mov	x3, #0x404                 	// #1028
    switch (flags & (ARCH_MMU_FLAG_PERM_USER | ARCH_MMU_FLAG_PERM_RO)) {
ffffffffea803c28:	121e0485 	and	w5, w4, #0xc
ffffffffea803c2c:	710020bf 	cmp	w5, #0x8
ffffffffea803c30:	540003e0 	b.eq	ffffffffea803cac <arch_mmu_map+0xb4>  // b.none
ffffffffea803c34:	710030bf 	cmp	w5, #0xc
ffffffffea803c38:	54000420 	b.eq	ffffffffea803cbc <arch_mmu_map+0xc4>  // b.none
            attr |= MMU_PTE_ATTR_AP_P_RW_U_RW;
ffffffffea803c3c:	b27a0066 	orr	x6, x3, #0x40
ffffffffea803c40:	710010bf 	cmp	w5, #0x4
ffffffffea803c44:	9a8300c3 	csel	x3, x6, x3, eq  // eq = none
        attr |= MMU_PTE_ATTR_UXN | MMU_PTE_ATTR_PXN;
ffffffffea803c48:	f27c009f 	tst	x4, #0x10
ffffffffea803c4c:	b24b0465 	orr	x5, x3, #0x60000000000000
ffffffffea803c50:	9a8310a3 	csel	x3, x5, x3, ne  // ne = any
            attr |= MMU_PTE_ATTR_NON_SECURE;
ffffffffea803c54:	f27b009f 	tst	x4, #0x20
ffffffffea803c58:	b27b0064 	orr	x4, x3, #0x20
ffffffffea803c5c:	9a831083 	csel	x3, x4, x3, ne  // ne = any
ffffffffea803c60:	14000002 	b	ffffffffea803c68 <arch_mmu_map+0x70>
            return ERR_INVALID_ARGS;
ffffffffea803c64:	928000e3 	mov	x3, #0xfffffffffffffff8    	// #-8
    return arm64_mmu_map(vaddr, paddr, count * PAGE_SIZE,
ffffffffea803c68:	12800005 	mov	w5, #0xffffffff            	// #-1
ffffffffea803c6c:	d0000244 	adrp	x4, ffffffffea84d000 <arm64_kernel_translation_table>
ffffffffea803c70:	b9000be5 	str	w5, [sp, #8]
ffffffffea803c74:	91000084 	add	x4, x4, #0x0
ffffffffea803c78:	f90003e4 	str	x4, [sp]
ffffffffea803c7c:	52800187 	mov	w7, #0xc                   	// #12
ffffffffea803c80:	528002a6 	mov	w6, #0x15                  	// #21
ffffffffea803c84:	528003a5 	mov	w5, #0x1d                  	// #29
ffffffffea803c88:	b2638be4 	mov	x4, #0xffffffffe0000000    	// #-536870912
ffffffffea803c8c:	97ffff83 	bl	ffffffffea803a98 <arm64_mmu_map>
                         mmu_flags_to_pte_attr(flags),
                         ~0UL << MMU_KERNEL_SIZE_SHIFT, MMU_KERNEL_SIZE_SHIFT,
                         MMU_KERNEL_TOP_SHIFT, MMU_KERNEL_PAGE_SIZE_SHIFT,
                         arm64_kernel_translation_table, MMU_ARM64_GLOBAL_ASID);
}
ffffffffea803c90:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea803c94:	910083ff 	add	sp, sp, #0x20
ffffffffea803c98:	d65f03c0 	ret
    switch (flags & (ARCH_MMU_FLAG_PERM_USER | ARCH_MMU_FLAG_PERM_RO)) {
ffffffffea803c9c:	121e0485 	and	w5, w4, #0xc
            attr |= MMU_PTE_ATTR_NORMAL_MEMORY | MMU_PTE_ATTR_SH_INNER_SHAREABLE;
ffffffffea803ca0:	d280e103 	mov	x3, #0x708                 	// #1800
    switch (flags & (ARCH_MMU_FLAG_PERM_USER | ARCH_MMU_FLAG_PERM_RO)) {
ffffffffea803ca4:	710020bf 	cmp	w5, #0x8
ffffffffea803ca8:	54fffc61 	b.ne	ffffffffea803c34 <arch_mmu_map+0x3c>  // b.any
            attr |= MMU_PTE_ATTR_AP_P_RO_U_NA;
ffffffffea803cac:	b2790063 	orr	x3, x3, #0x80
ffffffffea803cb0:	17ffffe6 	b	ffffffffea803c48 <arch_mmu_map+0x50>
            attr |= MMU_PTE_ATTR_STRONGLY_ORDERED;
ffffffffea803cb4:	d2808003 	mov	x3, #0x400                 	// #1024
ffffffffea803cb8:	17ffffdc 	b	ffffffffea803c28 <arch_mmu_map+0x30>
            attr |= MMU_PTE_ATTR_AP_P_RO_U_RO;
ffffffffea803cbc:	b27a0463 	orr	x3, x3, #0xc0
ffffffffea803cc0:	17ffffe2 	b	ffffffffea803c48 <arch_mmu_map+0x50>
ffffffffea803cc4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803cc8 <arch_mmu_unmap>:

int arch_mmu_unmap(vaddr_t vaddr, uint count)
{
    return arm64_mmu_unmap(vaddr, count * PAGE_SIZE,
ffffffffea803cc8:	d0000246 	adrp	x6, ffffffffea84d000 <arm64_kernel_translation_table>
ffffffffea803ccc:	12800007 	mov	w7, #0xffffffff            	// #-1
ffffffffea803cd0:	910000c6 	add	x6, x6, #0x0
ffffffffea803cd4:	52800185 	mov	w5, #0xc                   	// #12
ffffffffea803cd8:	528002a4 	mov	w4, #0x15                  	// #21
ffffffffea803cdc:	528003a3 	mov	w3, #0x1d                  	// #29
ffffffffea803ce0:	b2638be2 	mov	x2, #0xffffffffe0000000    	// #-536870912
ffffffffea803ce4:	d3747c21 	ubfiz	x1, x1, #12, #32
ffffffffea803ce8:	17ffff9a 	b	ffffffffea803b50 <arm64_mmu_unmap>
ffffffffea803cec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803cf0 <lk_init_level>:

extern const struct lk_init_struct __lk_init[];
extern const struct lk_init_struct __lk_init_end[];

void lk_init_level(enum lk_init_flags required_flag, uint start_level, uint stop_level)
{
ffffffffea803cf0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea803cf4:	910003fd 	mov	x29, sp
ffffffffea803cf8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea803cfc:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea803d00:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea803d04:	f90023f9 	str	x25, [sp, #64]
    LTRACEF("flags %#x, start_level %#x, stop_level %#x\n",
            required_flag, start_level, stop_level);

    ASSERT(start_level > 0);
ffffffffea803d08:	34000781 	cbz	w1, ffffffffea803df8 <lk_init_level+0x108>
ffffffffea803d0c:	900000b9 	adrp	x25, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea803d10:	900000b4 	adrp	x20, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
        /* search for the lowest uncalled hook to call */
        LTRACEF("last %p, last_called_level %#x\n", last, last_called_level);

        const struct lk_init_struct *found = NULL;
        bool seen_last = false;
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
ffffffffea803d14:	912d6339 	add	x25, x25, #0xb58
ffffffffea803d18:	91348294 	add	x20, x20, #0xd20
ffffffffea803d1c:	2a0003f5 	mov	w21, w0
ffffffffea803d20:	2a0103f8 	mov	w24, w1
ffffffffea803d24:	2a0203f7 	mov	w23, w2
    uint last_called_level = start_level - 1;
ffffffffea803d28:	51000425 	sub	w5, w1, #0x1
    const struct lk_init_struct *last = NULL;
ffffffffea803d2c:	d2800013 	mov	x19, #0x0                   	// #0
            LTRACEF("looking at %p (%s) level %#x, flags %#x, seen_last %d\n", ptr, ptr->name, ptr->level, ptr->flags, seen_last);

            if (ptr == last)
                seen_last = true;
ffffffffea803d30:	52800036 	mov	w22, #0x1                   	// #1
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
ffffffffea803d34:	eb14033f 	cmp	x25, x20
ffffffffea803d38:	54000500 	b.eq	ffffffffea803dd8 <lk_init_level+0xe8>  // b.none
ffffffffea803d3c:	d503201f 	nop
ffffffffea803d40:	aa1903e3 	mov	x3, x25
        bool seen_last = false;
ffffffffea803d44:	52800004 	mov	w4, #0x0                   	// #0
        const struct lk_init_struct *found = NULL;
ffffffffea803d48:	d2800006 	mov	x6, #0x0                   	// #0
ffffffffea803d4c:	14000004 	b	ffffffffea803d5c <lk_init_level+0x6c>
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
ffffffffea803d50:	91006063 	add	x3, x3, #0x18
ffffffffea803d54:	eb14007f 	cmp	x3, x20
ffffffffea803d58:	54000300 	b.eq	ffffffffea803db8 <lk_init_level+0xc8>  // b.none

            /* reject the easy ones */
            if (!(ptr->flags & required_flag))
ffffffffea803d5c:	b9400460 	ldr	w0, [x3, #4]
                seen_last = true;
ffffffffea803d60:	eb03027f 	cmp	x19, x3
ffffffffea803d64:	1a961084 	csel	w4, w4, w22, ne  // ne = any
            if (!(ptr->flags & required_flag))
ffffffffea803d68:	6a0002bf 	tst	w21, w0
ffffffffea803d6c:	54ffff20 	b.eq	ffffffffea803d50 <lk_init_level+0x60>  // b.none
                continue;
            if (ptr->level > stop_level)
ffffffffea803d70:	b9400060 	ldr	w0, [x3]
                continue;
            if (ptr->level < last_called_level)
ffffffffea803d74:	6b0000bf 	cmp	w5, w0
ffffffffea803d78:	7a579002 	ccmp	w0, w23, #0x2, ls  // ls = plast
ffffffffea803d7c:	54fffea8 	b.hi	ffffffffea803d50 <lk_init_level+0x60>  // b.pmore
                continue;
            if (found && found->level <= ptr->level)
ffffffffea803d80:	b4000086 	cbz	x6, ffffffffea803d90 <lk_init_level+0xa0>
ffffffffea803d84:	b94000c2 	ldr	w2, [x6]
ffffffffea803d88:	6b02001f 	cmp	w0, w2
ffffffffea803d8c:	54fffe22 	b.cs	ffffffffea803d50 <lk_init_level+0x60>  // b.hs, b.nlast
                continue;

            /* keep the lowest one we haven't called yet */
            if (ptr->level >= start_level && ptr->level > last_called_level) {
ffffffffea803d90:	6b0000bf 	cmp	w5, w0
ffffffffea803d94:	7a583000 	ccmp	w0, w24, #0x0, cc  // cc = lo, ul, last
ffffffffea803d98:	540002c2 	b.cs	ffffffffea803df0 <lk_init_level+0x100>  // b.hs, b.nlast

            /* if we're at the same level as the last one we called and we've
             * already passed over it this time around, we can mark this one
             * and early terminate the loop.
             */
            if (ptr->level == last_called_level && ptr != last && seen_last) {
ffffffffea803d9c:	6b0000bf 	cmp	w5, w0
ffffffffea803da0:	54fffd81 	b.ne	ffffffffea803d50 <lk_init_level+0x60>  // b.any
ffffffffea803da4:	7100009f 	cmp	w4, #0x0
ffffffffea803da8:	fa431264 	ccmp	x19, x3, #0x4, ne  // ne = any
ffffffffea803dac:	54fffd20 	b.eq	ffffffffea803d50 <lk_init_level+0x60>  // b.none
ffffffffea803db0:	aa0303f3 	mov	x19, x3
ffffffffea803db4:	14000004 	b	ffffffffea803dc4 <lk_init_level+0xd4>
                found = ptr;
                break;
            }
        }

        if (!found)
ffffffffea803db8:	b4000106 	cbz	x6, ffffffffea803dd8 <lk_init_level+0xe8>
ffffffffea803dbc:	b94000c0 	ldr	w0, [x6]
ffffffffea803dc0:	aa0603f3 	mov	x19, x6
        if (found->level >= EARLIEST_TRACE_LEVEL) {
            printf("INIT: cpu %d, calling hook %p (%s) at level %#x, flags %#x\n",
                   arch_curr_cpu_num(), found->hook, found->name, found->level, found->flags);
        }
#endif
        found->hook(found->level);
ffffffffea803dc4:	f9400661 	ldr	x1, [x19, #8]
ffffffffea803dc8:	d63f0020 	blr	x1
        last_called_level = found->level;
ffffffffea803dcc:	b9400265 	ldr	w5, [x19]
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
ffffffffea803dd0:	eb14033f 	cmp	x25, x20
ffffffffea803dd4:	54fffb61 	b.ne	ffffffffea803d40 <lk_init_level+0x50>  // b.any
        last = found;
    }
}
ffffffffea803dd8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea803ddc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea803de0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea803de4:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea803de8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea803dec:	d65f03c0 	ret
ffffffffea803df0:	aa0303e6 	mov	x6, x3
ffffffffea803df4:	17ffffd7 	b	ffffffffea803d50 <lk_init_level+0x60>
    ASSERT(start_level > 0);
ffffffffea803df8:	d0000084 	adrp	x4, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803dfc:	d0000082 	adrp	x2, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803e00:	d0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803e04:	91326084 	add	x4, x4, #0xc98
ffffffffea803e08:	52800663 	mov	w3, #0x33                  	// #51
ffffffffea803e0c:	9132a042 	add	x2, x2, #0xca8
ffffffffea803e10:	91330021 	add	x1, x1, #0xcc0
ffffffffea803e14:	aa1e03e0 	mov	x0, x30
ffffffffea803e18:	940036fc 	bl	ffffffffea811a08 <_panic>
ffffffffea803e1c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803e20 <bootstrap2>:
	// become the idle thread and enable interrupts to start the scheduler
	thread_become_idle();
}

static int bootstrap2(void *arg)
{
ffffffffea803e20:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
};

void lk_init_level(enum lk_init_flags flags, uint start_level, uint stop_level);

static inline void lk_primary_cpu_init_level(uint start_level, uint stop_level) {
	lk_init_level(LK_INIT_FLAG_PRIMARY_CPU, start_level, stop_level);
ffffffffea803e24:	12bfff02 	mov	w2, #0x7ffff               	// #524287
ffffffffea803e28:	52a000e1 	mov	w1, #0x70000               	// #458752
ffffffffea803e2c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803e30:	910003fd 	mov	x29, sp
ffffffffea803e34:	97ffffaf 	bl	ffffffffea803cf0 <lk_init_level>
	dprintf(SPEW, "top of bootstrap2()\n");

	lk_primary_cpu_init_level(LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_ARCH - 1);
	arch_init();
ffffffffea803e38:	97fffb60 	bl	ffffffffea802bb8 <arch_init>

	// initialize the rest of the platform
	dprintf(0, "initializing platform at trusty\n");
ffffffffea803e3c:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803e40:	91338000 	add	x0, x0, #0xce0
ffffffffea803e44:	94003673 	bl	ffffffffea811810 <_dprintf>
ffffffffea803e48:	12bffee2 	mov	w2, #0x8ffff               	// #589823
ffffffffea803e4c:	52a00101 	mov	w1, #0x80000               	// #524288
ffffffffea803e50:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803e54:	97ffffa7 	bl	ffffffffea803cf0 <lk_init_level>
	lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH, LK_INIT_LEVEL_PLATFORM - 1);
	platform_init();
ffffffffea803e58:	97fff704 	bl	ffffffffea801a68 <platform_init>
	tegra_boot_profiler_record("bootstrap2: platform_init done");
ffffffffea803e5c:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803e60:	91342000 	add	x0, x0, #0xd08
ffffffffea803e64:	94000ddf 	bl	ffffffffea8075e0 <tegra_boot_profiler_record>
ffffffffea803e68:	12bffec2 	mov	w2, #0x9ffff               	// #655359
ffffffffea803e6c:	52a00121 	mov	w1, #0x90000               	// #589824
ffffffffea803e70:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803e74:	97ffff9f 	bl	ffffffffea803cf0 <lk_init_level>

	// initialize the target
	dprintf(SPEW, "initializing target at trusty\n");
	lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM, LK_INIT_LEVEL_TARGET - 1);
	target_init();
ffffffffea803e78:	940030ec 	bl	ffffffffea810228 <target_init>
	tegra_boot_profiler_record("bootstrap2: target_init done");
ffffffffea803e7c:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803e80:	9134a000 	add	x0, x0, #0xd28
ffffffffea803e84:	94000dd7 	bl	ffffffffea8075e0 <tegra_boot_profiler_record>
ffffffffea803e88:	12bffea2 	mov	w2, #0xaffff               	// #720895
ffffffffea803e8c:	52a00141 	mov	w1, #0xa0000               	// #655360
ffffffffea803e90:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803e94:	97ffff97 	bl	ffffffffea803cf0 <lk_init_level>

	dprintf(SPEW, "calling apps_init()\n");
	lk_primary_cpu_init_level(LK_INIT_LEVEL_TARGET, LK_INIT_LEVEL_APPS - 1);
	apps_init();
ffffffffea803e98:	940000ce 	bl	ffffffffea8041d0 <apps_init>
	tegra_boot_profiler_record("bootstrap2: apps_init done");
ffffffffea803e9c:	d0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea803ea0:	91352000 	add	x0, x0, #0xd48
ffffffffea803ea4:	94000dcf 	bl	ffffffffea8075e0 <tegra_boot_profiler_record>
ffffffffea803ea8:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803eac:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea803eb0:	52a00161 	mov	w1, #0xb0000               	// #720896
ffffffffea803eb4:	97ffff8f 	bl	ffffffffea803cf0 <lk_init_level>

	lk_primary_cpu_init_level(LK_INIT_LEVEL_APPS, LK_INIT_LEVEL_LAST);

	dprintf(SPEW, "calling platform_bootstrap_epilog\n");
	platform_bootstrap_epilog();
ffffffffea803eb8:	97fff8b4 	bl	ffffffffea802188 <platform_bootstrap_epilog>

	return 0;
}
ffffffffea803ebc:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea803ec0:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea803ec4:	d65f03c0 	ret

ffffffffea803ec8 <secondary_cpu_bootstrap2>:
	dprintf(SPEW, "entering scheduler on cpu %d\n", cpu);
	thread_secondary_cpu_entry();
}

static int secondary_cpu_bootstrap2(void *arg)
{
ffffffffea803ec8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	/* secondary cpu initialize from threading level up. 0 to threading was handled in arch */
	lk_init_level(LK_INIT_FLAG_SECONDARY_CPUS, LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_LAST);
ffffffffea803ecc:	52800040 	mov	w0, #0x2                   	// #2
ffffffffea803ed0:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea803ed4:	52a000e1 	mov	w1, #0x70000               	// #458752
{
ffffffffea803ed8:	910003fd 	mov	x29, sp
	lk_init_level(LK_INIT_FLAG_SECONDARY_CPUS, LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_LAST);
ffffffffea803edc:	97ffff85 	bl	ffffffffea803cf0 <lk_init_level>

	return 0;
}
ffffffffea803ee0:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea803ee4:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea803ee8:	d65f03c0 	ret
ffffffffea803eec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803ef0 <lk_main>:
{
ffffffffea803ef0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	lk_boot_args[0] = arg0;
ffffffffea803ef4:	d00002c5 	adrp	x5, ffffffffea85d000 <rb_data+0x18>
ffffffffea803ef8:	910100a4 	add	x4, x5, #0x40
{
ffffffffea803efc:	910003fd 	mov	x29, sp
ffffffffea803f00:	a90153f3 	stp	x19, x20, [sp, #16]
	while (ctor != &__ctor_end) {
ffffffffea803f04:	b0000254 	adrp	x20, ffffffffea84c000 <__ctor_list>
{
ffffffffea803f08:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea803f0c:	a90363f7 	stp	x23, x24, [sp, #48]
	lk_boot_args[2] = arg2;
ffffffffea803f10:	a9008881 	stp	x1, x2, [x4, #8]
	lk_boot_args[0] = arg0;
ffffffffea803f14:	f90020a0 	str	x0, [x5, #64]
	lk_boot_args[3] = arg3;
ffffffffea803f18:	f9000c83 	str	x3, [x4, #24]
	early_tstamps.start = tegra_boot_profiler_get_timestamp();
ffffffffea803f1c:	94000daf 	bl	ffffffffea8075d8 <tegra_boot_profiler_get_timestamp>
ffffffffea803f20:	2a0003f8 	mov	w24, w0
	thread_init_early();
ffffffffea803f24:	94000997 	bl	ffffffffea806580 <thread_init_early>
ffffffffea803f28:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea803f2c:	2a0103e0 	mov	w0, w1
ffffffffea803f30:	529fffe2 	mov	w2, #0xffff                	// #65535
ffffffffea803f34:	97ffff6f 	bl	ffffffffea803cf0 <lk_init_level>
	arch_early_init();
ffffffffea803f38:	97fffb10 	bl	ffffffffea802b78 <arch_early_init>
	early_tstamps.arch_init = tegra_boot_profiler_get_timestamp();
ffffffffea803f3c:	94000da7 	bl	ffffffffea8075d8 <tegra_boot_profiler_get_timestamp>
ffffffffea803f40:	2a0003f7 	mov	w23, w0
ffffffffea803f44:	12bfffc2 	mov	w2, #0x1ffff               	// #131071
ffffffffea803f48:	52a00021 	mov	w1, #0x10000               	// #65536
ffffffffea803f4c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803f50:	97ffff68 	bl	ffffffffea803cf0 <lk_init_level>
	platform_early_init();
ffffffffea803f54:	97fff6c1 	bl	ffffffffea801a58 <platform_early_init>
	early_tstamps.platform_init = tegra_boot_profiler_get_timestamp();
ffffffffea803f58:	94000da0 	bl	ffffffffea8075d8 <tegra_boot_profiler_get_timestamp>
ffffffffea803f5c:	2a0003f6 	mov	w22, w0
ffffffffea803f60:	52a00041 	mov	w1, #0x20000               	// #131072
ffffffffea803f64:	12bfffa2 	mov	w2, #0x2ffff               	// #196607
ffffffffea803f68:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803f6c:	97ffff61 	bl	ffffffffea803cf0 <lk_init_level>
	target_early_init();
ffffffffea803f70:	940030ac 	bl	ffffffffea810220 <target_early_init>
	early_tstamps.target_init = tegra_boot_profiler_get_timestamp();
ffffffffea803f74:	94000d99 	bl	ffffffffea8075d8 <tegra_boot_profiler_get_timestamp>
ffffffffea803f78:	2a0003f5 	mov	w21, w0
	while (ctor != &__ctor_end) {
ffffffffea803f7c:	91000281 	add	x1, x20, #0x0
ffffffffea803f80:	b0000240 	adrp	x0, ffffffffea84c000 <__ctor_list>
ffffffffea803f84:	91002000 	add	x0, x0, #0x8
ffffffffea803f88:	eb00003f 	cmp	x1, x0
ffffffffea803f8c:	540001a0 	b.eq	ffffffffea803fc0 <lk_main+0xd0>  // b.none
ffffffffea803f90:	b0000254 	adrp	x20, ffffffffea84c000 <__ctor_list>
ffffffffea803f94:	91002294 	add	x20, x20, #0x8
ffffffffea803f98:	cb140014 	sub	x20, x0, x20
	ctor = &__ctor_list;
ffffffffea803f9c:	aa0103f3 	mov	x19, x1
ffffffffea803fa0:	927df294 	and	x20, x20, #0xfffffffffffffff8
ffffffffea803fa4:	91002294 	add	x20, x20, #0x8
ffffffffea803fa8:	8b010294 	add	x20, x20, x1
ffffffffea803fac:	d503201f 	nop
		func();
ffffffffea803fb0:	f8408660 	ldr	x0, [x19], #8
ffffffffea803fb4:	d63f0000 	blr	x0
	while (ctor != &__ctor_end) {
ffffffffea803fb8:	eb14027f 	cmp	x19, x20
ffffffffea803fbc:	54ffffa1 	b.ne	ffffffffea803fb0 <lk_main+0xc0>  // b.any
ffffffffea803fc0:	12bfff82 	mov	w2, #0x3ffff               	// #262143
ffffffffea803fc4:	52a00061 	mov	w1, #0x30000               	// #196608
ffffffffea803fc8:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803fcc:	97ffff49 	bl	ffffffffea803cf0 <lk_init_level>
	heap_init();
ffffffffea803fd0:	94003850 	bl	ffffffffea812110 <heap_init>
ffffffffea803fd4:	12bfff42 	mov	w2, #0x5ffff               	// #393215
ffffffffea803fd8:	52a00081 	mov	w1, #0x40000               	// #262144
ffffffffea803fdc:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803fe0:	97ffff44 	bl	ffffffffea803cf0 <lk_init_level>
	kernel_init();
ffffffffea803fe4:	9400062f 	bl	ffffffffea8058a0 <kernel_init>
	early_tstamps.kernel_init = tegra_boot_profiler_get_timestamp();
ffffffffea803fe8:	94000d7c 	bl	ffffffffea8075d8 <tegra_boot_profiler_get_timestamp>
ffffffffea803fec:	2a0003f3 	mov	w19, w0
ffffffffea803ff0:	12bfff22 	mov	w2, #0x6ffff               	// #458751
ffffffffea803ff4:	52a000c1 	mov	w1, #0x60000               	// #393216
ffffffffea803ff8:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803ffc:	97ffff3d 	bl	ffffffffea803cf0 <lk_init_level>
	tegra_boot_profiler_init(NULL);
ffffffffea804000:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea804004:	94000d71 	bl	ffffffffea8075c8 <tegra_boot_profiler_init>
	tegra_boot_profiler_prerecorded("lk_main: start", tstamp.start);
ffffffffea804008:	2a1803e1 	mov	w1, w24
ffffffffea80400c:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804010:	9136e000 	add	x0, x0, #0xdb8
ffffffffea804014:	94000d75 	bl	ffffffffea8075e8 <tegra_boot_profiler_prerecorded>
	tegra_boot_profiler_prerecorded("lk_main: arch_early_init", tstamp.arch_init);
ffffffffea804018:	2a1703e1 	mov	w1, w23
ffffffffea80401c:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804020:	91372000 	add	x0, x0, #0xdc8
ffffffffea804024:	94000d71 	bl	ffffffffea8075e8 <tegra_boot_profiler_prerecorded>
	tegra_boot_profiler_prerecorded("lk_main: platform_early_init", tstamp.platform_init);
ffffffffea804028:	2a1603e1 	mov	w1, w22
ffffffffea80402c:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804030:	9137a000 	add	x0, x0, #0xde8
ffffffffea804034:	94000d6d 	bl	ffffffffea8075e8 <tegra_boot_profiler_prerecorded>
	tegra_boot_profiler_prerecorded("lk_main: target_early_init", tstamp.target_init);
ffffffffea804038:	2a1503e1 	mov	w1, w21
ffffffffea80403c:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804040:	91382000 	add	x0, x0, #0xe08
ffffffffea804044:	94000d69 	bl	ffffffffea8075e8 <tegra_boot_profiler_prerecorded>
	tegra_boot_profiler_prerecorded("lk_main: kernel_init", tstamp.kernel_init);
ffffffffea804048:	2a1303e1 	mov	w1, w19
ffffffffea80404c:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804050:	9138a000 	add	x0, x0, #0xe28
ffffffffea804054:	94000d65 	bl	ffffffffea8075e8 <tegra_boot_profiler_prerecorded>
	thread_t *t = thread_create("bootstrap2", &bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
ffffffffea804058:	f0ffffe1 	adrp	x1, ffffffffea803000 <arm64_fpu_exception+0x70>
ffffffffea80405c:	91388021 	add	x1, x1, #0xe20
ffffffffea804060:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea804064:	52800203 	mov	w3, #0x10                  	// #16
ffffffffea804068:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea80406c:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804070:	91390000 	add	x0, x0, #0xe40
ffffffffea804074:	94000835 	bl	ffffffffea806148 <thread_create>
	t->pinned_cpu = 0;
ffffffffea804078:	b9003c1f 	str	wzr, [x0, #60]
	thread_t *t = thread_create("bootstrap2", &bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
ffffffffea80407c:	aa0003f3 	mov	x19, x0
	thread_detach(t);
ffffffffea804080:	94000b48 	bl	ffffffffea806da0 <thread_detach>
	thread_resume(t);
ffffffffea804084:	aa1303e0 	mov	x0, x19
ffffffffea804088:	94000890 	bl	ffffffffea8062c8 <thread_resume>
	thread_become_idle();
ffffffffea80408c:	9400097b 	bl	ffffffffea806678 <thread_become_idle>

ffffffffea804090 <lk_secondary_cpu_entry>:
{
ffffffffea804090:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea804094:	910003fd 	mov	x29, sp
	uint cpu = arch_curr_cpu_num();
ffffffffea804098:	97fffab6 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea80409c:	2a0003e1 	mov	w1, w0
	if (cpu > secondary_bootstrap_thread_count) {
ffffffffea8040a0:	f0000280 	adrp	x0, ffffffffea857000 <__bss_start>
ffffffffea8040a4:	b9406803 	ldr	w3, [x0, #104]
ffffffffea8040a8:	6b01007f 	cmp	w3, w1
ffffffffea8040ac:	540000c2 	b.cs	ffffffffea8040c4 <lk_secondary_cpu_entry+0x34>  // b.hs, b.nlast
}
ffffffffea8040b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
		dprintf(CRITICAL, "Invalid secondary cpu num %d, SMP_MAX_CPUS %d, secondary_bootstrap_thread_count %d\n",
ffffffffea8040b4:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8040b8:	52800102 	mov	w2, #0x8                   	// #8
ffffffffea8040bc:	91394000 	add	x0, x0, #0xe50
ffffffffea8040c0:	140035d4 	b	ffffffffea811810 <_dprintf>
ffffffffea8040c4:	b9001fa1 	str	w1, [x29, #28]
	thread_secondary_cpu_init_early();
ffffffffea8040c8:	94000992 	bl	ffffffffea806710 <thread_secondary_cpu_init_early>
	thread_resume(secondary_bootstrap_threads[cpu - 1]);
ffffffffea8040cc:	b9401fa1 	ldr	w1, [x29, #28]
ffffffffea8040d0:	f0000280 	adrp	x0, ffffffffea857000 <__bss_start>
ffffffffea8040d4:	9101c000 	add	x0, x0, #0x70
ffffffffea8040d8:	51000421 	sub	w1, w1, #0x1
ffffffffea8040dc:	f8617800 	ldr	x0, [x0, x1, lsl #3]
ffffffffea8040e0:	9400087a 	bl	ffffffffea8062c8 <thread_resume>
	thread_secondary_cpu_entry();
ffffffffea8040e4:	940009d3 	bl	ffffffffea806830 <thread_secondary_cpu_entry>

ffffffffea8040e8 <lk_init_secondary_cpus>:

void lk_init_secondary_cpus(uint secondary_cpu_count)
{
ffffffffea8040e8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	if (secondary_cpu_count >= SMP_MAX_CPUS) {
ffffffffea8040ec:	71001c1f 	cmp	w0, #0x7
{
ffffffffea8040f0:	910003fd 	mov	x29, sp
ffffffffea8040f4:	f90013f5 	str	x21, [sp, #32]
ffffffffea8040f8:	2a0003f5 	mov	w21, w0
	if (secondary_cpu_count >= SMP_MAX_CPUS) {
ffffffffea8040fc:	54000468 	b.hi	ffffffffea804188 <lk_init_secondary_cpus+0xa0>  // b.pmore
		dprintf(CRITICAL, "Invalid secondary_cpu_count %d, SMP_MAX_CPUS %d\n",
			secondary_cpu_count, SMP_MAX_CPUS);
		secondary_cpu_count = SMP_MAX_CPUS - 1;
	}
	for (uint i = 0; i < secondary_cpu_count; i++) {
ffffffffea804100:	340003a0 	cbz	w0, ffffffffea804174 <lk_init_secondary_cpus+0x8c>
ffffffffea804104:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea804108:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea80410c:	f9001fb8 	str	x24, [x29, #56]
ffffffffea804110:	f0fffff8 	adrp	x24, ffffffffea803000 <arm64_fpu_exception+0x70>
ffffffffea804114:	b0000097 	adrp	x23, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804118:	f0000296 	adrp	x22, ffffffffea857000 <__bss_start>
		dprintf(SPEW, "creating bootstrap completion thread for cpu %d\n", i + 1);
		thread_t *t = thread_create("secondarybootstrap2",
ffffffffea80411c:	913b2318 	add	x24, x24, #0xec8
ffffffffea804120:	913682f7 	add	x23, x23, #0xda0
					    &secondary_cpu_bootstrap2, NULL,
					    DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
		t->pinned_cpu = i + 1;
		thread_detach(t);
		secondary_bootstrap_threads[i] = t;
ffffffffea804124:	9101c2d6 	add	x22, x22, #0x70
		secondary_cpu_count = SMP_MAX_CPUS - 1;
ffffffffea804128:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea80412c:	d503201f 	nop
		thread_t *t = thread_create("secondarybootstrap2",
ffffffffea804130:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea804134:	52800203 	mov	w3, #0x10                  	// #16
ffffffffea804138:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea80413c:	aa1803e1 	mov	x1, x24
ffffffffea804140:	aa1703e0 	mov	x0, x23
ffffffffea804144:	94000801 	bl	ffffffffea806148 <thread_create>
		t->pinned_cpu = i + 1;
ffffffffea804148:	11000661 	add	w1, w19, #0x1
ffffffffea80414c:	b9003c01 	str	w1, [x0, #60]
		thread_t *t = thread_create("secondarybootstrap2",
ffffffffea804150:	aa0003f4 	mov	x20, x0
		thread_detach(t);
ffffffffea804154:	94000b13 	bl	ffffffffea806da0 <thread_detach>
		secondary_bootstrap_threads[i] = t;
ffffffffea804158:	f8337ad4 	str	x20, [x22, x19, lsl #3]
ffffffffea80415c:	91000673 	add	x19, x19, #0x1
	for (uint i = 0; i < secondary_cpu_count; i++) {
ffffffffea804160:	6b1302bf 	cmp	w21, w19
ffffffffea804164:	54fffe68 	b.hi	ffffffffea804130 <lk_init_secondary_cpus+0x48>  // b.pmore
ffffffffea804168:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80416c:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea804170:	f9401fb8 	ldr	x24, [x29, #56]
	}
	secondary_bootstrap_thread_count = secondary_cpu_count;
ffffffffea804174:	f0000280 	adrp	x0, ffffffffea857000 <__bss_start>
ffffffffea804178:	b9006815 	str	w21, [x0, #104]
}
ffffffffea80417c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea804180:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea804184:	d65f03c0 	ret
		dprintf(CRITICAL, "Invalid secondary_cpu_count %d, SMP_MAX_CPUS %d\n",
ffffffffea804188:	2a0003e1 	mov	w1, w0
ffffffffea80418c:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea804190:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea804194:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804198:	52800102 	mov	w2, #0x8                   	// #8
		secondary_cpu_count = SMP_MAX_CPUS - 1;
ffffffffea80419c:	528000f5 	mov	w21, #0x7                   	// #7
ffffffffea8041a0:	f9001fb8 	str	x24, [x29, #56]
		dprintf(CRITICAL, "Invalid secondary_cpu_count %d, SMP_MAX_CPUS %d\n",
ffffffffea8041a4:	9135a000 	add	x0, x0, #0xd68
ffffffffea8041a8:	9400359a 	bl	ffffffffea811810 <_dprintf>
ffffffffea8041ac:	17ffffd9 	b	ffffffffea804110 <lk_init_secondary_cpus+0x28>

ffffffffea8041b0 <app_thread_entry>:
		}
	}
}

static int app_thread_entry(void *arg)
{
ffffffffea8041b0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	const struct app_descriptor *app = (const struct app_descriptor *)arg;

	app->entry(app, NULL);
ffffffffea8041b4:	d2800001 	mov	x1, #0x0                   	// #0
{
ffffffffea8041b8:	910003fd 	mov	x29, sp
	app->entry(app, NULL);
ffffffffea8041bc:	f9400802 	ldr	x2, [x0, #16]
ffffffffea8041c0:	d63f0040 	blr	x2

	return 0;
}
ffffffffea8041c4:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8041c8:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8041cc:	d65f03c0 	ret

ffffffffea8041d0 <apps_init>:
{
ffffffffea8041d0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea8041d4:	900000a0 	adrp	x0, ffffffffea818000 <_mem_phys_base>
ffffffffea8041d8:	913fe000 	add	x0, x0, #0xff8
{
ffffffffea8041dc:	910003fd 	mov	x29, sp
ffffffffea8041e0:	f9000bf3 	str	x19, [sp, #16]
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea8041e4:	900000b3 	adrp	x19, ffffffffea818000 <_mem_phys_base>
ffffffffea8041e8:	913fe261 	add	x1, x19, #0xff8
ffffffffea8041ec:	eb00003f 	cmp	x1, x0
ffffffffea8041f0:	54000760 	b.eq	ffffffffea8042dc <apps_init+0x10c>  // b.none
ffffffffea8041f4:	a901d7b4 	stp	x20, x21, [x29, #24]
ffffffffea8041f8:	b00000b5 	adrp	x21, ffffffffea819000 <__trusty_app_start>
ffffffffea8041fc:	910082b5 	add	x21, x21, #0x20
ffffffffea804200:	aa0103f4 	mov	x20, x1
ffffffffea804204:	cb150015 	sub	x21, x0, x21
ffffffffea804208:	d29999a0 	mov	x0, #0xcccd                	// #52429
ffffffffea80420c:	f2b99980 	movk	x0, #0xcccc, lsl #16
ffffffffea804210:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea804214:	f2d99980 	movk	x0, #0xcccc, lsl #32
ffffffffea804218:	d343feb5 	lsr	x21, x21, #3
ffffffffea80421c:	f2e19980 	movk	x0, #0xccc, lsl #48
ffffffffea804220:	9b007eb5 	mul	x21, x21, x0
ffffffffea804224:	9240f2b5 	and	x21, x21, #0x1fffffffffffffff
ffffffffea804228:	910006b5 	add	x21, x21, #0x1
ffffffffea80422c:	8b150ab5 	add	x21, x21, x21, lsl #2
ffffffffea804230:	8b150c35 	add	x21, x1, x21, lsl #3
ffffffffea804234:	d503201f 	nop
		if (app->init)
ffffffffea804238:	f9400681 	ldr	x1, [x20, #8]
			app->init(app);
ffffffffea80423c:	aa1403e0 	mov	x0, x20
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea804240:	9100a294 	add	x20, x20, #0x28
		if (app->init)
ffffffffea804244:	b4000041 	cbz	x1, ffffffffea80424c <apps_init+0x7c>
			app->init(app);
ffffffffea804248:	d63f0020 	blr	x1
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea80424c:	eb15029f 	cmp	x20, x21
ffffffffea804250:	54ffff41 	b.ne	ffffffffea804238 <apps_init+0x68>  // b.any

static void start_app(const struct app_descriptor *app)
{
	uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;

	printf("starting app %s\n", app->name);
ffffffffea804254:	b0000096 	adrp	x22, ffffffffea815000 <__fault_handler_table_start>
	thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
ffffffffea804258:	90000015 	adrp	x21, ffffffffea804000 <lk_main+0x110>
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea80425c:	913fe273 	add	x19, x19, #0xff8
	printf("starting app %s\n", app->name);
ffffffffea804260:	913aa2d6 	add	x22, x22, #0xea8
	thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
ffffffffea804264:	9106c2b5 	add	x21, x21, #0x1b0
ffffffffea804268:	14000004 	b	ffffffffea804278 <apps_init+0xa8>
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea80426c:	9100a273 	add	x19, x19, #0x28
ffffffffea804270:	eb14027f 	cmp	x19, x20
ffffffffea804274:	54000300 	b.eq	ffffffffea8042d4 <apps_init+0x104>  // b.none
		if (app->entry && (app->flags & APP_FLAG_DONT_START_ON_BOOT) == 0) {
ffffffffea804278:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80427c:	b4ffff80 	cbz	x0, ffffffffea80426c <apps_init+0x9c>
ffffffffea804280:	b9401a61 	ldr	w1, [x19, #24]
ffffffffea804284:	3707ff41 	tbnz	w1, #0, ffffffffea80426c <apps_init+0x9c>
	printf("starting app %s\n", app->name);
ffffffffea804288:	aa1603e0 	mov	x0, x22
	uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;
ffffffffea80428c:	d2820017 	mov	x23, #0x1000                	// #4096
ffffffffea804290:	36080041 	tbz	w1, #1, ffffffffea804298 <apps_init+0xc8>
ffffffffea804294:	b9402277 	ldr	w23, [x19, #32]
	printf("starting app %s\n", app->name);
ffffffffea804298:	f9400261 	ldr	x1, [x19]
ffffffffea80429c:	94003b41 	bl	ffffffffea812fa0 <_printf>
	thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
ffffffffea8042a0:	f9400260 	ldr	x0, [x19]
ffffffffea8042a4:	aa1703e4 	mov	x4, x23
ffffffffea8042a8:	aa1303e2 	mov	x2, x19
ffffffffea8042ac:	aa1503e1 	mov	x1, x21
ffffffffea8042b0:	52800203 	mov	w3, #0x10                  	// #16
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea8042b4:	9100a273 	add	x19, x19, #0x28
	thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
ffffffffea8042b8:	940007a4 	bl	ffffffffea806148 <thread_create>
ffffffffea8042bc:	aa0003f7 	mov	x23, x0
	thread_detach(t);
ffffffffea8042c0:	94000ab8 	bl	ffffffffea806da0 <thread_detach>
	thread_resume(t);
ffffffffea8042c4:	aa1703e0 	mov	x0, x23
ffffffffea8042c8:	94000800 	bl	ffffffffea8062c8 <thread_resume>
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea8042cc:	eb14027f 	cmp	x19, x20
ffffffffea8042d0:	54fffd41 	b.ne	ffffffffea804278 <apps_init+0xa8>  // b.any
ffffffffea8042d4:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea8042d8:	a942dfb6 	ldp	x22, x23, [x29, #40]
}
ffffffffea8042dc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8042e0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8042e4:	d65f03c0 	ret

ffffffffea8042e8 <arm_gic_init_percpu>:
}

static void arm_gic_init_percpu(uint level)
{
#if WITH_LIB_SM
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8042e8:	929bffe2 	mov	x2, #0xffffffffffff2000    	// #-57344
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea8042ec:	929defe1 	mov	x1, #0xffffffffffff1080    	// #-61312
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8042f0:	f2be2802 	movk	x2, #0xf140, lsl #16
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea8042f4:	f2be2801 	movk	x1, #0xf140, lsl #16
#else
	GICREG(0, GICC_CTLR) = 1; // enable GIC0
#endif
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea8042f8:	929bff60 	mov	x0, #0xffffffffffff2004    	// #-57340
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8042fc:	52800163 	mov	w3, #0xb                   	// #11
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea804300:	f2be2800 	movk	x0, #0xf140, lsl #16
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804304:	b9000043 	str	w3, [x2]
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea804308:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea80430c:	b9000022 	str	w2, [x1]
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea804310:	52801fe1 	mov	w1, #0xff                  	// #255
ffffffffea804314:	b9000001 	str	w1, [x0]
}
ffffffffea804318:	d65f03c0 	ret
ffffffffea80431c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804320 <update_fiq_targets>:
}

static u_int current_fiq[8] = { 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff };

static bool update_fiq_targets(u_int cpu, bool enable, u_int triggered_fiq, bool resume_gicd)
{
ffffffffea804320:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	return (GICREG(0, GICD_TYPER) >> 5) & 0x7;
ffffffffea804324:	929dff64 	mov	x4, #0xffffffffffff1004    	// #-61436
ffffffffea804328:	f2be2804 	movk	x4, #0xf140, lsl #16
{
ffffffffea80432c:	910003fd 	mov	x29, sp
ffffffffea804330:	a90153f3 	stp	x19, x20, [sp, #16]
	u_int i, j;
	u_long mask;
	u_int fiq;
	bool smp = arm_gic_max_cpu() > 0;
	bool ret = false;
ffffffffea804334:	52800013 	mov	w19, #0x0                   	// #0
	return (GICREG(0, GICD_TYPER) >> 5) & 0x7;
ffffffffea804338:	b9400094 	ldr	w20, [x4]
{
ffffffffea80433c:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea804340:	12001c36 	and	w22, w1, #0xff
ffffffffea804344:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea804348:	2a0203f5 	mov	w21, w2
ffffffffea80434c:	12001c77 	and	w23, w3, #0xff
ffffffffea804350:	f90023f9 	str	x25, [sp, #64]
    arch_spin_lock(lock);
ffffffffea804354:	f0000298 	adrp	x24, ffffffffea857000 <__bss_start>
ffffffffea804358:	2a0003f9 	mov	w25, w0
ffffffffea80435c:	91046300 	add	x0, x24, #0x118
ffffffffea804360:	97fff97f 	bl	ffffffffea80295c <arch_spin_lock>
			fiq = i * BITMAP_BITS_PER_WORD + j;
			if (fiq == triggered_fiq)
				ret = true;
			LTRACEF("cpu %d, irq %i, enable %d\n", cpu, fiq, enable);
			if (smp)
				arm_gic_set_target_locked(fiq, 1U << cpu, enable ? ~0 : 0);
ffffffffea804364:	5280002d 	mov	w13, #0x1                   	// #1
ffffffffea804368:	f000028e 	adrp	x14, ffffffffea857000 <__bss_start>
ffffffffea80436c:	1ad921ad 	lsl	w13, w13, w25
			mask &= ~(1UL << j);
ffffffffea804370:	d280002a 	mov	x10, #0x1                   	// #1
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804374:	900000ab 	adrp	x11, ffffffffea818000 <_mem_phys_base>
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804378:	929fffe9 	mov	x9, #0xffffffffffff0000    	// #-65536
	return (GICREG(0, GICD_TYPER) >> 5) & 0x7;
ffffffffea80437c:	d3451e94 	ubfx	x20, x20, #5, #3
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804380:	12001dad 	and	w13, w13, #0xff
		mask = enabled_fiq_mask[i];
ffffffffea804384:	9102c1ce 	add	x14, x14, #0xb0
				ret = true;
ffffffffea804388:	2a0a03e2 	mov	w2, w10
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea80438c:	9109216b 	add	x11, x11, #0x248
				arm_gic_set_target_locked(fiq, 1U << cpu, enable ? ~0 : 0);
ffffffffea804390:	4b1603e1 	neg	w1, w22
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804394:	d2800003 	mov	x3, #0x0                   	// #0
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804398:	f2be2809 	movk	x9, #0xf140, lsl #16
ffffffffea80439c:	d503201f 	nop
		mask = enabled_fiq_mask[i];
ffffffffea8043a0:	f86379c6 	ldr	x6, [x14, x3, lsl #3]
		while (mask) {
ffffffffea8043a4:	b4000386 	cbz	x6, ffffffffea804414 <update_fiq_targets+0xf4>
ffffffffea8043a8:	531a646c 	lsl	w12, w3, #6
ffffffffea8043ac:	d503201f 	nop
}

/* find first zero bit starting from LSB */
static inline unsigned long _ffz(unsigned long x)
{
	return __builtin_ffsl(~x) - 1;
ffffffffea8043b0:	dac000c0 	rbit	x0, x6
ffffffffea8043b4:	f10000df 	cmp	x6, #0x0
ffffffffea8043b8:	dac01000 	clz	x0, x0
ffffffffea8043bc:	5a9f1000 	csinv	w0, w0, wzr, ne  // ne = any
			fiq = i * BITMAP_BITS_PER_WORD + j;
ffffffffea8043c0:	0b000184 	add	w4, w12, w0
				ret = true;
ffffffffea8043c4:	6b15009f 	cmp	w4, w21
			mask &= ~(1UL << j);
ffffffffea8043c8:	9ac02140 	lsl	x0, x10, x0
	u_int reg = irq / 4;
ffffffffea8043cc:	53027c87 	lsr	w7, w4, #2
	u_int shift = 8 * (irq % 4);
ffffffffea8043d0:	531d0488 	ubfiz	w8, w4, #3, #2
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea8043d4:	111800ef 	add	w15, w7, #0x600
			mask &= ~(1UL << j);
ffffffffea8043d8:	8a2000c6 	bic	x6, x6, x0
	enable_mask = (enable_mask << shift) & cpu_mask;
ffffffffea8043dc:	1ac82025 	lsl	w5, w1, w8
				ret = true;
ffffffffea8043e0:	1a821273 	csel	w19, w19, w2, ne  // ne = any
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea8043e4:	531e75ef 	lsl	w15, w15, #2
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea8043e8:	1ac821a8 	lsl	w8, w13, w8
			if (smp)
ffffffffea8043ec:	340002d4 	cbz	w20, ffffffffea804444 <update_fiq_targets+0x124>
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea8043f0:	b8677970 	ldr	w16, [x11, x7, lsl #2]
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea8043f4:	b86f4920 	ldr	w0, [x9, w15, uxtw]
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea8043f8:	4a1000a0 	eor	w0, w5, w16
ffffffffea8043fc:	0a080000 	and	w0, w0, w8
ffffffffea804400:	4a100000 	eor	w0, w0, w16
	GICREG(0, GICD_ITARGETSR(reg)) = gicd_itargetsr[reg] = new_val;
ffffffffea804404:	b8277960 	str	w0, [x11, x7, lsl #2]
ffffffffea804408:	b82f4920 	str	w0, [x9, w15, uxtw]
			if (!smp || resume_gicd)
ffffffffea80440c:	350001d7 	cbnz	w23, ffffffffea804444 <update_fiq_targets+0x124>
		while (mask) {
ffffffffea804410:	b5fffd06 	cbnz	x6, ffffffffea8043b0 <update_fiq_targets+0x90>
ffffffffea804414:	91000463 	add	x3, x3, #0x1
	for (i = 0; i < BITMAP_NUM_WORDS(MAX_INT); i++) {
ffffffffea804418:	f100347f 	cmp	x3, #0xd
ffffffffea80441c:	54fffc21 	b.ne	ffffffffea8043a0 <update_fiq_targets+0x80>  // b.any
    arch_spin_unlock(lock);
ffffffffea804420:	91046300 	add	x0, x24, #0x118
ffffffffea804424:	97fff956 	bl	ffffffffea80297c <arch_spin_unlock>
				gic_set_enable(fiq, enable);
		}
	}
	spin_unlock(&gicd_lock);
	return ret;
}
ffffffffea804428:	2a1303e0 	mov	w0, w19
ffffffffea80442c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea804430:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804434:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea804438:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80443c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea804440:	d65f03c0 	ret
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea804444:	12001080 	and	w0, w4, #0x1f
	int reg = vector / 32;
ffffffffea804448:	53057c84 	lsr	w4, w4, #5
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea80444c:	11110085 	add	w5, w4, #0x440
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea804450:	9ac02140 	lsl	x0, x10, x0
	if (enable)
ffffffffea804454:	340000b6 	cbz	w22, ffffffffea804468 <update_fiq_targets+0x148>
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804458:	531e74a5 	lsl	w5, w5, #2
ffffffffea80445c:	b825c920 	str	w0, [x9, w5, sxtw]
		while (mask) {
ffffffffea804460:	b5fffa86 	cbnz	x6, ffffffffea8043b0 <update_fiq_targets+0x90>
ffffffffea804464:	17ffffec 	b	ffffffffea804414 <update_fiq_targets+0xf4>
		GICREG(0, GICD_ICENABLER(reg)) = mask;
ffffffffea804468:	11118084 	add	w4, w4, #0x460
ffffffffea80446c:	531e7484 	lsl	w4, w4, #2
ffffffffea804470:	b824c920 	str	w0, [x9, w4, sxtw]
		while (mask) {
ffffffffea804474:	b5fff9e6 	cbnz	x6, ffffffffea8043b0 <update_fiq_targets+0x90>
ffffffffea804478:	17ffffe7 	b	ffffffffea804414 <update_fiq_targets+0xf4>
ffffffffea80447c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804480 <suspend_resume_fiq>:

#if !DISABLE_ARM_GIC_SUSPEND_RESUME
static void suspend_resume_fiq(bool resume_gicc, bool resume_gicd)
{
ffffffffea804480:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea804484:	910003fd 	mov	x29, sp
ffffffffea804488:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80448c:	12001c13 	and	w19, w0, #0xff
ffffffffea804490:	f90013f5 	str	x21, [sp, #32]
ffffffffea804494:	12001c34 	and	w20, w1, #0xff
ffffffffea804498:	aa1e03f5 	mov	x21, x30
	u_int cpu = arch_curr_cpu_num();
ffffffffea80449c:	97fff9b5 	bl	ffffffffea802b70 <arch_curr_cpu_num>

	ASSERT(cpu < 8);
ffffffffea8044a0:	71001c1f 	cmp	w0, #0x7
ffffffffea8044a4:	54000108 	b.hi	ffffffffea8044c4 <suspend_resume_fiq+0x44>  // b.pmore

	update_fiq_targets(cpu, resume_gicc, ~0, resume_gicd);
ffffffffea8044a8:	2a1403e3 	mov	w3, w20
ffffffffea8044ac:	2a1303e1 	mov	w1, w19
}
ffffffffea8044b0:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_fiq_targets(cpu, resume_gicc, ~0, resume_gicd);
ffffffffea8044b4:	12800002 	mov	w2, #0xffffffff            	// #-1
}
ffffffffea8044b8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8044bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
	update_fiq_targets(cpu, resume_gicc, ~0, resume_gicd);
ffffffffea8044c0:	17ffff98 	b	ffffffffea804320 <update_fiq_targets>
	ASSERT(cpu < 8);
ffffffffea8044c4:	d0000084 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8044c8:	d0000082 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8044cc:	b0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8044d0:	91018084 	add	x4, x4, #0x60
ffffffffea8044d4:	528046a3 	mov	w3, #0x235                 	// #565
ffffffffea8044d8:	9101a042 	add	x2, x2, #0x68
ffffffffea8044dc:	91330021 	add	x1, x1, #0xcc0
ffffffffea8044e0:	aa1503e0 	mov	x0, x21
ffffffffea8044e4:	94003549 	bl	ffffffffea811a08 <_panic>

ffffffffea8044e8 <arm_gic_suspend_cpu>:
	suspend_resume_fiq(false, false);
ffffffffea8044e8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8044ec:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8044f0:	17ffffe4 	b	ffffffffea804480 <suspend_resume_fiq>
ffffffffea8044f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8044f8 <register_int_handler>:
{
ffffffffea8044f8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea8044fc:	910003fd 	mov	x29, sp
ffffffffea804500:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804504:	2a0003f3 	mov	w19, w0
ffffffffea804508:	a903e7f8 	stp	x24, x25, [sp, #56]
ffffffffea80450c:	aa1e03f4 	mov	x20, x30
ffffffffea804510:	aa0103f9 	mov	x25, x1
ffffffffea804514:	aa0203f8 	mov	x24, x2
	uint cpu = arch_curr_cpu_num();
ffffffffea804518:	97fff996 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea80451c:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea804520:	f9001bb7 	str	x23, [x29, #48]
	if (vector >= MAX_INT)
ffffffffea804524:	710c7e7f 	cmp	w19, #0x31f
ffffffffea804528:	54000688 	b.hi	ffffffffea8045f8 <register_int_handler+0x100>  // b.pmore
ffffffffea80452c:	2a0003f5 	mov	w21, w0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804530:	d53b4220 	mrs	x0, daif
};

static inline void
arch_interrupt_save(spin_lock_saved_state_t *statep, spin_lock_save_flags_t flags)
{
    spin_lock_saved_state_t state = 0;
ffffffffea804534:	52800017 	mov	w23, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804538:	363804a0 	tbz	w0, #7, ffffffffea8045cc <register_int_handler+0xd4>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80453c:	d53b4220 	mrs	x0, daif
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
        arch_disable_ints();
    }
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804540:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea804544:	37300080 	tbnz	w0, #6, ffffffffea804554 <register_int_handler+0x5c>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804548:	321f02f7 	orr	w23, w23, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea80454c:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804550:	52800056 	mov	w22, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804554:	f0000294 	adrp	x20, ffffffffea857000 <__bss_start>
ffffffffea804558:	91046280 	add	x0, x20, #0x118
ffffffffea80455c:	97fff900 	bl	ffffffffea80295c <arch_spin_lock>
	if (!arm_gic_non_secure_interrupts_frozen)
ffffffffea804560:	f0000280 	adrp	x0, ffffffffea857000 <__bss_start>
ffffffffea804564:	3942a000 	ldrb	w0, [x0, #168]
ffffffffea804568:	35000380 	cbnz	w0, ffffffffea8045d8 <register_int_handler+0xe0>
	if (vector < GIC_MAX_PER_CPU_INT)
ffffffffea80456c:	71007e7f 	cmp	w19, #0x1f
ffffffffea804570:	54000248 	b.hi	ffffffffea8045b8 <register_int_handler+0xc0>  // b.pmore
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804574:	8b334eb3 	add	x19, x21, w19, uxtw #3
ffffffffea804578:	f0000283 	adrp	x3, ffffffffea857000 <__bss_start>
ffffffffea80457c:	91048063 	add	x3, x3, #0x120
ffffffffea804580:	8b131073 	add	x19, x3, x19, lsl #4
		h->arg = arg;
ffffffffea804584:	a9006279 	stp	x25, x24, [x19]
    arch_spin_unlock(lock);
ffffffffea804588:	91046280 	add	x0, x20, #0x118
ffffffffea80458c:	97fff8fc 	bl	ffffffffea80297c <arch_spin_unlock>
}

static inline void
arch_interrupt_restore(spin_lock_saved_state_t old_state, spin_lock_save_flags_t flags)
{
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804590:	34000056 	cbz	w22, ffffffffea804598 <register_int_handler+0xa0>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804594:	d50341ff 	msr	daifclr, #0x1
        arch_enable_fiqs();
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804598:	36000057 	tbz	w23, #0, ffffffffea8045a0 <register_int_handler+0xa8>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80459c:	d50342ff 	msr	daifclr, #0x2
ffffffffea8045a0:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea8045a4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8045a8:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea8045ac:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea8045b0:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8045b4:	d65f03c0 	ret
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea8045b8:	51008273 	sub	w19, w19, #0x20
ffffffffea8045bc:	900002a3 	adrp	x3, ffffffffea858000 <int_handler_table_per_cpu+0xee0>
ffffffffea8045c0:	91048063 	add	x3, x3, #0x120
ffffffffea8045c4:	8b131073 	add	x19, x3, x19, lsl #4
ffffffffea8045c8:	17ffffef 	b	ffffffffea804584 <register_int_handler+0x8c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8045cc:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8045d0:	52800037 	mov	w23, #0x1                   	// #1
ffffffffea8045d4:	17ffffda 	b	ffffffffea80453c <register_int_handler+0x44>
	TRACEF("change to interrupt %d ignored after booting ns\n", irq);
ffffffffea8045d8:	b0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8045dc:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8045e0:	2a1303e3 	mov	w3, w19
ffffffffea8045e4:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea8045e8:	913b0021 	add	x1, x1, #0xec0
ffffffffea8045ec:	913f8000 	add	x0, x0, #0xfe0
ffffffffea8045f0:	94003a6c 	bl	ffffffffea812fa0 <_printf>
ffffffffea8045f4:	17ffffe5 	b	ffffffffea804588 <register_int_handler+0x90>
		panic("register_int_handler: vector out of range %d\n", vector);
ffffffffea8045f8:	b0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8045fc:	2a1303e2 	mov	w2, w19
ffffffffea804600:	913ec021 	add	x1, x1, #0xfb0
ffffffffea804604:	aa1403e0 	mov	x0, x20
ffffffffea804608:	94003500 	bl	ffffffffea811a08 <_panic>
ffffffffea80460c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804610 <arm_gic_init>:
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea804610:	929fffe3 	mov	x3, #0xffffffffffff0000    	// #-65536
	for (i = 0; i < MAX_INT; i+= 32) {
ffffffffea804614:	52800001 	mov	w1, #0x0                   	// #0
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea804618:	f2be2803 	movk	x3, #0xf140, lsl #16
ffffffffea80461c:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea804620:	13057c20 	asr	w0, w1, #5
	for (i = 0; i < MAX_INT; i+= 32) {
ffffffffea804624:	11008021 	add	w1, w1, #0x20
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea804628:	11118000 	add	w0, w0, #0x460
	for (i = 0; i < MAX_INT; i+= 32) {
ffffffffea80462c:	710c803f 	cmp	w1, #0x320
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea804630:	531e7400 	lsl	w0, w0, #2
		GICREG(0, GICD_ICPENDR(i / 32)) = ~0;
ffffffffea804634:	11040004 	add	w4, w0, #0x100
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea804638:	b820c862 	str	w2, [x3, w0, sxtw]
		GICREG(0, GICD_ICPENDR(i / 32)) = ~0;
ffffffffea80463c:	b824c862 	str	w2, [x3, w4, sxtw]
	for (i = 0; i < MAX_INT; i+= 32) {
ffffffffea804640:	54ffff01 	b.ne	ffffffffea804620 <arm_gic_init+0x10>  // b.any
	return (GICREG(0, GICD_TYPER) >> 5) & 0x7;
ffffffffea804644:	929dff60 	mov	x0, #0xffffffffffff1004    	// #-61436
ffffffffea804648:	f2be2800 	movk	x0, #0xf140, lsl #16
ffffffffea80464c:	b9400000 	ldr	w0, [x0]
	if (arm_gic_max_cpu() > 0) {
ffffffffea804650:	f27b081f 	tst	x0, #0xe0
ffffffffea804654:	540001e0 	b.eq	ffffffffea804690 <arm_gic_init+0x80>  // b.none
ffffffffea804658:	900000a3 	adrp	x3, ffffffffea818000 <_mem_phys_base>
			GICREG(0, GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
ffffffffea80465c:	929fffe4 	mov	x4, #0xffffffffffff0000    	// #-65536
ffffffffea804660:	91092063 	add	x3, x3, #0x248
		for (i = 32; i < MAX_INT; i += 4) {
ffffffffea804664:	52800400 	mov	w0, #0x20                  	// #32
			GICREG(0, GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
ffffffffea804668:	f2be2804 	movk	x4, #0xf140, lsl #16
ffffffffea80466c:	d503201f 	nop
ffffffffea804670:	13027c02 	asr	w2, w0, #2
		for (i = 32; i < MAX_INT; i += 4) {
ffffffffea804674:	11001000 	add	w0, w0, #0x4
			GICREG(0, GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
ffffffffea804678:	11180041 	add	w1, w2, #0x600
		for (i = 32; i < MAX_INT; i += 4) {
ffffffffea80467c:	710c801f 	cmp	w0, #0x320
			GICREG(0, GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
ffffffffea804680:	531e7421 	lsl	w1, w1, #2
ffffffffea804684:	b862d862 	ldr	w2, [x3, w2, sxtw #2]
ffffffffea804688:	b821c882 	str	w2, [x4, w1, sxtw]
		for (i = 32; i < MAX_INT; i += 4) {
ffffffffea80468c:	54ffff21 	b.ne	ffffffffea804670 <arm_gic_init+0x60>  // b.any
	GICREG(0, GICD_CTLR) = 1; // enable GIC0
ffffffffea804690:	929dffe1 	mov	x1, #0xffffffffffff1000    	// #-61440
ffffffffea804694:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea804698:	f2be2801 	movk	x1, #0xf140, lsl #16
ffffffffea80469c:	900000a3 	adrp	x3, ffffffffea818000 <_mem_phys_base>
		GICREG(0, GICD_IGROUPR(reg)) = gicd_igroupr[reg];
ffffffffea8046a0:	929fffe4 	mov	x4, #0xffffffffffff0000    	// #-65536
ffffffffea8046a4:	91078063 	add	x3, x3, #0x1e0
	GICREG(0, GICD_CTLR) = 1; // enable GIC0
ffffffffea8046a8:	b9000020 	str	w0, [x1]
	GICREG(0, GICD_CTLR) = 3; // enable GIC0 ns interrupts
ffffffffea8046ac:	52800062 	mov	w2, #0x3                   	// #3
		GICREG(0, GICD_IGROUPR(reg)) = gicd_igroupr[reg];
ffffffffea8046b0:	f2be2804 	movk	x4, #0xf140, lsl #16
	GICREG(0, GICD_CTLR) = 3; // enable GIC0 ns interrupts
ffffffffea8046b4:	b9000022 	str	w2, [x1]
	for (i = 32; i < MAX_INT; i += 32) {
ffffffffea8046b8:	52800400 	mov	w0, #0x20                  	// #32
ffffffffea8046bc:	d503201f 	nop
		u_int reg = i / 32;
ffffffffea8046c0:	13057c02 	asr	w2, w0, #5
	for (i = 32; i < MAX_INT; i += 32) {
ffffffffea8046c4:	11008000 	add	w0, w0, #0x20
		GICREG(0, GICD_IGROUPR(reg)) = gicd_igroupr[reg];
ffffffffea8046c8:	11108041 	add	w1, w2, #0x420
	for (i = 32; i < MAX_INT; i += 32) {
ffffffffea8046cc:	710c801f 	cmp	w0, #0x320
		GICREG(0, GICD_IGROUPR(reg)) = gicd_igroupr[reg];
ffffffffea8046d0:	531e7421 	lsl	w1, w1, #2
ffffffffea8046d4:	b8625862 	ldr	w2, [x3, w2, uxtw #2]
ffffffffea8046d8:	b8214882 	str	w2, [x4, w1, uxtw]
	for (i = 32; i < MAX_INT; i += 32) {
ffffffffea8046dc:	54ffff21 	b.ne	ffffffffea8046c0 <arm_gic_init+0xb0>  // b.any
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8046e0:	929bffe2 	mov	x2, #0xffffffffffff2000    	// #-57344
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea8046e4:	929defe1 	mov	x1, #0xffffffffffff1080    	// #-61312
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8046e8:	f2be2802 	movk	x2, #0xf140, lsl #16
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea8046ec:	f2be2801 	movk	x1, #0xf140, lsl #16
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea8046f0:	929bff60 	mov	x0, #0xffffffffffff2004    	// #-57340
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8046f4:	52800163 	mov	w3, #0xb                   	// #11
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea8046f8:	f2be2800 	movk	x0, #0xf140, lsl #16
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8046fc:	b9000043 	str	w3, [x2]
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea804700:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea804704:	b9000022 	str	w2, [x1]
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea804708:	52801fe1 	mov	w1, #0xff                  	// #255
ffffffffea80470c:	b9000001 	str	w1, [x0]
}
ffffffffea804710:	d65f03c0 	ret
ffffffffea804714:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804718 <arm_gic_resume_cpu>:
{
ffffffffea804718:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80471c:	910003fd 	mov	x29, sp
ffffffffea804720:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804724:	a9025bf5 	stp	x21, x22, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804728:	d53b4220 	mrs	x0, daif
ffffffffea80472c:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804730:	37380060 	tbnz	w0, #7, ffffffffea80473c <arm_gic_resume_cpu+0x24>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804734:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804738:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80473c:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804740:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea804744:	37300080 	tbnz	w0, #6, ffffffffea804754 <arm_gic_resume_cpu+0x3c>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804748:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea80474c:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804750:	52800055 	mov	w21, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804754:	f0000293 	adrp	x19, ffffffffea857000 <__bss_start>
ffffffffea804758:	91046260 	add	x0, x19, #0x118
ffffffffea80475c:	97fff880 	bl	ffffffffea80295c <arch_spin_lock>
	if (!(GICREG(0, GICD_CTLR) & 1)) {
ffffffffea804760:	929dffe0 	mov	x0, #0xffffffffffff1000    	// #-61440
ffffffffea804764:	f2be2800 	movk	x0, #0xf140, lsl #16
ffffffffea804768:	b9400000 	ldr	w0, [x0]
ffffffffea80476c:	36000340 	tbz	w0, #0, ffffffffea8047d4 <arm_gic_resume_cpu+0xbc>
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804770:	929bffe2 	mov	x2, #0xffffffffffff2000    	// #-57344
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea804774:	929defe1 	mov	x1, #0xffffffffffff1080    	// #-61312
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804778:	f2be2802 	movk	x2, #0xf140, lsl #16
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea80477c:	f2be2801 	movk	x1, #0xf140, lsl #16
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea804780:	929bff60 	mov	x0, #0xffffffffffff2004    	// #-57340
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804784:	52800163 	mov	w3, #0xb                   	// #11
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea804788:	f2be2800 	movk	x0, #0xf140, lsl #16
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea80478c:	b9000043 	str	w3, [x2]
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea804790:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea804794:	b9000022 	str	w2, [x1]
	bool resume_gicd = false;
ffffffffea804798:	52800016 	mov	w22, #0x0                   	// #0
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea80479c:	52801fe1 	mov	w1, #0xff                  	// #255
ffffffffea8047a0:	b9000001 	str	w1, [x0]
    arch_spin_unlock(lock);
ffffffffea8047a4:	91046260 	add	x0, x19, #0x118
ffffffffea8047a8:	97fff875 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea8047ac:	34000055 	cbz	w21, ffffffffea8047b4 <arm_gic_resume_cpu+0x9c>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea8047b0:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8047b4:	36000054 	tbz	w20, #0, ffffffffea8047bc <arm_gic_resume_cpu+0xa4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8047b8:	d50342ff 	msr	daifclr, #0x2
	suspend_resume_fiq(true, resume_gicd);
ffffffffea8047bc:	2a1603e1 	mov	w1, w22
ffffffffea8047c0:	52800020 	mov	w0, #0x1                   	// #1
}
ffffffffea8047c4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8047c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8047cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
	suspend_resume_fiq(true, resume_gicd);
ffffffffea8047d0:	17ffff2c 	b	ffffffffea804480 <suspend_resume_fiq>
		arm_gic_init();
ffffffffea8047d4:	97ffff8f 	bl	ffffffffea804610 <arm_gic_init>
		resume_gicd = true;
ffffffffea8047d8:	52800036 	mov	w22, #0x1                   	// #1
ffffffffea8047dc:	17fffff2 	b	ffffffffea8047a4 <arm_gic_resume_cpu+0x8c>

ffffffffea8047e0 <arm_gic_sgi>:
		((flags & ARM_GIC_SGI_FLAG_NS) ? (1U << 15) : 0) |
ffffffffea8047e0:	53134823 	lsl	w3, w1, #13
		((cpu_mask & 0xff) << 16) |
ffffffffea8047e4:	53101c42 	ubfiz	w2, w2, #16, #8
		(irq & 0xf);
ffffffffea8047e8:	12000c04 	and	w4, w0, #0xf
		((flags & ARM_GIC_SGI_FLAG_TARGET_FILTER_MASK) << 24) |
ffffffffea8047ec:	53080421 	ubfiz	w1, w1, #24, #2
		((flags & ARM_GIC_SGI_FLAG_NS) ? (1U << 15) : 0) |
ffffffffea8047f0:	12110063 	and	w3, w3, #0x8000
	u_int val =
ffffffffea8047f4:	2a040042 	orr	w2, w2, w4
ffffffffea8047f8:	2a030021 	orr	w1, w1, w3
	if (irq >= 16)
ffffffffea8047fc:	71003c1f 	cmp	w0, #0xf
	u_int val =
ffffffffea804800:	2a020021 	orr	w1, w1, w2
	if (irq >= 16)
ffffffffea804804:	540000c8 	b.hi	ffffffffea80481c <arm_gic_sgi+0x3c>  // b.pmore
	GICREG(0, GICD_SGIR) = val;
ffffffffea804808:	929c1fe2 	mov	x2, #0xffffffffffff1f00    	// #-57600
	return NO_ERROR;
ffffffffea80480c:	52800000 	mov	w0, #0x0                   	// #0
	GICREG(0, GICD_SGIR) = val;
ffffffffea804810:	f2be2802 	movk	x2, #0xf140, lsl #16
ffffffffea804814:	b9000041 	str	w1, [x2]
}
ffffffffea804818:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80481c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea804820:	d65f03c0 	ret
ffffffffea804824:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804828 <unmask_interrupt>:
	if (vector >= MAX_INT)
ffffffffea804828:	710c7c1f 	cmp	w0, #0x31f
ffffffffea80482c:	54000368 	b.hi	ffffffffea804898 <unmask_interrupt+0x70>  // b.pmore
	if (!arm_gic_non_secure_interrupts_frozen)
ffffffffea804830:	f0000281 	adrp	x1, ffffffffea857000 <__bss_start>
ffffffffea804834:	3942a021 	ldrb	w1, [x1, #168]
ffffffffea804838:	35000181 	cbnz	w1, ffffffffea804868 <unmask_interrupt+0x40>
	int reg = vector / 32;
ffffffffea80483c:	53057c01 	lsr	w1, w0, #5
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804840:	929fffe4 	mov	x4, #0xffffffffffff0000    	// #-65536
ffffffffea804844:	11110021 	add	w1, w1, #0x440
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea804848:	12001003 	and	w3, w0, #0x1f
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea80484c:	f2be2804 	movk	x4, #0xf140, lsl #16
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea804850:	d2800022 	mov	x2, #0x1                   	// #1
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804854:	531e7421 	lsl	w1, w1, #2
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea804858:	9ac32043 	lsl	x3, x2, x3
	return NO_ERROR;
ffffffffea80485c:	52800000 	mov	w0, #0x0                   	// #0
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804860:	b821c883 	str	w3, [x4, w1, sxtw]
ffffffffea804864:	d65f03c0 	ret
{
ffffffffea804868:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80486c:	2a0003e3 	mov	w3, w0
	TRACEF("change to interrupt %d ignored after booting ns\n", irq);
ffffffffea804870:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea804874:	b0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
{
ffffffffea804878:	910003fd 	mov	x29, sp
	TRACEF("change to interrupt %d ignored after booting ns\n", irq);
ffffffffea80487c:	913b0021 	add	x1, x1, #0xec0
ffffffffea804880:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804884:	913f8000 	add	x0, x0, #0xfe0
ffffffffea804888:	940039c6 	bl	ffffffffea812fa0 <_printf>
	return NO_ERROR;
ffffffffea80488c:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea804890:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea804894:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea804898:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80489c:	d65f03c0 	ret

ffffffffea8048a0 <platform_irq>:
{
ffffffffea8048a0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	uint32_t ahppir = GICREG(0, GICC_AHPPIR);
ffffffffea8048a4:	929bfae0 	mov	x0, #0xffffffffffff2028    	// #-57304
ffffffffea8048a8:	f2be2800 	movk	x0, #0xf140, lsl #16
{
ffffffffea8048ac:	910003fd 	mov	x29, sp
ffffffffea8048b0:	a901d7f4 	stp	x20, x21, [sp, #24]
	uint32_t ahppir = GICREG(0, GICC_AHPPIR);
ffffffffea8048b4:	b9400015 	ldr	w21, [x0]
	uint cpu = arch_curr_cpu_num();
ffffffffea8048b8:	97fff8ae 	bl	ffffffffea802b70 <arch_curr_cpu_num>
	uint32_t pending_irq = ahppir & 0x3ff;
ffffffffea8048bc:	120026b4 	and	w20, w21, #0x3ff
	if (pending_irq < MAX_INT && get_int_handler(pending_irq, cpu)->handler) {
ffffffffea8048c0:	710c7e9f 	cmp	w20, #0x31f
ffffffffea8048c4:	54000948 	b.hi	ffffffffea8049ec <platform_irq+0x14c>  // b.pmore
ffffffffea8048c8:	f9000bb3 	str	x19, [x29, #16]
	if (vector < GIC_MAX_PER_CPU_INT)
ffffffffea8048cc:	71007e9f 	cmp	w20, #0x1f
ffffffffea8048d0:	54000949 	b.ls	ffffffffea8049f8 <platform_irq+0x158>  // b.plast
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea8048d4:	51008293 	sub	w19, w20, #0x20
ffffffffea8048d8:	900002a0 	adrp	x0, ffffffffea858000 <int_handler_table_per_cpu+0xee0>
ffffffffea8048dc:	91048000 	add	x0, x0, #0x120
ffffffffea8048e0:	8b131013 	add	x19, x0, x19, lsl #4
	if (pending_irq < MAX_INT && get_int_handler(pending_irq, cpu)->handler) {
ffffffffea8048e4:	f9400260 	ldr	x0, [x19]
ffffffffea8048e8:	b4000800 	cbz	x0, ffffffffea8049e8 <platform_irq+0x148>
ffffffffea8048ec:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea8048f0:	f9001fb8 	str	x24, [x29, #56]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8048f4:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea8048f8:	52800018 	mov	w24, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8048fc:	37380060 	tbnz	w0, #7, ffffffffea804908 <platform_irq+0x68>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804900:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804904:	52800038 	mov	w24, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804908:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea80490c:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea804910:	37300080 	tbnz	w0, #6, ffffffffea804920 <platform_irq+0x80>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804914:	321f0318 	orr	w24, w24, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804918:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea80491c:	52800057 	mov	w23, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804920:	f0000296 	adrp	x22, ffffffffea857000 <__bss_start>
ffffffffea804924:	910462d6 	add	x22, x22, #0x118
ffffffffea804928:	aa1603e0 	mov	x0, x22
ffffffffea80492c:	97fff80c 	bl	ffffffffea80295c <arch_spin_lock>
	return (GICREG(0, GICD_IPRIORITYR(reg)) >> shift) & 0xff;
ffffffffea804930:	121e1e82 	and	w2, w20, #0x3fc
ffffffffea804934:	52828000 	mov	w0, #0x1400                	// #5120
ffffffffea804938:	929fffe6 	mov	x6, #0xffffffffffff0000    	// #-65536
ffffffffea80493c:	0b000042 	add	w2, w2, w0
ffffffffea804940:	f2be2806 	movk	x6, #0xf140, lsl #16
	u_int shift = 8 * (irq % 4);
ffffffffea804944:	531d06a1 	ubfiz	w1, w21, #3, #2
	u_int mask = 0xff << shift;
ffffffffea804948:	52801fe4 	mov	w4, #0xff                  	// #255
	return (GICREG(0, GICD_IPRIORITYR(reg)) >> shift) & 0xff;
ffffffffea80494c:	b86248c5 	ldr	w5, [x6, w2, uxtw]
	u_int mask = 0xff << shift;
ffffffffea804950:	1ac12084 	lsl	w4, w4, w1
	regval = GICREG(0, GICD_IPRIORITYR(reg));
ffffffffea804954:	b86248c0 	ldr	w0, [x6, w2, uxtw]
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea804958:	2a2403e4 	mvn	w4, w4
ffffffffea80495c:	0a040000 	and	w0, w0, w4
	GICREG(0, GICD_IPRIORITYR(reg)) = regval;
ffffffffea804960:	b82248c0 	str	w0, [x6, w2, uxtw]
		DSB;
ffffffffea804964:	d5033f9f 	dsb	sy
		irq = GICREG(0, GICC_AIAR) & 0x3ff;
ffffffffea804968:	929bfbe3 	mov	x3, #0xffffffffffff2020    	// #-57312
	return (GICREG(0, GICD_IPRIORITYR(reg)) >> shift) & 0xff;
ffffffffea80496c:	1ac124a5 	lsr	w5, w5, w1
		irq = GICREG(0, GICC_AIAR) & 0x3ff;
ffffffffea804970:	f2be2803 	movk	x3, #0xf140, lsl #16
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea804974:	12001ca5 	and	w5, w5, #0xff
    arch_spin_unlock(lock);
ffffffffea804978:	aa1603e0 	mov	x0, x22
		irq = GICREG(0, GICC_AIAR) & 0x3ff;
ffffffffea80497c:	b9400075 	ldr	w21, [x3]
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea804980:	1ac120a1 	lsl	w1, w5, w1
	regval = GICREG(0, GICD_IPRIORITYR(reg));
ffffffffea804984:	b86248c7 	ldr	w7, [x6, w2, uxtw]
		irq = GICREG(0, GICC_AIAR) & 0x3ff;
ffffffffea804988:	120026b5 	and	w21, w21, #0x3ff
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea80498c:	0a0400e4 	and	w4, w7, w4
ffffffffea804990:	2a040021 	orr	w1, w1, w4
	GICREG(0, GICD_IPRIORITYR(reg)) = regval;
ffffffffea804994:	b82248c1 	str	w1, [x6, w2, uxtw]
ffffffffea804998:	97fff7f9 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea80499c:	34000057 	cbz	w23, ffffffffea8049a4 <platform_irq+0x104>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea8049a0:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8049a4:	36000058 	tbz	w24, #0, ffffffffea8049ac <platform_irq+0x10c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8049a8:	d50342ff 	msr	daifclr, #0x2
		if (irq < MAX_INT && (h = get_int_handler(pending_irq, cpu))->handler)
ffffffffea8049ac:	710c7ebf 	cmp	w21, #0x31f
ffffffffea8049b0:	54000308 	b.hi	ffffffffea804a10 <platform_irq+0x170>  // b.pmore
ffffffffea8049b4:	f9400261 	ldr	x1, [x19]
ffffffffea8049b8:	b40002c1 	cbz	x1, ffffffffea804a10 <platform_irq+0x170>
			ret = h->handler(h->arg);
ffffffffea8049bc:	f9400660 	ldr	x0, [x19, #8]
ffffffffea8049c0:	d63f0020 	blr	x1
		GICREG(0, GICC_AEOIR) = irq;
ffffffffea8049c4:	929bfb61 	mov	x1, #0xffffffffffff2024    	// #-57308
}
ffffffffea8049c8:	f9400bb3 	ldr	x19, [x29, #16]
		GICREG(0, GICC_AEOIR) = irq;
ffffffffea8049cc:	f2be2801 	movk	x1, #0xf140, lsl #16
}
ffffffffea8049d0:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea8049d4:	a942dfb6 	ldp	x22, x23, [x29, #40]
		GICREG(0, GICC_AEOIR) = irq;
ffffffffea8049d8:	b9000035 	str	w21, [x1]
}
ffffffffea8049dc:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8049e0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8049e4:	d65f03c0 	ret
ffffffffea8049e8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8049ec:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8049f0:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return sm_handle_irq();
ffffffffea8049f4:	14000e83 	b	ffffffffea808400 <sm_handle_irq>
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea8049f8:	2a0003f3 	mov	w19, w0
ffffffffea8049fc:	f0000280 	adrp	x0, ffffffffea857000 <__bss_start>
ffffffffea804a00:	8b344e73 	add	x19, x19, w20, uxtw #3
ffffffffea804a04:	91048000 	add	x0, x0, #0x120
ffffffffea804a08:	8b131013 	add	x19, x0, x19, lsl #4
ffffffffea804a0c:	17ffffb6 	b	ffffffffea8048e4 <platform_irq+0x44>
			TRACEF("unexpected irq %d != %d may get lost\n", irq, pending_irq);
ffffffffea804a10:	b0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804a14:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804a18:	2a1403e4 	mov	w4, w20
ffffffffea804a1c:	2a1503e3 	mov	w3, w21
ffffffffea804a20:	52803722 	mov	w2, #0x1b9                 	// #441
ffffffffea804a24:	913ba021 	add	x1, x1, #0xee8
ffffffffea804a28:	913e0000 	add	x0, x0, #0xf80
ffffffffea804a2c:	9400395d 	bl	ffffffffea812fa0 <_printf>
		enum handler_return ret = 0;
ffffffffea804a30:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea804a34:	17ffffe4 	b	ffffffffea8049c4 <platform_irq+0x124>

ffffffffea804a38 <platform_fiq>:
	sm_handle_fiq();
ffffffffea804a38:	14000e8c 	b	ffffffffea808468 <sm_handle_fiq>
ffffffffea804a3c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804a40 <smc_intc_get_next_irq>:
{
ffffffffea804a40:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea804a44:	910003fd 	mov	x29, sp
ffffffffea804a48:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804a4c:	aa0003f3 	mov	x19, x0
ffffffffea804a50:	a9025bf5 	stp	x21, x22, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804a54:	d53b4220 	mrs	x0, daif
ffffffffea804a58:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804a5c:	37380060 	tbnz	w0, #7, ffffffffea804a68 <smc_intc_get_next_irq+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804a60:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804a64:	52800035 	mov	w21, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804a68:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804a6c:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea804a70:	37300080 	tbnz	w0, #6, ffffffffea804a80 <smc_intc_get_next_irq+0x40>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804a74:	321f02b5 	orr	w21, w21, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804a78:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804a7c:	52800056 	mov	w22, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804a80:	f0000294 	adrp	x20, ffffffffea857000 <__bss_start>
ffffffffea804a84:	91046280 	add	x0, x20, #0x118
ffffffffea804a88:	97fff7b5 	bl	ffffffffea80295c <arch_spin_lock>
	arm_gic_non_secure_interrupts_frozen = true;
ffffffffea804a8c:	f0000281 	adrp	x1, ffffffffea857000 <__bss_start>
	u_int max_irq = per_cpu ? GIC_MAX_PER_CPU_INT : MAX_INT;
ffffffffea804a90:	b9400a60 	ldr	w0, [x19, #8]
	arm_gic_non_secure_interrupts_frozen = true;
ffffffffea804a94:	52800022 	mov	w2, #0x1                   	// #1
	ret = arm_gic_get_next_irq_locked(args->params[0], args->params[1]);
ffffffffea804a98:	b9400673 	ldr	w19, [x19, #4]
	arm_gic_non_secure_interrupts_frozen = true;
ffffffffea804a9c:	3902a022 	strb	w2, [x1, #168]
	u_int max_irq = per_cpu ? GIC_MAX_PER_CPU_INT : MAX_INT;
ffffffffea804aa0:	35000480 	cbnz	w0, ffffffffea804b30 <smc_intc_get_next_irq+0xf0>
	uint cpu = arch_curr_cpu_num();
ffffffffea804aa4:	97fff833 	bl	ffffffffea802b70 <arch_curr_cpu_num>
	u_int max_irq = per_cpu ? GIC_MAX_PER_CPU_INT : MAX_INT;
ffffffffea804aa8:	52806403 	mov	w3, #0x320                 	// #800
	if (!per_cpu && min_irq < GIC_MAX_PER_CPU_INT)
ffffffffea804aac:	71007e7f 	cmp	w19, #0x1f
ffffffffea804ab0:	54000448 	b.hi	ffffffffea804b38 <smc_intc_get_next_irq+0xf8>  // b.pmore
		min_irq = GIC_MAX_PER_CPU_INT;
ffffffffea804ab4:	52800413 	mov	w19, #0x20                  	// #32
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804ab8:	900002a5 	adrp	x5, ffffffffea858000 <int_handler_table_per_cpu+0xee0>
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804abc:	f0000284 	adrp	x4, ffffffffea857000 <__bss_start>
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804ac0:	910480a5 	add	x5, x5, #0x120
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804ac4:	2a0003e0 	mov	w0, w0
ffffffffea804ac8:	91048084 	add	x4, x4, #0x120
ffffffffea804acc:	14000007 	b	ffffffffea804ae8 <smc_intc_get_next_irq+0xa8>
ffffffffea804ad0:	8b021081 	add	x1, x4, x2, lsl #4
		if (get_int_handler(irq, cpu)->handler)
ffffffffea804ad4:	f9400021 	ldr	x1, [x1]
ffffffffea804ad8:	b5000161 	cbnz	x1, ffffffffea804b04 <smc_intc_get_next_irq+0xc4>
	for (irq = min_irq; irq < max_irq; irq++)
ffffffffea804adc:	11000673 	add	w19, w19, #0x1
ffffffffea804ae0:	6b03027f 	cmp	w19, w3
ffffffffea804ae4:	540002e2 	b.cs	ffffffffea804b40 <smc_intc_get_next_irq+0x100>  // b.hs, b.nlast
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804ae8:	51008261 	sub	w1, w19, #0x20
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804aec:	8b334c02 	add	x2, x0, w19, uxtw #3
	if (vector < GIC_MAX_PER_CPU_INT)
ffffffffea804af0:	71007e7f 	cmp	w19, #0x1f
ffffffffea804af4:	54fffee9 	b.ls	ffffffffea804ad0 <smc_intc_get_next_irq+0x90>  // b.plast
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804af8:	8b0110a1 	add	x1, x5, x1, lsl #4
		if (get_int_handler(irq, cpu)->handler)
ffffffffea804afc:	f9400021 	ldr	x1, [x1]
ffffffffea804b00:	b4fffee1 	cbz	x1, ffffffffea804adc <smc_intc_get_next_irq+0x9c>
ffffffffea804b04:	2a1303f3 	mov	w19, w19
    arch_spin_unlock(lock);
ffffffffea804b08:	91046280 	add	x0, x20, #0x118
ffffffffea804b0c:	97fff79c 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804b10:	35000216 	cbnz	w22, ffffffffea804b50 <smc_intc_get_next_irq+0x110>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804b14:	36000055 	tbz	w21, #0, ffffffffea804b1c <smc_intc_get_next_irq+0xdc>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804b18:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea804b1c:	aa1303e0 	mov	x0, x19
ffffffffea804b20:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804b24:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea804b28:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea804b2c:	d65f03c0 	ret
	uint cpu = arch_curr_cpu_num();
ffffffffea804b30:	97fff810 	bl	ffffffffea802b70 <arch_curr_cpu_num>
	u_int max_irq = per_cpu ? GIC_MAX_PER_CPU_INT : MAX_INT;
ffffffffea804b34:	52800403 	mov	w3, #0x20                  	// #32
	for (irq = min_irq; irq < max_irq; irq++)
ffffffffea804b38:	6b03027f 	cmp	w19, w3
ffffffffea804b3c:	54fffbe3 	b.cc	ffffffffea804ab8 <smc_intc_get_next_irq+0x78>  // b.lo, b.ul, b.last
		min_irq = GIC_MAX_PER_CPU_INT;
ffffffffea804b40:	92800133 	mov	x19, #0xfffffffffffffff6    	// #-10
ffffffffea804b44:	91046280 	add	x0, x20, #0x118
ffffffffea804b48:	97fff78d 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804b4c:	34fffe56 	cbz	w22, ffffffffea804b14 <smc_intc_get_next_irq+0xd4>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804b50:	d50341ff 	msr	daifclr, #0x1
ffffffffea804b54:	17fffff0 	b	ffffffffea804b14 <smc_intc_get_next_irq+0xd4>

ffffffffea804b58 <smc_intc_request_fiq>:
{
ffffffffea804b58:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea804b5c:	910003fd 	mov	x29, sp
ffffffffea804b60:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804b64:	a9025bf5 	stp	x21, x22, [sp, #32]
	u_int fiq = args->params[0];
ffffffffea804b68:	b9400413 	ldr	w19, [x0, #4]
{
ffffffffea804b6c:	f9001bf7 	str	x23, [sp, #48]
	bool enable = args->params[1];
ffffffffea804b70:	b9400817 	ldr	w23, [x0, #8]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804b74:	d53b4220 	mrs	x0, daif
ffffffffea804b78:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804b7c:	37380060 	tbnz	w0, #7, ffffffffea804b88 <smc_intc_request_fiq+0x30>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804b80:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804b84:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804b88:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804b8c:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea804b90:	37300080 	tbnz	w0, #6, ffffffffea804ba0 <smc_intc_request_fiq+0x48>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804b94:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804b98:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804b9c:	52800055 	mov	w21, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804ba0:	f0000296 	adrp	x22, ffffffffea857000 <__bss_start>
ffffffffea804ba4:	910462c0 	add	x0, x22, #0x118
ffffffffea804ba8:	97fff76d 	bl	ffffffffea80295c <arch_spin_lock>
	uint32_t mask = 1ULL << (irq % 32);
ffffffffea804bac:	12001260 	and	w0, w19, #0x1f
ffffffffea804bb0:	d2800028 	mov	x8, #0x1                   	// #1
	int reg = irq / 32;
ffffffffea804bb4:	53057e61 	lsr	w1, w19, #5
	if (irq >= MAX_INT)
ffffffffea804bb8:	710c7e7f 	cmp	w19, #0x31f
	uint32_t mask = 1ULL << (irq % 32);
ffffffffea804bbc:	9ac02108 	lsl	x8, x8, x0
	if (irq >= MAX_INT)
ffffffffea804bc0:	54000188 	b.hi	ffffffffea804bf0 <smc_intc_request_fiq+0x98>  // b.pmore
		GICREG(0, GICD_IGROUPR(reg)) = (gicd_igroupr[reg] &= ~mask);
ffffffffea804bc4:	93407c24 	sxtw	x4, w1
ffffffffea804bc8:	900000a3 	adrp	x3, ffffffffea818000 <_mem_phys_base>
ffffffffea804bcc:	11108020 	add	w0, w1, #0x420
ffffffffea804bd0:	91078063 	add	x3, x3, #0x1e0
ffffffffea804bd4:	929fffe5 	mov	x5, #0xffffffffffff0000    	// #-65536
ffffffffea804bd8:	531e7400 	lsl	w0, w0, #2
ffffffffea804bdc:	f2be2805 	movk	x5, #0xf140, lsl #16
ffffffffea804be0:	b8647862 	ldr	w2, [x3, x4, lsl #2]
ffffffffea804be4:	0a280042 	bic	w2, w2, w8
ffffffffea804be8:	b8247862 	str	w2, [x3, x4, lsl #2]
ffffffffea804bec:	b820c8a2 	str	w2, [x5, w0, sxtw]
	u_int reg = irq / 4;
ffffffffea804bf0:	53027e63 	lsr	w3, w19, #2
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804bf4:	900000a7 	adrp	x7, ffffffffea818000 <_mem_phys_base>
ffffffffea804bf8:	910920e7 	add	x7, x7, #0x248
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804bfc:	11180064 	add	w4, w3, #0x600
	u_int shift = 8 * (irq % 4);
ffffffffea804c00:	531d0665 	ubfiz	w5, w19, #3, #2
	enable_mask = (enable_mask << shift) & cpu_mask;
ffffffffea804c04:	12800000 	mov	w0, #0xffffffff            	// #-1
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804c08:	531e7484 	lsl	w4, w4, #2
ffffffffea804c0c:	929fffe6 	mov	x6, #0xffffffffffff0000    	// #-65536
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804c10:	b86378ea 	ldr	w10, [x7, x3, lsl #2]
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804c14:	f2be2806 	movk	x6, #0xf140, lsl #16
	enable_mask = (enable_mask << shift) & cpu_mask;
ffffffffea804c18:	1ac52000 	lsl	w0, w0, w5
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804c1c:	52801fe2 	mov	w2, #0xff                  	// #255
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804c20:	4a0a0000 	eor	w0, w0, w10
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804c24:	1ac52042 	lsl	w2, w2, w5
	regval = GICREG(0, GICD_IPRIORITYR(reg));
ffffffffea804c28:	51100089 	sub	w9, w4, #0x400
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804c2c:	0a020000 	and	w0, w0, w2
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804c30:	b86448c5 	ldr	w5, [x6, w4, uxtw]
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804c34:	4a0a0000 	eor	w0, w0, w10
	GICREG(0, GICD_ITARGETSR(reg)) = gicd_itargetsr[reg] = new_val;
ffffffffea804c38:	b82448c0 	str	w0, [x6, w4, uxtw]
ffffffffea804c3c:	f0000285 	adrp	x5, ffffffffea857000 <__bss_start>
ffffffffea804c40:	9102c0a4 	add	x4, x5, #0xb0
	regval = GICREG(0, GICD_IPRIORITYR(reg));
ffffffffea804c44:	b86948ca 	ldr	w10, [x6, w9, uxtw]
ffffffffea804c48:	53067e65 	lsr	w5, w19, #6
	GICREG(0, GICD_ITARGETSR(reg)) = gicd_itargetsr[reg] = new_val;
ffffffffea804c4c:	b82378e0 	str	w0, [x7, x3, lsl #2]
ffffffffea804c50:	d2800020 	mov	x0, #0x1                   	// #1
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea804c54:	0a220142 	bic	w2, w10, w2
	GICREG(0, GICD_IPRIORITYR(reg)) = regval;
ffffffffea804c58:	b82948c2 	str	w2, [x6, w9, uxtw]
ffffffffea804c5c:	9ad32013 	lsl	x19, x0, x19
ffffffffea804c60:	f8657882 	ldr	x2, [x4, x5, lsl #3]
	if (enable)
ffffffffea804c64:	34000257 	cbz	w23, ffffffffea804cac <smc_intc_request_fiq+0x154>
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804c68:	11110021 	add	w1, w1, #0x440
		*bitmap |= mask;
ffffffffea804c6c:	aa020273 	orr	x19, x19, x2
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804c70:	531e7421 	lsl	w1, w1, #2
ffffffffea804c74:	b821c8c8 	str	w8, [x6, w1, sxtw]
		*bitmap |= mask;
ffffffffea804c78:	f8257893 	str	x19, [x4, x5, lsl #3]
    arch_spin_unlock(lock);
ffffffffea804c7c:	910462c0 	add	x0, x22, #0x118
ffffffffea804c80:	97fff73f 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804c84:	34000055 	cbz	w21, ffffffffea804c8c <smc_intc_request_fiq+0x134>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804c88:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804c8c:	36000054 	tbz	w20, #0, ffffffffea804c94 <smc_intc_request_fiq+0x13c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804c90:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea804c94:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea804c98:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea804c9c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804ca0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea804ca4:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea804ca8:	d65f03c0 	ret
		GICREG(0, GICD_ICENABLER(reg)) = mask;
ffffffffea804cac:	11118021 	add	w1, w1, #0x460
		*bitmap &= ~mask;
ffffffffea804cb0:	8a330053 	bic	x19, x2, x19
		GICREG(0, GICD_ICENABLER(reg)) = mask;
ffffffffea804cb4:	531e7421 	lsl	w1, w1, #2
ffffffffea804cb8:	b821c8c8 	str	w8, [x6, w1, sxtw]
		*bitmap &= ~mask;
ffffffffea804cbc:	f8257893 	str	x19, [x4, x5, lsl #3]
ffffffffea804cc0:	17ffffef 	b	ffffffffea804c7c <smc_intc_request_fiq+0x124>
ffffffffea804cc4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804cc8 <sm_intc_fiq_enter>:
#endif

status_t sm_intc_fiq_enter(void)
{
ffffffffea804cc8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea804ccc:	910003fd 	mov	x29, sp
ffffffffea804cd0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804cd4:	f90013f5 	str	x21, [sp, #32]
ffffffffea804cd8:	aa1e03f5 	mov	x21, x30
	u_int cpu = arch_curr_cpu_num();
ffffffffea804cdc:	97fff7a5 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea804ce0:	2a0003f4 	mov	w20, w0
	u_int irq = GICREG(0, GICC_IAR) & 0x3ff;
ffffffffea804ce4:	929bfe61 	mov	x1, #0xffffffffffff200c    	// #-57332
	bool fiq_enabled;

	ASSERT(cpu < 8);
ffffffffea804ce8:	71001e9f 	cmp	w20, #0x7
	u_int irq = GICREG(0, GICC_IAR) & 0x3ff;
ffffffffea804cec:	f2be2801 	movk	x1, #0xf140, lsl #16
ffffffffea804cf0:	b9400033 	ldr	w19, [x1]
	ASSERT(cpu < 8);
ffffffffea804cf4:	54000308 	b.hi	ffffffffea804d54 <sm_intc_fiq_enter+0x8c>  // b.pmore
ffffffffea804cf8:	12002673 	and	w19, w19, #0x3ff

	LTRACEF("cpu %d, irq %i\n", cpu, irq);

	if (irq >= 1020) {
ffffffffea804cfc:	710fee7f 	cmp	w19, #0x3fb
ffffffffea804d00:	540003c8 	b.hi	ffffffffea804d78 <sm_intc_fiq_enter+0xb0>  // b.pmore
		LTRACEF("spurious fiq: cpu %d, old %d, new %d\n", cpu, current_fiq[cpu], irq);
		return ERR_NO_MSG;
	}

	fiq_enabled = update_fiq_targets(cpu, false, irq, false);
ffffffffea804d04:	2a1303e2 	mov	w2, w19
ffffffffea804d08:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea804d0c:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea804d10:	97fffd84 	bl	ffffffffea804320 <update_fiq_targets>
	GICREG(0, GICC_EOIR) = irq;
ffffffffea804d14:	929bfde2 	mov	x2, #0xffffffffffff2010    	// #-57328

	if (current_fiq[cpu] != 0x3ff) {
ffffffffea804d18:	900000a1 	adrp	x1, ffffffffea818000 <_mem_phys_base>
	GICREG(0, GICC_EOIR) = irq;
ffffffffea804d1c:	f2be2802 	movk	x2, #0xf140, lsl #16
	if (current_fiq[cpu] != 0x3ff) {
ffffffffea804d20:	91070021 	add	x1, x1, #0x1c0
	fiq_enabled = update_fiq_targets(cpu, false, irq, false);
ffffffffea804d24:	12001c00 	and	w0, w0, #0xff
	GICREG(0, GICC_EOIR) = irq;
ffffffffea804d28:	b9000053 	str	w19, [x2]
	if (current_fiq[cpu] != 0x3ff) {
ffffffffea804d2c:	b8747822 	ldr	w2, [x1, x20, lsl #2]
ffffffffea804d30:	710ffc5f 	cmp	w2, #0x3ff
ffffffffea804d34:	54000261 	b.ne	ffffffffea804d80 <sm_intc_fiq_enter+0xb8>  // b.any
		dprintf(INFO, "more than one fiq active: cpu %d, old %d, new %d\n", cpu, current_fiq[cpu], irq);
		return ERR_ALREADY_STARTED;
	}

	if (!fiq_enabled) {
ffffffffea804d38:	34000280 	cbz	w0, ffffffffea804d88 <sm_intc_fiq_enter+0xc0>
		dprintf(INFO, "got disabled fiq: cpu %d, new %d\n", cpu, irq);
		return ERR_NOT_READY;
	}

	current_fiq[cpu] = irq;
ffffffffea804d3c:	b8347833 	str	w19, [x1, x20, lsl #2]

	return 0;
ffffffffea804d40:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea804d44:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804d48:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea804d4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea804d50:	d65f03c0 	ret
	ASSERT(cpu < 8);
ffffffffea804d54:	d0000084 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea804d58:	d0000082 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea804d5c:	b0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804d60:	91018084 	add	x4, x4, #0x60
ffffffffea804d64:	52804823 	mov	w3, #0x241                 	// #577
ffffffffea804d68:	9101a042 	add	x2, x2, #0x68
ffffffffea804d6c:	91330021 	add	x1, x1, #0xcc0
ffffffffea804d70:	aa1503e0 	mov	x0, x21
ffffffffea804d74:	94003325 	bl	ffffffffea811a08 <_panic>
		return ERR_NO_MSG;
ffffffffea804d78:	12800060 	mov	w0, #0xfffffffc            	// #-4
ffffffffea804d7c:	17fffff2 	b	ffffffffea804d44 <sm_intc_fiq_enter+0x7c>
		return ERR_ALREADY_STARTED;
ffffffffea804d80:	128000a0 	mov	w0, #0xfffffffa            	// #-6
ffffffffea804d84:	17fffff0 	b	ffffffffea804d44 <sm_intc_fiq_enter+0x7c>
		return ERR_NOT_READY;
ffffffffea804d88:	12800040 	mov	w0, #0xfffffffd            	// #-3
ffffffffea804d8c:	17ffffee 	b	ffffffffea804d44 <sm_intc_fiq_enter+0x7c>

ffffffffea804d90 <sm_intc_fiq_exit>:

void sm_intc_fiq_exit(void)
{
ffffffffea804d90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea804d94:	910003fd 	mov	x29, sp
ffffffffea804d98:	f9000bf3 	str	x19, [sp, #16]
ffffffffea804d9c:	aa1e03f3 	mov	x19, x30
	u_int cpu = arch_curr_cpu_num();
ffffffffea804da0:	97fff774 	bl	ffffffffea802b70 <arch_curr_cpu_num>

	ASSERT(cpu < 8);
ffffffffea804da4:	71001c1f 	cmp	w0, #0x7
ffffffffea804da8:	f9000fb4 	str	x20, [x29, #24]
ffffffffea804dac:	54000208 	b.hi	ffffffffea804dec <sm_intc_fiq_exit+0x5c>  // b.pmore

	LTRACEF("cpu %d, irq %i\n", cpu, current_fiq[cpu]);
	if (current_fiq[cpu] == 0x3ff) {
ffffffffea804db0:	900000b4 	adrp	x20, ffffffffea818000 <_mem_phys_base>
ffffffffea804db4:	2a0003f3 	mov	w19, w0
ffffffffea804db8:	91070294 	add	x20, x20, #0x1c0
ffffffffea804dbc:	b8737a82 	ldr	w2, [x20, x19, lsl #2]
ffffffffea804dc0:	710ffc5f 	cmp	w2, #0x3ff
ffffffffea804dc4:	540000c0 	b.eq	ffffffffea804ddc <sm_intc_fiq_exit+0x4c>  // b.none
		dprintf(INFO, "%s: no fiq active, cpu %d\n", __func__, cpu);
		return;
	}
	update_fiq_targets(cpu, true, current_fiq[cpu], false);
ffffffffea804dc8:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea804dcc:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea804dd0:	97fffd54 	bl	ffffffffea804320 <update_fiq_targets>
	current_fiq[cpu] = 0x3ff;
ffffffffea804dd4:	52807fe0 	mov	w0, #0x3ff                 	// #1023
ffffffffea804dd8:	b8337a80 	str	w0, [x20, x19, lsl #2]
ffffffffea804ddc:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea804de0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea804de4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea804de8:	d65f03c0 	ret
	ASSERT(cpu < 8);
ffffffffea804dec:	d0000084 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea804df0:	d0000082 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea804df4:	b0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804df8:	91018084 	add	x4, x4, #0x60
ffffffffea804dfc:	52804c03 	mov	w3, #0x260                 	// #608
ffffffffea804e00:	9101a042 	add	x2, x2, #0x68
ffffffffea804e04:	91330021 	add	x1, x1, #0xcc0
ffffffffea804e08:	aa1303e0 	mov	x0, x19
ffffffffea804e0c:	940032ff 	bl	ffffffffea811a08 <_panic>

ffffffffea804e10 <arm_gic_sim_irq_handler>:
 *        expired.
 *        The body of this function is a mimic of irq_exception routine in
 *        arch/arm64/exceptions.S
 */
status_t arm_gic_sim_irq_handler(u_int irq)
{
ffffffffea804e10:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea804e14:	910003fd 	mov	x29, sp
ffffffffea804e18:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804e1c:	2a0003f4 	mov	w20, w0
	status_t ret = NO_ERROR;
#if WITH_LIB_SM
	uint cpu = arch_curr_cpu_num();
ffffffffea804e20:	97fff754 	bl	ffffffffea802b70 <arch_curr_cpu_num>
	struct int_handler_struct *h;
	spin_lock_saved_state_t state;

	LTRACEF("irq: %u cpu: %u\n", irq, cpu);

	if (irq >= MAX_INT) {
ffffffffea804e24:	710c7e9f 	cmp	w20, #0x31f
ffffffffea804e28:	54000c28 	b.hi	ffffffffea804fac <arm_gic_sim_irq_handler+0x19c>  // b.pmore
ffffffffea804e2c:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea804e30:	2a0003f3 	mov	w19, w0
ffffffffea804e34:	f9001bb7 	str	x23, [x29, #48]
			irq, MAX_INT);
		return ERR_INVALID_ARGS;
	}

	/* Barrier against speculatively loading int_handler_struct addresses */
	platform_arch_speculation_barrier();
ffffffffea804e38:	97fff4e0 	bl	ffffffffea8021b8 <platform_arch_speculation_barrier>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804e3c:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea804e40:	52800016 	mov	w22, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804e44:	36380520 	tbz	w0, #7, ffffffffea804ee8 <arm_gic_sim_irq_handler+0xd8>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804e48:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804e4c:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea804e50:	37300080 	tbnz	w0, #6, ffffffffea804e60 <arm_gic_sim_irq_handler+0x50>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804e54:	321f02d6 	orr	w22, w22, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804e58:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804e5c:	52800057 	mov	w23, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804e60:	f0000295 	adrp	x21, ffffffffea857000 <__bss_start>
ffffffffea804e64:	910462a0 	add	x0, x21, #0x118
ffffffffea804e68:	97fff6bd 	bl	ffffffffea80295c <arch_spin_lock>
	if (vector < GIC_MAX_PER_CPU_INT)
ffffffffea804e6c:	71007e9f 	cmp	w20, #0x1f
ffffffffea804e70:	54000309 	b.ls	ffffffffea804ed0 <arm_gic_sim_irq_handler+0xc0>  // b.plast
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804e74:	51008281 	sub	w1, w20, #0x20
ffffffffea804e78:	900002a0 	adrp	x0, ffffffffea858000 <int_handler_table_per_cpu+0xee0>
ffffffffea804e7c:	91048000 	add	x0, x0, #0x120
ffffffffea804e80:	8b011001 	add	x1, x0, x1, lsl #4

	spin_lock_save(&gicd_lock, &state, GICD_LOCK_FLAGS);
	if ((h = get_int_handler(irq, cpu))->handler != NULL) {
ffffffffea804e84:	f9400022 	ldr	x2, [x1]
ffffffffea804e88:	b4000802 	cbz	x2, ffffffffea804f88 <arm_gic_sim_irq_handler+0x178>
		if (h->handler(h->arg) == INT_RESCHEDULE) {
ffffffffea804e8c:	f9400420 	ldr	x0, [x1, #8]
	status_t ret = NO_ERROR;
ffffffffea804e90:	52800013 	mov	w19, #0x0                   	// #0
		if (h->handler(h->arg) == INT_RESCHEDULE) {
ffffffffea804e94:	d63f0040 	blr	x2
ffffffffea804e98:	7100041f 	cmp	w0, #0x1
ffffffffea804e9c:	54000380 	b.eq	ffffffffea804f0c <arm_gic_sim_irq_handler+0xfc>  // b.none
    arch_spin_unlock(lock);
ffffffffea804ea0:	910462a0 	add	x0, x21, #0x118
ffffffffea804ea4:	97fff6b6 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804ea8:	34000057 	cbz	w23, ffffffffea804eb0 <arm_gic_sim_irq_handler+0xa0>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804eac:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804eb0:	36000236 	tbz	w22, #0, ffffffffea804ef4 <arm_gic_sim_irq_handler+0xe4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804eb4:	d50342ff 	msr	daifclr, #0x2
ffffffffea804eb8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea804ebc:	f9401bb7 	ldr	x23, [x29, #48]
	spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);
#else
	ret = ERR_NOT_SUPPORTED;
#endif
	return ret;
}
ffffffffea804ec0:	2a1303e0 	mov	w0, w19
ffffffffea804ec4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804ec8:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea804ecc:	d65f03c0 	ret
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804ed0:	2a1303e1 	mov	w1, w19
ffffffffea804ed4:	f0000280 	adrp	x0, ffffffffea857000 <__bss_start>
ffffffffea804ed8:	8b344c21 	add	x1, x1, w20, uxtw #3
ffffffffea804edc:	91048000 	add	x0, x0, #0x120
ffffffffea804ee0:	8b011001 	add	x1, x0, x1, lsl #4
ffffffffea804ee4:	17ffffe8 	b	ffffffffea804e84 <arm_gic_sim_irq_handler+0x74>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804ee8:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804eec:	52800036 	mov	w22, #0x1                   	// #1
ffffffffea804ef0:	17ffffd6 	b	ffffffffea804e48 <arm_gic_sim_irq_handler+0x38>
}
ffffffffea804ef4:	2a1303e0 	mov	w0, w19
ffffffffea804ef8:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea804efc:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea804f00:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804f04:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea804f08:	d65f03c0 	ret
ffffffffea804f0c:	910462a0 	add	x0, x21, #0x118
ffffffffea804f10:	97fff69b 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804f14:	34000057 	cbz	w23, ffffffffea804f1c <arm_gic_sim_irq_handler+0x10c>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804f18:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804f1c:	36000056 	tbz	w22, #0, ffffffffea804f24 <arm_gic_sim_irq_handler+0x114>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804f20:	d50342ff 	msr	daifclr, #0x2
			    thread_preempt();
ffffffffea804f24:	9400051d 	bl	ffffffffea806398 <thread_preempt>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804f28:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea804f2c:	52800016 	mov	w22, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804f30:	37380060 	tbnz	w0, #7, ffffffffea804f3c <arm_gic_sim_irq_handler+0x12c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804f34:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804f38:	52800036 	mov	w22, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804f3c:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804f40:	37300160 	tbnz	w0, #6, ffffffffea804f6c <arm_gic_sim_irq_handler+0x15c>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804f44:	321f02d6 	orr	w22, w22, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804f48:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea804f4c:	910462b5 	add	x21, x21, #0x118
	status_t ret = NO_ERROR;
ffffffffea804f50:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea804f54:	aa1503e0 	mov	x0, x21
ffffffffea804f58:	97fff681 	bl	ffffffffea80295c <arch_spin_lock>
    arch_spin_unlock(lock);
ffffffffea804f5c:	aa1503e0 	mov	x0, x21
ffffffffea804f60:	97fff687 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804f64:	d50341ff 	msr	daifclr, #0x1
ffffffffea804f68:	17ffffd2 	b	ffffffffea804eb0 <arm_gic_sim_irq_handler+0xa0>
    arch_spin_lock(lock);
ffffffffea804f6c:	910462b5 	add	x21, x21, #0x118
ffffffffea804f70:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea804f74:	aa1503e0 	mov	x0, x21
ffffffffea804f78:	97fff679 	bl	ffffffffea80295c <arch_spin_lock>
    arch_spin_unlock(lock);
ffffffffea804f7c:	aa1503e0 	mov	x0, x21
ffffffffea804f80:	97fff67f 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea804f84:	17ffffcb 	b	ffffffffea804eb0 <arm_gic_sim_irq_handler+0xa0>
		ret = ERR_NOT_FOUND;
ffffffffea804f88:	12800033 	mov	w19, #0xfffffffe            	// #-2
		TRACEF("interrupt handler not found. irq: %u\n", irq);
ffffffffea804f8c:	b0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804f90:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804f94:	2a1403e3 	mov	w3, w20
ffffffffea804f98:	52805242 	mov	w2, #0x292                 	// #658
ffffffffea804f9c:	913be021 	add	x1, x1, #0xef8
ffffffffea804fa0:	913d4000 	add	x0, x0, #0xf50
ffffffffea804fa4:	940037ff 	bl	ffffffffea812fa0 <_printf>
ffffffffea804fa8:	17ffffbe 	b	ffffffffea804ea0 <arm_gic_sim_irq_handler+0x90>
		TRACEF("Interrupt out of range: vector = %u, MAX_INT = %u\n",
ffffffffea804fac:	b0000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804fb0:	b0000080 	adrp	x0, ffffffffea815000 <__fault_handler_table_start>
ffffffffea804fb4:	52806404 	mov	w4, #0x320                 	// #800
ffffffffea804fb8:	2a1403e3 	mov	w3, w20
ffffffffea804fbc:	52805062 	mov	w2, #0x283                 	// #643
ffffffffea804fc0:	913be021 	add	x1, x1, #0xef8
		return ERR_INVALID_ARGS;
ffffffffea804fc4:	128000f3 	mov	w19, #0xfffffff8            	// #-8
		TRACEF("Interrupt out of range: vector = %u, MAX_INT = %u\n",
ffffffffea804fc8:	913c4000 	add	x0, x0, #0xf10
ffffffffea804fcc:	940037f5 	bl	ffffffffea812fa0 <_printf>
		return ERR_INVALID_ARGS;
ffffffffea804fd0:	17ffffbc 	b	ffffffffea804ec0 <arm_gic_sim_irq_handler+0xb0>
ffffffffea804fd4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804fd8 <cntpct_to_lk_time>:
}

static inline uint64_t
mul_u32_u32(uint32_t a, uint32_t b, int a_shift, int b_shift)
{
    uint64_t ret = (uint64_t)a * b;
ffffffffea804fd8:	b00002c1 	adrp	x1, ffffffffea85d000 <rb_data+0x18>
ffffffffea804fdc:	9101c024 	add	x4, x1, #0x70
ffffffffea804fe0:	92407c02 	and	x2, x0, #0xffffffff
}

static inline uint32_t
u32_mul_u64_fp32_64(uint64_t a, struct fp_32_64 b)
{
    uint32_t a_r32 = a >> 32;
ffffffffea804fe4:	d360fc00 	lsr	x0, x0, #32
    uint64_t ret = (uint64_t)a * b;
ffffffffea804fe8:	b9407023 	ldr	w3, [x1, #112]
ffffffffea804fec:	b9400881 	ldr	w1, [x4, #8]
ffffffffea804ff0:	b9400484 	ldr	w4, [x4, #4]
ffffffffea804ff4:	9b027c63 	mul	x3, x3, x2
ffffffffea804ff8:	9b017c05 	mul	x5, x0, x1
ffffffffea804ffc:	9b017c41 	mul	x1, x2, x1
    uint64_t res_l32;
    uint32_t ret;

    /* mul_u32_u32(a_r32, b.l0, 32, 0) does not affect result */
    res_l32 = mul_u32_u32(a_0, b.l0, 0, 0) << 32;
    res_l32 += mul_u32_u32(a_r32, b.l32, 32, -32) << 32;
ffffffffea805000:	9b040c00 	madd	x0, x0, x4, x3
ffffffffea805004:	9b041442 	madd	x2, x2, x4, x5
ffffffffea805008:	8b008040 	add	x0, x2, x0, lsl #32
    res_l32 += mul_u32_u32(a_0, b.l32, 0, -32);
    res_l32 += mul_u32_u32(a_r32, b.l64, 32, -64);
    res_l32 += mul_u32_u32(a_0, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea80500c:	8b418000 	add	x0, x0, x1, lsr #32
    ret = (res_l32 >> 32) + ((uint32_t)res_l32 >> 31); /* Round to nearest integer */
ffffffffea805010:	d360fc01 	lsr	x1, x0, #32
}

static lk_time_t cntpct_to_lk_time(uint64_t cntpct)
{
	return u32_mul_u64_fp32_64(cntpct, ms_per_cntpct);
}
ffffffffea805014:	0b407c20 	add	w0, w1, w0, lsr #31
ffffffffea805018:	d65f03c0 	ret
ffffffffea80501c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805020 <platform_tick>:
}

static void write_cntp_ctl(uint32_t cntp_ctl)
{
	LTRACEF_LEVEL(3, "cntp_ctl: 0x%x %x\n", cntp_ctl, read_cntp_ctl());
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea805020:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805024:	d51fe221 	msr	cntps_ctl_el1, x1
ffffffffea805028:	d5033fdf 	isb
}

static enum handler_return platform_tick(void *arg)
{
	write_cntp_ctl(0);
	if (t_callback) {
ffffffffea80502c:	d00002a1 	adrp	x1, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
ffffffffea805030:	f9409027 	ldr	x7, [x1, #288]
ffffffffea805034:	b4000147 	cbz	x7, ffffffffea80505c <platform_tick+0x3c>
{
ffffffffea805038:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80503c:	aa0003e6 	mov	x6, x0
ffffffffea805040:	910003fd 	mov	x29, sp
	cntpct = READ_TIMER_REG64(TIMER_REG_CT);
ffffffffea805044:	d53be020 	mrs	x0, cntpct_el0
	return cntpct_to_lk_bigtime(read_cntpct());
}

lk_time_t current_time(void)
{
	return cntpct_to_lk_time(read_cntpct());
ffffffffea805048:	97ffffe4 	bl	ffffffffea804fd8 <cntpct_to_lk_time>
		return t_callback(arg, current_time());
ffffffffea80504c:	2a0003e1 	mov	w1, w0
}
ffffffffea805050:	a8c17bfd 	ldp	x29, x30, [sp], #16
		return t_callback(arg, current_time());
ffffffffea805054:	aa0603e0 	mov	x0, x6
ffffffffea805058:	d61f00e0 	br	x7
}
ffffffffea80505c:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805060:	d65f03c0 	ret
ffffffffea805064:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805068 <arm_generic_timer_resume_cpu>:
	WRITE_TIMER_REG32(TIMER_REG_TVAL, cntp_tval);
ffffffffea805068:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80506c:	d51fe200 	msr	cntps_tval_el1, x0
ffffffffea805070:	d5033fdf 	isb
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea805074:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea805078:	d51fe220 	msr	cntps_ctl_el1, x0
ffffffffea80507c:	d5033fdf 	isb
static void arm_generic_timer_resume_cpu(uint level)
{
	/* Always trigger a timer interrupt on each cpu for now */
	write_cntp_tval(0);
	write_cntp_ctl(1);
}
ffffffffea805080:	d65f03c0 	ret
ffffffffea805084:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805088 <arm_generic_timer_init_secondary_cpu>:
{
ffffffffea805088:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	register_int_handler(timer_irq, &platform_tick, NULL);
ffffffffea80508c:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea805090:	90000001 	adrp	x1, ffffffffea805000 <cntpct_to_lk_time+0x28>
ffffffffea805094:	91008021 	add	x1, x1, #0x20
{
ffffffffea805098:	910003fd 	mov	x29, sp
ffffffffea80509c:	f9000bf3 	str	x19, [sp, #16]
	register_int_handler(timer_irq, &platform_tick, NULL);
ffffffffea8050a0:	d00002b3 	adrp	x19, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
ffffffffea8050a4:	b9412a60 	ldr	w0, [x19, #296]
ffffffffea8050a8:	97fffd14 	bl	ffffffffea8044f8 <register_int_handler>
	unmask_interrupt(timer_irq);
ffffffffea8050ac:	b9412a60 	ldr	w0, [x19, #296]
}
ffffffffea8050b0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8050b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	unmask_interrupt(timer_irq);
ffffffffea8050b8:	17fffddc 	b	ffffffffea804828 <unmask_interrupt>
ffffffffea8050bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8050c0 <test_cntpct_to_lk_time>:
{
ffffffffea8050c0:	2a0003e5 	mov	w5, w0
ffffffffea8050c4:	2a0103e8 	mov	w8, w1
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea8050c8:	d29ef9e1 	mov	x1, #0xf7cf                	// #63439
{
ffffffffea8050cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea8050d0:	f2bc6a61 	movk	x1, #0xe353, lsl #16
	if ((uint64_t)cntfrq * wrap_count > UINT_MAX)
ffffffffea8050d4:	b2407fe3 	mov	x3, #0xffffffff            	// #4294967295
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea8050d8:	9ba87ca0 	umull	x0, w5, w8
ffffffffea8050dc:	f2d374a1 	movk	x1, #0x9ba5, lsl #32
ffffffffea8050e0:	f2e41881 	movk	x1, #0x20c4, lsl #48
	if ((uint64_t)cntfrq * wrap_count > UINT_MAX)
ffffffffea8050e4:	9ba27ca4 	umull	x4, w5, w2
{
ffffffffea8050e8:	910003fd 	mov	x29, sp
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea8050ec:	d343fc00 	lsr	x0, x0, #3
{
ffffffffea8050f0:	aa0503e6 	mov	x6, x5
ffffffffea8050f4:	aa0803e7 	mov	x7, x8
	if ((uint64_t)cntfrq * wrap_count > UINT_MAX)
ffffffffea8050f8:	eb03009f 	cmp	x4, x3
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea8050fc:	9bc17c00 	umulh	x0, x0, x1
ffffffffea805100:	d344fc00 	lsr	x0, x0, #4
	if ((uint64_t)cntfrq * wrap_count > UINT_MAX)
ffffffffea805104:	54000229 	b.ls	ffffffffea805148 <test_cntpct_to_lk_time+0x88>  // b.plast
		cntpct += (((uint64_t)cntfrq << 32) / 1000) * wrap_count;
ffffffffea805108:	d36388a4 	lsl	x4, x5, #29
ffffffffea80510c:	2a0203e2 	mov	w2, w2
ffffffffea805110:	9bc17c84 	umulh	x4, x4, x1
ffffffffea805114:	d344fc84 	lsr	x4, x4, #4
ffffffffea805118:	9b020080 	madd	x0, x4, x2, x0
	lk_time = cntpct_to_lk_time(cntpct);
ffffffffea80511c:	97ffffaf 	bl	ffffffffea804fd8 <cntpct_to_lk_time>
	if (a != b) {
ffffffffea805120:	eb20411f 	cmp	x8, w0, uxtw
ffffffffea805124:	540000e0 	b.eq	ffffffffea805140 <test_cntpct_to_lk_time+0x80>  // b.none
	test_time_conversion_check_result(lk_time, expected_lk_time, (1000 + cntfrq - 1) / cntfrq, true);
ffffffffea805128:	110f9cc1 	add	w1, w6, #0x3e7
	return (a > 0) ? a : -a;
ffffffffea80512c:	6b070000 	subs	w0, w0, w7
ffffffffea805130:	5a805400 	cneg	w0, w0, mi  // mi = first
	test_time_conversion_check_result(lk_time, expected_lk_time, (1000 + cntfrq - 1) / cntfrq, true);
ffffffffea805134:	1ac60826 	udiv	w6, w1, w6
		if (diff <= limit)
ffffffffea805138:	6b0000df 	cmp	w6, w0
ffffffffea80513c:	540000e3 	b.cc	ffffffffea805158 <test_cntpct_to_lk_time+0x98>  // b.lo, b.ul, b.last
}
ffffffffea805140:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea805144:	d65f03c0 	ret
		cntpct += (((uint64_t)(cntfrq * wrap_count) << 32) / 1000);
ffffffffea805148:	d3637c84 	ubfiz	x4, x4, #29, #32
ffffffffea80514c:	9bc17c84 	umulh	x4, x4, x1
ffffffffea805150:	8b441000 	add	x0, x0, x4, lsr #4
ffffffffea805154:	17fffff2 	b	ffffffffea80511c <test_cntpct_to_lk_time+0x5c>
}
ffffffffea805158:	a8c17bfd 	ldp	x29, x30, [sp], #16
			TRACEF("FAIL, off by %llu\n", diff);
ffffffffea80515c:	b0000084 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea805160:	93407c03 	sxtw	x3, w0
ffffffffea805164:	b0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea805168:	52801f42 	mov	w2, #0xfa                  	// #250
ffffffffea80516c:	91026021 	add	x1, x1, #0x98
ffffffffea805170:	91068080 	add	x0, x4, #0x1a0
ffffffffea805174:	1400378b 	b	ffffffffea812fa0 <_printf>

ffffffffea805178 <test_cntpct_to_lk_bigtime>:
	uint64_t cntpct = (uint64_t)cntfrq * expected_s;
ffffffffea805178:	2a0003e4 	mov	w4, w0
    uint64_t ret = (uint64_t)a * b;
ffffffffea80517c:	900002c5 	adrp	x5, ffffffffea85d000 <rb_data+0x18>
ffffffffea805180:	910180a2 	add	x2, x5, #0x60
	lk_bigtime_t expected_lk_bigtime = expected_s * 1000 * 1000;
ffffffffea805184:	d2884803 	mov	x3, #0x4240                	// #16960
ffffffffea805188:	b94060a6 	ldr	w6, [x5, #96]
ffffffffea80518c:	f2a001e3 	movk	x3, #0xf, lsl #16
	uint64_t cntpct = (uint64_t)cntfrq * expected_s;
ffffffffea805190:	9b017c84 	mul	x4, x4, x1
ffffffffea805194:	29409449 	ldp	w9, w5, [x2, #4]
ffffffffea805198:	92407c88 	and	x8, x4, #0xffffffff
}

static inline uint64_t
u64_mul_u64_fp32_64(uint64_t a, struct fp_32_64 b)
{
    uint32_t a_r32 = a >> 32;
ffffffffea80519c:	d360fc84 	lsr	x4, x4, #32
	lk_bigtime_t expected_lk_bigtime = expected_s * 1000 * 1000;
ffffffffea8051a0:	9b037c21 	mul	x1, x1, x3
    uint64_t ret = (uint64_t)a * b;
ffffffffea8051a4:	9b097d07 	mul	x7, x8, x9
ffffffffea8051a8:	9b057d02 	mul	x2, x8, x5
ffffffffea8051ac:	9b057c85 	mul	x5, x4, x5
ffffffffea8051b0:	9b067c83 	mul	x3, x4, x6
    tmp = mul_u32_u32(a_0, b.l32, 0, -32);
    res_0 += tmp >> 32;
    res_l32 = (uint32_t)tmp;
    tmp = mul_u32_u32(a_r32, b.l64, 32, -64);
    res_0 += tmp >> 32;
    res_l32 += (uint32_t)tmp;
ffffffffea8051b4:	92407caa 	and	x10, x5, #0xffffffff
    uint64_t ret = (uint64_t)a * b;
ffffffffea8051b8:	9b097c84 	mul	x4, x4, x9
    res_0 += tmp >> 32;
ffffffffea8051bc:	d360fce9 	lsr	x9, x7, #32
    res_l32 += (uint32_t)tmp;
ffffffffea8051c0:	8b274147 	add	x7, x10, w7, uxtw
    tmp = mul_u32_u32(a_0, b.l64, 0, -64); /* Improve rounding accuracy */
    res_l32 += tmp >> 32;
    res_0 += res_l32 >> 32;
    res_l32_32 = res_l32;
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea8051c4:	9b0810c4 	madd	x4, x6, x8, x4
    res_l32 += tmp >> 32;
ffffffffea8051c8:	8b4280e2 	add	x2, x7, x2, lsr #32
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea8051cc:	8b038123 	add	x3, x9, x3, lsl #32
ffffffffea8051d0:	8b040063 	add	x3, x3, x4
    res_0 += res_l32 >> 32;
ffffffffea8051d4:	d360fc44 	lsr	x4, x2, #32
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea8051d8:	8b458085 	add	x5, x4, x5, lsr #32
ffffffffea8051dc:	531f7c42 	lsr	w2, w2, #31
ffffffffea8051e0:	8b050063 	add	x3, x3, x5
ffffffffea8051e4:	8b030043 	add	x3, x2, x3
	if (a != b) {
ffffffffea8051e8:	eb03003f 	cmp	x1, x3
ffffffffea8051ec:	54000100 	b.eq	ffffffffea80520c <test_cntpct_to_lk_bigtime+0x94>  // b.none
	test_time_conversion_check_result(lk_bigtime, expected_lk_bigtime, (1000 * 1000 + cntfrq - 1) / cntfrq, false);
ffffffffea8051f0:	1143d002 	add	w2, w0, #0xf4, lsl #12
	return (a > 0) ? a : -a;
ffffffffea8051f4:	eb010063 	subs	x3, x3, x1
	test_time_conversion_check_result(lk_bigtime, expected_lk_bigtime, (1000 * 1000 + cntfrq - 1) / cntfrq, false);
ffffffffea8051f8:	1108fc42 	add	w2, w2, #0x23f
	return (a > 0) ? a : -a;
ffffffffea8051fc:	da835463 	cneg	x3, x3, mi  // mi = first
	test_time_conversion_check_result(lk_bigtime, expected_lk_bigtime, (1000 * 1000 + cntfrq - 1) / cntfrq, false);
ffffffffea805200:	1ac00840 	udiv	w0, w2, w0
		if (diff <= limit)
ffffffffea805204:	eb03001f 	cmp	x0, x3
ffffffffea805208:	54000043 	b.cc	ffffffffea805210 <test_cntpct_to_lk_bigtime+0x98>  // b.lo, b.ul, b.last
}
ffffffffea80520c:	d65f03c0 	ret
			TRACEF("FAIL, off by %llu\n", diff);
ffffffffea805210:	b0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea805214:	b0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea805218:	52801f42 	mov	w2, #0xfa                  	// #250
ffffffffea80521c:	91026021 	add	x1, x1, #0x98
ffffffffea805220:	91068000 	add	x0, x0, #0x1a0
ffffffffea805224:	1400375f 	b	ffffffffea812fa0 <_printf>

ffffffffea805228 <test_lk_time_to_cntpct>:
    uint64_t ret = (uint64_t)a * b;
ffffffffea805228:	900002c3 	adrp	x3, ffffffffea85d000 <rb_data+0x18>
ffffffffea80522c:	91020064 	add	x4, x3, #0x80
	uint64_t expected_cntpct = ((uint64_t)cntfrq * lk_time + 500) / 1000;
ffffffffea805230:	d2803e82 	mov	x2, #0x1f4                 	// #500
ffffffffea805234:	d29ef9e7 	mov	x7, #0xf7cf                	// #63439
    ret = res_0 + (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805238:	b9408066 	ldr	w6, [x3, #128]
ffffffffea80523c:	f2bc6a67 	movk	x7, #0xe353, lsl #16
    uint64_t ret = (uint64_t)a * b;
ffffffffea805240:	29409085 	ldp	w5, w4, [x4, #4]
ffffffffea805244:	d503201f 	nop
ffffffffea805248:	9ba10803 	umaddl	x3, w0, w1, x2
ffffffffea80524c:	f2d374a7 	movk	x7, #0x9ba5, lsl #32
ffffffffea805250:	f2e41887 	movk	x7, #0x20c4, lsl #48
ffffffffea805254:	9ba57c25 	umull	x5, w1, w5
ffffffffea805258:	d343fc63 	lsr	x3, x3, #3
ffffffffea80525c:	9ba47c20 	umull	x0, w1, w4
    res_l32 += mul_u32_u32(a, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea805260:	92407ca2 	and	x2, x5, #0xffffffff
    res_0 += tmp >> 32;
ffffffffea805264:	d360fca5 	lsr	x5, x5, #32
ffffffffea805268:	9bc77c63 	umulh	x3, x3, x7
    res_l32 += mul_u32_u32(a, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea80526c:	8b408040 	add	x0, x2, x0, lsr #32
    ret = res_0 + (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805270:	9ba61421 	umaddl	x1, w1, w6, x5
ffffffffea805274:	531f7c02 	lsr	w2, w0, #31
ffffffffea805278:	8b408040 	add	x0, x2, x0, lsr #32
ffffffffea80527c:	d344fc63 	lsr	x3, x3, #4
ffffffffea805280:	8b000021 	add	x1, x1, x0
	if (a != b) {
ffffffffea805284:	eb01007f 	cmp	x3, x1
ffffffffea805288:	540000a0 	b.eq	ffffffffea80529c <test_lk_time_to_cntpct+0x74>  // b.none
	return (a > 0) ? a : -a;
ffffffffea80528c:	eb030021 	subs	x1, x1, x3
ffffffffea805290:	da815423 	cneg	x3, x1, mi  // mi = first
		if (diff <= limit)
ffffffffea805294:	f100047f 	cmp	x3, #0x1
ffffffffea805298:	54000041 	b.ne	ffffffffea8052a0 <test_lk_time_to_cntpct+0x78>  // b.any
}
ffffffffea80529c:	d65f03c0 	ret
			TRACEF("FAIL, off by %llu\n", diff);
ffffffffea8052a0:	b0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8052a4:	b0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8052a8:	52801f42 	mov	w2, #0xfa                  	// #250
ffffffffea8052ac:	91026021 	add	x1, x1, #0x98
ffffffffea8052b0:	91068000 	add	x0, x0, #0x1a0
ffffffffea8052b4:	1400373b 	b	ffffffffea812fa0 <_printf>

ffffffffea8052b8 <platform_set_oneshot_timer>:
    uint64_t ret = (uint64_t)a * b;
ffffffffea8052b8:	900002c4 	adrp	x4, ffffffffea85d000 <rb_data+0x18>
ffffffffea8052bc:	91020083 	add	x3, x4, #0x80
    ret = res_0 + (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea8052c0:	b9408086 	ldr	w6, [x4, #128]
    uint64_t ret = (uint64_t)a * b;
ffffffffea8052c4:	29408c64 	ldp	w4, w3, [x3, #4]
ffffffffea8052c8:	9ba47c44 	umull	x4, w2, w4
ffffffffea8052cc:	9ba37c43 	umull	x3, w2, w3
    res_l32 += mul_u32_u32(a, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea8052d0:	92407c85 	and	x5, x4, #0xffffffff
    res_0 += tmp >> 32;
ffffffffea8052d4:	d360fc84 	lsr	x4, x4, #32
    res_l32 += mul_u32_u32(a, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea8052d8:	8b4380a3 	add	x3, x5, x3, lsr #32
    ret = res_0 + (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea8052dc:	9ba61042 	umaddl	x2, w2, w6, x4
ffffffffea8052e0:	531f7c65 	lsr	w5, w3, #31
ffffffffea8052e4:	8b4380a3 	add	x3, x5, x3, lsr #32
ffffffffea8052e8:	8b030042 	add	x2, x2, x3
	ASSERT(arg == NULL);
ffffffffea8052ec:	b50002c1 	cbnz	x1, ffffffffea805344 <platform_set_oneshot_timer+0x8c>
	t_callback = callback;
ffffffffea8052f0:	d00002a1 	adrp	x1, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
	if (cntpct_interval <= INT_MAX)
ffffffffea8052f4:	b2407be3 	mov	x3, #0x7fffffff            	// #2147483647
ffffffffea8052f8:	eb03005f 	cmp	x2, x3
	t_callback = callback;
ffffffffea8052fc:	f9009020 	str	x0, [x1, #288]
	if (cntpct_interval <= INT_MAX)
ffffffffea805300:	54000149 	b.ls	ffffffffea805328 <platform_set_oneshot_timer+0x70>  // b.plast
	cntpct = READ_TIMER_REG64(TIMER_REG_CT);
ffffffffea805304:	d53be020 	mrs	x0, cntpct_el0
		write_cntp_cval(read_cntpct() + cntpct_interval);
ffffffffea805308:	8b000042 	add	x2, x2, x0
	WRITE_TIMER_REG64(TIMER_REG_CVAL, cntp_cval);
ffffffffea80530c:	d51fe242 	msr	cntps_cval_el1, x2
ffffffffea805310:	d5033fdf 	isb
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea805314:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea805318:	d51fe220 	msr	cntps_ctl_el1, x0
ffffffffea80531c:	d5033fdf 	isb
}
ffffffffea805320:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805324:	d65f03c0 	ret
	WRITE_TIMER_REG32(TIMER_REG_TVAL, cntp_tval);
ffffffffea805328:	d51fe202 	msr	cntps_tval_el1, x2
ffffffffea80532c:	d5033fdf 	isb
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea805330:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea805334:	d51fe220 	msr	cntps_ctl_el1, x0
ffffffffea805338:	d5033fdf 	isb
}
ffffffffea80533c:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805340:	d65f03c0 	ret
{
ffffffffea805344:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(arg == NULL);
ffffffffea805348:	b0000084 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80534c:	b0000082 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea805350:	90000081 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
{
ffffffffea805354:	910003fd 	mov	x29, sp
ffffffffea805358:	aa1e03e0 	mov	x0, x30
	ASSERT(arg == NULL);
ffffffffea80535c:	91044084 	add	x4, x4, #0x110
ffffffffea805360:	528019c3 	mov	w3, #0xce                  	// #206
ffffffffea805364:	91048042 	add	x2, x2, #0x120
ffffffffea805368:	91330021 	add	x1, x1, #0xcc0
ffffffffea80536c:	940031a7 	bl	ffffffffea811a08 <_panic>

ffffffffea805370 <platform_stop_timer>:
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea805370:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805374:	d51fe220 	msr	cntps_ctl_el1, x0
ffffffffea805378:	d5033fdf 	isb
}
ffffffffea80537c:	d65f03c0 	ret

ffffffffea805380 <current_time_hires>:
	cntpct = READ_TIMER_REG64(TIMER_REG_CT);
ffffffffea805380:	d53be023 	mrs	x3, cntpct_el0
    uint64_t ret = (uint64_t)a * b;
ffffffffea805384:	900002c1 	adrp	x1, ffffffffea85d000 <rb_data+0x18>
ffffffffea805388:	91018020 	add	x0, x1, #0x60
    uint32_t a_r32 = a >> 32;
ffffffffea80538c:	d360fc64 	lsr	x4, x3, #32
ffffffffea805390:	92407c63 	and	x3, x3, #0xffffffff
    uint64_t ret = (uint64_t)a * b;
ffffffffea805394:	b9406026 	ldr	w6, [x1, #96]
ffffffffea805398:	29408007 	ldp	w7, w0, [x0, #4]
ffffffffea80539c:	9b067c82 	mul	x2, x4, x6
ffffffffea8053a0:	9b007c85 	mul	x5, x4, x0
ffffffffea8053a4:	9b077c61 	mul	x1, x3, x7
ffffffffea8053a8:	9b007c60 	mul	x0, x3, x0
ffffffffea8053ac:	9b077c84 	mul	x4, x4, x7
    res_l32 += (uint32_t)tmp;
ffffffffea8053b0:	92407ca7 	and	x7, x5, #0xffffffff
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea8053b4:	9b0310c4 	madd	x4, x6, x3, x4
    res_l32 += (uint32_t)tmp;
ffffffffea8053b8:	8b2140e3 	add	x3, x7, w1, uxtw
    res_l32 += tmp >> 32;
ffffffffea8053bc:	8b408060 	add	x0, x3, x0, lsr #32
    res_0 += tmp >> 32;
ffffffffea8053c0:	d360fc21 	lsr	x1, x1, #32
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea8053c4:	8b028021 	add	x1, x1, x2, lsl #32
    res_0 += res_l32 >> 32;
ffffffffea8053c8:	d360fc02 	lsr	x2, x0, #32
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea8053cc:	8b040021 	add	x1, x1, x4
ffffffffea8053d0:	8b458045 	add	x5, x2, x5, lsr #32
ffffffffea8053d4:	531f7c00 	lsr	w0, w0, #31
ffffffffea8053d8:	8b050021 	add	x1, x1, x5
}
ffffffffea8053dc:	8b010000 	add	x0, x0, x1
ffffffffea8053e0:	d65f03c0 	ret
ffffffffea8053e4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8053e8 <current_time>:
	cntpct = READ_TIMER_REG64(TIMER_REG_CT);
ffffffffea8053e8:	d53be020 	mrs	x0, cntpct_el0
	return cntpct_to_lk_time(read_cntpct());
ffffffffea8053ec:	17fffefb 	b	ffffffffea804fd8 <cntpct_to_lk_time>

ffffffffea8053f0 <arm_generic_timer_init>:
{
ffffffffea8053f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea8053f4:	910003fd 	mov	x29, sp
ffffffffea8053f8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8053fc:	2a0003f4 	mov	w20, w0
	if (freq_override == 0) {
ffffffffea805400:	35001001 	cbnz	w1, ffffffffea805600 <arm_generic_timer_init+0x210>
	cntfrq = READ_TIMER_REG32(TIMER_REG_CNTFRQ);
ffffffffea805404:	d53be000 	mrs	x0, cntfrq_el0
ffffffffea805408:	2a0003f3 	mov	w19, w0
		if (!cntfrq) {
ffffffffea80540c:	34000fe0 	cbz	w0, ffffffffea805608 <arm_generic_timer_init+0x218>
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea805410:	2a1303e5 	mov	w5, w19
ffffffffea805414:	d29ef9eb 	mov	x11, #0xf7cf                	// #63439
ffffffffea805418:	f2bc6a6b 	movk	x11, #0xe353, lsl #16
    result->l0 = tmp >> 32;
ffffffffea80541c:	900002c2 	adrp	x2, ffffffffea85d000 <rb_data+0x18>
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea805420:	d3607cae 	lsl	x14, x5, #32
ffffffffea805424:	f2d374ab 	movk	x11, #0x9ba5, lsl #32
ffffffffea805428:	f2e4188b 	movk	x11, #0x20c4, lsl #48
    result->l0 = tmp >> 32;
ffffffffea80542c:	9102004a 	add	x10, x2, #0x80
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea805430:	d343fdc6 	lsr	x6, x14, #3
ffffffffea805434:	d2c84800 	mov	x0, #0x424000000000        	// #72842645340160
ffffffffea805438:	d2c07d01 	mov	x1, #0x3e800000000         	// #4294967296000
ffffffffea80543c:	f2e001e0 	movk	x0, #0xf, lsl #48
    result->l0 = tmp >> 32;
ffffffffea805440:	900002d0 	adrp	x16, ffffffffea85d000 <rb_data+0x18>
ffffffffea805444:	900002cf 	adrp	x15, ffffffffea85d000 <rb_data+0x18>
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea805448:	9bcb7cc6 	umulh	x6, x6, x11
    result->l0 = tmp >> 32;
ffffffffea80544c:	9101c20d 	add	x13, x16, #0x70
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea805450:	9ac50829 	udiv	x9, x1, x5
    result->l0 = tmp >> 32;
ffffffffea805454:	910181ec 	add	x12, x15, #0x60
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea805458:	9ac50808 	udiv	x8, x0, x5
ffffffffea80545c:	d344fcc7 	lsr	x7, x6, #4
    result->l0 = tmp >> 32;
ffffffffea805460:	d364fcc6 	lsr	x6, x6, #36
ffffffffea805464:	b9008046 	str	w6, [x2, #128]
    rem = ((uint64_t)dividend << 32) % divisor;
ffffffffea805468:	d37be8e2 	lsl	x2, x7, #5
ffffffffea80546c:	9b058524 	msub	x4, x9, x5, x1
ffffffffea805470:	cb070042 	sub	x2, x2, x7
	test_lk_time_to_cntpct(cntfrq, 0);
ffffffffea805474:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805478:	9b058103 	msub	x3, x8, x5, x0
    result->l0 = tmp >> 32;
ffffffffea80547c:	d360fd11 	lsr	x17, x8, #32
    rem = ((uint64_t)dividend << 32) % divisor;
ffffffffea805480:	8b0208e2 	add	x2, x7, x2, lsl #2
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea805484:	d3607c84 	lsl	x4, x4, #32
    result->l0 = tmp >> 32;
ffffffffea805488:	d360fd20 	lsr	x0, x9, #32
ffffffffea80548c:	b90061f1 	str	w17, [x15, #96]
    rem = ((uint64_t)dividend << 32) % divisor;
ffffffffea805490:	cb020dc2 	sub	x2, x14, x2, lsl #3
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea805494:	d3607c63 	lsl	x3, x3, #32
ffffffffea805498:	9ac50884 	udiv	x4, x4, x5
    result->l0 = tmp >> 32;
ffffffffea80549c:	b9007200 	str	w0, [x16, #112]
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea8054a0:	d3607c42 	lsl	x2, x2, #32
ffffffffea8054a4:	2a1303e0 	mov	w0, w19
ffffffffea8054a8:	9ac50863 	udiv	x3, x3, x5
ffffffffea8054ac:	d343fc42 	lsr	x2, x2, #3
    result->l64 = tmp;
ffffffffea8054b0:	290091a9 	stp	w9, w4, [x13, #4]
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea8054b4:	9bcb7c42 	umulh	x2, x2, x11
    result->l64 = tmp;
ffffffffea8054b8:	29008d88 	stp	w8, w3, [x12, #4]
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea8054bc:	d344fc42 	lsr	x2, x2, #4
    result->l64 = tmp;
ffffffffea8054c0:	29008947 	stp	w7, w2, [x10, #4]
ffffffffea8054c4:	97ffff59 	bl	ffffffffea805228 <test_lk_time_to_cntpct>
	test_lk_time_to_cntpct(cntfrq, 1);
ffffffffea8054c8:	2a1303e0 	mov	w0, w19
ffffffffea8054cc:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8054d0:	97ffff56 	bl	ffffffffea805228 <test_lk_time_to_cntpct>
	test_lk_time_to_cntpct(cntfrq, INT_MAX);
ffffffffea8054d4:	2a1303e0 	mov	w0, w19
ffffffffea8054d8:	12b00001 	mov	w1, #0x7fffffff            	// #2147483647
ffffffffea8054dc:	97ffff53 	bl	ffffffffea805228 <test_lk_time_to_cntpct>
	test_lk_time_to_cntpct(cntfrq, INT_MAX + 1U);
ffffffffea8054e0:	2a1303e0 	mov	w0, w19
ffffffffea8054e4:	52b00001 	mov	w1, #0x80000000            	// #-2147483648
ffffffffea8054e8:	97ffff50 	bl	ffffffffea805228 <test_lk_time_to_cntpct>
	test_lk_time_to_cntpct(cntfrq, ~0);
ffffffffea8054ec:	2a1303e0 	mov	w0, w19
ffffffffea8054f0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8054f4:	97ffff4d 	bl	ffffffffea805228 <test_lk_time_to_cntpct>
	test_cntpct_to_lk_time(cntfrq, 0, 0);
ffffffffea8054f8:	2a1303e0 	mov	w0, w19
ffffffffea8054fc:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea805500:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805504:	97fffeef 	bl	ffffffffea8050c0 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, INT_MAX, 0);
ffffffffea805508:	2a1303e0 	mov	w0, w19
ffffffffea80550c:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea805510:	12b00001 	mov	w1, #0x7fffffff            	// #2147483647
ffffffffea805514:	97fffeeb 	bl	ffffffffea8050c0 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, INT_MAX + 1U, 0);
ffffffffea805518:	2a1303e0 	mov	w0, w19
ffffffffea80551c:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea805520:	52b00001 	mov	w1, #0x80000000            	// #-2147483648
ffffffffea805524:	97fffee7 	bl	ffffffffea8050c0 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, ~0, 0);
ffffffffea805528:	2a1303e0 	mov	w0, w19
ffffffffea80552c:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea805530:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea805534:	97fffee3 	bl	ffffffffea8050c0 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, 0, 1);
ffffffffea805538:	2a1303e0 	mov	w0, w19
ffffffffea80553c:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea805540:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805544:	97fffedf 	bl	ffffffffea8050c0 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, 0, 7);
ffffffffea805548:	2a1303e0 	mov	w0, w19
ffffffffea80554c:	528000e2 	mov	w2, #0x7                   	// #7
ffffffffea805550:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805554:	97fffedb 	bl	ffffffffea8050c0 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, 0, 70);
ffffffffea805558:	2a1303e0 	mov	w0, w19
ffffffffea80555c:	528008c2 	mov	w2, #0x46                  	// #70
ffffffffea805560:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805564:	97fffed7 	bl	ffffffffea8050c0 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, 0, 700);
ffffffffea805568:	52805782 	mov	w2, #0x2bc                 	// #700
ffffffffea80556c:	2a1303e0 	mov	w0, w19
ffffffffea805570:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805574:	97fffed3 	bl	ffffffffea8050c0 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_bigtime(cntfrq, 0);
ffffffffea805578:	2a1303e0 	mov	w0, w19
ffffffffea80557c:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea805580:	97fffefe 	bl	ffffffffea805178 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 1);
ffffffffea805584:	2a1303e0 	mov	w0, w19
ffffffffea805588:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea80558c:	97fffefb 	bl	ffffffffea805178 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 60 * 60 * 24);
ffffffffea805590:	d28a3001 	mov	x1, #0x5180                	// #20864
ffffffffea805594:	2a1303e0 	mov	w0, w19
ffffffffea805598:	f2a00021 	movk	x1, #0x1, lsl #16
ffffffffea80559c:	97fffef7 	bl	ffffffffea805178 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 60 * 60 * 24 * 365);
ffffffffea8055a0:	d2867001 	mov	x1, #0x3380                	// #13184
ffffffffea8055a4:	2a1303e0 	mov	w0, w19
ffffffffea8055a8:	f2a03c21 	movk	x1, #0x1e1, lsl #16
ffffffffea8055ac:	97fffef3 	bl	ffffffffea805178 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 60 * 60 * 24 * (365 * 10 + 2));
ffffffffea8055b0:	d294c001 	mov	x1, #0xa600                	// #42496
ffffffffea8055b4:	2a1303e0 	mov	w0, w19
ffffffffea8055b8:	f2a259c1 	movk	x1, #0x12ce, lsl #16
ffffffffea8055bc:	97fffeef 	bl	ffffffffea805178 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 60ULL * 60 * 24 * (365 * 100 + 2));
ffffffffea8055c0:	d2982001 	mov	x1, #0xc100                	// #49408
ffffffffea8055c4:	2a1303e0 	mov	w0, w19
ffffffffea8055c8:	f2b77f41 	movk	x1, #0xbbfa, lsl #16
ffffffffea8055cc:	97fffeeb 	bl	ffffffffea805178 <test_cntpct_to_lk_bigtime>
	register_int_handler(irq, &platform_tick, NULL);
ffffffffea8055d0:	90000001 	adrp	x1, ffffffffea805000 <cntpct_to_lk_time+0x28>
ffffffffea8055d4:	91008021 	add	x1, x1, #0x20
ffffffffea8055d8:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea8055dc:	2a1403e0 	mov	w0, w20
ffffffffea8055e0:	97fffbc6 	bl	ffffffffea8044f8 <register_int_handler>
	unmask_interrupt(irq);
ffffffffea8055e4:	2a1403e0 	mov	w0, w20
ffffffffea8055e8:	97fffc90 	bl	ffffffffea804828 <unmask_interrupt>
	timer_irq = irq;
ffffffffea8055ec:	d00002a0 	adrp	x0, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
ffffffffea8055f0:	b9012814 	str	w20, [x0, #296]
}
ffffffffea8055f4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8055f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8055fc:	d65f03c0 	ret
ffffffffea805600:	2a0103f3 	mov	w19, w1
ffffffffea805604:	17ffff83 	b	ffffffffea805410 <arm_generic_timer_init+0x20>
ffffffffea805608:	a94153f3 	ldp	x19, x20, [sp, #16]
			TRACEF("Failed to initialize timer, frequency is 0\n");
ffffffffea80560c:	b0000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
}
ffffffffea805610:	a8c27bfd 	ldp	x29, x30, [sp], #32
			TRACEF("Failed to initialize timer, frequency is 0\n");
ffffffffea805614:	b0000080 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea805618:	52802942 	mov	w2, #0x14a                 	// #330
ffffffffea80561c:	91030021 	add	x1, x1, #0xc0
ffffffffea805620:	91036000 	add	x0, x0, #0xd8
ffffffffea805624:	1400365f 	b	ffffffffea812fa0 <_printf>

ffffffffea805628 <event_init>:
 * @param initial  Initial value for "signaled" state
 * @param flags    0 or EVENT_FLAG_AUTOUNSIGNAL
 */
void event_init(event_t *e, bool initial, uint flags)
{
	*e = (event_t)EVENT_INITIAL_VALUE(*e, initial, flags);
ffffffffea805628:	528dce85 	mov	w5, #0x6e74                	// #28276
ffffffffea80562c:	528d2e84 	mov	w4, #0x6974                	// #26996
ffffffffea805630:	72acaec5 	movk	w5, #0x6576, lsl #16
ffffffffea805634:	91006003 	add	x3, x0, #0x18
ffffffffea805638:	72aeec24 	movk	w4, #0x7761, lsl #16
ffffffffea80563c:	b9000005 	str	w5, [x0]
ffffffffea805640:	39001001 	strb	w1, [x0, #4]
ffffffffea805644:	b9000802 	str	w2, [x0, #8]
ffffffffea805648:	b9001004 	str	w4, [x0, #16]
ffffffffea80564c:	a9018c03 	stp	x3, x3, [x0, #24]
ffffffffea805650:	b900281f 	str	wzr, [x0, #40]
}
ffffffffea805654:	d65f03c0 	ret

ffffffffea805658 <event_destroy>:
 * still waiting on the event will be resumed.
 *
 * @param e        Event object to initialize
 */
void event_destroy(event_t *e)
{
ffffffffea805658:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80565c:	910003fd 	mov	x29, sp
ffffffffea805660:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805664:	aa0003f3 	mov	x19, x0
ffffffffea805668:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80566c:	d53b4220 	mrs	x0, daif
ffffffffea805670:	91004275 	add	x21, x19, #0x10
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea805674:	37380260 	tbnz	w0, #7, ffffffffea8056c0 <event_destroy+0x68>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805678:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80567c:	f00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea805680:	912ea294 	add	x20, x20, #0xba8
ffffffffea805684:	aa1403e0 	mov	x0, x20
ffffffffea805688:	97fff4b5 	bl	ffffffffea80295c <arch_spin_lock>
	DEBUG_ASSERT(e->magic == EVENT_MAGIC);

	THREAD_LOCK(state);

	e->magic = 0;
ffffffffea80568c:	b900027f 	str	wzr, [x19]
	e->signalled = false;
	e->flags = 0;
	wait_queue_destroy(&e->wait, true);
ffffffffea805690:	52800021 	mov	w1, #0x1                   	// #1
	e->signalled = false;
ffffffffea805694:	3900127f 	strb	wzr, [x19, #4]
	wait_queue_destroy(&e->wait, true);
ffffffffea805698:	aa1503e0 	mov	x0, x21
	e->flags = 0;
ffffffffea80569c:	b9000a7f 	str	wzr, [x19, #8]
	wait_queue_destroy(&e->wait, true);
ffffffffea8056a0:	9400063a 	bl	ffffffffea806f88 <wait_queue_destroy>
    arch_spin_unlock(lock);
ffffffffea8056a4:	aa1403e0 	mov	x0, x20
ffffffffea8056a8:	97fff4b5 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8056ac:	d50342ff 	msr	daifclr, #0x2

	THREAD_UNLOCK(state);
}
ffffffffea8056b0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8056b4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8056b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8056bc:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8056c0:	f00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8056c4:	912ea294 	add	x20, x20, #0xba8
ffffffffea8056c8:	aa1403e0 	mov	x0, x20
ffffffffea8056cc:	97fff4a4 	bl	ffffffffea80295c <arch_spin_lock>
	e->magic = 0;
ffffffffea8056d0:	b900027f 	str	wzr, [x19]
	wait_queue_destroy(&e->wait, true);
ffffffffea8056d4:	aa1503e0 	mov	x0, x21
	e->signalled = false;
ffffffffea8056d8:	3900127f 	strb	wzr, [x19, #4]
	wait_queue_destroy(&e->wait, true);
ffffffffea8056dc:	52800021 	mov	w1, #0x1                   	// #1
	e->flags = 0;
ffffffffea8056e0:	b9000a7f 	str	wzr, [x19, #8]
	wait_queue_destroy(&e->wait, true);
ffffffffea8056e4:	94000629 	bl	ffffffffea806f88 <wait_queue_destroy>
}
ffffffffea8056e8:	f94013f5 	ldr	x21, [sp, #32]
    arch_spin_unlock(lock);
ffffffffea8056ec:	aa1403e0 	mov	x0, x20
ffffffffea8056f0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8056f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8056f8:	17fff4a1 	b	ffffffffea80297c <arch_spin_unlock>
ffffffffea8056fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805700 <event_wait_timeout>:
 *
 * @return  0 on success, ERR_TIMED_OUT on timeout,
 *         other values on other errors.
 */
status_t event_wait_timeout(event_t *e, lk_time_t timeout)
{
ffffffffea805700:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805704:	910003fd 	mov	x29, sp
ffffffffea805708:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80570c:	aa0003f3 	mov	x19, x0
ffffffffea805710:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea805714:	2a0103f6 	mov	w22, w1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805718:	d53b4220 	mrs	x0, daif
ffffffffea80571c:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea805720:	37380060 	tbnz	w0, #7, ffffffffea80572c <event_wait_timeout+0x2c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805724:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea805728:	52800035 	mov	w21, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea80572c:	f00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea805730:	912ea280 	add	x0, x20, #0xba8
ffffffffea805734:	97fff48a 	bl	ffffffffea80295c <arch_spin_lock>

	DEBUG_ASSERT(e->magic == EVENT_MAGIC);

	THREAD_LOCK(state);

	if (e->signalled) {
ffffffffea805738:	39401260 	ldrb	w0, [x19, #4]
ffffffffea80573c:	340001e0 	cbz	w0, ffffffffea805778 <event_wait_timeout+0x78>
		/* signalled, we're going to fall through */
		if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
ffffffffea805740:	b9400a60 	ldr	w0, [x19, #8]
	status_t ret = NO_ERROR;
ffffffffea805744:	52800016 	mov	w22, #0x0                   	// #0
		if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
ffffffffea805748:	37000140 	tbnz	w0, #0, ffffffffea805770 <event_wait_timeout+0x70>
    arch_spin_unlock(lock);
ffffffffea80574c:	912ea280 	add	x0, x20, #0xba8
ffffffffea805750:	97fff48b 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea805754:	34000055 	cbz	w21, ffffffffea80575c <event_wait_timeout+0x5c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea805758:	d50342ff 	msr	daifclr, #0x2
	}

	THREAD_UNLOCK(state);

	return ret;
}
ffffffffea80575c:	2a1603e0 	mov	w0, w22
ffffffffea805760:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805764:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea805768:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80576c:	d65f03c0 	ret
			e->signalled = false;
ffffffffea805770:	3900127f 	strb	wzr, [x19, #4]
ffffffffea805774:	17fffff6 	b	ffffffffea80574c <event_wait_timeout+0x4c>
		ret = wait_queue_block(&e->wait, timeout);
ffffffffea805778:	2a1603e1 	mov	w1, w22
ffffffffea80577c:	91004260 	add	x0, x19, #0x10
ffffffffea805780:	94000442 	bl	ffffffffea806888 <wait_queue_block>
ffffffffea805784:	2a0003f6 	mov	w22, w0
ffffffffea805788:	17fffff1 	b	ffffffffea80574c <event_wait_timeout+0x4c>
ffffffffea80578c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805790 <event_signal>:
 *                    queue.
 *
 * @return  Returns NO_ERROR on success.
 */
status_t event_signal(event_t *e, bool reschedule)
{
ffffffffea805790:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805794:	910003fd 	mov	x29, sp
ffffffffea805798:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80579c:	aa0003f3 	mov	x19, x0
ffffffffea8057a0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8057a4:	12001c35 	and	w21, w1, #0xff
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8057a8:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8057ac:	37380340 	tbnz	w0, #7, ffffffffea805814 <event_signal+0x84>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8057b0:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea8057b4:	f00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8057b8:	912ea296 	add	x22, x20, #0xba8
ffffffffea8057bc:	aa1603e0 	mov	x0, x22
ffffffffea8057c0:	97fff467 	bl	ffffffffea80295c <arch_spin_lock>
	DEBUG_ASSERT(e->magic == EVENT_MAGIC);

	THREAD_LOCK(state);

	if (!e->signalled) {
ffffffffea8057c4:	39401260 	ldrb	w0, [x19, #4]
ffffffffea8057c8:	350005c0 	cbnz	w0, ffffffffea805880 <event_signal+0xf0>
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8057cc:	52800036 	mov	w22, #0x1                   	// #1
		if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
ffffffffea8057d0:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea8057d4:	91004260 	add	x0, x19, #0x10
ffffffffea8057d8:	36000381 	tbz	w1, #0, ffffffffea805848 <event_signal+0xb8>
			/* try to release one thread and leave unsignalled if successful */
			if (wait_queue_wake_one(&e->wait, reschedule, NO_ERROR) <= 0) {
ffffffffea8057dc:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8057e0:	2a1503e1 	mov	w1, w21
ffffffffea8057e4:	940004a5 	bl	ffffffffea806a78 <wait_queue_wake_one>
ffffffffea8057e8:	7100001f 	cmp	w0, #0x0
ffffffffea8057ec:	5400040d 	b.le	ffffffffea80586c <event_signal+0xdc>
    arch_spin_unlock(lock);
ffffffffea8057f0:	912ea280 	add	x0, x20, #0xba8
ffffffffea8057f4:	97fff462 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8057f8:	340001f6 	cbz	w22, ffffffffea805834 <event_signal+0xa4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8057fc:	d50342ff 	msr	daifclr, #0x2
	}

	THREAD_UNLOCK(state);

	return NO_ERROR;
}
ffffffffea805800:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805804:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805808:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80580c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805810:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea805814:	f00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea805818:	912ea296 	add	x22, x20, #0xba8
ffffffffea80581c:	aa1603e0 	mov	x0, x22
ffffffffea805820:	97fff44f 	bl	ffffffffea80295c <arch_spin_lock>
	if (!e->signalled) {
ffffffffea805824:	39401260 	ldrb	w0, [x19, #4]
ffffffffea805828:	34000280 	cbz	w0, ffffffffea805878 <event_signal+0xe8>
    arch_spin_unlock(lock);
ffffffffea80582c:	aa1603e0 	mov	x0, x22
ffffffffea805830:	97fff453 	bl	ffffffffea80297c <arch_spin_unlock>
}
ffffffffea805834:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805838:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80583c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea805840:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805844:	d65f03c0 	ret
			e->signalled = true;
ffffffffea805848:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea80584c:	39001261 	strb	w1, [x19, #4]
			wait_queue_wake_all(&e->wait, reschedule, NO_ERROR);
ffffffffea805850:	2a1503e1 	mov	w1, w21
ffffffffea805854:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea805858:	940004d2 	bl	ffffffffea806ba0 <wait_queue_wake_all>
ffffffffea80585c:	912ea280 	add	x0, x20, #0xba8
ffffffffea805860:	97fff447 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea805864:	35fffcd6 	cbnz	w22, ffffffffea8057fc <event_signal+0x6c>
ffffffffea805868:	17fffff3 	b	ffffffffea805834 <event_signal+0xa4>
				e->signalled = true;
ffffffffea80586c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea805870:	39001260 	strb	w0, [x19, #4]
ffffffffea805874:	17ffffdf 	b	ffffffffea8057f0 <event_signal+0x60>
    spin_lock_saved_state_t state = 0;
ffffffffea805878:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea80587c:	17ffffd5 	b	ffffffffea8057d0 <event_signal+0x40>
ffffffffea805880:	aa1603e0 	mov	x0, x22
ffffffffea805884:	97fff43e 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea805888:	d50342ff 	msr	daifclr, #0x2
ffffffffea80588c:	17ffffdd 	b	ffffffffea805800 <event_signal+0x70>

ffffffffea805890 <event_unsignal>:
 */
status_t event_unsignal(event_t *e)
{
	DEBUG_ASSERT(e->magic == EVENT_MAGIC);

	e->signalled = false;
ffffffffea805890:	3900101f 	strb	wzr, [x0, #4]

	return NO_ERROR;
}
ffffffffea805894:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805898:	d65f03c0 	ret
ffffffffea80589c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8058a0 <kernel_init>:
#include <kernel/thread.h>
#include <kernel/timer.h>
#include <kernel/mp.h>

void kernel_init(void)
{
ffffffffea8058a0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea8058a4:	910003fd 	mov	x29, sp
	// if enabled, configure the kernel's event log
	kernel_evlog_init();

	// initialize the threading system
	dprintf(SPEW, "initializing mp\n");
	mp_init();
ffffffffea8058a8:	9400071a 	bl	ffffffffea807510 <mp_init>

	// initialize the threading system
	dprintf(SPEW, "initializing threads\n");
	thread_init();
ffffffffea8058ac:	94000365 	bl	ffffffffea806640 <thread_init>

	// initialize kernel timers
	dprintf(SPEW, "initializing timers\n");
	timer_init();
}
ffffffffea8058b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	timer_init();
ffffffffea8058b4:	1400070b 	b	ffffffffea8074e0 <timer_init>

ffffffffea8058b8 <mutex_init>:
/**
 * @brief  Initialize a mutex_t
 */
void mutex_init(mutex_t *m)
{
	*m = (mutex_t)MUTEX_INITIAL_VALUE(*m);
ffffffffea8058b8:	528e8f03 	mov	w3, #0x7478                	// #29816
ffffffffea8058bc:	528d2e82 	mov	w2, #0x6974                	// #26996
ffffffffea8058c0:	72adaea3 	movk	w3, #0x6d75, lsl #16
ffffffffea8058c4:	91008001 	add	x1, x0, #0x20
ffffffffea8058c8:	72aeec22 	movk	w2, #0x7761, lsl #16
ffffffffea8058cc:	b9000003 	str	w3, [x0]
ffffffffea8058d0:	f900041f 	str	xzr, [x0, #8]
ffffffffea8058d4:	b900101f 	str	wzr, [x0, #16]
ffffffffea8058d8:	b9001802 	str	w2, [x0, #24]
ffffffffea8058dc:	a9020401 	stp	x1, x1, [x0, #32]
ffffffffea8058e0:	b900301f 	str	wzr, [x0, #48]
}
ffffffffea8058e4:	d65f03c0 	ret

ffffffffea8058e8 <mutex_acquire_timeout>:
 *
 * @return  NO_ERROR on success, ERR_TIMED_OUT on timeout,
 * other values on error
 */
status_t mutex_acquire_timeout(mutex_t *m, lk_time_t timeout)
{
ffffffffea8058e8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea8058ec:	910003fd 	mov	x29, sp
ffffffffea8058f0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8058f4:	aa0003f3 	mov	x19, x0
ffffffffea8058f8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8058fc:	f9001bf7 	str	x23, [sp, #48]
ffffffffea805900:	2a0103f7 	mov	w23, w1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805904:	d53b4220 	mrs	x0, daif
ffffffffea805908:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80590c:	37380060 	tbnz	w0, #7, ffffffffea805918 <mutex_acquire_timeout+0x30>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805910:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea805914:	52800035 	mov	w21, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea805918:	f00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea80591c:	912ea280 	add	x0, x20, #0xba8
ffffffffea805920:	97fff40f 	bl	ffffffffea80295c <arch_spin_lock>
		      get_current_thread(), get_current_thread()->name, m);
#endif

	THREAD_LOCK(state);

	status_t ret = NO_ERROR;
ffffffffea805924:	52800016 	mov	w22, #0x0                   	// #0
	if (unlikely(++m->count > 1)) {
ffffffffea805928:	b9401260 	ldr	w0, [x19, #16]
ffffffffea80592c:	11000400 	add	w0, w0, #0x1
ffffffffea805930:	b9001260 	str	w0, [x19, #16]
ffffffffea805934:	7100041f 	cmp	w0, #0x1
ffffffffea805938:	540001ac 	b.gt	ffffffffea80596c <mutex_acquire_timeout+0x84>
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80593c:	d538d080 	mrs	x0, tpidr_el1
			 */
			goto err;
		}
	}

	m->holder = get_current_thread();
ffffffffea805940:	f9000660 	str	x0, [x19, #8]
    arch_spin_unlock(lock);
ffffffffea805944:	912ea280 	add	x0, x20, #0xba8
ffffffffea805948:	97fff40d 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea80594c:	34000055 	cbz	w21, ffffffffea805954 <mutex_acquire_timeout+0x6c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea805950:	d50342ff 	msr	daifclr, #0x2

err:
	THREAD_UNLOCK(state);
	return ret;
}
ffffffffea805954:	2a1603e0 	mov	w0, w22
ffffffffea805958:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80595c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805960:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea805964:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea805968:	d65f03c0 	ret
		ret = wait_queue_block(&m->wait, timeout);
ffffffffea80596c:	2a1703e1 	mov	w1, w23
ffffffffea805970:	91006260 	add	x0, x19, #0x18
ffffffffea805974:	940003c5 	bl	ffffffffea806888 <wait_queue_block>
ffffffffea805978:	2a0003f6 	mov	w22, w0
		if (unlikely(ret < NO_ERROR)) {
ffffffffea80597c:	36fffe00 	tbz	w0, #31, ffffffffea80593c <mutex_acquire_timeout+0x54>
			if (likely(ret == ERR_TIMED_OUT)) {
ffffffffea805980:	3100341f 	cmn	w0, #0xd
ffffffffea805984:	54fffe01 	b.ne	ffffffffea805944 <mutex_acquire_timeout+0x5c>  // b.any
				m->count--;
ffffffffea805988:	b9401260 	ldr	w0, [x19, #16]
ffffffffea80598c:	51000400 	sub	w0, w0, #0x1
ffffffffea805990:	b9001260 	str	w0, [x19, #16]
ffffffffea805994:	17ffffec 	b	ffffffffea805944 <mutex_acquire_timeout+0x5c>

ffffffffea805998 <mutex_release>:

/**
 * @brief  Release mutex
 */
status_t mutex_release(mutex_t *m)
{
ffffffffea805998:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80599c:	910003fd 	mov	x29, sp
ffffffffea8059a0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8059a4:	aa0003f3 	mov	x19, x0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8059a8:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8059ac:	37380260 	tbnz	w0, #7, ffffffffea8059f8 <mutex_release+0x60>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8059b0:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea8059b4:	f00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8059b8:	912ea294 	add	x20, x20, #0xba8
ffffffffea8059bc:	aa1403e0 	mov	x0, x20
ffffffffea8059c0:	97fff3e7 	bl	ffffffffea80295c <arch_spin_lock>

	THREAD_LOCK(state);

	m->holder = 0;

	if (unlikely(--m->count >= 1)) {
ffffffffea8059c4:	b9401260 	ldr	w0, [x19, #16]
	m->holder = 0;
ffffffffea8059c8:	f900067f 	str	xzr, [x19, #8]
	if (unlikely(--m->count >= 1)) {
ffffffffea8059cc:	51000400 	sub	w0, w0, #0x1
ffffffffea8059d0:	b9001260 	str	w0, [x19, #16]
ffffffffea8059d4:	7100001f 	cmp	w0, #0x0
ffffffffea8059d8:	540003ac 	b.gt	ffffffffea805a4c <mutex_release+0xb4>
    arch_spin_unlock(lock);
ffffffffea8059dc:	aa1403e0 	mov	x0, x20
ffffffffea8059e0:	97fff3e7 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8059e4:	d50342ff 	msr	daifclr, #0x2
		wait_queue_wake_one(&m->wait, true, NO_ERROR);
	}

	THREAD_UNLOCK(state);
	return NO_ERROR;
}
ffffffffea8059e8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8059ec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8059f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8059f4:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8059f8:	f00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8059fc:	912ea294 	add	x20, x20, #0xba8
ffffffffea805a00:	aa1403e0 	mov	x0, x20
ffffffffea805a04:	97fff3d6 	bl	ffffffffea80295c <arch_spin_lock>
	if (unlikely(--m->count >= 1)) {
ffffffffea805a08:	b9401260 	ldr	w0, [x19, #16]
	m->holder = 0;
ffffffffea805a0c:	f900067f 	str	xzr, [x19, #8]
	if (unlikely(--m->count >= 1)) {
ffffffffea805a10:	51000400 	sub	w0, w0, #0x1
ffffffffea805a14:	b9001260 	str	w0, [x19, #16]
ffffffffea805a18:	7100001f 	cmp	w0, #0x0
ffffffffea805a1c:	540000ec 	b.gt	ffffffffea805a38 <mutex_release+0xa0>
    arch_spin_unlock(lock);
ffffffffea805a20:	aa1403e0 	mov	x0, x20
ffffffffea805a24:	97fff3d6 	bl	ffffffffea80297c <arch_spin_unlock>
}
ffffffffea805a28:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805a2c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805a30:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea805a34:	d65f03c0 	ret
		wait_queue_wake_one(&m->wait, true, NO_ERROR);
ffffffffea805a38:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea805a3c:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea805a40:	91006260 	add	x0, x19, #0x18
ffffffffea805a44:	9400040d 	bl	ffffffffea806a78 <wait_queue_wake_one>
ffffffffea805a48:	17fffff6 	b	ffffffffea805a20 <mutex_release+0x88>
ffffffffea805a4c:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea805a50:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea805a54:	91006260 	add	x0, x19, #0x18
ffffffffea805a58:	94000408 	bl	ffffffffea806a78 <wait_queue_wake_one>
ffffffffea805a5c:	17ffffe0 	b	ffffffffea8059dc <mutex_release+0x44>

ffffffffea805a60 <init_thread_struct>:
	list_add_tail(&run_queue[t->priority], &t->queue_node);
	run_queue_bitmap |= (1<<t->priority);
}

static void init_thread_struct(thread_t *t, const char *name)
{
ffffffffea805a60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	memset(t, 0, sizeof(thread_t));
ffffffffea805a64:	d2805b02 	mov	x2, #0x2d8                 	// #728
{
ffffffffea805a68:	910003fd 	mov	x29, sp
ffffffffea805a6c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805a70:	aa0003f3 	mov	x19, x0
ffffffffea805a74:	aa0103f4 	mov	x20, x1
	memset(t, 0, sizeof(thread_t));
ffffffffea805a78:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805a7c:	94003645 	bl	ffffffffea813390 <memset>
	t->magic = THREAD_MAGIC;
ffffffffea805a80:	528e4c81 	mov	w1, #0x7264                	// #29284
	t->pinned_cpu = -1;
ffffffffea805a84:	12800000 	mov	w0, #0xffffffff            	// #-1
	t->magic = THREAD_MAGIC;
ffffffffea805a88:	72ae8d01 	movk	w1, #0x7468, lsl #16
ffffffffea805a8c:	b9000261 	str	w1, [x19]
	t->pinned_cpu = -1;
ffffffffea805a90:	b9003e60 	str	w0, [x19, #60]
	strlcpy(t->name, name, sizeof(t->name));
ffffffffea805a94:	aa1403e1 	mov	x1, x20
ffffffffea805a98:	910ae260 	add	x0, x19, #0x2b8
ffffffffea805a9c:	d2800402 	mov	x2, #0x20                  	// #32
}
ffffffffea805aa0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805aa4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	strlcpy(t->name, name, sizeof(t->name));
ffffffffea805aa8:	1400367c 	b	ffffffffea813498 <strlcpy>
ffffffffea805aac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805ab0 <get_top_thread>:
}

static thread_t *get_top_thread(int cpu, bool unlink)
{
	thread_t *newthread;
	uint32_t local_run_queue_bitmap = run_queue_bitmap;
ffffffffea805ab0:	f00002ac 	adrp	x12, ffffffffea85c000 <idle_threads+0xeb0>
{
ffffffffea805ab4:	2a0003e4 	mov	w4, w0
ffffffffea805ab8:	12001c21 	and	w1, w1, #0xff
	uint32_t local_run_queue_bitmap = run_queue_bitmap;
ffffffffea805abc:	b94b918a 	ldr	w10, [x12, #2960]
	uint next_queue;

	while (local_run_queue_bitmap) {
ffffffffea805ac0:	3400056a 	cbz	w10, ffffffffea805b6c <get_top_thread+0xbc>
ffffffffea805ac4:	f00002a9 	adrp	x9, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea805ac8:	2a0a03e7 	mov	w7, w10
		/* find the first (remaining) queue with a thread in it */
		next_queue = HIGHEST_PRIORITY - __builtin_clz(local_run_queue_bitmap)
			- (sizeof(run_queue_bitmap) * 8 - NUM_PRIORITIES);

		list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
ffffffffea805acc:	91264128 	add	x8, x9, #0x990
		next_queue = HIGHEST_PRIORITY - __builtin_clz(local_run_queue_bitmap)
ffffffffea805ad0:	528003eb 	mov	w11, #0x1f                  	// #31

				return newthread;
			}
		}

		local_run_queue_bitmap &= ~(1<<next_queue);
ffffffffea805ad4:	5280002d 	mov	w13, #0x1                   	// #1
		next_queue = HIGHEST_PRIORITY - __builtin_clz(local_run_queue_bitmap)
ffffffffea805ad8:	5ac010e5 	clz	w5, w7
ffffffffea805adc:	4b050166 	sub	w6, w11, w5
ffffffffea805ae0:	aa0603e5 	mov	x5, x6
		list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
ffffffffea805ae4:	8b061100 	add	x0, x8, x6, lsl #4
ffffffffea805ae8:	8b26d103 	add	x3, x8, w6, sxtw #4
ffffffffea805aec:	f9400402 	ldr	x2, [x0, #8]
ffffffffea805af0:	d1006040 	sub	x0, x2, #0x18
ffffffffea805af4:	eb02007f 	cmp	x3, x2
ffffffffea805af8:	54000340 	b.eq	ffffffffea805b60 <get_top_thread+0xb0>  // b.none
			if (newthread->pinned_cpu < 0 || newthread->pinned_cpu == cpu) {
ffffffffea805afc:	b9403c02 	ldr	w2, [x0, #60]
ffffffffea805b00:	7100005f 	cmp	w2, #0x0
ffffffffea805b04:	7a42a084 	ccmp	w4, w2, #0x4, ge  // ge = tcont
ffffffffea805b08:	54000140 	b.eq	ffffffffea805b30 <get_top_thread+0x80>  // b.none
ffffffffea805b0c:	d503201f 	nop
		list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
ffffffffea805b10:	f9401002 	ldr	x2, [x0, #32]
ffffffffea805b14:	d1006040 	sub	x0, x2, #0x18
ffffffffea805b18:	eb02007f 	cmp	x3, x2
ffffffffea805b1c:	54000220 	b.eq	ffffffffea805b60 <get_top_thread+0xb0>  // b.none
			if (newthread->pinned_cpu < 0 || newthread->pinned_cpu == cpu) {
ffffffffea805b20:	b9403c02 	ldr	w2, [x0, #60]
ffffffffea805b24:	7100005f 	cmp	w2, #0x0
ffffffffea805b28:	7a44a044 	ccmp	w2, w4, #0x4, ge  // ge = tcont
ffffffffea805b2c:	54ffff21 	b.ne	ffffffffea805b10 <get_top_thread+0x60>  // b.any
				if (unlink) {
ffffffffea805b30:	34000161 	cbz	w1, ffffffffea805b5c <get_top_thread+0xac>
	item->next->prev = item->prev;
ffffffffea805b34:	a9418402 	ldp	x2, x1, [x0, #24]
        &(entry)->member != (list);\
        entry = temp_entry, temp_entry = containerof((temp_entry)->member.next, type, member))

static inline bool list_is_empty(struct list_node *list)
{
	return (list->next == list) ? true : false;
ffffffffea805b38:	91264129 	add	x9, x9, #0x990
ffffffffea805b3c:	8b061126 	add	x6, x9, x6, lsl #4
	item->next->prev = item->prev;
ffffffffea805b40:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea805b44:	f9400c02 	ldr	x2, [x0, #24]
ffffffffea805b48:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea805b4c:	a901fc1f 	stp	xzr, xzr, [x0, #24]
					if (list_is_empty(&run_queue[next_queue]))
ffffffffea805b50:	f94004c1 	ldr	x1, [x6, #8]
ffffffffea805b54:	eb03003f 	cmp	x1, x3
ffffffffea805b58:	54000140 	b.eq	ffffffffea805b80 <get_top_thread+0xd0>  // b.none
	}
	/* no threads to run, select the idle thread for this cpu */
	return &idle_threads[cpu];
}
ffffffffea805b5c:	d65f03c0 	ret
		local_run_queue_bitmap &= ~(1<<next_queue);
ffffffffea805b60:	1ac521a5 	lsl	w5, w13, w5
	while (local_run_queue_bitmap) {
ffffffffea805b64:	6a2500e7 	bics	w7, w7, w5
ffffffffea805b68:	54fffb81 	b.ne	ffffffffea805ad8 <get_top_thread+0x28>  // b.any
	return &idle_threads[cpu];
ffffffffea805b6c:	d00002a0 	adrp	x0, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
ffffffffea805b70:	91054000 	add	x0, x0, #0x150
ffffffffea805b74:	52805b01 	mov	w1, #0x2d8                 	// #728
ffffffffea805b78:	9b210080 	smaddl	x0, w4, w1, x0
}
ffffffffea805b7c:	d65f03c0 	ret
						run_queue_bitmap &= ~(1<<next_queue);
ffffffffea805b80:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea805b84:	1ac52025 	lsl	w5, w1, w5
ffffffffea805b88:	0a25014a 	bic	w10, w10, w5
ffffffffea805b8c:	b90b918a 	str	w10, [x12, #2960]
}
ffffffffea805b90:	d65f03c0 	ret
ffffffffea805b94:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805b98 <thread_get_mp_reschedule_target.isra.5>:
static mp_cpu_mask_t thread_get_mp_reschedule_target(thread_t *current_thread, thread_t *t)
ffffffffea805b98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805b9c:	910003fd 	mov	x29, sp
ffffffffea805ba0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805ba4:	aa0203f3 	mov	x19, x2
ffffffffea805ba8:	f90013f5 	str	x21, [sp, #32]
ffffffffea805bac:	aa0003f4 	mov	x20, x0
ffffffffea805bb0:	aa0103f5 	mov	x21, x1
	uint cpu = arch_curr_cpu_num();
ffffffffea805bb4:	97fff3ef 	bl	ffffffffea802b70 <arch_curr_cpu_num>
	if (t->pinned_cpu != -1 && current_thread->pinned_cpu == t->pinned_cpu)
ffffffffea805bb8:	b9400261 	ldr	w1, [x19]
ffffffffea805bbc:	3100043f 	cmn	w1, #0x1
ffffffffea805bc0:	54000280 	b.eq	ffffffffea805c10 <thread_get_mp_reschedule_target.isra.5+0x78>  // b.none
ffffffffea805bc4:	b9400283 	ldr	w3, [x20]
ffffffffea805bc8:	2a0003e2 	mov	w2, w0
		return 0;
ffffffffea805bcc:	52800000 	mov	w0, #0x0                   	// #0
	if (t->pinned_cpu != -1 && current_thread->pinned_cpu == t->pinned_cpu)
ffffffffea805bd0:	6b03003f 	cmp	w1, w3
ffffffffea805bd4:	54000160 	b.eq	ffffffffea805c00 <thread_get_mp_reschedule_target.isra.5+0x68>  // b.none
	if (t->pinned_cpu == -1 || (uint)t->pinned_cpu == cpu)
ffffffffea805bd8:	6b01005f 	cmp	w2, w1
ffffffffea805bdc:	54000120 	b.eq	ffffffffea805c00 <thread_get_mp_reschedule_target.isra.5+0x68>  // b.none
	if (t->priority < cpu_priority[target_cpu])
ffffffffea805be0:	d00002a2 	adrp	x2, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
ffffffffea805be4:	9104c042 	add	x2, x2, #0x130
	return 1UL << target_cpu;
ffffffffea805be8:	d2800020 	mov	x0, #0x1                   	// #1
	if (t->priority < cpu_priority[target_cpu])
ffffffffea805bec:	b94002a3 	ldr	w3, [x21]
	return 1UL << target_cpu;
ffffffffea805bf0:	9ac12000 	lsl	x0, x0, x1
	if (t->priority < cpu_priority[target_cpu])
ffffffffea805bf4:	b8615841 	ldr	w1, [x2, w1, uxtw #2]
	return 1UL << target_cpu;
ffffffffea805bf8:	6b01007f 	cmp	w3, w1
ffffffffea805bfc:	1a80b3e0 	csel	w0, wzr, w0, lt  // lt = tstop
}
ffffffffea805c00:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805c04:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805c08:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805c0c:	d65f03c0 	ret
		return 0;
ffffffffea805c10:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea805c14:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805c18:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805c1c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805c20:	d65f03c0 	ret
ffffffffea805c24:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805c28 <thread_mp_reschedule>:
{
ffffffffea805c28:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea805c2c:	aa0103e2 	mov	x2, x1
	mp_reschedule(thread_get_mp_reschedule_target(current_thread, t), 0);
ffffffffea805c30:	9100f042 	add	x2, x2, #0x3c
ffffffffea805c34:	9100a021 	add	x1, x1, #0x28
{
ffffffffea805c38:	910003fd 	mov	x29, sp
	mp_reschedule(thread_get_mp_reschedule_target(current_thread, t), 0);
ffffffffea805c3c:	9100f000 	add	x0, x0, #0x3c
ffffffffea805c40:	97ffffd6 	bl	ffffffffea805b98 <thread_get_mp_reschedule_target.isra.5>
}
ffffffffea805c44:	a8c17bfd 	ldp	x29, x30, [sp], #16
	mp_reschedule(thread_get_mp_reschedule_target(current_thread, t), 0);
ffffffffea805c48:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805c4c:	14000633 	b	ffffffffea807518 <mp_reschedule>

ffffffffea805c50 <thread_cond_mp_reschedule.isra.6>:

static void thread_cond_mp_reschedule(thread_t *current_thread, const char *caller)
ffffffffea805c50:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
{
	int i;
	uint best_cpu = ~0U;
	int best_cpu_priority = INT_MAX;
	thread_t *t = get_top_thread(-1, false);
ffffffffea805c54:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805c58:	12800000 	mov	w0, #0xffffffff            	// #-1
static void thread_cond_mp_reschedule(thread_t *current_thread, const char *caller)
ffffffffea805c5c:	910003fd 	mov	x29, sp
	thread_t *t = get_top_thread(-1, false);
ffffffffea805c60:	97ffff94 	bl	ffffffffea805ab0 <get_top_thread>
ffffffffea805c64:	900002c6 	adrp	x6, ffffffffea85d000 <rb_data+0x18>

	for (i = 0; i < SMP_MAX_CPUS; i++) {
		if (!(mp.active_cpus & (1 << i)))
			continue;

		if (cpu_priority[i] < best_cpu_priority) {
ffffffffea805c68:	d00002a8 	adrp	x8, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
		if (!(mp.active_cpus & (1 << i)))
ffffffffea805c6c:	910300c6 	add	x6, x6, #0xc0
		if (cpu_priority[i] < best_cpu_priority) {
ffffffffea805c70:	9104c108 	add	x8, x8, #0x130
	thread_t *t = get_top_thread(-1, false);
ffffffffea805c74:	d2800001 	mov	x1, #0x0                   	// #0
	uint best_cpu = ~0U;
ffffffffea805c78:	12800003 	mov	w3, #0xffffffff            	// #-1
	int best_cpu_priority = INT_MAX;
ffffffffea805c7c:	12b00002 	mov	w2, #0x7fffffff            	// #2147483647
		if (!(mp.active_cpus & (1 << i)))
ffffffffea805c80:	52800027 	mov	w7, #0x1                   	// #1
ffffffffea805c84:	d503201f 	nop
ffffffffea805c88:	b94000c4 	ldr	w4, [x6]
ffffffffea805c8c:	1ac120e5 	lsl	w5, w7, w1
ffffffffea805c90:	6a0400bf 	tst	w5, w4
ffffffffea805c94:	540000a0 	b.eq	ffffffffea805ca8 <thread_cond_mp_reschedule.isra.6+0x58>  // b.none
		if (cpu_priority[i] < best_cpu_priority) {
ffffffffea805c98:	b8617904 	ldr	w4, [x8, x1, lsl #2]
			best_cpu = i;
ffffffffea805c9c:	6b02009f 	cmp	w4, w2
ffffffffea805ca0:	1a81a063 	csel	w3, w3, w1, ge  // ge = tcont
ffffffffea805ca4:	1a84a042 	csel	w2, w2, w4, ge  // ge = tcont
ffffffffea805ca8:	91000421 	add	x1, x1, #0x1
	for (i = 0; i < SMP_MAX_CPUS; i++) {
ffffffffea805cac:	f100203f 	cmp	x1, #0x8
ffffffffea805cb0:	54fffec1 	b.ne	ffffffffea805c88 <thread_cond_mp_reschedule.isra.6+0x38>  // b.any
			best_cpu_priority = cpu_priority[i];
		}
	}

	if (t->priority <= best_cpu_priority)
ffffffffea805cb4:	b9402804 	ldr	w4, [x0, #40]
ffffffffea805cb8:	6b02009f 	cmp	w4, w2
ffffffffea805cbc:	5400006c 	b.gt	ffffffffea805cc8 <thread_cond_mp_reschedule.isra.6+0x78>
		t->priority, t->name,
		current_thread->priority, current_thread->name);
#endif
	cpu_priority[best_cpu] = t->priority;
	mp_reschedule(1UL << best_cpu, 0);
}
ffffffffea805cc0:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea805cc4:	d65f03c0 	ret
	cpu_priority[best_cpu] = t->priority;
ffffffffea805cc8:	d00002a2 	adrp	x2, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
ffffffffea805ccc:	9104c042 	add	x2, x2, #0x130
	mp_reschedule(1UL << best_cpu, 0);
ffffffffea805cd0:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea805cd4:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805cd8:	9ac32000 	lsl	x0, x0, x3
	cpu_priority[best_cpu] = t->priority;
ffffffffea805cdc:	b8235844 	str	w4, [x2, w3, uxtw #2]
}
ffffffffea805ce0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	mp_reschedule(1UL << best_cpu, 0);
ffffffffea805ce4:	1400060d 	b	ffffffffea807518 <mp_reschedule>

ffffffffea805ce8 <thread_resched>:
 *
 * This is probably not the function you're looking for. See
 * thread_yield() instead.
 */
void thread_resched(void)
{
ffffffffea805ce8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805cec:	910003fd 	mov	x29, sp
ffffffffea805cf0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805cf4:	f90013f5 	str	x21, [sp, #32]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea805cf8:	d538d094 	mrs	x20, tpidr_el1
	thread_t *oldthread;
	thread_t *newthread;

	thread_t *current_thread = get_current_thread();
	uint cpu = arch_curr_cpu_num();
ffffffffea805cfc:	97fff39d 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea805d00:	2a0003f5 	mov	w21, w0
	ASSERT(current_thread->state != THREAD_RUNNING);
#endif

	THREAD_STATS_INC(reschedules);

	newthread = get_top_thread(cpu, true);
ffffffffea805d04:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea805d08:	97ffff6a 	bl	ffffffffea805ab0 <get_top_thread>
ffffffffea805d0c:	aa0003f3 	mov	x19, x0

#if THREAD_CHECKS
	ASSERT(newthread);
#endif

	newthread->state = THREAD_RUNNING;
ffffffffea805d10:	52800040 	mov	w0, #0x2                   	// #2

	oldthread = current_thread;

	if (newthread == oldthread)
ffffffffea805d14:	eb14027f 	cmp	x19, x20
	newthread->state = THREAD_RUNNING;
ffffffffea805d18:	b9002e60 	str	w0, [x19, #44]
	if (newthread == oldthread)
ffffffffea805d1c:	540006a0 	b.eq	ffffffffea805df0 <thread_resched+0x108>  // b.none
		return;

	/* set up quantum for the new thread if it was consumed */
	if (newthread->remaining_quantum <= 0) {
ffffffffea805d20:	b9403260 	ldr	w0, [x19, #48]
ffffffffea805d24:	7100001f 	cmp	w0, #0x0
ffffffffea805d28:	5400052d 	b.le	ffffffffea805dcc <thread_resched+0xe4>
ffffffffea805d2c:	900002c1 	adrp	x1, ffffffffea85d000 <rb_data+0x18>
ffffffffea805d30:	91030021 	add	x1, x1, #0xc0
		newthread->remaining_quantum = 5; // XXX make this smarter
	}

	/* mark the cpu ownership of the threads */
	oldthread->curr_cpu = -1;
ffffffffea805d34:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea805d38:	b9003a80 	str	w0, [x20, #56]
ffffffffea805d3c:	d2800020 	mov	x0, #0x1                   	// #1
	newthread->curr_cpu = cpu;
ffffffffea805d40:	b9003a75 	str	w21, [x19, #56]
ffffffffea805d44:	29409823 	ldp	w3, w6, [x1, #4]
ffffffffea805d48:	9ad52000 	lsl	x0, x0, x21

	if (thread_is_idle(newthread)) {
ffffffffea805d4c:	b9403664 	ldr	w4, [x19, #52]
extern struct mp_state mp;

/* must be called with the thread lock held */
static inline void mp_set_cpu_idle(uint cpu)
{
    mp.idle_cpus |= 1UL << cpu;
ffffffffea805d50:	2a2003e2 	mvn	w2, w0
ffffffffea805d54:	0a030047 	and	w7, w2, w3
		mp_set_cpu_idle(cpu);
	} else {
		mp_set_cpu_busy(cpu);
	}

	if (thread_is_realtime(newthread)) {
ffffffffea805d58:	b9402a65 	ldr	w5, [x19, #40]
ffffffffea805d5c:	2a000063 	orr	w3, w3, w0
    mp.realtime_cpus |= 1UL << cpu;
}

static inline void mp_set_cpu_non_realtime(uint cpu)
{
    mp.realtime_cpus &= ~(1UL << cpu);
ffffffffea805d60:	0a060042 	and	w2, w2, w6
    mp.idle_cpus |= 1UL << cpu;
ffffffffea805d64:	f27c009f 	tst	x4, #0x10
    mp.realtime_cpus &= ~(1UL << cpu);
ffffffffea805d68:	2a0000c0 	orr	w0, w6, w0
    mp.idle_cpus |= 1UL << cpu;
ffffffffea805d6c:	1a871063 	csel	w3, w3, w7, ne  // ne = any
	return (t->flags & THREAD_FLAG_REAL_TIME) && t->priority > DEFAULT_PRIORITY;
ffffffffea805d70:	f27d009f 	tst	x4, #0x8
    mp.realtime_cpus &= ~(1UL << cpu);
ffffffffea805d74:	7a5018a4 	ccmp	w5, #0x10, #0x4, ne  // ne = any
ffffffffea805d78:	1a80d040 	csel	w0, w2, w0, le
ffffffffea805d7c:	29008023 	stp	w3, w0, [x1, #4]
#endif

	KEVLOG_THREAD_SWITCH(oldthread, newthread);

#if PLATFORM_HAS_DYNAMIC_TIMER
	if (thread_is_real_time_or_idle(newthread)) {
ffffffffea805d80:	721d049f 	tst	w4, #0x18
ffffffffea805d84:	540002a1 	b.ne	ffffffffea805dd8 <thread_resched+0xf0>  // b.any
	return !!(t->flags & (THREAD_FLAG_REAL_TIME | THREAD_FLAG_IDLE));
ffffffffea805d88:	b9403680 	ldr	w0, [x20, #52]
			dprintf(ALWAYS, "arch_context_switch: stop preempt, cpu %d, old %p (%s), new %p (%s)\n",
				cpu, oldthread, oldthread->name, newthread, newthread->name);
#endif
			timer_cancel(&preempt_timer[cpu]);
		}
	} else if (thread_is_real_time_or_idle(oldthread)) {
ffffffffea805d8c:	721d041f 	tst	w0, #0x18
ffffffffea805d90:	54000461 	b.ne	ffffffffea805e1c <thread_resched+0x134>  // b.any

	/* set some optional target debug leds */
	target_set_debug_led(0, !thread_is_idle(&idle_threads[cpu]));

	/* do the switch */
	cpu_priority[cpu] = newthread->priority;
ffffffffea805d94:	d00002a0 	adrp	x0, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
ffffffffea805d98:	9104c000 	add	x0, x0, #0x130
ffffffffea805d9c:	b8355805 	str	w5, [x0, w21, uxtw #2]
}

static inline void set_current_thread(struct thread *t)
{
    ARM64_WRITE_SYSREG(tpidr_el1, (uint64_t)t);
ffffffffea805da0:	d518d093 	msr	tpidr_el1, x19
ffffffffea805da4:	d5033fdf 	isb
		oldthread->flags, newthread, newthread->name,
		newthread->priority, newthread->flags);
#endif

#ifdef WITH_LIB_UTHREAD
	uthread_context_switch(oldthread, newthread);
ffffffffea805da8:	aa1303e1 	mov	x1, x19
ffffffffea805dac:	aa1403e0 	mov	x0, x20
ffffffffea805db0:	94003772 	bl	ffffffffea813b78 <uthread_context_switch>
#endif
	arch_context_switch(oldthread, newthread);
}
ffffffffea805db4:	f94013f5 	ldr	x21, [sp, #32]
	arch_context_switch(oldthread, newthread);
ffffffffea805db8:	aa1303e1 	mov	x1, x19
ffffffffea805dbc:	aa1403e0 	mov	x0, x20
}
ffffffffea805dc0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805dc4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	arch_context_switch(oldthread, newthread);
ffffffffea805dc8:	17fff4c8 	b	ffffffffea8030e8 <arch_context_switch>
		newthread->remaining_quantum = 5; // XXX make this smarter
ffffffffea805dcc:	528000a0 	mov	w0, #0x5                   	// #5
ffffffffea805dd0:	b9003260 	str	w0, [x19, #48]
ffffffffea805dd4:	17ffffd6 	b	ffffffffea805d2c <thread_resched+0x44>
		thread_cond_mp_reschedule(newthread, __func__);
ffffffffea805dd8:	97ffff9e 	bl	ffffffffea805c50 <thread_cond_mp_reschedule.isra.6>
	return !!(t->flags & (THREAD_FLAG_REAL_TIME | THREAD_FLAG_IDLE));
ffffffffea805ddc:	b9403680 	ldr	w0, [x20, #52]
		if (!thread_is_real_time_or_idle(oldthread)) {
ffffffffea805de0:	721d041f 	tst	w0, #0x18
ffffffffea805de4:	540000e0 	b.eq	ffffffffea805e00 <thread_resched+0x118>  // b.none
ffffffffea805de8:	b9402a65 	ldr	w5, [x19, #40]
ffffffffea805dec:	17ffffea 	b	ffffffffea805d94 <thread_resched+0xac>
}
ffffffffea805df0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805df4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805df8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805dfc:	d65f03c0 	ret
			timer_cancel(&preempt_timer[cpu]);
ffffffffea805e00:	f00002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea805e04:	91204000 	add	x0, x0, #0x810
ffffffffea805e08:	52800601 	mov	w1, #0x30                  	// #48
ffffffffea805e0c:	9ba102a0 	umaddl	x0, w21, w1, x0
ffffffffea805e10:	94000576 	bl	ffffffffea8073e8 <timer_cancel>
ffffffffea805e14:	b9402a65 	ldr	w5, [x19, #40]
ffffffffea805e18:	17ffffdf 	b	ffffffffea805d94 <thread_resched+0xac>
		timer_set_periodic(&preempt_timer[cpu], 10, (timer_callback)thread_timer_tick, NULL);
ffffffffea805e1c:	f00002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea805e20:	91204000 	add	x0, x0, #0x810
ffffffffea805e24:	52800601 	mov	w1, #0x30                  	// #48
ffffffffea805e28:	90000002 	adrp	x2, ffffffffea805000 <cntpct_to_lk_time+0x28>
ffffffffea805e2c:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea805e30:	913ba042 	add	x2, x2, #0xee8
ffffffffea805e34:	9ba102a0 	umaddl	x0, w21, w1, x0
ffffffffea805e38:	52800141 	mov	w1, #0xa                   	// #10
ffffffffea805e3c:	94000565 	bl	ffffffffea8073d0 <timer_set_periodic>
ffffffffea805e40:	b9402a65 	ldr	w5, [x19, #40]
ffffffffea805e44:	17ffffd4 	b	ffffffffea805d94 <thread_resched+0xac>

ffffffffea805e48 <thread_sleep_handler>:
	}
}

/* timer callback to wake up a sleeping thread */
static enum handler_return thread_sleep_handler(timer_t *timer, lk_time_t now, void *arg)
{
ffffffffea805e48:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805e4c:	910003fd 	mov	x29, sp
ffffffffea805e50:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805e54:	aa0203f3 	mov	x19, x2
ffffffffea805e58:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805e5c:	d53b4220 	mrs	x0, daif
ffffffffea805e60:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea805e64:	37380060 	tbnz	w0, #7, ffffffffea805e70 <thread_sleep_handler+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805e68:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea805e6c:	52800035 	mov	w21, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea805e70:	f00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea805e74:	912ea294 	add	x20, x20, #0xba8
ffffffffea805e78:	aa1403e0 	mov	x0, x20
ffffffffea805e7c:	97fff2b8 	bl	ffffffffea80295c <arch_spin_lock>
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea805e80:	b9402a62 	ldr	w2, [x19, #40]
	item->next = list->next;
ffffffffea805e84:	f00002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea805e88:	91264021 	add	x1, x1, #0x990
	run_queue_bitmap |= (1<<t->priority);
ffffffffea805e8c:	f00002a5 	adrp	x5, ffffffffea85c000 <idle_threads+0xeb0>
	ASSERT(t->state == THREAD_SLEEPING);
#endif

	THREAD_LOCK(state);

	t->state = THREAD_READY;
ffffffffea805e90:	52800020 	mov	w0, #0x1                   	// #1
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea805e94:	91006264 	add	x4, x19, #0x18
ffffffffea805e98:	8b22d021 	add	x1, x1, w2, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea805e9c:	1ac22003 	lsl	w3, w0, w2
ffffffffea805ea0:	b94b90a6 	ldr	w6, [x5, #2960]
ffffffffea805ea4:	f9400422 	ldr	x2, [x1, #8]
ffffffffea805ea8:	a9018a61 	stp	x1, x2, [x19, #24]
ffffffffea805eac:	2a060062 	orr	w2, w3, w6
ffffffffea805eb0:	b90b90a2 	str	w2, [x5, #2960]
	list->next->prev = item;
ffffffffea805eb4:	f9400422 	ldr	x2, [x1, #8]
	t->state = THREAD_READY;
ffffffffea805eb8:	b9002e60 	str	w0, [x19, #44]
    arch_spin_unlock(lock);
ffffffffea805ebc:	aa1403e0 	mov	x0, x20
ffffffffea805ec0:	f9000044 	str	x4, [x2]
	list->next = item;
ffffffffea805ec4:	f9000424 	str	x4, [x1, #8]
ffffffffea805ec8:	97fff2ad 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea805ecc:	34000055 	cbz	w21, ffffffffea805ed4 <thread_sleep_handler+0x8c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea805ed0:	d50342ff 	msr	daifclr, #0x2
	insert_in_run_queue_head(t);

	THREAD_UNLOCK(state);

	return INT_RESCHEDULE;
}
ffffffffea805ed4:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea805ed8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805edc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805ee0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805ee4:	d65f03c0 	ret

ffffffffea805ee8 <thread_timer_tick>:
{
ffffffffea805ee8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea805eec:	910003fd 	mov	x29, sp
ffffffffea805ef0:	f9000bf3 	str	x19, [sp, #16]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea805ef4:	d538d093 	mrs	x19, tpidr_el1
	return !!(t->flags & THREAD_FLAG_IDLE);
ffffffffea805ef8:	b9403660 	ldr	w0, [x19, #52]
	if (thread_is_idle(current_thread))
ffffffffea805efc:	362000a0 	tbz	w0, #4, ffffffffea805f10 <thread_timer_tick+0x28>
		return INT_NO_RESCHEDULE;
ffffffffea805f00:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea805f04:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea805f08:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea805f0c:	d65f03c0 	ret
ffffffffea805f10:	f9000fb4 	str	x20, [x29, #24]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805f14:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea805f18:	36380280 	tbz	w0, #7, ffffffffea805f68 <thread_timer_tick+0x80>
    arch_spin_lock(lock);
ffffffffea805f1c:	f00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea805f20:	912ea294 	add	x20, x20, #0xba8
ffffffffea805f24:	aa1403e0 	mov	x0, x20
ffffffffea805f28:	97fff28d 	bl	ffffffffea80295c <arch_spin_lock>
	thread_cond_mp_reschedule(current_thread, __func__);
ffffffffea805f2c:	97ffff49 	bl	ffffffffea805c50 <thread_cond_mp_reschedule.isra.6>
    arch_spin_unlock(lock);
ffffffffea805f30:	aa1403e0 	mov	x0, x20
ffffffffea805f34:	97fff292 	bl	ffffffffea80297c <arch_spin_unlock>
	return !!(t->flags & (THREAD_FLAG_REAL_TIME | THREAD_FLAG_IDLE));
ffffffffea805f38:	b9403660 	ldr	w0, [x19, #52]
	if (thread_is_real_time_or_idle(current_thread))
ffffffffea805f3c:	721d041f 	tst	w0, #0x18
ffffffffea805f40:	540002c1 	b.ne	ffffffffea805f98 <thread_timer_tick+0xb0>  // b.any
	current_thread->remaining_quantum--;
ffffffffea805f44:	b9403260 	ldr	w0, [x19, #48]
	if (current_thread->remaining_quantum <= 0) {
ffffffffea805f48:	f9400fb4 	ldr	x20, [x29, #24]
	current_thread->remaining_quantum--;
ffffffffea805f4c:	51000400 	sub	w0, w0, #0x1
ffffffffea805f50:	b9003260 	str	w0, [x19, #48]
	if (current_thread->remaining_quantum <= 0) {
ffffffffea805f54:	7100001f 	cmp	w0, #0x0
}
ffffffffea805f58:	f9400bf3 	ldr	x19, [sp, #16]
	if (current_thread->remaining_quantum <= 0) {
ffffffffea805f5c:	1a9fc7e0 	cset	w0, le
}
ffffffffea805f60:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea805f64:	d65f03c0 	ret
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805f68:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea805f6c:	f00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea805f70:	912ea294 	add	x20, x20, #0xba8
ffffffffea805f74:	aa1403e0 	mov	x0, x20
ffffffffea805f78:	97fff279 	bl	ffffffffea80295c <arch_spin_lock>
	thread_cond_mp_reschedule(current_thread, __func__);
ffffffffea805f7c:	97ffff35 	bl	ffffffffea805c50 <thread_cond_mp_reschedule.isra.6>
    arch_spin_unlock(lock);
ffffffffea805f80:	aa1403e0 	mov	x0, x20
ffffffffea805f84:	97fff27e 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea805f88:	d50342ff 	msr	daifclr, #0x2
	return !!(t->flags & (THREAD_FLAG_REAL_TIME | THREAD_FLAG_IDLE));
ffffffffea805f8c:	b9403660 	ldr	w0, [x19, #52]
	if (thread_is_real_time_or_idle(current_thread))
ffffffffea805f90:	721d041f 	tst	w0, #0x18
ffffffffea805f94:	54fffd80 	b.eq	ffffffffea805f44 <thread_timer_tick+0x5c>  // b.none
ffffffffea805f98:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea805f9c:	17ffffd9 	b	ffffffffea805f00 <thread_timer_tick+0x18>

ffffffffea805fa0 <thread_create_etc>:
{
ffffffffea805fa0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea805fa4:	910003fd 	mov	x29, sp
ffffffffea805fa8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805fac:	aa0003f3 	mov	x19, x0
ffffffffea805fb0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea805fb4:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea805fb8:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea805fbc:	aa0503f6 	mov	x22, x5
ffffffffea805fc0:	f90023f9 	str	x25, [sp, #64]
ffffffffea805fc4:	aa0203f8 	mov	x24, x2
ffffffffea805fc8:	aa0303f7 	mov	x23, x3
ffffffffea805fcc:	aa0603f5 	mov	x21, x6
ffffffffea805fd0:	2a0403f9 	mov	w25, w4
	if (!t) {
ffffffffea805fd4:	b4000840 	cbz	x0, ffffffffea8060dc <thread_create_etc+0x13c>
	init_thread_struct(t, name);
ffffffffea805fd8:	aa1303e0 	mov	x0, x19
ffffffffea805fdc:	97fffea1 	bl	ffffffffea805a60 <init_thread_struct>
 * @defgroup  wait  Wait Queue
 * @{
 */
void wait_queue_init(wait_queue_t *wait)
{
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea805fe0:	528d2e81 	mov	w1, #0x6974                	// #26996
	t->curr_cpu = -1;
ffffffffea805fe4:	12800002 	mov	w2, #0xffffffff            	// #-1
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea805fe8:	72aeec21 	movk	w1, #0x7761, lsl #16
	t->state = THREAD_SUSPENDED;
ffffffffea805fec:	29057e79 	stp	w25, wzr, [x19, #40]
	t->curr_cpu = -1;
ffffffffea805ff0:	b9003a62 	str	w2, [x19, #56]
	t->blocking_wait_queue = NULL;
ffffffffea805ff4:	f900227f 	str	xzr, [x19, #64]
	t->wait_queue_block_ret = NO_ERROR;
ffffffffea805ff8:	b9004a7f 	str	wzr, [x19, #72]
	t->entry = entry;
ffffffffea805ffc:	f9013e78 	str	x24, [x19, #632]
	t->arg = arg;
ffffffffea806000:	f9014277 	str	x23, [x19, #640]
	t->retcode = 0;
ffffffffea806004:	b9028a7f 	str	wzr, [x19, #648]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea806008:	b9029261 	str	w1, [x19, #656]
ffffffffea80600c:	910a6261 	add	x1, x19, #0x298
ffffffffea806010:	f9014e61 	str	x1, [x19, #664]
ffffffffea806014:	f9015261 	str	x1, [x19, #672]
ffffffffea806018:	b902aa7f 	str	wzr, [x19, #680]
	if (!stack) {
ffffffffea80601c:	b5000236 	cbnz	x22, ffffffffea806060 <thread_create_etc+0xc0>
		t->stack = malloc(stack_size);
ffffffffea806020:	aa1503e0 	mov	x0, x21
ffffffffea806024:	94003407 	bl	ffffffffea813040 <malloc>
ffffffffea806028:	f9013660 	str	x0, [x19, #616]
		if (!t->stack) {
ffffffffea80602c:	b5000180 	cbnz	x0, ffffffffea80605c <thread_create_etc+0xbc>
			if (flags & THREAD_FLAG_FREE_STRUCT)
ffffffffea806030:	35000114 	cbnz	w20, ffffffffea806050 <thread_create_etc+0xb0>
}
ffffffffea806034:	a94153f3 	ldp	x19, x20, [sp, #16]
			return NULL;
ffffffffea806038:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80603c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806040:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806044:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea806048:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80604c:	d65f03c0 	ret
				free(t);
ffffffffea806050:	aa1303e0 	mov	x0, x19
ffffffffea806054:	94003411 	bl	ffffffffea813098 <free>
ffffffffea806058:	17fffff7 	b	ffffffffea806034 <thread_create_etc+0x94>
		flags |= THREAD_FLAG_FREE_STACK;
ffffffffea80605c:	321f0294 	orr	w20, w20, #0x2
	t->flags = flags;
ffffffffea806060:	b9003674 	str	w20, [x19, #52]
	t->stack_size = stack_size;
ffffffffea806064:	f9013a75 	str	x21, [x19, #624]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806068:	d538d080 	mrs	x0, tpidr_el1
		t->tls[i] = current_thread->tls[i];
ffffffffea80606c:	f9415801 	ldr	x1, [x0, #688]
	arch_thread_initialize(t);
ffffffffea806070:	aa1303e0 	mov	x0, x19
		t->tls[i] = current_thread->tls[i];
ffffffffea806074:	f9015a61 	str	x1, [x19, #688]
	arch_thread_initialize(t);
ffffffffea806078:	97fff404 	bl	ffffffffea803088 <arch_thread_initialize>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80607c:	d53b4220 	mrs	x0, daif
ffffffffea806080:	91002274 	add	x20, x19, #0x8
ffffffffea806084:	373803c0 	tbnz	w0, #7, ffffffffea8060fc <thread_create_etc+0x15c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806088:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80608c:	d00002b5 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806090:	912ea2b5 	add	x21, x21, #0xba8
ffffffffea806094:	aa1503e0 	mov	x0, x21
ffffffffea806098:	97fff231 	bl	ffffffffea80295c <arch_spin_lock>
	item->next = list->next;
ffffffffea80609c:	d00002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8060a0:	912e6021 	add	x1, x1, #0xb98
    arch_spin_unlock(lock);
ffffffffea8060a4:	aa1503e0 	mov	x0, x21
ffffffffea8060a8:	f9400422 	ldr	x2, [x1, #8]
ffffffffea8060ac:	a9008a61 	stp	x1, x2, [x19, #8]
	list->next->prev = item;
ffffffffea8060b0:	f9000054 	str	x20, [x2]
	list->next = item;
ffffffffea8060b4:	f9000434 	str	x20, [x1, #8]
ffffffffea8060b8:	97fff231 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8060bc:	d50342ff 	msr	daifclr, #0x2
ffffffffea8060c0:	aa1303e0 	mov	x0, x19
}
ffffffffea8060c4:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea8060c8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8060cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8060d0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8060d4:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8060d8:	d65f03c0 	ret
ffffffffea8060dc:	f9002fa1 	str	x1, [x29, #88]
		t = malloc(sizeof(thread_t));
ffffffffea8060e0:	d2805b00 	mov	x0, #0x2d8                 	// #728
ffffffffea8060e4:	940033d7 	bl	ffffffffea813040 <malloc>
		flags |= THREAD_FLAG_FREE_STRUCT;
ffffffffea8060e8:	52800094 	mov	w20, #0x4                   	// #4
		t = malloc(sizeof(thread_t));
ffffffffea8060ec:	aa0003f3 	mov	x19, x0
		if (!t)
ffffffffea8060f0:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea8060f4:	b5fff720 	cbnz	x0, ffffffffea805fd8 <thread_create_etc+0x38>
ffffffffea8060f8:	17ffffcf 	b	ffffffffea806034 <thread_create_etc+0x94>
    arch_spin_lock(lock);
ffffffffea8060fc:	d00002b5 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806100:	912ea2b5 	add	x21, x21, #0xba8
ffffffffea806104:	aa1503e0 	mov	x0, x21
ffffffffea806108:	97fff215 	bl	ffffffffea80295c <arch_spin_lock>
	item->next = list->next;
ffffffffea80610c:	d00002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806110:	912e6021 	add	x1, x1, #0xb98
    arch_spin_unlock(lock);
ffffffffea806114:	aa1503e0 	mov	x0, x21
ffffffffea806118:	f9400422 	ldr	x2, [x1, #8]
ffffffffea80611c:	a9008a61 	stp	x1, x2, [x19, #8]
	list->next->prev = item;
ffffffffea806120:	f9000054 	str	x20, [x2]
	list->next = item;
ffffffffea806124:	f9000434 	str	x20, [x1, #8]
ffffffffea806128:	97fff215 	bl	ffffffffea80297c <arch_spin_unlock>
}
ffffffffea80612c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea806130:	aa1303e0 	mov	x0, x19
ffffffffea806134:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806138:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80613c:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806140:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806144:	d65f03c0 	ret

ffffffffea806148 <thread_create>:
	return thread_create_etc(NULL, name, entry, arg, priority, NULL, stack_size);
ffffffffea806148:	aa0403e6 	mov	x6, x4
ffffffffea80614c:	d2800005 	mov	x5, #0x0                   	// #0
ffffffffea806150:	2a0303e4 	mov	w4, w3
ffffffffea806154:	aa0203e3 	mov	x3, x2
ffffffffea806158:	aa0103e2 	mov	x2, x1
ffffffffea80615c:	aa0003e1 	mov	x1, x0
ffffffffea806160:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea806164:	17ffff8f 	b	ffffffffea805fa0 <thread_create_etc>

ffffffffea806168 <thread_set_real_time>:
	if (!t)
ffffffffea806168:	b4000560 	cbz	x0, ffffffffea806214 <thread_set_real_time+0xac>
{
ffffffffea80616c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea806170:	910003fd 	mov	x29, sp
ffffffffea806174:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806178:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80617c:	d53b4221 	mrs	x1, daif
    spin_lock_saved_state_t state = 0;
ffffffffea806180:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea806184:	36380281 	tbz	w1, #7, ffffffffea8061d4 <thread_set_real_time+0x6c>
ffffffffea806188:	aa0003f3 	mov	x19, x0
    arch_spin_lock(lock);
ffffffffea80618c:	d00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806190:	912ea280 	add	x0, x20, #0xba8
ffffffffea806194:	97fff1f2 	bl	ffffffffea80295c <arch_spin_lock>
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806198:	d538d080 	mrs	x0, tpidr_el1
	if (t == get_current_thread()) {
ffffffffea80619c:	eb00027f 	cmp	x19, x0
ffffffffea8061a0:	540002c0 	b.eq	ffffffffea8061f8 <thread_set_real_time+0x90>  // b.none
	t->flags |= THREAD_FLAG_REAL_TIME;
ffffffffea8061a4:	b9403661 	ldr	w1, [x19, #52]
    arch_spin_unlock(lock);
ffffffffea8061a8:	912ea280 	add	x0, x20, #0xba8
ffffffffea8061ac:	321d0021 	orr	w1, w1, #0x8
ffffffffea8061b0:	b9003661 	str	w1, [x19, #52]
ffffffffea8061b4:	97fff1f2 	bl	ffffffffea80297c <arch_spin_unlock>
	return NO_ERROR;
ffffffffea8061b8:	52800000 	mov	w0, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8061bc:	34000055 	cbz	w21, ffffffffea8061c4 <thread_set_real_time+0x5c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8061c0:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8061c4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8061c8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8061cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8061d0:	d65f03c0 	ret
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8061d4:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea8061d8:	d00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8061dc:	aa0003f3 	mov	x19, x0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8061e0:	52800035 	mov	w21, #0x1                   	// #1
ffffffffea8061e4:	912ea280 	add	x0, x20, #0xba8
ffffffffea8061e8:	97fff1dd 	bl	ffffffffea80295c <arch_spin_lock>
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea8061ec:	d538d080 	mrs	x0, tpidr_el1
	if (t == get_current_thread()) {
ffffffffea8061f0:	eb00027f 	cmp	x19, x0
ffffffffea8061f4:	54fffd81 	b.ne	ffffffffea8061a4 <thread_set_real_time+0x3c>  // b.any
		timer_cancel(&preempt_timer[arch_curr_cpu_num()]);
ffffffffea8061f8:	97fff25e 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea8061fc:	d00002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806200:	91204021 	add	x1, x1, #0x810
ffffffffea806204:	52800602 	mov	w2, #0x30                  	// #48
ffffffffea806208:	9ba20400 	umaddl	x0, w0, w2, x1
ffffffffea80620c:	94000477 	bl	ffffffffea8073e8 <timer_cancel>
ffffffffea806210:	17ffffe5 	b	ffffffffea8061a4 <thread_set_real_time+0x3c>
		return ERR_INVALID_ARGS;
ffffffffea806214:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea806218:	d65f03c0 	ret
ffffffffea80621c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806220 <thread_yield>:
{
ffffffffea806220:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea806224:	910003fd 	mov	x29, sp
ffffffffea806228:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80622c:	f90013f5 	str	x21, [sp, #32]
ffffffffea806230:	d538d093 	mrs	x19, tpidr_el1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806234:	d53b4220 	mrs	x0, daif
ffffffffea806238:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80623c:	37380060 	tbnz	w0, #7, ffffffffea806248 <thread_yield+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806240:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea806244:	52800035 	mov	w21, #0x1                   	// #1
ffffffffea806248:	d00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea80624c:	912ea280 	add	x0, x20, #0xba8
ffffffffea806250:	97fff1c3 	bl	ffffffffea80295c <arch_spin_lock>
	return !!(t->flags & THREAD_FLAG_IDLE);
ffffffffea806254:	b9403661 	ldr	w1, [x19, #52]
	current_thread->state = THREAD_READY;
ffffffffea806258:	52800020 	mov	w0, #0x1                   	// #1
	current_thread->remaining_quantum = 0;
ffffffffea80625c:	2905fe60 	stp	w0, wzr, [x19, #44]
	if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
ffffffffea806260:	37200221 	tbnz	w1, #4, ffffffffea8062a4 <thread_yield+0x84>
	list_add_tail(&run_queue[t->priority], &t->queue_node);
ffffffffea806264:	b9402a65 	ldr	w5, [x19, #40]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806268:	d00002a4 	adrp	x4, ffffffffea85c000 <idle_threads+0xeb0>
	item->prev = list->prev;
ffffffffea80626c:	d00002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806270:	91264021 	add	x1, x1, #0x990
ffffffffea806274:	b94b9087 	ldr	w7, [x4, #2960]
	list_add_tail(&run_queue[t->priority], &t->queue_node);
ffffffffea806278:	91006263 	add	x3, x19, #0x18
ffffffffea80627c:	937c7ca2 	sbfiz	x2, x5, #4, #32
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806280:	1ac52000 	lsl	w0, w0, w5
ffffffffea806284:	2a070000 	orr	w0, w0, w7
ffffffffea806288:	b90b9080 	str	w0, [x4, #2960]
ffffffffea80628c:	8b020026 	add	x6, x1, x2
ffffffffea806290:	f8626820 	ldr	x0, [x1, x2]
	item->next = list;
ffffffffea806294:	a9019a60 	stp	x0, x6, [x19, #24]
	list->prev->next = item;
ffffffffea806298:	f8626820 	ldr	x0, [x1, x2]
ffffffffea80629c:	f9000403 	str	x3, [x0, #8]
	list->prev = item;
ffffffffea8062a0:	f8226823 	str	x3, [x1, x2]
	thread_resched();
ffffffffea8062a4:	97fffe91 	bl	ffffffffea805ce8 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea8062a8:	912ea280 	add	x0, x20, #0xba8
ffffffffea8062ac:	97fff1b4 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8062b0:	34000055 	cbz	w21, ffffffffea8062b8 <thread_yield+0x98>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8062b4:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8062b8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8062bc:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8062c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8062c4:	d65f03c0 	ret

ffffffffea8062c8 <thread_resume>:
{
ffffffffea8062c8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea8062cc:	910003fd 	mov	x29, sp
ffffffffea8062d0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8062d4:	aa0003f3 	mov	x19, x0
ffffffffea8062d8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8062dc:	f9001bf7 	str	x23, [sp, #48]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8062e0:	d53b4237 	mrs	x23, daif
ffffffffea8062e4:	d53b4220 	mrs	x0, daif
ffffffffea8062e8:	52800016 	mov	w22, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8062ec:	37380060 	tbnz	w0, #7, ffffffffea8062f8 <thread_resume+0x30>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8062f0:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8062f4:	52800036 	mov	w22, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea8062f8:	d00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8062fc:	912ea280 	add	x0, x20, #0xba8
ffffffffea806300:	97fff197 	bl	ffffffffea80295c <arch_spin_lock>
	bool resched = false;
ffffffffea806304:	52800015 	mov	w21, #0x0                   	// #0
	if (t->state == THREAD_SUSPENDED) {
ffffffffea806308:	b9402e60 	ldr	w0, [x19, #44]
ffffffffea80630c:	35000280 	cbnz	w0, ffffffffea80635c <thread_resume+0x94>
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806310:	b9402a64 	ldr	w4, [x19, #40]
	item->next = list->next;
ffffffffea806314:	d00002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806318:	91264000 	add	x0, x0, #0x990
	run_queue_bitmap |= (1<<t->priority);
ffffffffea80631c:	d00002a3 	adrp	x3, ffffffffea85c000 <idle_threads+0xeb0>
		t->state = THREAD_READY;
ffffffffea806320:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea806324:	b9002e61 	str	w1, [x19, #44]
ffffffffea806328:	8b24d000 	add	x0, x0, w4, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea80632c:	1ac42021 	lsl	w1, w1, w4
ffffffffea806330:	b94b9065 	ldr	w5, [x3, #2960]
		if (!ints_disabled) /* HACK, don't resced into bootstrap thread before idle thread is set up */
ffffffffea806334:	d27902f5 	eor	x21, x23, #0x80
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806338:	91006262 	add	x2, x19, #0x18
ffffffffea80633c:	f9400404 	ldr	x4, [x0, #8]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806340:	2a050021 	orr	w1, w1, w5
ffffffffea806344:	a9019260 	stp	x0, x4, [x19, #24]
		if (!ints_disabled) /* HACK, don't resced into bootstrap thread before idle thread is set up */
ffffffffea806348:	53071eb5 	ubfx	w21, w21, #7, #1
	run_queue_bitmap |= (1<<t->priority);
ffffffffea80634c:	b90b9061 	str	w1, [x3, #2960]
	list->next->prev = item;
ffffffffea806350:	f9400403 	ldr	x3, [x0, #8]
ffffffffea806354:	f9000062 	str	x2, [x3]
	list->next = item;
ffffffffea806358:	f9000402 	str	x2, [x0, #8]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80635c:	d538d080 	mrs	x0, tpidr_el1
	thread_mp_reschedule(get_current_thread(), t);
ffffffffea806360:	aa1303e1 	mov	x1, x19
ffffffffea806364:	97fffe31 	bl	ffffffffea805c28 <thread_mp_reschedule>
    arch_spin_unlock(lock);
ffffffffea806368:	912ea280 	add	x0, x20, #0xba8
ffffffffea80636c:	97fff184 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806370:	34000056 	cbz	w22, ffffffffea806378 <thread_resume+0xb0>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806374:	d50342ff 	msr	daifclr, #0x2
	if (resched)
ffffffffea806378:	34000055 	cbz	w21, ffffffffea806380 <thread_resume+0xb8>
		thread_yield();
ffffffffea80637c:	97ffffa9 	bl	ffffffffea806220 <thread_yield>
}
ffffffffea806380:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea806384:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea806388:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80638c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806390:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea806394:	d65f03c0 	ret

ffffffffea806398 <thread_preempt>:
{
ffffffffea806398:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80639c:	910003fd 	mov	x29, sp
ffffffffea8063a0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8063a4:	a9025bf5 	stp	x21, x22, [sp, #32]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea8063a8:	d538d093 	mrs	x19, tpidr_el1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8063ac:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8063b0:	373804e0 	tbnz	w0, #7, ffffffffea80644c <thread_preempt+0xb4>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8063b4:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea8063b8:	d00002b5 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8063bc:	912ea2b6 	add	x22, x21, #0xba8
ffffffffea8063c0:	aa1603e0 	mov	x0, x22
ffffffffea8063c4:	97fff166 	bl	ffffffffea80295c <arch_spin_lock>
	return !!(t->flags & THREAD_FLAG_IDLE);
ffffffffea8063c8:	b9403660 	ldr	w0, [x19, #52]
	current_thread->state = THREAD_READY;
ffffffffea8063cc:	52800034 	mov	w20, #0x1                   	// #1
ffffffffea8063d0:	b9002e74 	str	w20, [x19, #44]
	if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
ffffffffea8063d4:	37200680 	tbnz	w0, #4, ffffffffea8064a4 <thread_preempt+0x10c>
ffffffffea8063d8:	b9402a62 	ldr	w2, [x19, #40]
ffffffffea8063dc:	d00002a4 	adrp	x4, ffffffffea85c000 <idle_threads+0xeb0>
		if (current_thread->remaining_quantum > 0)
ffffffffea8063e0:	b9403266 	ldr	w6, [x19, #48]
ffffffffea8063e4:	d00002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8063e8:	b94b9087 	ldr	w7, [x4, #2960]
ffffffffea8063ec:	91264021 	add	x1, x1, #0x990
ffffffffea8063f0:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea8063f4:	937c7c43 	sbfiz	x3, x2, #4, #32
ffffffffea8063f8:	1ac22000 	lsl	w0, w0, w2
ffffffffea8063fc:	91006265 	add	x5, x19, #0x18
ffffffffea806400:	8b030022 	add	x2, x1, x3
ffffffffea806404:	2a070000 	orr	w0, w0, w7
ffffffffea806408:	710000df 	cmp	w6, #0x0
ffffffffea80640c:	540003ed 	b.le	ffffffffea806488 <thread_preempt+0xf0>
	item->next = list->next;
ffffffffea806410:	f9400441 	ldr	x1, [x2, #8]
ffffffffea806414:	a9018662 	stp	x2, x1, [x19, #24]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806418:	b90b9080 	str	w0, [x4, #2960]
	list->next->prev = item;
ffffffffea80641c:	f9400440 	ldr	x0, [x2, #8]
ffffffffea806420:	f9000005 	str	x5, [x0]
	list->next = item;
ffffffffea806424:	f9000445 	str	x5, [x2, #8]
	thread_resched();
ffffffffea806428:	97fffe30 	bl	ffffffffea805ce8 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea80642c:	912ea2a0 	add	x0, x21, #0xba8
ffffffffea806430:	97fff153 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806434:	34000054 	cbz	w20, ffffffffea80643c <thread_preempt+0xa4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806438:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea80643c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806440:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806444:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806448:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea80644c:	d00002b5 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806450:	912ea2b6 	add	x22, x21, #0xba8
ffffffffea806454:	aa1603e0 	mov	x0, x22
ffffffffea806458:	97fff141 	bl	ffffffffea80295c <arch_spin_lock>
	return !!(t->flags & THREAD_FLAG_IDLE);
ffffffffea80645c:	b9403660 	ldr	w0, [x19, #52]
	current_thread->state = THREAD_READY;
ffffffffea806460:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea806464:	b9002e61 	str	w1, [x19, #44]
    spin_lock_saved_state_t state = 0;
ffffffffea806468:	52800014 	mov	w20, #0x0                   	// #0
	if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
ffffffffea80646c:	3627fb60 	tbz	w0, #4, ffffffffea8063d8 <thread_preempt+0x40>
	thread_resched();
ffffffffea806470:	97fffe1e 	bl	ffffffffea805ce8 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea806474:	aa1603e0 	mov	x0, x22
}
ffffffffea806478:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80647c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806480:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806484:	17fff13e 	b	ffffffffea80297c <arch_spin_unlock>
	item->prev = list->prev;
ffffffffea806488:	f8636826 	ldr	x6, [x1, x3]
	item->next = list;
ffffffffea80648c:	a9018a66 	stp	x6, x2, [x19, #24]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806490:	b90b9080 	str	w0, [x4, #2960]
	list->prev->next = item;
ffffffffea806494:	f8636820 	ldr	x0, [x1, x3]
ffffffffea806498:	f9000405 	str	x5, [x0, #8]
	list->prev = item;
ffffffffea80649c:	f8236825 	str	x5, [x1, x3]
ffffffffea8064a0:	17ffffe2 	b	ffffffffea806428 <thread_preempt+0x90>
	thread_resched();
ffffffffea8064a4:	97fffe11 	bl	ffffffffea805ce8 <thread_resched>
ffffffffea8064a8:	aa1603e0 	mov	x0, x22
ffffffffea8064ac:	97fff134 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea8064b0:	17ffffe2 	b	ffffffffea806438 <thread_preempt+0xa0>
ffffffffea8064b4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8064b8 <thread_sleep>:
{
ffffffffea8064b8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea8064bc:	910003fd 	mov	x29, sp
ffffffffea8064c0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8064c4:	f90013f5 	str	x21, [sp, #32]
ffffffffea8064c8:	2a0003f5 	mov	w21, w0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea8064cc:	d538d093 	mrs	x19, tpidr_el1
	timer_initialize(&timer);
ffffffffea8064d0:	9100c3a0 	add	x0, x29, #0x30
ffffffffea8064d4:	940003b1 	bl	ffffffffea807398 <timer_initialize>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8064d8:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8064dc:	373802c0 	tbnz	w0, #7, ffffffffea806534 <thread_sleep+0x7c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8064e0:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea8064e4:	d00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8064e8:	912ea294 	add	x20, x20, #0xba8
ffffffffea8064ec:	aa1403e0 	mov	x0, x20
ffffffffea8064f0:	97fff11b 	bl	ffffffffea80295c <arch_spin_lock>
	timer_set_oneshot(&timer, delay, thread_sleep_handler, (void *)current_thread);
ffffffffea8064f4:	aa1303e3 	mov	x3, x19
ffffffffea8064f8:	2a1503e1 	mov	w1, w21
ffffffffea8064fc:	9100c3a0 	add	x0, x29, #0x30
ffffffffea806500:	f0ffffe2 	adrp	x2, ffffffffea805000 <cntpct_to_lk_time+0x28>
ffffffffea806504:	91392042 	add	x2, x2, #0xe48
ffffffffea806508:	940003ac 	bl	ffffffffea8073b8 <timer_set_oneshot>
	current_thread->state = THREAD_SLEEPING;
ffffffffea80650c:	52800080 	mov	w0, #0x4                   	// #4
ffffffffea806510:	b9002e60 	str	w0, [x19, #44]
	thread_resched();
ffffffffea806514:	97fffdf5 	bl	ffffffffea805ce8 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea806518:	aa1403e0 	mov	x0, x20
ffffffffea80651c:	97fff118 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806520:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea806524:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806528:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80652c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806530:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea806534:	d00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806538:	912ea294 	add	x20, x20, #0xba8
ffffffffea80653c:	aa1403e0 	mov	x0, x20
ffffffffea806540:	97fff107 	bl	ffffffffea80295c <arch_spin_lock>
	timer_set_oneshot(&timer, delay, thread_sleep_handler, (void *)current_thread);
ffffffffea806544:	aa1303e3 	mov	x3, x19
ffffffffea806548:	2a1503e1 	mov	w1, w21
ffffffffea80654c:	9100c3a0 	add	x0, x29, #0x30
ffffffffea806550:	f0ffffe2 	adrp	x2, ffffffffea805000 <cntpct_to_lk_time+0x28>
ffffffffea806554:	91392042 	add	x2, x2, #0xe48
ffffffffea806558:	94000398 	bl	ffffffffea8073b8 <timer_set_oneshot>
	current_thread->state = THREAD_SLEEPING;
ffffffffea80655c:	52800080 	mov	w0, #0x4                   	// #4
ffffffffea806560:	b9002e60 	str	w0, [x19, #44]
	thread_resched();
ffffffffea806564:	97fffde1 	bl	ffffffffea805ce8 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea806568:	aa1403e0 	mov	x0, x20
ffffffffea80656c:	97fff104 	bl	ffffffffea80297c <arch_spin_unlock>
}
ffffffffea806570:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806574:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806578:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80657c:	d65f03c0 	ret

ffffffffea806580 <thread_init_early>:
{
ffffffffea806580:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea806584:	d00002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806588:	91264000 	add	x0, x0, #0x990
ffffffffea80658c:	910003fd 	mov	x29, sp
ffffffffea806590:	91080001 	add	x1, x0, #0x200
ffffffffea806594:	a90153f3 	stp	x19, x20, [sp, #16]
	list->prev = list->next = list;
ffffffffea806598:	a9000000 	stp	x0, x0, [x0]
ffffffffea80659c:	91004000 	add	x0, x0, #0x10
	for (i=0; i < NUM_PRIORITIES; i++)
ffffffffea8065a0:	eb01001f 	cmp	x0, x1
ffffffffea8065a4:	54ffffa1 	b.ne	ffffffffea806598 <thread_init_early+0x18>  // b.any
ffffffffea8065a8:	d00002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8065ac:	912e6014 	add	x20, x0, #0xb98
	init_thread_struct(t, "bootstrap");
ffffffffea8065b0:	b00002b3 	adrp	x19, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
ffffffffea8065b4:	91054273 	add	x19, x19, #0x150
ffffffffea8065b8:	f905cc14 	str	x20, [x0, #2968]
ffffffffea8065bc:	90000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8065c0:	aa1303e0 	mov	x0, x19
ffffffffea8065c4:	9107c021 	add	x1, x1, #0x1f0
ffffffffea8065c8:	f9000694 	str	x20, [x20, #8]
ffffffffea8065cc:	97fffd25 	bl	ffffffffea805a60 <init_thread_struct>
	item->next = list->next;
ffffffffea8065d0:	f9400682 	ldr	x2, [x20, #8]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8065d4:	528d2e83 	mov	w3, #0x6974                	// #26996
ffffffffea8065d8:	72aeec23 	movk	w3, #0x7761, lsl #16
	t->priority = HIGHEST_PRIORITY;
ffffffffea8065dc:	528003e1 	mov	w1, #0x1f                  	// #31
	t->state = THREAD_RUNNING;
ffffffffea8065e0:	52800045 	mov	w5, #0x2                   	// #2
	t->flags = THREAD_FLAG_DETACHED;
ffffffffea8065e4:	d2800024 	mov	x4, #0x1                   	// #1
ffffffffea8065e8:	a9008a74 	stp	x20, x2, [x19, #8]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8065ec:	b00002a0 	adrp	x0, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
	t->state = THREAD_RUNNING;
ffffffffea8065f0:	29051661 	stp	w1, w5, [x19, #40]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8065f4:	910fa000 	add	x0, x0, #0x3e8
	t->flags = THREAD_FLAG_DETACHED;
ffffffffea8065f8:	f8034264 	stur	x4, [x19, #52]
	t->curr_cpu = 0;
ffffffffea8065fc:	b9003e7f 	str	wzr, [x19, #60]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea806600:	b9029263 	str	w3, [x19, #656]
	cpu_priority[0] = t->priority;
ffffffffea806604:	b00002a3 	adrp	x3, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea806608:	f9014e60 	str	x0, [x19, #664]
ffffffffea80660c:	f9015260 	str	x0, [x19, #672]
	list->next->prev = item;
ffffffffea806610:	b00002a0 	adrp	x0, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
ffffffffea806614:	b902aa7f 	str	wzr, [x19, #680]
ffffffffea806618:	91056000 	add	x0, x0, #0x158
ffffffffea80661c:	f9000040 	str	x0, [x2]
	cpu_priority[0] = t->priority;
ffffffffea806620:	b9013061 	str	w1, [x3, #304]
	list->next = item;
ffffffffea806624:	f9000680 	str	x0, [x20, #8]
    ARM64_WRITE_SYSREG(tpidr_el1, (uint64_t)t);
ffffffffea806628:	d518d093 	msr	tpidr_el1, x19
ffffffffea80662c:	d5033fdf 	isb
}
ffffffffea806630:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806634:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806638:	d65f03c0 	ret
ffffffffea80663c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806640 <thread_init>:
{
ffffffffea806640:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea806644:	910003fd 	mov	x29, sp
ffffffffea806648:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80664c:	d00002b3 	adrp	x19, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806650:	91204273 	add	x19, x19, #0x810
ffffffffea806654:	91060274 	add	x20, x19, #0x180
		timer_initialize(&preempt_timer[i]);
ffffffffea806658:	aa1303e0 	mov	x0, x19
ffffffffea80665c:	9100c273 	add	x19, x19, #0x30
ffffffffea806660:	9400034e 	bl	ffffffffea807398 <timer_initialize>
	for (uint i = 0; i < SMP_MAX_CPUS; i++) {
ffffffffea806664:	eb14027f 	cmp	x19, x20
ffffffffea806668:	54ffff81 	b.ne	ffffffffea806658 <thread_init+0x18>  // b.any
}
ffffffffea80666c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806670:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806674:	d65f03c0 	ret

ffffffffea806678 <thread_become_idle>:
{
ffffffffea806678:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80667c:	910003fd 	mov	x29, sp
ffffffffea806680:	f9000bf3 	str	x19, [sp, #16]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806684:	d538d093 	mrs	x19, tpidr_el1
	snprintf(name, sizeof(name), "idle %d", arch_curr_cpu_num());
ffffffffea806688:	97fff13a 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea80668c:	2a0003e3 	mov	w3, w0
ffffffffea806690:	d2800201 	mov	x1, #0x10                  	// #16
ffffffffea806694:	910083a0 	add	x0, x29, #0x20
ffffffffea806698:	90000082 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80669c:	91070042 	add	x2, x2, #0x1c0
ffffffffea8066a0:	94003222 	bl	ffffffffea812f28 <snprintf>
ffffffffea8066a4:	d538d080 	mrs	x0, tpidr_el1
	strlcpy(current_thread->name, name, sizeof(current_thread->name));
ffffffffea8066a8:	d2800402 	mov	x2, #0x20                  	// #32
ffffffffea8066ac:	910ae000 	add	x0, x0, #0x2b8
ffffffffea8066b0:	8b0203a1 	add	x1, x29, x2
ffffffffea8066b4:	94003379 	bl	ffffffffea813498 <strlcpy>
	t->flags |= THREAD_FLAG_IDLE;
ffffffffea8066b8:	b9403660 	ldr	w0, [x19, #52]
	t->priority = IDLE_PRIORITY;
ffffffffea8066bc:	b9002a7f 	str	wzr, [x19, #40]
	t->flags |= THREAD_FLAG_IDLE;
ffffffffea8066c0:	321c0000 	orr	w0, w0, #0x10
ffffffffea8066c4:	b9003660 	str	w0, [x19, #52]
	t->pinned_cpu = arch_curr_cpu_num();
ffffffffea8066c8:	97fff12a 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea8066cc:	b9003e60 	str	w0, [x19, #60]
	mp_set_curr_cpu_active(true);
ffffffffea8066d0:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea8066d4:	940003a5 	bl	ffffffffea807568 <mp_set_curr_cpu_active>
	mp_set_cpu_idle(arch_curr_cpu_num());
ffffffffea8066d8:	97fff126 	bl	ffffffffea802b70 <arch_curr_cpu_num>
    mp.idle_cpus |= 1UL << cpu;
ffffffffea8066dc:	f00002a1 	adrp	x1, ffffffffea85d000 <rb_data+0x18>
ffffffffea8066e0:	91030021 	add	x1, x1, #0xc0
ffffffffea8066e4:	d2800022 	mov	x2, #0x1                   	// #1
ffffffffea8066e8:	9ac02042 	lsl	x2, x2, x0
ffffffffea8066ec:	b9400420 	ldr	w0, [x1, #4]
ffffffffea8066f0:	2a020000 	orr	w0, w0, w2
ffffffffea8066f4:	b9000420 	str	w0, [x1, #4]
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8066f8:	d50342ff 	msr	daifclr, #0x2
	thread_yield();
ffffffffea8066fc:	97fffec9 	bl	ffffffffea806220 <thread_yield>
		arch_idle();
ffffffffea806700:	97fff140 	bl	ffffffffea802c00 <arch_idle>
ffffffffea806704:	97fff13f 	bl	ffffffffea802c00 <arch_idle>
ffffffffea806708:	17fffffe 	b	ffffffffea806700 <thread_become_idle+0x88>
ffffffffea80670c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806710 <thread_secondary_cpu_init_early>:
{
ffffffffea806710:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea806714:	910003fd 	mov	x29, sp
ffffffffea806718:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80671c:	52805b13 	mov	w19, #0x2d8                 	// #728
ffffffffea806720:	a9025bf5 	stp	x21, x22, [sp, #32]
	thread_t *t = &idle_threads[cpu];
ffffffffea806724:	b00002b5 	adrp	x21, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
{
ffffffffea806728:	a90363f7 	stp	x23, x24, [sp, #48]
	uint cpu = arch_curr_cpu_num();
ffffffffea80672c:	97fff111 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea806730:	2a0003f7 	mov	w23, w0
	snprintf(name, sizeof(name), "idle %d", cpu);
ffffffffea806734:	90000082 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea806738:	2a1703e3 	mov	w3, w23
ffffffffea80673c:	91070042 	add	x2, x2, #0x1c0
	thread_t *t = &idle_threads[cpu];
ffffffffea806740:	910542b8 	add	x24, x21, #0x150
	snprintf(name, sizeof(name), "idle %d", cpu);
ffffffffea806744:	910103a0 	add	x0, x29, #0x40
ffffffffea806748:	9bb37ef3 	umull	x19, w23, w19
ffffffffea80674c:	d2800201 	mov	x1, #0x10                  	// #16
ffffffffea806750:	940031f6 	bl	ffffffffea812f28 <snprintf>
	thread_t *t = &idle_threads[cpu];
ffffffffea806754:	8b180274 	add	x20, x19, x24
	init_thread_struct(t, name);
ffffffffea806758:	910103a1 	add	x1, x29, #0x40
ffffffffea80675c:	aa1403e0 	mov	x0, x20
ffffffffea806760:	97fffcc0 	bl	ffffffffea805a60 <init_thread_struct>
	t->pinned_cpu = cpu;
ffffffffea806764:	d2805b00 	mov	x0, #0x2d8                 	// #728
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea806768:	910a6261 	add	x1, x19, #0x298
ffffffffea80676c:	528d2e82 	mov	w2, #0x6974                	// #26996
ffffffffea806770:	8b180021 	add	x1, x1, x24
	t->pinned_cpu = cpu;
ffffffffea806774:	9b0062e0 	madd	x0, x23, x0, x24
	t->priority = HIGHEST_PRIORITY;
ffffffffea806778:	528003e5 	mov	w5, #0x1f                  	// #31
	t->state = THREAD_RUNNING;
ffffffffea80677c:	52800044 	mov	w4, #0x2                   	// #2
	t->flags = THREAD_FLAG_DETACHED | THREAD_FLAG_IDLE;
ffffffffea806780:	52800223 	mov	w3, #0x11                  	// #17
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea806784:	72aeec22 	movk	w2, #0x7761, lsl #16
	t->state = THREAD_RUNNING;
ffffffffea806788:	29051005 	stp	w5, w4, [x0, #40]
	t->curr_cpu = cpu;
ffffffffea80678c:	2906dc03 	stp	w3, w23, [x0, #52]
	t->pinned_cpu = cpu;
ffffffffea806790:	b9003c17 	str	w23, [x0, #60]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea806794:	b9029002 	str	w2, [x0, #656]
ffffffffea806798:	f9014c01 	str	x1, [x0, #664]
ffffffffea80679c:	f9015001 	str	x1, [x0, #672]
ffffffffea8067a0:	b902a81f 	str	wzr, [x0, #680]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8067a4:	d53b4220 	mrs	x0, daif
ffffffffea8067a8:	52800018 	mov	w24, #0x0                   	// #0
ffffffffea8067ac:	37380060 	tbnz	w0, #7, ffffffffea8067b8 <thread_secondary_cpu_init_early+0xa8>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8067b0:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8067b4:	52800038 	mov	w24, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea8067b8:	d00002b6 	adrp	x22, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8067bc:	912ea2d6 	add	x22, x22, #0xba8
ffffffffea8067c0:	aa1603e0 	mov	x0, x22
	list_add_head(&thread_list, &t->thread_list_node);
ffffffffea8067c4:	910542b5 	add	x21, x21, #0x150
ffffffffea8067c8:	97fff065 	bl	ffffffffea80295c <arch_spin_lock>
ffffffffea8067cc:	91002273 	add	x19, x19, #0x8
	item->next = list->next;
ffffffffea8067d0:	d2805b00 	mov	x0, #0x2d8                 	// #728
ffffffffea8067d4:	d00002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8067d8:	912e6021 	add	x1, x1, #0xb98
ffffffffea8067dc:	8b150273 	add	x19, x19, x21
ffffffffea8067e0:	9b0056e0 	madd	x0, x23, x0, x21
	cpu_priority[cpu] = t->priority;
ffffffffea8067e4:	b00002a2 	adrp	x2, ffffffffea85b000 <int_handler_table_shared+0x2ee0>
ffffffffea8067e8:	9104c042 	add	x2, x2, #0x130
ffffffffea8067ec:	f9400423 	ldr	x3, [x1, #8]
ffffffffea8067f0:	a9008c01 	stp	x1, x3, [x0, #8]
	list->next->prev = item;
ffffffffea8067f4:	f9000073 	str	x19, [x3]
	list->next = item;
ffffffffea8067f8:	f9000433 	str	x19, [x1, #8]
ffffffffea8067fc:	b9402800 	ldr	w0, [x0, #40]
ffffffffea806800:	b8377840 	str	w0, [x2, x23, lsl #2]
    ARM64_WRITE_SYSREG(tpidr_el1, (uint64_t)t);
ffffffffea806804:	d518d094 	msr	tpidr_el1, x20
ffffffffea806808:	d5033fdf 	isb
    arch_spin_unlock(lock);
ffffffffea80680c:	aa1603e0 	mov	x0, x22
ffffffffea806810:	97fff05b 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806814:	34000058 	cbz	w24, ffffffffea80681c <thread_secondary_cpu_init_early+0x10c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806818:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea80681c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806820:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806824:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806828:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80682c:	d65f03c0 	ret

ffffffffea806830 <thread_secondary_cpu_entry>:
{
ffffffffea806830:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea806834:	910003fd 	mov	x29, sp
ffffffffea806838:	f9000bf3 	str	x19, [sp, #16]
	uint cpu = arch_curr_cpu_num();
ffffffffea80683c:	97fff0cd 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea806840:	2a0003f3 	mov	w19, w0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806844:	d538d080 	mrs	x0, tpidr_el1
	t->priority = IDLE_PRIORITY;
ffffffffea806848:	b900281f 	str	wzr, [x0, #40]
	mp_set_curr_cpu_active(true);
ffffffffea80684c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea806850:	94000346 	bl	ffffffffea807568 <mp_set_curr_cpu_active>
ffffffffea806854:	f00002a0 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
ffffffffea806858:	91030000 	add	x0, x0, #0xc0
ffffffffea80685c:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea806860:	9ad32022 	lsl	x2, x1, x19
ffffffffea806864:	b9400401 	ldr	w1, [x0, #4]
ffffffffea806868:	2a020021 	orr	w1, w1, w2
ffffffffea80686c:	b9000401 	str	w1, [x0, #4]
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806870:	d50342ff 	msr	daifclr, #0x2
	thread_yield();
ffffffffea806874:	97fffe6b 	bl	ffffffffea806220 <thread_yield>
		arch_idle();
ffffffffea806878:	97fff0e2 	bl	ffffffffea802c00 <arch_idle>
ffffffffea80687c:	97fff0e1 	bl	ffffffffea802c00 <arch_idle>
ffffffffea806880:	17fffffe 	b	ffffffffea806878 <thread_secondary_cpu_entry+0x48>
ffffffffea806884:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806888 <wait_queue_block>:
 *
 * @return ERR_TIMED_OUT on timeout, else returns the return
 * value specified when the queue was woken by wait_queue_wake_one().
 */
status_t wait_queue_block(wait_queue_t *wait, lk_time_t timeout)
{
ffffffffea806888:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80688c:	910003fd 	mov	x29, sp
ffffffffea806890:	f9000bf3 	str	x19, [sp, #16]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806894:	d538d093 	mrs	x19, tpidr_el1
	ASSERT(current_thread->state == THREAD_RUNNING);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif

	if (timeout == 0)
ffffffffea806898:	340004a1 	cbz	w1, ffffffffea80692c <wait_queue_block+0xa4>
	item->prev = list->prev;
ffffffffea80689c:	aa0003e3 	mov	x3, x0
		return ERR_TIMED_OUT;

	list_add_tail(&wait->list, &current_thread->queue_node);
	wait->count++;
ffffffffea8068a0:	b9401802 	ldr	w2, [x0, #24]
	current_thread->state = THREAD_BLOCKED;
ffffffffea8068a4:	52800064 	mov	w4, #0x3                   	// #3
	wait->count++;
ffffffffea8068a8:	11000442 	add	w2, w2, #0x1
ffffffffea8068ac:	f8408c65 	ldr	x5, [x3, #8]!
ffffffffea8068b0:	f9000fb4 	str	x20, [x29, #24]
ffffffffea8068b4:	2a0103f4 	mov	w20, w1
	item->next = list;
ffffffffea8068b8:	a9018e65 	stp	x5, x3, [x19, #24]
	list_add_tail(&wait->list, &current_thread->queue_node);
ffffffffea8068bc:	91006261 	add	x1, x19, #0x18
	current_thread->blocking_wait_queue = wait;
	current_thread->wait_queue_block_ret = NO_ERROR;

	/* if the timeout is nonzero or noninfinite, set a callback to yank us out of the queue */
	if (timeout != INFINITE_TIME) {
ffffffffea8068c0:	3100069f 	cmn	w20, #0x1
	list->prev->next = item;
ffffffffea8068c4:	f9400403 	ldr	x3, [x0, #8]
ffffffffea8068c8:	f9000461 	str	x1, [x3, #8]
	list->prev = item;
ffffffffea8068cc:	f9000401 	str	x1, [x0, #8]
	wait->count++;
ffffffffea8068d0:	b9001802 	str	w2, [x0, #24]
	current_thread->state = THREAD_BLOCKED;
ffffffffea8068d4:	b9002e64 	str	w4, [x19, #44]
	current_thread->blocking_wait_queue = wait;
ffffffffea8068d8:	f9002260 	str	x0, [x19, #64]
	current_thread->wait_queue_block_ret = NO_ERROR;
ffffffffea8068dc:	b9004a7f 	str	wzr, [x19, #72]
	if (timeout != INFINITE_TIME) {
ffffffffea8068e0:	540000e1 	b.ne	ffffffffea8068fc <wait_queue_block+0x74>  // b.any
		timer_initialize(&timer);
		timer_set_oneshot(&timer, timeout, wait_queue_timeout_handler, (void *)current_thread);
	}

	thread_resched();
ffffffffea8068e4:	97fffd01 	bl	ffffffffea805ce8 <thread_resched>
	/* we don't really know if the timer fired or not, so it's better safe to try to cancel it */
	if (timeout != INFINITE_TIME) {
		timer_cancel(&timer);
	}

	return current_thread->wait_queue_block_ret;
ffffffffea8068e8:	b9404a60 	ldr	w0, [x19, #72]
ffffffffea8068ec:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea8068f0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8068f4:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8068f8:	d65f03c0 	ret
		timer_initialize(&timer);
ffffffffea8068fc:	910083a0 	add	x0, x29, #0x20
ffffffffea806900:	940002a6 	bl	ffffffffea807398 <timer_initialize>
		timer_set_oneshot(&timer, timeout, wait_queue_timeout_handler, (void *)current_thread);
ffffffffea806904:	910083a0 	add	x0, x29, #0x20
ffffffffea806908:	aa1303e3 	mov	x3, x19
ffffffffea80690c:	2a1403e1 	mov	w1, w20
ffffffffea806910:	b0000002 	adrp	x2, ffffffffea807000 <thread_unblock_from_wait_queue+0x50>
ffffffffea806914:	91016042 	add	x2, x2, #0x58
ffffffffea806918:	940002a8 	bl	ffffffffea8073b8 <timer_set_oneshot>
	thread_resched();
ffffffffea80691c:	97fffcf3 	bl	ffffffffea805ce8 <thread_resched>
		timer_cancel(&timer);
ffffffffea806920:	910083a0 	add	x0, x29, #0x20
ffffffffea806924:	940002b1 	bl	ffffffffea8073e8 <timer_cancel>
ffffffffea806928:	17fffff0 	b	ffffffffea8068e8 <wait_queue_block+0x60>
		return ERR_TIMED_OUT;
ffffffffea80692c:	12800180 	mov	w0, #0xfffffff3            	// #-13
ffffffffea806930:	17fffff0 	b	ffffffffea8068f0 <wait_queue_block+0x68>
ffffffffea806934:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806938 <thread_join>:
{
ffffffffea806938:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80693c:	910003fd 	mov	x29, sp
ffffffffea806940:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806944:	aa0003f3 	mov	x19, x0
ffffffffea806948:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80694c:	2a0203f4 	mov	w20, w2
ffffffffea806950:	aa0103f5 	mov	x21, x1
ffffffffea806954:	f9001bf7 	str	x23, [sp, #48]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806958:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80695c:	37380540 	tbnz	w0, #7, ffffffffea806a04 <thread_join+0xcc>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806960:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea806964:	d00002b6 	adrp	x22, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806968:	912ea2d7 	add	x23, x22, #0xba8
ffffffffea80696c:	aa1703e0 	mov	x0, x23
ffffffffea806970:	97ffeffb 	bl	ffffffffea80295c <arch_spin_lock>
	if (t->flags & THREAD_FLAG_DETACHED) {
ffffffffea806974:	b9403660 	ldr	w0, [x19, #52]
ffffffffea806978:	370006e0 	tbnz	w0, #0, ffffffffea806a54 <thread_join+0x11c>
	if (t->state != THREAD_DEATH) {
ffffffffea80697c:	b9402e60 	ldr	w0, [x19, #44]
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea806980:	52800037 	mov	w23, #0x1                   	// #1
ffffffffea806984:	7100141f 	cmp	w0, #0x5
ffffffffea806988:	54000521 	b.ne	ffffffffea806a2c <thread_join+0xf4>  // b.any
ffffffffea80698c:	d503201f 	nop
	if (retcode)
ffffffffea806990:	b4000075 	cbz	x21, ffffffffea80699c <thread_join+0x64>
		*retcode = t->retcode;
ffffffffea806994:	b9428a60 	ldr	w0, [x19, #648]
ffffffffea806998:	b90002a0 	str	w0, [x21]
	item->next->prev = item->prev;
ffffffffea80699c:	a9408662 	ldp	x2, x1, [x19, #8]
    arch_spin_unlock(lock);
ffffffffea8069a0:	912ea2c0 	add	x0, x22, #0xba8
ffffffffea8069a4:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea8069a8:	f9400662 	ldr	x2, [x19, #8]
ffffffffea8069ac:	f9000441 	str	x1, [x2, #8]
	t->magic = 0;
ffffffffea8069b0:	b900027f 	str	wzr, [x19]
	item->prev = item->next = 0;
ffffffffea8069b4:	a900fe7f 	stp	xzr, xzr, [x19, #8]
ffffffffea8069b8:	97ffeff1 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8069bc:	34000057 	cbz	w23, ffffffffea8069c4 <thread_join+0x8c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8069c0:	d50342ff 	msr	daifclr, #0x2
	if (t->flags & THREAD_FLAG_FREE_STACK && t->stack)
ffffffffea8069c4:	b9403661 	ldr	w1, [x19, #52]
ffffffffea8069c8:	360800a1 	tbz	w1, #1, ffffffffea8069dc <thread_join+0xa4>
ffffffffea8069cc:	f9413660 	ldr	x0, [x19, #616]
ffffffffea8069d0:	b4000060 	cbz	x0, ffffffffea8069dc <thread_join+0xa4>
		free(t->stack);
ffffffffea8069d4:	940031b1 	bl	ffffffffea813098 <free>
ffffffffea8069d8:	b9403661 	ldr	w1, [x19, #52]
	return NO_ERROR;
ffffffffea8069dc:	52800014 	mov	w20, #0x0                   	// #0
	if (t->flags & THREAD_FLAG_FREE_STRUCT)
ffffffffea8069e0:	36100061 	tbz	w1, #2, ffffffffea8069ec <thread_join+0xb4>
		free(t);
ffffffffea8069e4:	aa1303e0 	mov	x0, x19
ffffffffea8069e8:	940031ac 	bl	ffffffffea813098 <free>
}
ffffffffea8069ec:	2a1403e0 	mov	w0, w20
ffffffffea8069f0:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea8069f4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8069f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8069fc:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea806a00:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea806a04:	d00002b6 	adrp	x22, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806a08:	912ea2d7 	add	x23, x22, #0xba8
ffffffffea806a0c:	aa1703e0 	mov	x0, x23
ffffffffea806a10:	97ffefd3 	bl	ffffffffea80295c <arch_spin_lock>
	if (t->flags & THREAD_FLAG_DETACHED) {
ffffffffea806a14:	b9403660 	ldr	w0, [x19, #52]
ffffffffea806a18:	37000280 	tbnz	w0, #0, ffffffffea806a68 <thread_join+0x130>
	if (t->state != THREAD_DEATH) {
ffffffffea806a1c:	b9402e60 	ldr	w0, [x19, #44]
    spin_lock_saved_state_t state = 0;
ffffffffea806a20:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea806a24:	7100141f 	cmp	w0, #0x5
ffffffffea806a28:	54fffb40 	b.eq	ffffffffea806990 <thread_join+0x58>  // b.none
		status_t err = wait_queue_block(&t->retcode_wait_queue, timeout);
ffffffffea806a2c:	2a1403e1 	mov	w1, w20
ffffffffea806a30:	910a4260 	add	x0, x19, #0x290
ffffffffea806a34:	97ffff95 	bl	ffffffffea806888 <wait_queue_block>
ffffffffea806a38:	2a0003f4 	mov	w20, w0
		if (err < 0) {
ffffffffea806a3c:	36fffaa0 	tbz	w0, #31, ffffffffea806990 <thread_join+0x58>
    arch_spin_unlock(lock);
ffffffffea806a40:	912ea2c0 	add	x0, x22, #0xba8
ffffffffea806a44:	97ffefce 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806a48:	34fffd37 	cbz	w23, ffffffffea8069ec <thread_join+0xb4>
ffffffffea806a4c:	d50342ff 	msr	daifclr, #0x2
ffffffffea806a50:	17ffffe7 	b	ffffffffea8069ec <thread_join+0xb4>
ffffffffea806a54:	aa1703e0 	mov	x0, x23
ffffffffea806a58:	97ffefc9 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea806a5c:	d50342ff 	msr	daifclr, #0x2
		return ERR_THREAD_DETACHED;
ffffffffea806a60:	12800434 	mov	w20, #0xffffffde            	// #-34
ffffffffea806a64:	17ffffe2 	b	ffffffffea8069ec <thread_join+0xb4>
ffffffffea806a68:	aa1703e0 	mov	x0, x23
ffffffffea806a6c:	12800434 	mov	w20, #0xffffffde            	// #-34
ffffffffea806a70:	97ffefc3 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea806a74:	17ffffde 	b	ffffffffea8069ec <thread_join+0xb4>

ffffffffea806a78 <wait_queue_wake_one>:
 * from wait_queue_block().
 *
 * @return  The number of threads woken (zero or one)
 */
int wait_queue_wake_one(wait_queue_t *wait, bool reschedule, status_t wait_queue_error)
{
ffffffffea806a78:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea806a7c:	910003fd 	mov	x29, sp
ffffffffea806a80:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806a84:	12001c34 	and	w20, w1, #0xff
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806a88:	d538d086 	mrs	x6, tpidr_el1
	if (list->next != list) {
ffffffffea806a8c:	f9400801 	ldr	x1, [x0, #16]
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif

	t = list_remove_head_type(&wait->list, thread_t, queue_node);
ffffffffea806a90:	91002003 	add	x3, x0, #0x8
ffffffffea806a94:	eb03003f 	cmp	x1, x3
ffffffffea806a98:	54000780 	b.eq	ffffffffea806b88 <wait_queue_wake_one+0x110>  // b.none
	item->next->prev = item->prev;
ffffffffea806a9c:	a9401025 	ldp	x5, x4, [x1]
	item->prev = item->next = 0;
ffffffffea806aa0:	aa0103e3 	mov	x3, x1
	if (t) {
ffffffffea806aa4:	f100603f 	cmp	x1, #0x18
	item->next->prev = item->prev;
ffffffffea806aa8:	f9000085 	str	x5, [x4]
	item->prev->next = item->next;
ffffffffea806aac:	f9400025 	ldr	x5, [x1]
ffffffffea806ab0:	f90004a4 	str	x4, [x5, #8]
	item->prev = item->next = 0;
ffffffffea806ab4:	f900043f 	str	xzr, [x1, #8]
ffffffffea806ab8:	f81e847f 	str	xzr, [x3], #-24
ffffffffea806abc:	54000660 	b.eq	ffffffffea806b88 <wait_queue_wake_one+0x110>  // b.none
		wait->count--;
ffffffffea806ac0:	b9401804 	ldr	w4, [x0, #24]
#if THREAD_CHECKS
		ASSERT(t->state == THREAD_BLOCKED);
#endif
		t->state = THREAD_READY;
ffffffffea806ac4:	52800025 	mov	w5, #0x1                   	// #1
ffffffffea806ac8:	d00002a8 	adrp	x8, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806acc:	d00002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
		wait->count--;
ffffffffea806ad0:	51000484 	sub	w4, w4, #0x1
ffffffffea806ad4:	b9001804 	str	w4, [x0, #24]
		t->state = THREAD_READY;
ffffffffea806ad8:	b9002c65 	str	w5, [x3, #44]
		t->wait_queue_block_ret = wait_queue_error;
		t->blocking_wait_queue = NULL;
ffffffffea806adc:	f900207f 	str	xzr, [x3, #64]
		t->wait_queue_block_ret = wait_queue_error;
ffffffffea806ae0:	b9004862 	str	w2, [x3, #72]
ffffffffea806ae4:	b94b9109 	ldr	w9, [x8, #2960]

		/* if we're instructed to reschedule, stick the current thread on the head
		 * of the run queue first, so that the newly awakened thread gets a chance to run
		 * before the current one, but the current one doesn't get unnecessarilly punished.
		 */
		if (reschedule) {
ffffffffea806ae8:	340001b4 	cbz	w20, ffffffffea806b1c <wait_queue_wake_one+0xa4>
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806aec:	b94028c4 	ldr	w4, [x6, #40]
	item->next = list->next;
ffffffffea806af0:	91264020 	add	x0, x1, #0x990
			current_thread->state = THREAD_READY;
ffffffffea806af4:	b9002cc5 	str	w5, [x6, #44]
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806af8:	910060c2 	add	x2, x6, #0x18
ffffffffea806afc:	8b24d000 	add	x0, x0, w4, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806b00:	1ac420a5 	lsl	w5, w5, w4
ffffffffea806b04:	2a050129 	orr	w9, w9, w5
ffffffffea806b08:	f9400404 	ldr	x4, [x0, #8]
ffffffffea806b0c:	a90190c0 	stp	x0, x4, [x6, #24]
	list->next->prev = item;
ffffffffea806b10:	f9400404 	ldr	x4, [x0, #8]
ffffffffea806b14:	f9000082 	str	x2, [x4]
	list->next = item;
ffffffffea806b18:	f9000402 	str	x2, [x0, #8]
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806b1c:	b9402864 	ldr	w4, [x3, #40]
	item->next = list->next;
ffffffffea806b20:	91264022 	add	x2, x1, #0x990
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806b24:	52800025 	mov	w5, #0x1                   	// #1
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806b28:	91006067 	add	x7, x3, #0x18
			insert_in_run_queue_head(current_thread);
		}
		insert_in_run_queue_head(t);
		thread_mp_reschedule(current_thread, t);
ffffffffea806b2c:	aa0303e1 	mov	x1, x3
ffffffffea806b30:	aa0603e0 	mov	x0, x6
ffffffffea806b34:	8b24d042 	add	x2, x2, w4, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806b38:	1ac420a4 	lsl	w4, w5, w4
ffffffffea806b3c:	2a090084 	orr	w4, w4, w9
ffffffffea806b40:	b90b9104 	str	w4, [x8, #2960]
		if (reschedule) {
			thread_resched();
		}
		ret = 1;
ffffffffea806b44:	2a0503f3 	mov	w19, w5
ffffffffea806b48:	f9400444 	ldr	x4, [x2, #8]
ffffffffea806b4c:	a9019062 	stp	x2, x4, [x3, #24]
	list->next->prev = item;
ffffffffea806b50:	f9400443 	ldr	x3, [x2, #8]
ffffffffea806b54:	f9000067 	str	x7, [x3]
	list->next = item;
ffffffffea806b58:	f9000447 	str	x7, [x2, #8]
		thread_mp_reschedule(current_thread, t);
ffffffffea806b5c:	97fffc33 	bl	ffffffffea805c28 <thread_mp_reschedule>
		if (reschedule) {
ffffffffea806b60:	350000b4 	cbnz	w20, ffffffffea806b74 <wait_queue_wake_one+0xfc>

	}

	return ret;
}
ffffffffea806b64:	2a1303e0 	mov	w0, w19
ffffffffea806b68:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806b6c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806b70:	d65f03c0 	ret
			thread_resched();
ffffffffea806b74:	97fffc5d 	bl	ffffffffea805ce8 <thread_resched>
}
ffffffffea806b78:	2a1303e0 	mov	w0, w19
ffffffffea806b7c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806b80:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806b84:	d65f03c0 	ret
	int ret = 0;
ffffffffea806b88:	52800013 	mov	w19, #0x0                   	// #0
}
ffffffffea806b8c:	2a1303e0 	mov	w0, w19
ffffffffea806b90:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806b94:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806b98:	d65f03c0 	ret
ffffffffea806b9c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806ba0 <wait_queue_wake_all>:
 * from wait_queue_block().
 *
 * @return  The number of threads woken (zero or one)
 */
int wait_queue_wake_all(wait_queue_t *wait, bool reschedule, status_t wait_queue_error)
{
ffffffffea806ba0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea806ba4:	910003fd 	mov	x29, sp
ffffffffea806ba8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806bac:	f90013f5 	str	x21, [sp, #32]
ffffffffea806bb0:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea806bb4:	12001c38 	and	w24, w1, #0xff
ffffffffea806bb8:	f90027fa 	str	x26, [sp, #72]
ffffffffea806bbc:	d538d095 	mrs	x21, tpidr_el1
ffffffffea806bc0:	91002017 	add	x23, x0, #0x8
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif

	if (reschedule && wait->count > 0) {
ffffffffea806bc4:	340002b8 	cbz	w24, ffffffffea806c18 <wait_queue_wake_all+0x78>
ffffffffea806bc8:	b9401801 	ldr	w1, [x0, #24]
ffffffffea806bcc:	7100003f 	cmp	w1, #0x0
ffffffffea806bd0:	54000bcd 	b.le	ffffffffea806d48 <wait_queue_wake_all+0x1a8>
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806bd4:	b9402aa4 	ldr	w4, [x21, #40]
	item->next = list->next;
ffffffffea806bd8:	d00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806bdc:	91264294 	add	x20, x20, #0x990
		/* if we're instructed to reschedule, stick the current thread on the head
		 * of the run queue first, so that the newly awakened threads get a chance to run
		 * before the current one, but the current one doesn't get unnecessarilly punished.
		 */
		current_thread->state = THREAD_READY;
ffffffffea806be0:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea806be4:	b9002ea1 	str	w1, [x21, #44]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806be8:	d00002ba 	adrp	x26, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806bec:	8b24d294 	add	x20, x20, w4, sxtw #4
ffffffffea806bf0:	1ac42021 	lsl	w1, w1, w4
ffffffffea806bf4:	b94b9345 	ldr	w5, [x26, #2960]
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806bf8:	910062a3 	add	x3, x21, #0x18
ffffffffea806bfc:	f9400684 	ldr	x4, [x20, #8]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806c00:	2a050021 	orr	w1, w1, w5
ffffffffea806c04:	a90192b4 	stp	x20, x4, [x21, #24]
ffffffffea806c08:	b90b9341 	str	w1, [x26, #2960]
	list->next->prev = item;
ffffffffea806c0c:	f9400684 	ldr	x4, [x20, #8]
ffffffffea806c10:	f9000083 	str	x3, [x4]
	list->next = item;
ffffffffea806c14:	f9000683 	str	x3, [x20, #8]
	if (list->next != list) {
ffffffffea806c18:	f9400803 	ldr	x3, [x0, #16]
ffffffffea806c1c:	eb0302ff 	cmp	x23, x3
ffffffffea806c20:	540009a0 	b.eq	ffffffffea806d54 <wait_queue_wake_all+0x1b4>  // b.none
	item->next->prev = item->prev;
ffffffffea806c24:	a9401065 	ldp	x5, x4, [x3]
	item->prev = item->next = 0;
ffffffffea806c28:	aa0303e1 	mov	x1, x3
		insert_in_run_queue_head(current_thread);
	}

	/* pop all the threads off the wait queue into the run queue */
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
ffffffffea806c2c:	f100607f 	cmp	x3, #0x18
	item->next->prev = item->prev;
ffffffffea806c30:	f9000085 	str	x5, [x4]
	item->prev->next = item->next;
ffffffffea806c34:	f9400065 	ldr	x5, [x3]
ffffffffea806c38:	f90004a4 	str	x4, [x5, #8]
	item->prev = item->next = 0;
ffffffffea806c3c:	f900047f 	str	xzr, [x3, #8]
ffffffffea806c40:	f81e843f 	str	xzr, [x1], #-24
ffffffffea806c44:	54000880 	b.eq	ffffffffea806d54 <wait_queue_wake_all+0x1b4>  // b.none
ffffffffea806c48:	d00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806c4c:	d00002ba 	adrp	x26, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806c50:	f90017b6 	str	x22, [x29, #40]
ffffffffea806c54:	9100f2b5 	add	x21, x21, #0x3c
ffffffffea806c58:	f90023b9 	str	x25, [x29, #64]
	item->next = list->next;
ffffffffea806c5c:	91264294 	add	x20, x20, #0x990
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806c60:	912e435a 	add	x26, x26, #0xb90
ffffffffea806c64:	2a0203f6 	mov	w22, w2
ffffffffea806c68:	aa0003f9 	mov	x25, x0
ffffffffea806c6c:	a90573bb 	stp	x27, x28, [x29, #80]
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
ffffffffea806c70:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea806c74:	5280001b 	mov	w27, #0x0                   	// #0
		wait->count--;
#if THREAD_CHECKS
		ASSERT(t->state == THREAD_BLOCKED);
#endif
		t->state = THREAD_READY;
ffffffffea806c78:	5280003c 	mov	w28, #0x1                   	// #1
ffffffffea806c7c:	d503201f 	nop
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806c80:	b9402823 	ldr	w3, [x1, #40]
ffffffffea806c84:	91006025 	add	x5, x1, #0x18
		wait->count--;
ffffffffea806c88:	b9401b22 	ldr	w2, [x25, #24]
		t->wait_queue_block_ret = wait_queue_error;
		t->blocking_wait_queue = NULL;

		insert_in_run_queue_head(t);
		mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
		ret++;
ffffffffea806c8c:	11000673 	add	w19, w19, #0x1
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806c90:	b9400340 	ldr	w0, [x26]
ffffffffea806c94:	8b23d284 	add	x4, x20, w3, sxtw #4
		wait->count--;
ffffffffea806c98:	51000442 	sub	w2, w2, #0x1
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806c9c:	1ac32383 	lsl	w3, w28, w3
ffffffffea806ca0:	2a000063 	orr	w3, w3, w0
ffffffffea806ca4:	b9000343 	str	w3, [x26]
		mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
ffffffffea806ca8:	aa1503e0 	mov	x0, x21
ffffffffea806cac:	f9400486 	ldr	x6, [x4, #8]
		wait->count--;
ffffffffea806cb0:	b9001b22 	str	w2, [x25, #24]
		mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
ffffffffea806cb4:	9100f022 	add	x2, x1, #0x3c
ffffffffea806cb8:	a9019824 	stp	x4, x6, [x1, #24]
ffffffffea806cbc:	9100a021 	add	x1, x1, #0x28
		t->state = THREAD_READY;
ffffffffea806cc0:	b900043c 	str	w28, [x1, #4]
	list->next->prev = item;
ffffffffea806cc4:	f9400483 	ldr	x3, [x4, #8]
		t->blocking_wait_queue = NULL;
ffffffffea806cc8:	f9000c3f 	str	xzr, [x1, #24]
		t->wait_queue_block_ret = wait_queue_error;
ffffffffea806ccc:	b9002036 	str	w22, [x1, #32]
ffffffffea806cd0:	f9000065 	str	x5, [x3]
	list->next = item;
ffffffffea806cd4:	f9000485 	str	x5, [x4, #8]
		mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
ffffffffea806cd8:	97fffbb0 	bl	ffffffffea805b98 <thread_get_mp_reschedule_target.isra.5>
ffffffffea806cdc:	2a00037b 	orr	w27, w27, w0
	if (list->next != list) {
ffffffffea806ce0:	f9400b23 	ldr	x3, [x25, #16]
	item->prev = item->next = 0;
ffffffffea806ce4:	aa0303e1 	mov	x1, x3
	if (list->next != list) {
ffffffffea806ce8:	eb17007f 	cmp	x3, x23
ffffffffea806cec:	54000120 	b.eq	ffffffffea806d10 <wait_queue_wake_all+0x170>  // b.none
	item->next->prev = item->prev;
ffffffffea806cf0:	a9400062 	ldp	x2, x0, [x3]
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
ffffffffea806cf4:	f100607f 	cmp	x3, #0x18
ffffffffea806cf8:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea806cfc:	f9400062 	ldr	x2, [x3]
ffffffffea806d00:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea806d04:	f900047f 	str	xzr, [x3, #8]
ffffffffea806d08:	f81e843f 	str	xzr, [x1], #-24
ffffffffea806d0c:	54fffba1 	b.ne	ffffffffea806c80 <wait_queue_wake_all+0xe0>  // b.any
#if THREAD_CHECKS
	ASSERT(wait->count == 0);
#endif

	if (ret > 0) {
		mp_reschedule(mp_reschedule_target, 0);
ffffffffea806d10:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea806d14:	2a1b03e0 	mov	w0, w27
ffffffffea806d18:	94000200 	bl	ffffffffea807518 <mp_reschedule>
		if (reschedule) {
ffffffffea806d1c:	350002d8 	cbnz	w24, ffffffffea806d74 <wait_queue_wake_all+0x1d4>
			thread_resched();
		}
	}

	return ret;
}
ffffffffea806d20:	2a1303e0 	mov	w0, w19
ffffffffea806d24:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea806d28:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea806d2c:	a94573bb 	ldp	x27, x28, [x29, #80]
ffffffffea806d30:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806d34:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806d38:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806d3c:	f94027fa 	ldr	x26, [sp, #72]
ffffffffea806d40:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806d44:	d65f03c0 	ret
	if (list->next != list) {
ffffffffea806d48:	f9400803 	ldr	x3, [x0, #16]
ffffffffea806d4c:	eb17007f 	cmp	x3, x23
ffffffffea806d50:	54fff6a1 	b.ne	ffffffffea806c24 <wait_queue_wake_all+0x84>  // b.any
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
ffffffffea806d54:	52800013 	mov	w19, #0x0                   	// #0
}
ffffffffea806d58:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806d5c:	2a1303e0 	mov	w0, w19
ffffffffea806d60:	f94027fa 	ldr	x26, [sp, #72]
ffffffffea806d64:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806d68:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806d6c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806d70:	d65f03c0 	ret
			thread_resched();
ffffffffea806d74:	97fffbdd 	bl	ffffffffea805ce8 <thread_resched>
	return ret;
ffffffffea806d78:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea806d7c:	2a1303e0 	mov	w0, w19
	return ret;
ffffffffea806d80:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea806d84:	a94573bb 	ldp	x27, x28, [x29, #80]
}
ffffffffea806d88:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806d8c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806d90:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806d94:	f94027fa 	ldr	x26, [sp, #72]
ffffffffea806d98:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806d9c:	d65f03c0 	ret

ffffffffea806da0 <thread_detach>:
{
ffffffffea806da0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea806da4:	910003fd 	mov	x29, sp
ffffffffea806da8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806dac:	aa0003f3 	mov	x19, x0
ffffffffea806db0:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806db4:	d53b4220 	mrs	x0, daif
ffffffffea806db8:	910a4275 	add	x21, x19, #0x290
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea806dbc:	37380340 	tbnz	w0, #7, ffffffffea806e24 <thread_detach+0x84>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806dc0:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea806dc4:	d00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806dc8:	912ea294 	add	x20, x20, #0xba8
ffffffffea806dcc:	aa1403e0 	mov	x0, x20
ffffffffea806dd0:	97ffeee3 	bl	ffffffffea80295c <arch_spin_lock>
	wait_queue_wake_all(&t->retcode_wait_queue, false, ERR_THREAD_DETACHED);
ffffffffea806dd4:	12800422 	mov	w2, #0xffffffde            	// #-34
ffffffffea806dd8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea806ddc:	aa1503e0 	mov	x0, x21
ffffffffea806de0:	97ffff70 	bl	ffffffffea806ba0 <wait_queue_wake_all>
	if (t->state == THREAD_DEATH) {
ffffffffea806de4:	b9402e60 	ldr	w0, [x19, #44]
ffffffffea806de8:	7100141f 	cmp	w0, #0x5
ffffffffea806dec:	54000461 	b.ne	ffffffffea806e78 <thread_detach+0xd8>  // b.any
		t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
ffffffffea806df0:	b9403661 	ldr	w1, [x19, #52]
    arch_spin_unlock(lock);
ffffffffea806df4:	aa1403e0 	mov	x0, x20
ffffffffea806df8:	121f7821 	and	w1, w1, #0xfffffffe
ffffffffea806dfc:	b9003661 	str	w1, [x19, #52]
ffffffffea806e00:	97ffeedf 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806e04:	d50342ff 	msr	daifclr, #0x2
		return thread_join(t, NULL, 0);
ffffffffea806e08:	aa1303e0 	mov	x0, x19
}
ffffffffea806e0c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806e10:	a94153f3 	ldp	x19, x20, [sp, #16]
		return thread_join(t, NULL, 0);
ffffffffea806e14:	52800002 	mov	w2, #0x0                   	// #0
}
ffffffffea806e18:	a8c37bfd 	ldp	x29, x30, [sp], #48
		return thread_join(t, NULL, 0);
ffffffffea806e1c:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea806e20:	17fffec6 	b	ffffffffea806938 <thread_join>
    arch_spin_lock(lock);
ffffffffea806e24:	d00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806e28:	912ea294 	add	x20, x20, #0xba8
ffffffffea806e2c:	aa1403e0 	mov	x0, x20
ffffffffea806e30:	97ffeecb 	bl	ffffffffea80295c <arch_spin_lock>
	wait_queue_wake_all(&t->retcode_wait_queue, false, ERR_THREAD_DETACHED);
ffffffffea806e34:	12800422 	mov	w2, #0xffffffde            	// #-34
ffffffffea806e38:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea806e3c:	aa1503e0 	mov	x0, x21
ffffffffea806e40:	97ffff58 	bl	ffffffffea806ba0 <wait_queue_wake_all>
	if (t->state == THREAD_DEATH) {
ffffffffea806e44:	b9402e60 	ldr	w0, [x19, #44]
ffffffffea806e48:	7100141f 	cmp	w0, #0x5
ffffffffea806e4c:	540002c0 	b.eq	ffffffffea806ea4 <thread_detach+0x104>  // b.none
		t->flags |= THREAD_FLAG_DETACHED;
ffffffffea806e50:	b9403661 	ldr	w1, [x19, #52]
    arch_spin_unlock(lock);
ffffffffea806e54:	aa1403e0 	mov	x0, x20
ffffffffea806e58:	32000021 	orr	w1, w1, #0x1
ffffffffea806e5c:	b9003661 	str	w1, [x19, #52]
ffffffffea806e60:	97ffeec7 	bl	ffffffffea80297c <arch_spin_unlock>
}
ffffffffea806e64:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806e68:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea806e6c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806e70:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806e74:	d65f03c0 	ret
		t->flags |= THREAD_FLAG_DETACHED;
ffffffffea806e78:	b9403661 	ldr	w1, [x19, #52]
ffffffffea806e7c:	aa1403e0 	mov	x0, x20
ffffffffea806e80:	32000021 	orr	w1, w1, #0x1
ffffffffea806e84:	b9003661 	str	w1, [x19, #52]
ffffffffea806e88:	97ffeebd 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea806e8c:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea806e90:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea806e94:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806e98:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806e9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806ea0:	d65f03c0 	ret
		t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
ffffffffea806ea4:	b9403661 	ldr	w1, [x19, #52]
ffffffffea806ea8:	aa1403e0 	mov	x0, x20
ffffffffea806eac:	121f7821 	and	w1, w1, #0xfffffffe
ffffffffea806eb0:	b9003661 	str	w1, [x19, #52]
ffffffffea806eb4:	97ffeeb2 	bl	ffffffffea80297c <arch_spin_unlock>
}
ffffffffea806eb8:	f94013f5 	ldr	x21, [sp, #32]
		return thread_join(t, NULL, 0);
ffffffffea806ebc:	aa1303e0 	mov	x0, x19
ffffffffea806ec0:	52800002 	mov	w2, #0x0                   	// #0
}
ffffffffea806ec4:	a94153f3 	ldp	x19, x20, [sp, #16]
		return thread_join(t, NULL, 0);
ffffffffea806ec8:	d2800001 	mov	x1, #0x0                   	// #0
}
ffffffffea806ecc:	a8c37bfd 	ldp	x29, x30, [sp], #48
		return thread_join(t, NULL, 0);
ffffffffea806ed0:	17fffe9a 	b	ffffffffea806938 <thread_join>
ffffffffea806ed4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806ed8 <thread_exit>:
{
ffffffffea806ed8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea806edc:	910003fd 	mov	x29, sp
ffffffffea806ee0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806ee4:	aa1e03f4 	mov	x20, x30
ffffffffea806ee8:	f90013f5 	str	x21, [sp, #32]
ffffffffea806eec:	2a0003f5 	mov	w21, w0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806ef0:	d538d093 	mrs	x19, tpidr_el1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806ef4:	d53b4220 	mrs	x0, daif
ffffffffea806ef8:	37380040 	tbnz	w0, #7, ffffffffea806f00 <thread_exit+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806efc:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea806f00:	d00002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806f04:	912ea000 	add	x0, x0, #0xba8
ffffffffea806f08:	97ffee95 	bl	ffffffffea80295c <arch_spin_lock>
	current_thread->retcode = retcode;
ffffffffea806f0c:	b9028a75 	str	w21, [x19, #648]
	if (current_thread->flags & THREAD_FLAG_DETACHED) {
ffffffffea806f10:	b9403661 	ldr	w1, [x19, #52]
	current_thread->state = THREAD_DEATH;
ffffffffea806f14:	528000a0 	mov	w0, #0x5                   	// #5
ffffffffea806f18:	b9002e60 	str	w0, [x19, #44]
	if (current_thread->flags & THREAD_FLAG_DETACHED) {
ffffffffea806f1c:	360002a1 	tbz	w1, #0, ffffffffea806f70 <thread_exit+0x98>
	item->next->prev = item->prev;
ffffffffea806f20:	a9408262 	ldp	x2, x0, [x19, #8]
ffffffffea806f24:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea806f28:	f9400662 	ldr	x2, [x19, #8]
ffffffffea806f2c:	f9000440 	str	x0, [x2, #8]
		current_thread->magic = 0;
ffffffffea806f30:	b900027f 	str	wzr, [x19]
	item->prev = item->next = 0;
ffffffffea806f34:	a900fe7f 	stp	xzr, xzr, [x19, #8]
		if (current_thread->flags & THREAD_FLAG_FREE_STACK && current_thread->stack)
ffffffffea806f38:	360800a1 	tbz	w1, #1, ffffffffea806f4c <thread_exit+0x74>
ffffffffea806f3c:	f9413660 	ldr	x0, [x19, #616]
ffffffffea806f40:	b4000060 	cbz	x0, ffffffffea806f4c <thread_exit+0x74>
			heap_delayed_free(current_thread->stack);
ffffffffea806f44:	94002c47 	bl	ffffffffea812060 <heap_delayed_free>
ffffffffea806f48:	b9403661 	ldr	w1, [x19, #52]
		if (current_thread->flags & THREAD_FLAG_FREE_STRUCT)
ffffffffea806f4c:	371000c1 	tbnz	w1, #2, ffffffffea806f64 <thread_exit+0x8c>
	thread_resched();
ffffffffea806f50:	97fffb66 	bl	ffffffffea805ce8 <thread_resched>
	panic("somehow fell through thread_exit()\n");
ffffffffea806f54:	90000081 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea806f58:	aa1403e0 	mov	x0, x20
ffffffffea806f5c:	91072021 	add	x1, x1, #0x1c8
ffffffffea806f60:	94002aaa 	bl	ffffffffea811a08 <_panic>
			heap_delayed_free(current_thread);
ffffffffea806f64:	aa1303e0 	mov	x0, x19
ffffffffea806f68:	94002c3e 	bl	ffffffffea812060 <heap_delayed_free>
ffffffffea806f6c:	17fffff9 	b	ffffffffea806f50 <thread_exit+0x78>
		wait_queue_wake_all(&current_thread->retcode_wait_queue, false, 0);
ffffffffea806f70:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea806f74:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea806f78:	910a4260 	add	x0, x19, #0x290
ffffffffea806f7c:	97ffff09 	bl	ffffffffea806ba0 <wait_queue_wake_all>
ffffffffea806f80:	17fffff4 	b	ffffffffea806f50 <thread_exit+0x78>
ffffffffea806f84:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806f88 <wait_queue_destroy>:
 * @brief  Free all resources allocated in wait_queue_init()
 *
 * If any threads were waiting on this queue, they are all woken.
 */
void wait_queue_destroy(wait_queue_t *wait, bool reschedule)
{
ffffffffea806f88:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
#if THREAD_CHECKS
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif
	wait_queue_wake_all(wait, reschedule, ERR_OBJECT_DESTROYED);
ffffffffea806f8c:	12800142 	mov	w2, #0xfffffff5            	// #-11
{
ffffffffea806f90:	910003fd 	mov	x29, sp
ffffffffea806f94:	f9000bf3 	str	x19, [sp, #16]
ffffffffea806f98:	aa0003f3 	mov	x19, x0
	wait_queue_wake_all(wait, reschedule, ERR_OBJECT_DESTROYED);
ffffffffea806f9c:	97ffff01 	bl	ffffffffea806ba0 <wait_queue_wake_all>
	wait->magic = 0;
ffffffffea806fa0:	b900027f 	str	wzr, [x19]
}
ffffffffea806fa4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea806fa8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806fac:	d65f03c0 	ret

ffffffffea806fb0 <thread_unblock_from_wait_queue>:
	ASSERT(t->magic == THREAD_MAGIC);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif

	if (t->state != THREAD_BLOCKED)
ffffffffea806fb0:	b9402c02 	ldr	w2, [x0, #44]
ffffffffea806fb4:	71000c5f 	cmp	w2, #0x3
ffffffffea806fb8:	540004c1 	b.ne	ffffffffea807050 <thread_unblock_from_wait_queue+0xa0>  // b.any
ffffffffea806fbc:	2a0103e3 	mov	w3, w1
ffffffffea806fc0:	aa0003e1 	mov	x1, x0
{
ffffffffea806fc4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806fc8:	d00002a8 	adrp	x8, ffffffffea85c000 <idle_threads+0xeb0>
	item->next = list->next;
ffffffffea806fcc:	d00002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea806fd0:	91264000 	add	x0, x0, #0x990
{
ffffffffea806fd4:	910003fd 	mov	x29, sp
	item->next->prev = item->prev;
ffffffffea806fd8:	a941a424 	ldp	x4, x9, [x1, #24]
#endif

	list_delete(&t->queue_node);
	t->blocking_wait_queue->count--;
	t->blocking_wait_queue = NULL;
	t->state = THREAD_READY;
ffffffffea806fdc:	52800026 	mov	w6, #0x1                   	// #1
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806fe0:	b9402822 	ldr	w2, [x1, #40]
	list_delete(&t->queue_node);
ffffffffea806fe4:	91006025 	add	x5, x1, #0x18
	t->blocking_wait_queue->count--;
ffffffffea806fe8:	f9402027 	ldr	x7, [x1, #64]
ffffffffea806fec:	f9000124 	str	x4, [x9]
	item->next = list->next;
ffffffffea806ff0:	8b22d000 	add	x0, x0, w2, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806ff4:	b94b910a 	ldr	w10, [x8, #2960]
	item->prev->next = item->next;
ffffffffea806ff8:	f9400c2b 	ldr	x11, [x1, #24]
ffffffffea806ffc:	1ac220c2 	lsl	w2, w6, w2
	t->blocking_wait_queue->count--;
ffffffffea807000:	b94018e4 	ldr	w4, [x7, #24]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea807004:	2a0a0042 	orr	w2, w2, w10
ffffffffea807008:	b90b9102 	str	w2, [x8, #2960]
ffffffffea80700c:	f9000569 	str	x9, [x11, #8]
	t->blocking_wait_queue->count--;
ffffffffea807010:	51000484 	sub	w4, w4, #0x1
	item->prev = item->next = 0;
ffffffffea807014:	f900103f 	str	xzr, [x1, #32]
	item->next = list->next;
ffffffffea807018:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80701c:	b90018e4 	str	w4, [x7, #24]
ffffffffea807020:	a9018820 	stp	x0, x2, [x1, #24]
	t->state = THREAD_READY;
ffffffffea807024:	b9002c26 	str	w6, [x1, #44]
	list->next->prev = item;
ffffffffea807028:	f9400402 	ldr	x2, [x0, #8]
	t->blocking_wait_queue = NULL;
ffffffffea80702c:	f900203f 	str	xzr, [x1, #64]
	t->wait_queue_block_ret = wait_queue_error;
ffffffffea807030:	b9004823 	str	w3, [x1, #72]
ffffffffea807034:	f9000045 	str	x5, [x2]
	list->next = item;
ffffffffea807038:	f9000405 	str	x5, [x0, #8]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80703c:	d538d080 	mrs	x0, tpidr_el1
	insert_in_run_queue_head(t);
	thread_mp_reschedule(get_current_thread(), t);
ffffffffea807040:	97fffafa 	bl	ffffffffea805c28 <thread_mp_reschedule>

	return NO_ERROR;
ffffffffea807044:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea807048:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80704c:	d65f03c0 	ret
		return ERR_NOT_BLOCKED;
ffffffffea807050:	12800160 	mov	w0, #0xfffffff4            	// #-12
}
ffffffffea807054:	d65f03c0 	ret

ffffffffea807058 <wait_queue_timeout_handler>:
{
ffffffffea807058:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80705c:	910003fd 	mov	x29, sp
ffffffffea807060:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea807064:	b00002b3 	adrp	x19, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807068:	912ea273 	add	x19, x19, #0xba8
ffffffffea80706c:	aa0203f4 	mov	x20, x2
ffffffffea807070:	aa1303e0 	mov	x0, x19
ffffffffea807074:	97ffee3a 	bl	ffffffffea80295c <arch_spin_lock>
	if (thread_unblock_from_wait_queue(thread, ERR_TIMED_OUT) >= NO_ERROR) {
ffffffffea807078:	12800181 	mov	w1, #0xfffffff3            	// #-13
ffffffffea80707c:	aa1403e0 	mov	x0, x20
ffffffffea807080:	97ffffcc 	bl	ffffffffea806fb0 <thread_unblock_from_wait_queue>
ffffffffea807084:	2a0003f4 	mov	w20, w0
    arch_spin_unlock(lock);
ffffffffea807088:	aa1303e0 	mov	x0, x19
ffffffffea80708c:	97ffee3c 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea807090:	2a3403e0 	mvn	w0, w20
}
ffffffffea807094:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807098:	531f7c00 	lsr	w0, w0, #31
ffffffffea80709c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8070a0:	d65f03c0 	ret
ffffffffea8070a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8070a8 <insert_timer_in_queue>:

	DEBUG_ASSERT(arch_ints_disabled());

	LTRACEF("timer %p, cpu %u, scheduled %u, periodic %u\n", timer, cpu, timer->scheduled_time, timer->periodic_time);

	list_for_every_entry(&timers[cpu].timer_queue, entry, timer_t, node) {
ffffffffea8070a8:	2a0003e0 	mov	w0, w0
ffffffffea8070ac:	b00002a7 	adrp	x7, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8070b0:	912f00e5 	add	x5, x7, #0xbc0
ffffffffea8070b4:	8b0014a5 	add	x5, x5, x0, lsl #5
ffffffffea8070b8:	f94004a2 	ldr	x2, [x5, #8]
ffffffffea8070bc:	aa0203e4 	mov	x4, x2
ffffffffea8070c0:	d1002042 	sub	x2, x2, #0x8
ffffffffea8070c4:	eb0400bf 	cmp	x5, x4
ffffffffea8070c8:	54000200 	b.eq	ffffffffea807108 <insert_timer_in_queue+0x60>  // b.none
		if (TIME_GT(entry->scheduled_time, timer->scheduled_time)) {
ffffffffea8070cc:	b9401826 	ldr	w6, [x1, #24]
ffffffffea8070d0:	b9401843 	ldr	w3, [x2, #24]
ffffffffea8070d4:	4b060063 	sub	w3, w3, w6
ffffffffea8070d8:	7100007f 	cmp	w3, #0x0
ffffffffea8070dc:	540000cd 	b.le	ffffffffea8070f4 <insert_timer_in_queue+0x4c>
ffffffffea8070e0:	14000013 	b	ffffffffea80712c <insert_timer_in_queue+0x84>
ffffffffea8070e4:	b9401843 	ldr	w3, [x2, #24]
ffffffffea8070e8:	4b060063 	sub	w3, w3, w6
ffffffffea8070ec:	7100007f 	cmp	w3, #0x0
ffffffffea8070f0:	540001ec 	b.gt	ffffffffea80712c <insert_timer_in_queue+0x84>
	list_for_every_entry(&timers[cpu].timer_queue, entry, timer_t, node) {
ffffffffea8070f4:	f9400842 	ldr	x2, [x2, #16]
ffffffffea8070f8:	aa0203e4 	mov	x4, x2
ffffffffea8070fc:	d1002042 	sub	x2, x2, #0x8
ffffffffea807100:	eb05009f 	cmp	x4, x5
ffffffffea807104:	54ffff01 	b.ne	ffffffffea8070e4 <insert_timer_in_queue+0x3c>  // b.any
	item->prev = list->prev;
ffffffffea807108:	912f00e7 	add	x7, x7, #0xbc0
ffffffffea80710c:	d37be800 	lsl	x0, x0, #5
			return;
		}
	}

	/* walked off the end of the list */
	list_add_tail(&timers[cpu].timer_queue, &timer->node);
ffffffffea807110:	91002022 	add	x2, x1, #0x8
ffffffffea807114:	f86068e3 	ldr	x3, [x7, x0]
	item->next = list;
ffffffffea807118:	a9009423 	stp	x3, x5, [x1, #8]
	list->prev->next = item;
ffffffffea80711c:	f86068e1 	ldr	x1, [x7, x0]
ffffffffea807120:	f9000422 	str	x2, [x1, #8]
	list->prev = item;
ffffffffea807124:	f82068e2 	str	x2, [x7, x0]
}
ffffffffea807128:	d65f03c0 	ret
	item->prev = list->prev;
ffffffffea80712c:	f9400440 	ldr	x0, [x2, #8]
	item->next = list;
ffffffffea807130:	a9009020 	stp	x0, x4, [x1, #8]
			list_add_before(&entry->node, &timer->node);
ffffffffea807134:	91002021 	add	x1, x1, #0x8
	list->prev->next = item;
ffffffffea807138:	f9400440 	ldr	x0, [x2, #8]
ffffffffea80713c:	f9000401 	str	x1, [x0, #8]
	list->prev = item;
ffffffffea807140:	f9000441 	str	x1, [x2, #8]
}
ffffffffea807144:	d65f03c0 	ret

ffffffffea807148 <timer_tick>:
	spin_unlock_irqrestore(&timer_lock, state);
}

/* called at interrupt time to process any pending timers */
static enum handler_return timer_tick(void *arg, lk_time_t now)
{
ffffffffea807148:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80714c:	910003fd 	mov	x29, sp
ffffffffea807150:	a90153f3 	stp	x19, x20, [sp, #16]

	spin_lock(&timer_lock);

	for (;;) {
		/* see if there's an event to process */
		timer = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea807154:	b00002b3 	adrp	x19, ffffffffea85c000 <idle_threads+0xeb0>
{
ffffffffea807158:	a9025bf5 	stp	x21, x22, [sp, #32]
    arch_spin_lock(lock);
ffffffffea80715c:	d00002b5 	adrp	x21, ffffffffea85d000 <rb_data+0x18>
ffffffffea807160:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea807164:	910282b4 	add	x20, x21, #0xa0
ffffffffea807168:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea80716c:	2a0103f8 	mov	w24, w1
	uint cpu = arch_curr_cpu_num();
ffffffffea807170:	97ffee80 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea807174:	2a0003f7 	mov	w23, w0
ffffffffea807178:	aa1403e0 	mov	x0, x20
ffffffffea80717c:	97ffedf8 	bl	ffffffffea80295c <arch_spin_lock>
		timer = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea807180:	d37b7ee0 	ubfiz	x0, x23, #5, #32
ffffffffea807184:	912f0273 	add	x19, x19, #0xbc0
ffffffffea807188:	8b000273 	add	x19, x19, x0
	enum handler_return ret = INT_NO_RESCHEDULE;
ffffffffea80718c:	52800016 	mov	w22, #0x0                   	// #0
	if (list->next != list) {
ffffffffea807190:	aa1303f9 	mov	x25, x19
		bool periodic = timer->periodic_time > 0;

		LTRACEF("timer %p firing callback %p, arg %p\n", timer, timer->callback, timer->arg);
		KEVLOG_TIMER_CALL(timer->callback, timer->arg);
		if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
			ret = INT_RESCHEDULE;
ffffffffea807194:	5280003a 	mov	w26, #0x1                   	// #1
ffffffffea807198:	f9400721 	ldr	x1, [x25, #8]
ffffffffea80719c:	eb01027f 	cmp	x19, x1
ffffffffea8071a0:	540000e0 	b.eq	ffffffffea8071bc <timer_tick+0x74>  // b.none
ffffffffea8071a4:	f9002bbb 	str	x27, [x29, #80]
		if (likely(timer == 0))
ffffffffea8071a8:	f100203f 	cmp	x1, #0x8
		timer = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea8071ac:	d100203b 	sub	x27, x1, #0x8
ffffffffea8071b0:	b4000041 	cbz	x1, ffffffffea8071b8 <timer_tick+0x70>
		if (likely(timer == 0))
ffffffffea8071b4:	54000161 	b.ne	ffffffffea8071e0 <timer_tick+0x98>  // b.any
ffffffffea8071b8:	f9402bbb 	ldr	x27, [x29, #80]
    arch_spin_unlock(lock);
ffffffffea8071bc:	910282a0 	add	x0, x21, #0xa0
ffffffffea8071c0:	97ffedef 	bl	ffffffffea80297c <arch_spin_unlock>
	if (thread_timer_tick() == INT_RESCHEDULE)
		ret = INT_RESCHEDULE;
#endif

	return ret;
}
ffffffffea8071c4:	2a1603e0 	mov	w0, w22
ffffffffea8071c8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8071cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8071d0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8071d4:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea8071d8:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8071dc:	d65f03c0 	ret
		if (likely(TIME_LT(now, timer->scheduled_time)))
ffffffffea8071e0:	b9401b62 	ldr	w2, [x27, #24]
ffffffffea8071e4:	4b020300 	sub	w0, w24, w2
ffffffffea8071e8:	36f80100 	tbz	w0, #31, ffffffffea807208 <timer_tick+0xc0>
		platform_set_oneshot_timer(timer_tick, NULL, delay);
ffffffffea8071ec:	90000000 	adrp	x0, ffffffffea807000 <thread_unblock_from_wait_queue+0x50>
ffffffffea8071f0:	4b180042 	sub	w2, w2, w24
ffffffffea8071f4:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8071f8:	91052000 	add	x0, x0, #0x148
ffffffffea8071fc:	97fff82f 	bl	ffffffffea8052b8 <platform_set_oneshot_timer>
ffffffffea807200:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea807204:	17ffffee 	b	ffffffffea8071bc <timer_tick+0x74>
	item->next->prev = item->prev;
ffffffffea807208:	a9408762 	ldp	x2, x1, [x27, #8]
ffffffffea80720c:	f9002fbc 	str	x28, [x29, #88]
ffffffffea807210:	aa1403e0 	mov	x0, x20
ffffffffea807214:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea807218:	f9400762 	ldr	x2, [x27, #8]
ffffffffea80721c:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea807220:	a900ff7f 	stp	xzr, xzr, [x27, #8]
ffffffffea807224:	97ffedd6 	bl	ffffffffea80297c <arch_spin_unlock>
		bool periodic = timer->periodic_time > 0;
ffffffffea807228:	b9401f7c 	ldr	w28, [x27, #28]
		if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
ffffffffea80722c:	a9420b63 	ldp	x3, x2, [x27, #32]
ffffffffea807230:	2a1803e1 	mov	w1, w24
ffffffffea807234:	aa1b03e0 	mov	x0, x27
ffffffffea807238:	d63f0060 	blr	x3
			ret = INT_RESCHEDULE;
ffffffffea80723c:	7100041f 	cmp	w0, #0x1
ffffffffea807240:	1a9a12d6 	csel	w22, w22, w26, ne  // ne = any
    arch_spin_lock(lock);
ffffffffea807244:	aa1403e0 	mov	x0, x20
ffffffffea807248:	97ffedc5 	bl	ffffffffea80295c <arch_spin_lock>
		if (periodic && !list_in_list(&timer->node) && timer->periodic_time > 0) {
ffffffffea80724c:	3400007c 	cbz	w28, ffffffffea807258 <timer_tick+0x110>
	if (item->prev == 0 && item->next == 0)
ffffffffea807250:	f9400760 	ldr	x0, [x27, #8]
ffffffffea807254:	b4000060 	cbz	x0, ffffffffea807260 <timer_tick+0x118>
ffffffffea807258:	a94573bb 	ldp	x27, x28, [x29, #80]
ffffffffea80725c:	17ffffcf 	b	ffffffffea807198 <timer_tick+0x50>
ffffffffea807260:	f9400b60 	ldr	x0, [x27, #16]
ffffffffea807264:	b5ffffa0 	cbnz	x0, ffffffffea807258 <timer_tick+0x110>
ffffffffea807268:	b9401f60 	ldr	w0, [x27, #28]
ffffffffea80726c:	34ffff60 	cbz	w0, ffffffffea807258 <timer_tick+0x110>
			timer->scheduled_time = now + timer->periodic_time;
ffffffffea807270:	0b180000 	add	w0, w0, w24
ffffffffea807274:	b9001b60 	str	w0, [x27, #24]
			insert_timer_in_queue(cpu, timer);
ffffffffea807278:	aa1b03e1 	mov	x1, x27
ffffffffea80727c:	2a1703e0 	mov	w0, w23
ffffffffea807280:	97ffff8a 	bl	ffffffffea8070a8 <insert_timer_in_queue>
ffffffffea807284:	a94573bb 	ldp	x27, x28, [x29, #80]
ffffffffea807288:	17ffffc4 	b	ffffffffea807198 <timer_tick+0x50>
ffffffffea80728c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807290 <timer_set>:
{
ffffffffea807290:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea807294:	910003fd 	mov	x29, sp
ffffffffea807298:	f90013f5 	str	x21, [sp, #32]
ffffffffea80729c:	2a0103f5 	mov	w21, w1
ffffffffea8072a0:	f9400401 	ldr	x1, [x0, #8]
ffffffffea8072a4:	f9000bf3 	str	x19, [sp, #16]
ffffffffea8072a8:	aa0003f3 	mov	x19, x0
ffffffffea8072ac:	b5000681 	cbnz	x1, ffffffffea80737c <timer_set+0xec>
ffffffffea8072b0:	f9400801 	ldr	x1, [x0, #16]
ffffffffea8072b4:	b5000641 	cbnz	x1, ffffffffea80737c <timer_set+0xec>
ffffffffea8072b8:	f9000fb4 	str	x20, [x29, #24]
ffffffffea8072bc:	aa0403f4 	mov	x20, x4
ffffffffea8072c0:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea8072c4:	2a0203f7 	mov	w23, w2
ffffffffea8072c8:	aa0303f6 	mov	x22, x3
	now = current_time();
ffffffffea8072cc:	97fff847 	bl	ffffffffea8053e8 <current_time>
	timer->arg = arg;
ffffffffea8072d0:	a9025276 	stp	x22, x20, [x19, #32]
	timer->scheduled_time = now + delay;
ffffffffea8072d4:	0b150000 	add	w0, w0, w21
	timer->periodic_time = period;
ffffffffea8072d8:	29035e60 	stp	w0, w23, [x19, #24]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8072dc:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea8072e0:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8072e4:	36380340 	tbz	w0, #7, ffffffffea80734c <timer_set+0xbc>
ffffffffea8072e8:	d00002b6 	adrp	x22, ffffffffea85d000 <rb_data+0x18>
ffffffffea8072ec:	910282c0 	add	x0, x22, #0xa0
ffffffffea8072f0:	97ffed9b 	bl	ffffffffea80295c <arch_spin_lock>
	uint cpu = arch_curr_cpu_num();
ffffffffea8072f4:	97ffee1f 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea8072f8:	2a0003e8 	mov	w8, w0
	insert_timer_in_queue(cpu, timer);
ffffffffea8072fc:	aa1303e1 	mov	x1, x19
ffffffffea807300:	97ffff6a 	bl	ffffffffea8070a8 <insert_timer_in_queue>
	if (list->next != list) {
ffffffffea807304:	d37b7d08 	ubfiz	x8, x8, #5, #32
ffffffffea807308:	b00002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea80730c:	912f0000 	add	x0, x0, #0xbc0
ffffffffea807310:	8b080000 	add	x0, x0, x8
ffffffffea807314:	f9400401 	ldr	x1, [x0, #8]
	if (list_peek_head_type(&timers[cpu].timer_queue, timer_t, node) == timer) {
ffffffffea807318:	f100003f 	cmp	x1, #0x0
ffffffffea80731c:	fa411004 	ccmp	x0, x1, #0x4, ne  // ne = any
ffffffffea807320:	540001c1 	b.ne	ffffffffea807358 <timer_set+0xc8>  // b.any
    arch_spin_unlock(lock);
ffffffffea807324:	910282c0 	add	x0, x22, #0xa0
ffffffffea807328:	97ffed95 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea80732c:	34000054 	cbz	w20, ffffffffea807334 <timer_set+0xa4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea807330:	d50342ff 	msr	daifclr, #0x2
ffffffffea807334:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea807338:	a942dfb6 	ldp	x22, x23, [x29, #40]
}
ffffffffea80733c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea807340:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea807344:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea807348:	d65f03c0 	ret
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80734c:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea807350:	52800034 	mov	w20, #0x1                   	// #1
ffffffffea807354:	17ffffe5 	b	ffffffffea8072e8 <timer_set+0x58>
	if (list_peek_head_type(&timers[cpu].timer_queue, timer_t, node) == timer) {
ffffffffea807358:	d1002021 	sub	x1, x1, #0x8
ffffffffea80735c:	eb01027f 	cmp	x19, x1
ffffffffea807360:	54fffe21 	b.ne	ffffffffea807324 <timer_set+0x94>  // b.any
		platform_set_oneshot_timer(timer_tick, NULL, delay);
ffffffffea807364:	90000000 	adrp	x0, ffffffffea807000 <thread_unblock_from_wait_queue+0x50>
ffffffffea807368:	2a1503e2 	mov	w2, w21
ffffffffea80736c:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea807370:	91052000 	add	x0, x0, #0x148
ffffffffea807374:	97fff7d1 	bl	ffffffffea8052b8 <platform_set_oneshot_timer>
ffffffffea807378:	17ffffeb 	b	ffffffffea807324 <timer_set+0x94>
		panic("timer %p already in list\n", timer);
ffffffffea80737c:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807380:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea807384:	aa1303e2 	mov	x2, x19
ffffffffea807388:	91080021 	add	x1, x1, #0x200
ffffffffea80738c:	aa1e03e0 	mov	x0, x30
ffffffffea807390:	f9000fb4 	str	x20, [x29, #24]
ffffffffea807394:	9400299d 	bl	ffffffffea811a08 <_panic>

ffffffffea807398 <timer_initialize>:
	*timer = (timer_t)TIMER_INITIAL_VALUE(*timer);
ffffffffea807398:	528dae41 	mov	w1, #0x6d72                	// #28018
ffffffffea80739c:	a900fc1f 	stp	xzr, xzr, [x0, #8]
ffffffffea8073a0:	72ae8d21 	movk	w1, #0x7469, lsl #16
ffffffffea8073a4:	b9000001 	str	w1, [x0]
ffffffffea8073a8:	a901fc1f 	stp	xzr, xzr, [x0, #24]
ffffffffea8073ac:	f900141f 	str	xzr, [x0, #40]
}
ffffffffea8073b0:	d65f03c0 	ret
ffffffffea8073b4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8073b8 <timer_set_oneshot>:
		delay = 1;
ffffffffea8073b8:	7100003f 	cmp	w1, #0x0
	timer_set(timer, delay, 0, callback, arg);
ffffffffea8073bc:	aa0303e4 	mov	x4, x3
ffffffffea8073c0:	1a9f1421 	csinc	w1, w1, wzr, ne  // ne = any
ffffffffea8073c4:	aa0203e3 	mov	x3, x2
ffffffffea8073c8:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8073cc:	17ffffb1 	b	ffffffffea807290 <timer_set>

ffffffffea8073d0 <timer_set_periodic>:
		period = 1;
ffffffffea8073d0:	7100003f 	cmp	w1, #0x0
	timer_set(timer, period, period, callback, arg);
ffffffffea8073d4:	aa0303e4 	mov	x4, x3
		period = 1;
ffffffffea8073d8:	1a9f1421 	csinc	w1, w1, wzr, ne  // ne = any
	timer_set(timer, period, period, callback, arg);
ffffffffea8073dc:	aa0203e3 	mov	x3, x2
ffffffffea8073e0:	2a0103e2 	mov	w2, w1
ffffffffea8073e4:	17ffffab 	b	ffffffffea807290 <timer_set>

ffffffffea8073e8 <timer_cancel>:
{
ffffffffea8073e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8073ec:	910003fd 	mov	x29, sp
ffffffffea8073f0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8073f4:	aa0003f3 	mov	x19, x0
ffffffffea8073f8:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8073fc:	d53b4220 	mrs	x0, daif
ffffffffea807400:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea807404:	37380060 	tbnz	w0, #7, ffffffffea807410 <timer_cancel+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea807408:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea80740c:	52800035 	mov	w21, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea807410:	d00002b4 	adrp	x20, ffffffffea85d000 <rb_data+0x18>
ffffffffea807414:	91028280 	add	x0, x20, #0xa0
ffffffffea807418:	97ffed51 	bl	ffffffffea80295c <arch_spin_lock>
	uint cpu = arch_curr_cpu_num();
ffffffffea80741c:	97ffedd5 	bl	ffffffffea802b70 <arch_curr_cpu_num>
	timer_t *oldhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea807420:	2a0003e0 	mov	w0, w0
ffffffffea807424:	b00002a2 	adrp	x2, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807428:	912f0041 	add	x1, x2, #0xbc0
ffffffffea80742c:	8b001421 	add	x1, x1, x0, lsl #5
ffffffffea807430:	a9409666 	ldp	x6, x5, [x19, #8]
ffffffffea807434:	f9400423 	ldr	x3, [x1, #8]
ffffffffea807438:	f100007f 	cmp	x3, #0x0
ffffffffea80743c:	d1002064 	sub	x4, x3, #0x8
ffffffffea807440:	fa431024 	ccmp	x1, x3, #0x4, ne  // ne = any
ffffffffea807444:	9a9f1084 	csel	x4, x4, xzr, ne  // ne = any
	if (item->prev == 0 && item->next == 0)
ffffffffea807448:	b4000486 	cbz	x6, ffffffffea8074d8 <timer_cancel+0xf0>
	item->next->prev = item->prev;
ffffffffea80744c:	f90000a6 	str	x6, [x5]
	item->prev->next = item->next;
ffffffffea807450:	f9400663 	ldr	x3, [x19, #8]
ffffffffea807454:	f9000465 	str	x5, [x3, #8]
	item->prev = item->next = 0;
ffffffffea807458:	a900fe7f 	stp	xzr, xzr, [x19, #8]
	if (list->next != list) {
ffffffffea80745c:	912f0042 	add	x2, x2, #0xbc0
ffffffffea807460:	8b001440 	add	x0, x2, x0, lsl #5
ffffffffea807464:	f9400400 	ldr	x0, [x0, #8]
	timer->periodic_time = 0;
ffffffffea807468:	b9001e7f 	str	wzr, [x19, #28]
	timer->arg = NULL;
ffffffffea80746c:	a9027e7f 	stp	xzr, xzr, [x19, #32]
	timer_t *newhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea807470:	f100001f 	cmp	x0, #0x0
ffffffffea807474:	fa401024 	ccmp	x1, x0, #0x4, ne  // ne = any
ffffffffea807478:	540001e0 	b.eq	ffffffffea8074b4 <timer_cancel+0xcc>  // b.none
	if (newhead == NULL) {
ffffffffea80747c:	f100201f 	cmp	x0, #0x8
ffffffffea807480:	540001a0 	b.eq	ffffffffea8074b4 <timer_cancel+0xcc>  // b.none
	timer_t *newhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea807484:	d1002013 	sub	x19, x0, #0x8
	} else if (newhead != oldhead) {
ffffffffea807488:	eb13009f 	cmp	x4, x19
ffffffffea80748c:	54000160 	b.eq	ffffffffea8074b8 <timer_cancel+0xd0>  // b.none
		lk_time_t now = current_time();
ffffffffea807490:	97fff7d6 	bl	ffffffffea8053e8 <current_time>
		if (TIME_LT(newhead->scheduled_time, now))
ffffffffea807494:	b9401a62 	ldr	w2, [x19, #24]
		platform_set_oneshot_timer(timer_tick, NULL, delay);
ffffffffea807498:	90000003 	adrp	x3, ffffffffea807000 <thread_unblock_from_wait_queue+0x50>
ffffffffea80749c:	d2800001 	mov	x1, #0x0                   	// #0
			delay = 0;
ffffffffea8074a0:	6b000042 	subs	w2, w2, w0
		platform_set_oneshot_timer(timer_tick, NULL, delay);
ffffffffea8074a4:	91052060 	add	x0, x3, #0x148
ffffffffea8074a8:	1a9f5042 	csel	w2, w2, wzr, pl  // pl = nfrst
ffffffffea8074ac:	97fff783 	bl	ffffffffea8052b8 <platform_set_oneshot_timer>
ffffffffea8074b0:	14000002 	b	ffffffffea8074b8 <timer_cancel+0xd0>
		platform_stop_timer();
ffffffffea8074b4:	97fff7af 	bl	ffffffffea805370 <platform_stop_timer>
    arch_spin_unlock(lock);
ffffffffea8074b8:	91028280 	add	x0, x20, #0xa0
ffffffffea8074bc:	97ffed30 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8074c0:	34000055 	cbz	w21, ffffffffea8074c8 <timer_cancel+0xe0>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8074c4:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8074c8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8074cc:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8074d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8074d4:	d65f03c0 	ret
	if (item->prev == 0 && item->next == 0)
ffffffffea8074d8:	b5fffba5 	cbnz	x5, ffffffffea80744c <timer_cancel+0x64>
ffffffffea8074dc:	17ffffe0 	b	ffffffffea80745c <timer_cancel+0x74>

ffffffffea8074e0 <timer_init>:

void timer_init(void)
{
	timer_lock = SPIN_LOCK_INITIAL_VALUE;
ffffffffea8074e0:	d00002a2 	adrp	x2, ffffffffea85d000 <rb_data+0x18>
ffffffffea8074e4:	b00002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8074e8:	912f0000 	add	x0, x0, #0xbc0
ffffffffea8074ec:	91040001 	add	x1, x0, #0x100
ffffffffea8074f0:	f900505f 	str	xzr, [x2, #160]
ffffffffea8074f4:	d503201f 	nop
	list->prev = list->next = list;
ffffffffea8074f8:	a9000000 	stp	x0, x0, [x0]
ffffffffea8074fc:	91008000 	add	x0, x0, #0x20
	for (uint i = 0; i < SMP_MAX_CPUS; i++) {
ffffffffea807500:	eb01001f 	cmp	x0, x1
ffffffffea807504:	54ffffa1 	b.ne	ffffffffea8074f8 <timer_init+0x18>  // b.any
	}
#if !PLATFORM_HAS_DYNAMIC_TIMER
	/* register for a periodic timer tick */
	platform_set_periodic_timer(timer_tick, NULL, 10); /* 10ms */
#endif
}
ffffffffea807508:	d65f03c0 	ret
ffffffffea80750c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807510 <mp_init>:
/* a global state structure, aligned on cpu cache line to minimize aliasing */
struct mp_state mp __CPU_ALIGN;

void mp_init(void)
{
}
ffffffffea807510:	d65f03c0 	ret
ffffffffea807514:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807518 <mp_reschedule>:

void mp_reschedule(mp_cpu_mask_t target, uint flags)
{
ffffffffea807518:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80751c:	910003fd 	mov	x29, sp
ffffffffea807520:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea807524:	2a0003f4 	mov	w20, w0
ffffffffea807528:	2a0103f3 	mov	w19, w1
#if WITH_SMP
	uint local_cpu = arch_curr_cpu_num();
ffffffffea80752c:	97ffed91 	bl	ffffffffea802b70 <arch_curr_cpu_num>

	LTRACEF("local %d, target 0x%x\n", local_cpu, target);

	/* mask out cpus that are not active and the local cpu */
	target &= mp.active_cpus;
ffffffffea807530:	d00002a4 	adrp	x4, ffffffffea85d000 <rb_data+0x18>
ffffffffea807534:	b940c082 	ldr	w2, [x4, #192]
ffffffffea807538:	0a140042 	and	w2, w2, w20

	/* mask out cpus that are currently running realtime code */
	if ((flags & MP_RESCHEDULE_FLAG_REALTIME) == 0) {
ffffffffea80753c:	37000093 	tbnz	w19, #0, ffffffffea80754c <mp_reschedule+0x34>
ffffffffea807540:	91030081 	add	x1, x4, #0xc0
		target &= ~mp.realtime_cpus;
ffffffffea807544:	b9400821 	ldr	w1, [x1, #8]
ffffffffea807548:	0a210042 	bic	w2, w2, w1

	LTRACEF("local %d, post mask target now 0x%x\n", local_cpu, target);

	arch_mp_send_ipi(target, MP_IPI_RESCHEDULE);
#endif
}
ffffffffea80754c:	a94153f3 	ldp	x19, x20, [sp, #16]
	target &= ~(1U << local_cpu);
ffffffffea807550:	52800023 	mov	w3, #0x1                   	// #1
}
ffffffffea807554:	a8c27bfd 	ldp	x29, x30, [sp], #32
	target &= ~(1U << local_cpu);
ffffffffea807558:	1ac02060 	lsl	w0, w3, w0
	arch_mp_send_ipi(target, MP_IPI_RESCHEDULE);
ffffffffea80755c:	2a0303e1 	mov	w1, w3
ffffffffea807560:	0a200040 	bic	w0, w2, w0
ffffffffea807564:	17ffef73 	b	ffffffffea803330 <arch_mp_send_ipi>

ffffffffea807568 <mp_set_curr_cpu_active>:

void mp_set_curr_cpu_active(bool active)
{
ffffffffea807568:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80756c:	910003fd 	mov	x29, sp
	atomic_or((volatile int *)&mp.active_cpus, 1U << arch_curr_cpu_num());
ffffffffea807570:	97ffed80 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea807574:	52800022 	mov	w2, #0x1                   	// #1
    return __atomic_fetch_or(ptr, val, __ATOMIC_RELAXED);
ffffffffea807578:	d00002a1 	adrp	x1, ffffffffea85d000 <rb_data+0x18>
ffffffffea80757c:	91030021 	add	x1, x1, #0xc0
ffffffffea807580:	1ac02040 	lsl	w0, w2, w0
ffffffffea807584:	885f7c22 	ldxr	w2, [x1]
ffffffffea807588:	2a000042 	orr	w2, w2, w0
ffffffffea80758c:	88037c22 	stxr	w3, w2, [x1]
ffffffffea807590:	35ffffa3 	cbnz	w3, ffffffffea807584 <mp_set_curr_cpu_active+0x1c>
}
ffffffffea807594:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea807598:	d65f03c0 	ret
ffffffffea80759c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8075a0 <mp_mbx_reschedule_irq>:

#if WITH_SMP
enum handler_return mp_mbx_reschedule_irq(void)
{
ffffffffea8075a0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea8075a4:	910003fd 	mov	x29, sp
	uint cpu = arch_curr_cpu_num();
ffffffffea8075a8:	97ffed72 	bl	ffffffffea802b70 <arch_curr_cpu_num>

	LTRACEF("cpu %u\n", cpu);

	THREAD_STATS_INC(reschedule_ipis);

	return (mp.active_cpus & (1U << cpu)) ? INT_RESCHEDULE : INT_NO_RESCHEDULE;
ffffffffea8075ac:	d00002a1 	adrp	x1, ffffffffea85d000 <rb_data+0x18>
}
ffffffffea8075b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return (mp.active_cpus & (1U << cpu)) ? INT_RESCHEDULE : INT_NO_RESCHEDULE;
ffffffffea8075b4:	b940c021 	ldr	w1, [x1, #192]
ffffffffea8075b8:	1ac02420 	lsr	w0, w1, w0
}
ffffffffea8075bc:	12000000 	and	w0, w0, #0x1
ffffffffea8075c0:	d65f03c0 	ret
ffffffffea8075c4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8075c8 <tegra_boot_profiler_init>:
 * If the profiler is not enabled then we just turn all of the profiler
 * functions into no-ops.
 * The '(void)' statements are to silence compiler
 * warnings */

long tegra_boot_profiler_init(paddr_t boot_arg){ return 0L; }
ffffffffea8075c8:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea8075cc:	d65f03c0 	ret

ffffffffea8075d0 <tegra_boot_profiler_deinit>:

void tegra_boot_profiler_deinit(void){ ; }
ffffffffea8075d0:	d65f03c0 	ret
ffffffffea8075d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8075d8 <tegra_boot_profiler_get_timestamp>:

uint32_t tegra_boot_profiler_get_timestamp(void) { return 0U; }
ffffffffea8075d8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8075dc:	d65f03c0 	ret

ffffffffea8075e0 <tegra_boot_profiler_record>:

/* If TOS boot profiler is NOT enabled no records will be added */
void tegra_boot_profiler_record(const char *str) {
	(void)str;
}
ffffffffea8075e0:	d65f03c0 	ret
ffffffffea8075e4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8075e8 <tegra_boot_profiler_prerecorded>:

void tegra_boot_profiler_prerecorded(const char *str, uint32_t tstamp) {
	(void)str;
	(void)tstamp;
}
ffffffffea8075e8:	d65f03c0 	ret
ffffffffea8075ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8075f0 <memlog_init>:
static smc32_entity_t log_sm_entity = {
	.stdcall_handler = memlog_stdcall,
};

static void memlog_init(uint level)
{
ffffffffea8075f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	int err;

	err = sm_register_entity(SMC_ENTITY_LOGGING, &log_sm_entity);
ffffffffea8075f4:	b0000081 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea8075f8:	52800660 	mov	w0, #0x33                  	// #51
ffffffffea8075fc:	9115e021 	add	x1, x1, #0x578
{
ffffffffea807600:	910003fd 	mov	x29, sp
	err = sm_register_entity(SMC_ENTITY_LOGGING, &log_sm_entity);
ffffffffea807604:	940004ef 	bl	ffffffffea8089c0 <sm_register_entity>
	if (err) {
ffffffffea807608:	35000060 	cbnz	w0, ffffffffea807614 <memlog_init+0x24>
		printf("trusty error register entity: %d\n", err);
	}
}
ffffffffea80760c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea807610:	d65f03c0 	ret
ffffffffea807614:	a8c17bfd 	ldp	x29, x30, [sp], #16
		printf("trusty error register entity: %d\n", err);
ffffffffea807618:	f0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80761c:	2a0003e1 	mov	w1, w0
ffffffffea807620:	91098040 	add	x0, x2, #0x260
ffffffffea807624:	14002e5f 	b	ffffffffea812fa0 <_printf>

ffffffffea807628 <memlog_print_callback>:
{
ffffffffea807628:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80762c:	910003fd 	mov	x29, sp
ffffffffea807630:	a90153f3 	stp	x19, x20, [sp, #16]
	struct memlog *log = containerof(cb, struct memlog, cb);
ffffffffea807634:	d1008014 	sub	x20, x0, #0x20
{
ffffffffea807638:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80763c:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea807640:	aa0003f7 	mov	x23, x0
ffffffffea807644:	f90023f9 	str	x25, [sp, #64]
ffffffffea807648:	aa0103f8 	mov	x24, x1
ffffffffea80764c:	aa0203f9 	mov	x25, x2
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea807650:	d53b4220 	mrs	x0, daif
ffffffffea807654:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea807658:	37380060 	tbnz	w0, #7, ffffffffea807664 <memlog_print_callback+0x3c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80765c:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea807660:	52800035 	mov	w21, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea807664:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea807668:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea80766c:	37300080 	tbnz	w0, #6, ffffffffea80767c <memlog_print_callback+0x54>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea807670:	321f02b5 	orr	w21, w21, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea807674:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea807678:	52800053 	mov	w19, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea80767c:	b00002b6 	adrp	x22, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807680:	913302c0 	add	x0, x22, #0xcc0
ffffffffea807684:	97ffecb6 	bl	ffffffffea80295c <arch_spin_lock>
	for (i = 0; i < len / chunk_size; i++) {
ffffffffea807688:	d347ff2a 	lsr	x10, x25, #7
ffffffffea80768c:	b40003ea 	cbz	x10, ffffffffea807708 <memlog_print_callback+0xe0>
ffffffffea807690:	d379e14a 	lsl	x10, x10, #7
ffffffffea807694:	aa1803e7 	mov	x7, x24
ffffffffea807698:	8b180149 	add	x9, x10, x24
ffffffffea80769c:	d503201f 	nop
		__memlog_write(log, &str[i * chunk_size], chunk_size);
ffffffffea8076a0:	f9400286 	ldr	x6, [x20]
	log_offset = rb->alloc;
ffffffffea8076a4:	b94000c8 	ldr	w8, [x6]
	rb->alloc += len;
ffffffffea8076a8:	b94000c0 	ldr	w0, [x6]
ffffffffea8076ac:	11020000 	add	w0, w0, #0x80
ffffffffea8076b0:	b90000c0 	str	w0, [x6]
	wmb();
ffffffffea8076b4:	d5033e9f 	dsb	st
	for (i = 0; i < len; i++) {
ffffffffea8076b8:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea8076bc:	d503201f 	nop
		uint32_t offset = (log_offset + i) & (log->rb_sz - 1);
ffffffffea8076c0:	f9400680 	ldr	x0, [x20, #8]
ffffffffea8076c4:	0b030105 	add	w5, w8, w3
		*ptr = str[i];
ffffffffea8076c8:	386368e4 	ldrb	w4, [x7, x3]
	for (i = 0; i < len; i++) {
ffffffffea8076cc:	91000463 	add	x3, x3, #0x1
		uint32_t offset = (log_offset + i) & (log->rb_sz - 1);
ffffffffea8076d0:	51000400 	sub	w0, w0, #0x1
	for (i = 0; i < len; i++) {
ffffffffea8076d4:	f102007f 	cmp	x3, #0x80
		*ptr = str[i];
ffffffffea8076d8:	0a050000 	and	w0, w0, w5
ffffffffea8076dc:	8b0000c0 	add	x0, x6, x0
ffffffffea8076e0:	39003004 	strb	w4, [x0, #12]
	for (i = 0; i < len; i++) {
ffffffffea8076e4:	54fffee1 	b.ne	ffffffffea8076c0 <memlog_print_callback+0x98>  // b.any
	wmb();
ffffffffea8076e8:	d5033e9f 	dsb	st
	rb->put += len;
ffffffffea8076ec:	b94004c0 	ldr	w0, [x6, #4]
ffffffffea8076f0:	910200e7 	add	x7, x7, #0x80
	for (i = 0; i < len / chunk_size; i++) {
ffffffffea8076f4:	eb07013f 	cmp	x9, x7
	rb->put += len;
ffffffffea8076f8:	11020000 	add	w0, w0, #0x80
ffffffffea8076fc:	b90004c0 	str	w0, [x6, #4]
	for (i = 0; i < len / chunk_size; i++) {
ffffffffea807700:	54fffd01 	b.ne	ffffffffea8076a0 <memlog_print_callback+0x78>  // b.any
ffffffffea807704:	cb0a0339 	sub	x25, x25, x10
	if (rem) {
ffffffffea807708:	b4000319 	cbz	x25, ffffffffea807768 <memlog_print_callback+0x140>
		__memlog_write(log, &str[i * chunk_size], rem);
ffffffffea80770c:	f85e02e3 	ldur	x3, [x23, #-32]
	rb->alloc += len;
ffffffffea807710:	2a1903e7 	mov	w7, w25
	log_offset = rb->alloc;
ffffffffea807714:	b9400066 	ldr	w6, [x3]
	rb->alloc += len;
ffffffffea807718:	b9400060 	ldr	w0, [x3]
ffffffffea80771c:	0b190000 	add	w0, w0, w25
ffffffffea807720:	b9000060 	str	w0, [x3]
	wmb();
ffffffffea807724:	d5033e9f 	dsb	st
ffffffffea807728:	8b180149 	add	x9, x10, x24
	for (i = 0; i < len; i++) {
ffffffffea80772c:	d2800001 	mov	x1, #0x0                   	// #0
		uint32_t offset = (log_offset + i) & (log->rb_sz - 1);
ffffffffea807730:	f9400680 	ldr	x0, [x20, #8]
ffffffffea807734:	0b0100c5 	add	w5, w6, w1
		*ptr = str[i];
ffffffffea807738:	38616924 	ldrb	w4, [x9, x1]
	for (i = 0; i < len; i++) {
ffffffffea80773c:	91000421 	add	x1, x1, #0x1
		uint32_t offset = (log_offset + i) & (log->rb_sz - 1);
ffffffffea807740:	51000400 	sub	w0, w0, #0x1
	for (i = 0; i < len; i++) {
ffffffffea807744:	eb19003f 	cmp	x1, x25
		*ptr = str[i];
ffffffffea807748:	0a050000 	and	w0, w0, w5
ffffffffea80774c:	8b000060 	add	x0, x3, x0
ffffffffea807750:	39003004 	strb	w4, [x0, #12]
	for (i = 0; i < len; i++) {
ffffffffea807754:	54fffee1 	b.ne	ffffffffea807730 <memlog_print_callback+0x108>  // b.any
	wmb();
ffffffffea807758:	d5033e9f 	dsb	st
	rb->put += len;
ffffffffea80775c:	b9400460 	ldr	w0, [x3, #4]
ffffffffea807760:	0b0000e0 	add	w0, w7, w0
ffffffffea807764:	b9000460 	str	w0, [x3, #4]
    arch_spin_unlock(lock);
ffffffffea807768:	913302c0 	add	x0, x22, #0xcc0
ffffffffea80776c:	97ffec84 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea807770:	34000053 	cbz	w19, ffffffffea807778 <memlog_print_callback+0x150>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea807774:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea807778:	36000055 	tbz	w21, #0, ffffffffea807780 <memlog_print_callback+0x158>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80777c:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea807780:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807784:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea807788:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80778c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea807790:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea807794:	d65f03c0 	ret

ffffffffea807798 <memlog_add>:
{
ffffffffea807798:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80779c:	910003fd 	mov	x29, sp
ffffffffea8077a0:	f90013f5 	str	x21, [sp, #32]
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea8077a4:	b0000095 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea8077a8:	9115a2a3 	add	x3, x21, #0x568
ffffffffea8077ac:	f9400465 	ldr	x5, [x3, #8]
ffffffffea8077b0:	eb05007f 	cmp	x3, x5
ffffffffea8077b4:	54000260 	b.eq	ffffffffea807800 <memlog_add+0x68>  // b.none
ffffffffea8077b8:	d100e0a4 	sub	x4, x5, #0x38
ffffffffea8077bc:	8b010006 	add	x6, x0, x1
ffffffffea8077c0:	aa0303e5 	mov	x5, x3
		if (pa + sz <= log->buf_pa) {
ffffffffea8077c4:	f9400883 	ldr	x3, [x4, #16]
ffffffffea8077c8:	eb06007f 	cmp	x3, x6
ffffffffea8077cc:	54000122 	b.cs	ffffffffea8077f0 <memlog_add+0x58>  // b.hs, b.nlast
		if (pa >= log->buf_pa + log->buf_sz){
ffffffffea8077d0:	f9400c87 	ldr	x7, [x4, #24]
ffffffffea8077d4:	8b070063 	add	x3, x3, x7
ffffffffea8077d8:	eb03001f 	cmp	x0, x3
ffffffffea8077dc:	540000a2 	b.cs	ffffffffea8077f0 <memlog_add+0x58>  // b.hs, b.nlast
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea8077e0:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
}
ffffffffea8077e4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8077e8:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8077ec:	d65f03c0 	ret
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea8077f0:	f9402083 	ldr	x3, [x4, #64]
ffffffffea8077f4:	d100e064 	sub	x4, x3, #0x38
ffffffffea8077f8:	eb0300bf 	cmp	x5, x3
ffffffffea8077fc:	54fffe41 	b.ne	ffffffffea8077c4 <memlog_add+0x2c>  // b.any
ffffffffea807800:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea807804:	aa0003f4 	mov	x20, x0
ffffffffea807808:	a90363b7 	stp	x23, x24, [x29, #48]
	log = malloc(sizeof(*log));
ffffffffea80780c:	d2800900 	mov	x0, #0x48                  	// #72
ffffffffea807810:	2a0203f8 	mov	w24, w2
ffffffffea807814:	aa0103f7 	mov	x23, x1
ffffffffea807818:	94002e0a 	bl	ffffffffea813040 <malloc>
ffffffffea80781c:	aa0003f3 	mov	x19, x0
	if (!log) {
ffffffffea807820:	b40009a0 	cbz	x0, ffffffffea807954 <memlog_add+0x1bc>
ffffffffea807824:	f90017b6 	str	x22, [x29, #40]
	sz = ROUNDUP((sz + offset), mb);
ffffffffea807828:	b2404fe1 	mov	x1, #0xfffff               	// #1048575
ffffffffea80782c:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea807830:	8b0102f6 	add	x22, x23, x1
	offset = pa & (mb - 1);
ffffffffea807834:	92404e99 	and	x25, x20, #0xfffff
	pa = ROUNDDOWN(pa, mb);
ffffffffea807838:	926cae9a 	and	x26, x20, #0xfffffffffff00000
	sz = ROUNDUP((sz + offset), mb);
ffffffffea80783c:	8b1902d6 	add	x22, x22, x25
	err = trusty_hyp_check_guest_pa_valid(pa, sz, guest);
ffffffffea807840:	2a1803e2 	mov	w2, w24
	sz = ROUNDUP((sz + offset), mb);
ffffffffea807844:	926caed6 	and	x22, x22, #0xfffffffffff00000
	err = trusty_hyp_check_guest_pa_valid(pa, sz, guest);
ffffffffea807848:	aa1a03e0 	mov	x0, x26
	log->buf_sz = sz;
ffffffffea80784c:	a9015e74 	stp	x20, x23, [x19, #16]
	err = trusty_hyp_check_guest_pa_valid(pa, sz, guest);
ffffffffea807850:	aa1603e1 	mov	x1, x22
ffffffffea807854:	97ffebaf 	bl	ffffffffea802710 <trusty_hyp_check_guest_pa_valid>
	if (err != NO_ERROR) {
ffffffffea807858:	350005e0 	cbnz	w0, ffffffffea807914 <memlog_add+0x17c>
	err = vmm_alloc_physical(vmm_get_kernel_aspace(),
ffffffffea80785c:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807860:	d00002a0 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
ffffffffea807864:	52800607 	mov	w7, #0x30                  	// #48
ffffffffea807868:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80786c:	aa1a03e5 	mov	x5, x26
ffffffffea807870:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea807874:	910163a3 	add	x3, x29, #0x58
ffffffffea807878:	aa1603e2 	mov	x2, x22
ffffffffea80787c:	91096021 	add	x1, x1, #0x258
ffffffffea807880:	91034000 	add	x0, x0, #0xd0
ffffffffea807884:	94002621 	bl	ffffffffea811108 <vmm_alloc_physical>
	if (err) {
ffffffffea807888:	35000520 	cbnz	w0, ffffffffea80792c <memlog_add+0x194>
	log->rb_sz = lower_pow2(log->buf_sz - offsetof(struct log_rb, data));
ffffffffea80788c:	f9400e60 	ldr	x0, [x19, #24]
	item->next = list->next;
ffffffffea807890:	9115a2b5 	add	x21, x21, #0x568
	*va += offset;
ffffffffea807894:	f9402fa5 	ldr	x5, [x29, #88]
	return 1u << (31 - __builtin_clz(v));
ffffffffea807898:	528003e3 	mov	w3, #0x1f                  	// #31
	log->rb_sz = lower_pow2(log->buf_sz - offsetof(struct log_rb, data));
ffffffffea80789c:	51003000 	sub	w0, w0, #0xc
	return 1u << (31 - __builtin_clz(v));
ffffffffea8078a0:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea8078a4:	5ac01000 	clz	w0, w0
	*va += offset;
ffffffffea8078a8:	8b050321 	add	x1, x25, x5
	return 1u << (31 - __builtin_clz(v));
ffffffffea8078ac:	4b000060 	sub	w0, w3, w0
ffffffffea8078b0:	f94006a4 	ldr	x4, [x21, #8]
	*va += offset;
ffffffffea8078b4:	f9002fa1 	str	x1, [x29, #88]
	list_add_head(&log_list, &log->entry);
ffffffffea8078b8:	9100e263 	add	x3, x19, #0x38
	return 1u << (31 - __builtin_clz(v));
ffffffffea8078bc:	1ac02042 	lsl	w2, w2, w0
	log->rb_sz = lower_pow2(log->buf_sz - offsetof(struct log_rb, data));
ffffffffea8078c0:	a9000a61 	stp	x1, x2, [x19]
	return 1u << (31 - __builtin_clz(v));
ffffffffea8078c4:	aa0203e0 	mov	x0, x2
	rb->sz = log->rb_sz;
ffffffffea8078c8:	b9000820 	str	w0, [x1, #8]
	rb->alloc = 0;
ffffffffea8078cc:	b8256b3f 	str	wzr, [x25, x5]
	log->cb.print = memlog_print_callback;
ffffffffea8078d0:	90000002 	adrp	x2, ffffffffea807000 <thread_unblock_from_wait_queue+0x50>
	rb->put = 0;
ffffffffea8078d4:	b900043f 	str	wzr, [x1, #4]
	log->cb.print = memlog_print_callback;
ffffffffea8078d8:	9118a042 	add	x2, x2, #0x628
ffffffffea8078dc:	a9039275 	stp	x21, x4, [x19, #56]
	register_print_callback(&log->cb);
ffffffffea8078e0:	91008260 	add	x0, x19, #0x20
	list->next->prev = item;
ffffffffea8078e4:	f9000083 	str	x3, [x4]
	log->cb.print = memlog_print_callback;
ffffffffea8078e8:	f9001a62 	str	x2, [x19, #48]
	list->next = item;
ffffffffea8078ec:	f90006a3 	str	x3, [x21, #8]
	register_print_callback(&log->cb);
ffffffffea8078f0:	940026e0 	bl	ffffffffea811470 <register_print_callback>
	return 0;
ffffffffea8078f4:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea8078f8:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea8078fc:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea807900:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea807904:	a943e7b8 	ldp	x24, x25, [x29, #56]
}
ffffffffea807908:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80790c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea807910:	d65f03c0 	ret
		dprintf(ALWAYS, "%s: check_guest_pa_valid failed, error = %d",
ffffffffea807914:	f0000063 	adrp	x3, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807918:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80791c:	2a0003e2 	mov	w2, w0
ffffffffea807920:	91088021 	add	x1, x1, #0x220
ffffffffea807924:	9108a060 	add	x0, x3, #0x228
ffffffffea807928:	940027ba 	bl	ffffffffea811810 <_dprintf>
	free(log);
ffffffffea80792c:	aa1303e0 	mov	x0, x19
ffffffffea807930:	94002dda 	bl	ffffffffea813098 <free>
	return status;
ffffffffea807934:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea807938:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea80793c:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea807940:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea807944:	a943e7b8 	ldp	x24, x25, [x29, #56]
}
ffffffffea807948:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80794c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea807950:	d65f03c0 	ret
		return SM_ERR_INTERNAL_FAILURE;
ffffffffea807954:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea807958:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80795c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea807960:	17ffffa1 	b	ffffffffea8077e4 <memlog_add+0x4c>
ffffffffea807964:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807968 <memlog_rm>:
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea807968:	b0000082 	adrp	x2, ffffffffea818000 <_mem_phys_base>
ffffffffea80796c:	9115a042 	add	x2, x2, #0x568
ffffffffea807970:	f9400441 	ldr	x1, [x2, #8]
ffffffffea807974:	eb01005f 	cmp	x2, x1
ffffffffea807978:	54000500 	b.eq	ffffffffea807a18 <memlog_rm+0xb0>  // b.none
{
ffffffffea80797c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea807980:	910003fd 	mov	x29, sp
ffffffffea807984:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea807988:	d100e033 	sub	x19, x1, #0x38
		if (log->buf_pa == pa) {
ffffffffea80798c:	f85d8021 	ldur	x1, [x1, #-40]
ffffffffea807990:	eb01001f 	cmp	x0, x1
ffffffffea807994:	540000a1 	b.ne	ffffffffea8079a8 <memlog_rm+0x40>  // b.any
ffffffffea807998:	1400000c 	b	ffffffffea8079c8 <memlog_rm+0x60>
ffffffffea80799c:	f85d8021 	ldur	x1, [x1, #-40]
ffffffffea8079a0:	eb01001f 	cmp	x0, x1
ffffffffea8079a4:	54000120 	b.eq	ffffffffea8079c8 <memlog_rm+0x60>  // b.none
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea8079a8:	f9402261 	ldr	x1, [x19, #64]
ffffffffea8079ac:	eb01005f 	cmp	x2, x1
ffffffffea8079b0:	d100e033 	sub	x19, x1, #0x38
ffffffffea8079b4:	54ffff41 	b.ne	ffffffffea80799c <memlog_rm+0x34>  // b.any
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea8079b8:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
}
ffffffffea8079bc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8079c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8079c4:	d65f03c0 	ret
	unregister_print_callback(&log->cb);
ffffffffea8079c8:	91008260 	add	x0, x19, #0x20
ffffffffea8079cc:	940026d9 	bl	ffffffffea811530 <unregister_print_callback>
	item->next->prev = item->prev;
ffffffffea8079d0:	a9438a63 	ldp	x3, x2, [x19, #56]
	result = vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)log->rb);
ffffffffea8079d4:	d00002a0 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
ffffffffea8079d8:	f9400261 	ldr	x1, [x19]
ffffffffea8079dc:	91034000 	add	x0, x0, #0xd0
ffffffffea8079e0:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea8079e4:	f9401e63 	ldr	x3, [x19, #56]
ffffffffea8079e8:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea8079ec:	a903fe7f 	stp	xzr, xzr, [x19, #56]
ffffffffea8079f0:	94002628 	bl	ffffffffea811290 <vmm_free_region>
ffffffffea8079f4:	2a0003f4 	mov	w20, w0
	free(log);
ffffffffea8079f8:	aa1303e0 	mov	x0, x19
ffffffffea8079fc:	94002da7 	bl	ffffffffea813098 <free>
	return 0;
ffffffffea807a00:	7100029f 	cmp	w20, #0x0
ffffffffea807a04:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
}
ffffffffea807a08:	a94153f3 	ldp	x19, x20, [sp, #16]
	return 0;
ffffffffea807a0c:	9a9f1000 	csel	x0, x0, xzr, ne  // ne = any
}
ffffffffea807a10:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea807a14:	d65f03c0 	ret
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea807a18:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
}
ffffffffea807a1c:	d65f03c0 	ret

ffffffffea807a20 <memlog_stdcall>:
	switch (args->smc_nr) {
ffffffffea807a20:	b9400001 	ldr	w1, [x0]
ffffffffea807a24:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea807a28:	72a66002 	movk	w2, #0x3300, lsl #16
ffffffffea807a2c:	6b02003f 	cmp	w1, w2
ffffffffea807a30:	54000120 	b.eq	ffffffffea807a54 <memlog_stdcall+0x34>  // b.none
ffffffffea807a34:	11000442 	add	w2, w2, #0x1
ffffffffea807a38:	6b02003f 	cmp	w1, w2
ffffffffea807a3c:	54000140 	b.eq	ffffffffea807a64 <memlog_stdcall+0x44>  // b.none
ffffffffea807a40:	52a66000 	mov	w0, #0x33000000            	// #855638016
		return SM_ERR_UNDEFINED_SMC;
ffffffffea807a44:	6b00003f 	cmp	w1, w0
ffffffffea807a48:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
ffffffffea807a4c:	9a9f1400 	csinc	x0, x0, xzr, ne  // ne = any
}
ffffffffea807a50:	d65f03c0 	ret
		return memlog_add(args_get_pa(args), args_get_sz(args), args_get_guest(args));
ffffffffea807a54:	b9400c01 	ldr	w1, [x0, #12]
ffffffffea807a58:	b9401c02 	ldr	w2, [x0, #28]
ffffffffea807a5c:	f8404000 	ldur	x0, [x0, #4]
ffffffffea807a60:	17ffff4e 	b	ffffffffea807798 <memlog_add>
		return memlog_rm(args_get_pa(args));
ffffffffea807a64:	f8404000 	ldur	x0, [x0, #4]
ffffffffea807a68:	17ffffc0 	b	ffffffffea807968 <memlog_rm>
ffffffffea807a6c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807a70 <sm_sched_nonsecure>:
#include <lib/sm/sm_err.h>

#include <kernel/vm.h>

FUNCTION(sm_sched_nonsecure)
	push	x1, x30
ffffffffea807a70:	a9bf7be1 	stp	x1, x30, [sp, #-16]!
.Lfastcall_complete:
	mov	x1, x0
ffffffffea807a74:	aa0003e1 	mov	x1, x0
.Lreturn_sm_err:
	ldr	x0, =SMC_SC_NS_RETURN
ffffffffea807a78:	58000500 	ldr	x0, ffffffffea807b18 <smc_fastcall_secure_monitor+0x30>
	mov	x2, xzr
ffffffffea807a7c:	aa1f03e2 	mov	x2, xzr
	mov	x3, xzr
ffffffffea807a80:	aa1f03e3 	mov	x3, xzr
	smc	#0
ffffffffea807a84:	d4000003 	smc	#0x0

	tbnz	x0, #30, .Lsm_err_not_supported /* Check calling convention */
ffffffffea807a88:	37f00280 	tbnz	w0, #30, ffffffffea807ad8 <sm_sched_nonsecure+0x68>
	tbz	x0, #31, .Lnot_fast_call
ffffffffea807a8c:	36f801a0 	tbz	w0, #31, ffffffffea807ac0 <sm_sched_nonsecure+0x50>

	/* fastcall */
	sub	sp, sp, #(4 * SMC_NUM_ARGS) /* allocate smc32_args_t on stack */
ffffffffea807a90:	d10083ff 	sub	sp, sp, #0x20
	stp	w0, w1, [sp]
ffffffffea807a94:	290007e0 	stp	w0, w1, [sp]
	stp	w2, w3, [sp, #4 * 2]
ffffffffea807a98:	29010fe2 	stp	w2, w3, [sp, #8]
	stp	w4, w5, [sp, #4 * 4]
ffffffffea807a9c:	290217e4 	stp	w4, w5, [sp, #16]
	stp	w6, w7, [sp, #4 * 6]
ffffffffea807aa0:	29031fe6 	stp	w6, w7, [sp, #24]

	ubfx	x0, x0, #24, #6		/* x0 = entity */
ffffffffea807aa4:	d3587400 	ubfx	x0, x0, #24, #6
	ldr	x9, =sm_fastcall_table
ffffffffea807aa8:	580003c9 	ldr	x9, ffffffffea807b20 <smc_fastcall_secure_monitor+0x38>
	ldr	x9, [x9, x0, lsl #3]
ffffffffea807aac:	f8607929 	ldr	x9, [x9, x0, lsl #3]

	mov	x0, sp			/* x0 = smc_args_t* args */
ffffffffea807ab0:	910003e0 	mov	x0, sp
	blr	x9
ffffffffea807ab4:	d63f0120 	blr	x9
	add	sp, sp, #(4 * SMC_NUM_ARGS)
ffffffffea807ab8:	910083ff 	add	sp, sp, #0x20
	b	.Lfastcall_complete
ffffffffea807abc:	17ffffee 	b	ffffffffea807a74 <sm_sched_nonsecure+0x4>

.Lnot_fast_call:
	pop	x9, x30
ffffffffea807ac0:	a8c17be9 	ldp	x9, x30, [sp], #16
	stp	w0, w1, [x9], #8
ffffffffea807ac4:	28810520 	stp	w0, w1, [x9], #8
	stp	w2, w3, [x9], #8
ffffffffea807ac8:	28810d22 	stp	w2, w3, [x9], #8
	stp	w4, w5, [x9], #8
ffffffffea807acc:	28811524 	stp	w4, w5, [x9], #8
	stp	w6, w7, [x9], #8
ffffffffea807ad0:	28811d26 	stp	w6, w7, [x9], #8
	ret
ffffffffea807ad4:	d65f03c0 	ret

.Lsm_err_not_supported:
	mov	x1, #SM_ERR_NOT_SUPPORTED
ffffffffea807ad8:	928000e1 	mov	x1, #0xfffffffffffffff8    	// #-8
	b	.Lreturn_sm_err
ffffffffea807adc:	17ffffe7 	b	ffffffffea807a78 <sm_sched_nonsecure+0x8>

.Lsm_err_busy:
	mov	x1, #SM_ERR_BUSY
ffffffffea807ae0:	92800081 	mov	x1, #0xfffffffffffffffb    	// #-5
	b	.Lreturn_sm_err
ffffffffea807ae4:	17ffffe5 	b	ffffffffea807a78 <sm_sched_nonsecure+0x8>

ffffffffea807ae8 <smc_fastcall_secure_monitor>:

FUNCTION(smc_fastcall_secure_monitor)
	ldrh	w1, [x0]	/* r1 = function# */
ffffffffea807ae8:	79400001 	ldrh	w1, [x0]
	ldr	x2, =sm_nr_fastcall_functions
ffffffffea807aec:	580001e2 	ldr	x2, ffffffffea807b28 <smc_fastcall_secure_monitor+0x40>
	ldr	w2, [x2]
ffffffffea807af0:	b9400042 	ldr	w2, [x2]
	cmp	w1, w2
ffffffffea807af4:	6b02003f 	cmp	w1, w2
	bhs	.Lfastcall_smc_undefined
ffffffffea807af8:	540000a2 	b.cs	ffffffffea807b0c <smc_fastcall_secure_monitor+0x24>  // b.hs, b.nlast
	ldr	x2, =sm_fastcall_function_table
ffffffffea807afc:	580001a2 	ldr	x2, ffffffffea807b30 <smc_fastcall_secure_monitor+0x48>
	ldr	x2, [x2, x1, lsl#3]
ffffffffea807b00:	f8617842 	ldr	x2, [x2, x1, lsl #3]
	cbz	x2, .Lfastcall_smc_undefined
ffffffffea807b04:	b4000042 	cbz	x2, ffffffffea807b0c <smc_fastcall_secure_monitor+0x24>
	br	x2
ffffffffea807b08:	d61f0040 	br	x2
.Lfastcall_smc_undefined:
	ldr	x2, =smc_undefined
ffffffffea807b0c:	58000162 	ldr	x2, ffffffffea807b38 <smc_fastcall_secure_monitor+0x50>
	br	x2
ffffffffea807b10:	d61f0040 	br	x2
ffffffffea807b14:	00000000 	.inst	0x00000000 ; undefined
ffffffffea807b18:	3c000000 	.word	0x3c000000
ffffffffea807b1c:	00000000 	.word	0x00000000
ffffffffea807b20:	ea8186b0 	.word	0xea8186b0
ffffffffea807b24:	ffffffff 	.word	0xffffffff
ffffffffea807b28:	ea818ab0 	.word	0xea818ab0
ffffffffea807b2c:	ffffffff 	.word	0xffffffff
ffffffffea807b30:	ea818640 	.word	0xea818640
ffffffffea807b34:	ffffffff 	.word	0xffffffff
ffffffffea807b38:	ea8086a8 	.word	0xea8086a8
ffffffffea807b3c:	ffffffff 	.word	0xffffffff

ffffffffea807b40 <platform_halt>:
#include <lib/sm/sm_err.h>
#include <platform.h>

void platform_halt(platform_halt_action suggested_action,
                   platform_halt_reason reason)
{
ffffffffea807b40:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);

    dprintf(ALWAYS, "HALT: (reason = %d)\n", reason);
ffffffffea807b44:	f0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807b48:	910a4000 	add	x0, x0, #0x290
{
ffffffffea807b4c:	910003fd 	mov	x29, sp
    smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);
ffffffffea807b50:	a9017fbf 	stp	xzr, xzr, [x29, #16]
ffffffffea807b54:	a9027fbf 	stp	xzr, xzr, [x29, #32]
    dprintf(ALWAYS, "HALT: (reason = %d)\n", reason);
ffffffffea807b58:	9400272e 	bl	ffffffffea811810 <_dprintf>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea807b5c:	d50342df 	msr	daifset, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea807b60:	d50341df 	msr	daifset, #0x1
ffffffffea807b64:	d503201f 	nop
    arch_disable_ints();
    arch_disable_fiqs();
    while(true) {
        sm_sched_nonsecure(SM_ERR_PANIC, &args);
ffffffffea807b68:	910043a1 	add	x1, x29, #0x10
ffffffffea807b6c:	92800140 	mov	x0, #0xfffffffffffffff5    	// #-11
ffffffffea807b70:	97ffffc0 	bl	ffffffffea807a70 <sm_sched_nonsecure>
ffffffffea807b74:	17fffffd 	b	ffffffffea807b68 <platform_halt+0x28>

ffffffffea807b78 <sm_secondary_init>:
LK_INIT_HOOK_FLAGS(libsm_mon_perrcpu, sm_mon_percpu_init,
		   LK_INIT_LEVEL_PLATFORM - 3, LK_INIT_FLAG_ALL_CPUS);
#endif

static void sm_secondary_init(uint level)
{
ffffffffea807b78:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea807b7c:	910003fd 	mov	x29, sp
ffffffffea807b80:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea807b84:	f90013f5 	str	x21, [sp, #32]
	int cpu = arch_curr_cpu_num();

	event_init(&nsirqevent[cpu], false, EVENT_FLAG_AUTOUNSIGNAL);

	snprintf(name, sizeof(name), "irq-ns-switch-%d", cpu);
	nsirqthreads[cpu] = thread_create(name, sm_irq_loop, (void *)(uintptr_t)cpu,
ffffffffea807b88:	b00002b5 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
{
ffffffffea807b8c:	f9001bf7 	str	x23, [sp, #48]
ffffffffea807b90:	aa1e03f7 	mov	x23, x30
	int cpu = arch_curr_cpu_num();
ffffffffea807b94:	97ffebf7 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea807b98:	93407c14 	sxtw	x20, w0
	event_init(&nsirqevent[cpu], false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea807b9c:	b00002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807ba0:	9134a000 	add	x0, x0, #0xd28
ffffffffea807ba4:	52800603 	mov	w3, #0x30                  	// #48
	nsirqthreads[cpu] = thread_create(name, sm_irq_loop, (void *)(uintptr_t)cpu,
ffffffffea807ba8:	913aa2b5 	add	x21, x21, #0xea8
	event_init(&nsirqevent[cpu], false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea807bac:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea807bb0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea807bb4:	9b230280 	smaddl	x0, w20, w3, x0
ffffffffea807bb8:	97fff69c 	bl	ffffffffea805628 <event_init>
	snprintf(name, sizeof(name), "irq-ns-switch-%d", cpu);
ffffffffea807bbc:	2a1403e3 	mov	w3, w20
ffffffffea807bc0:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea807bc4:	f0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807bc8:	910103a0 	add	x0, x29, #0x40
ffffffffea807bcc:	91162042 	add	x2, x2, #0x588
ffffffffea807bd0:	94002cd6 	bl	ffffffffea812f28 <snprintf>
	nsirqthreads[cpu] = thread_create(name, sm_irq_loop, (void *)(uintptr_t)cpu,
ffffffffea807bd4:	b0000001 	adrp	x1, ffffffffea808000 <sm_return_and_wait_for_next_stdcall.isra.1+0x58>
ffffffffea807bd8:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea807bdc:	528003e3 	mov	w3, #0x1f                  	// #31
ffffffffea807be0:	aa1403e2 	mov	x2, x20
ffffffffea807be4:	91098021 	add	x1, x1, #0x260
ffffffffea807be8:	910103a0 	add	x0, x29, #0x40
ffffffffea807bec:	97fff957 	bl	ffffffffea806148 <thread_create>
ffffffffea807bf0:	f90017b6 	str	x22, [x29, #40]
ffffffffea807bf4:	f8347aa0 	str	x0, [x21, x20, lsl #3]
					  HIGHEST_PRIORITY, DEFAULT_STACK_SIZE);
	if (!nsirqthreads[cpu]) {
ffffffffea807bf8:	b4000540 	cbz	x0, ffffffffea807ca0 <sm_secondary_init+0x128>
ffffffffea807bfc:	aa0003e1 	mov	x1, x0
	}
	nsirqthreads[cpu]->pinned_cpu = cpu;
	thread_set_real_time(nsirqthreads[cpu]);

	snprintf(name, sizeof(name), "idle-ns-switch-%d", cpu);
	nsidlethreads[cpu] = thread_create(name,
ffffffffea807c00:	b00002b6 	adrp	x22, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807c04:	9133a2d6 	add	x22, x22, #0xce8
	nsirqthreads[cpu]->pinned_cpu = cpu;
ffffffffea807c08:	b9003c34 	str	w20, [x1, #60]
	thread_set_real_time(nsirqthreads[cpu]);
ffffffffea807c0c:	97fff957 	bl	ffffffffea806168 <thread_set_real_time>
	snprintf(name, sizeof(name), "idle-ns-switch-%d", cpu);
ffffffffea807c10:	2a1403e3 	mov	w3, w20
ffffffffea807c14:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea807c18:	f0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807c1c:	910103a0 	add	x0, x29, #0x40
ffffffffea807c20:	91176042 	add	x2, x2, #0x5d8
ffffffffea807c24:	94002cc1 	bl	ffffffffea812f28 <snprintf>
	nsidlethreads[cpu] = thread_create(name,
ffffffffea807c28:	b0000001 	adrp	x1, ffffffffea808000 <sm_return_and_wait_for_next_stdcall.isra.1+0x58>
ffffffffea807c2c:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea807c30:	91046021 	add	x1, x1, #0x118
ffffffffea807c34:	52800023 	mov	w3, #0x1                   	// #1
ffffffffea807c38:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea807c3c:	910103a0 	add	x0, x29, #0x40
ffffffffea807c40:	97fff942 	bl	ffffffffea806148 <thread_create>
ffffffffea807c44:	f8347ac0 	str	x0, [x22, x20, lsl #3]
ffffffffea807c48:	aa0003e1 	mov	x1, x0
			(thread_start_routine)sm_wait_for_smcall,
			NULL, LOWEST_PRIORITY + 1, DEFAULT_STACK_SIZE);
	if (!nsidlethreads[cpu]) {
ffffffffea807c4c:	b4000200 	cbz	x0, ffffffffea807c8c <sm_secondary_init+0x114>
		panic("failed to create idle NS switcher thread for cpu %d!\n", cpu);
	}
	nsidlethreads[cpu]->pinned_cpu = cpu;
ffffffffea807c50:	b9003c34 	str	w20, [x1, #60]
	thread_set_real_time(nsidlethreads[cpu]);
ffffffffea807c54:	97fff945 	bl	ffffffffea806168 <thread_set_real_time>

	if (ns_threads_started) {
ffffffffea807c58:	b00002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807c5c:	39738000 	ldrb	w0, [x0, #3296]
ffffffffea807c60:	340000a0 	cbz	w0, ffffffffea807c74 <sm_secondary_init+0xfc>
		thread_resume(nsirqthreads[cpu]);
ffffffffea807c64:	f8747aa0 	ldr	x0, [x21, x20, lsl #3]
ffffffffea807c68:	97fff998 	bl	ffffffffea8062c8 <thread_resume>
		thread_resume(nsidlethreads[cpu]);
ffffffffea807c6c:	f8747ac0 	ldr	x0, [x22, x20, lsl #3]
ffffffffea807c70:	97fff996 	bl	ffffffffea8062c8 <thread_resume>
	}
}
ffffffffea807c74:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807c78:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea807c7c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea807c80:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea807c84:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea807c88:	d65f03c0 	ret
		panic("failed to create idle NS switcher thread for cpu %d!\n", cpu);
ffffffffea807c8c:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807c90:	2a1403e2 	mov	w2, w20
ffffffffea807c94:	9117c021 	add	x1, x1, #0x5f0
ffffffffea807c98:	aa1703e0 	mov	x0, x23
ffffffffea807c9c:	9400275b 	bl	ffffffffea811a08 <_panic>
		panic("failed to create irq NS switcher thread for cpu %d!\n", cpu);
ffffffffea807ca0:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807ca4:	2a1403e2 	mov	w2, w20
ffffffffea807ca8:	91168021 	add	x1, x1, #0x5a0
ffffffffea807cac:	aa1703e0 	mov	x0, x23
ffffffffea807cb0:	94002756 	bl	ffffffffea811a08 <_panic>
ffffffffea807cb4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807cb8 <resume_nsthreads>:
	mutex_release(&boot_args_lock);
	return err;
}

static void resume_nsthreads(void)
{
ffffffffea807cb8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	int i;

	ns_threads_started = true;
ffffffffea807cbc:	b00002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807cc0:	52800021 	mov	w1, #0x1                   	// #1
{
ffffffffea807cc4:	910003fd 	mov	x29, sp
ffffffffea807cc8:	a90153f3 	stp	x19, x20, [sp, #16]
	ns_threads_started = true;
ffffffffea807ccc:	39338001 	strb	w1, [x0, #3296]
{
ffffffffea807cd0:	f90013f5 	str	x21, [sp, #32]
	smp_wmb();
ffffffffea807cd4:	d5033abf 	dmb	ishst
ffffffffea807cd8:	b00002b5 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807cdc:	b00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
	for (i = 0; i < SMP_MAX_CPUS; i++) {
		if (nsirqthreads[i]) {
ffffffffea807ce0:	913aa2b5 	add	x21, x21, #0xea8
			thread_resume(nsirqthreads[i]);
		}
		if (nsidlethreads[i]) {
ffffffffea807ce4:	9133a294 	add	x20, x20, #0xce8
	smp_wmb();
ffffffffea807ce8:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea807cec:	d503201f 	nop
		if (nsirqthreads[i]) {
ffffffffea807cf0:	f8756a61 	ldr	x1, [x19, x21]
			thread_resume(nsirqthreads[i]);
ffffffffea807cf4:	aa0103e0 	mov	x0, x1
		if (nsirqthreads[i]) {
ffffffffea807cf8:	b4000041 	cbz	x1, ffffffffea807d00 <resume_nsthreads+0x48>
			thread_resume(nsirqthreads[i]);
ffffffffea807cfc:	97fff973 	bl	ffffffffea8062c8 <thread_resume>
		if (nsidlethreads[i]) {
ffffffffea807d00:	f8746a61 	ldr	x1, [x19, x20]
ffffffffea807d04:	91002273 	add	x19, x19, #0x8
			thread_resume(nsidlethreads[i]);
ffffffffea807d08:	aa0103e0 	mov	x0, x1
		if (nsidlethreads[i]) {
ffffffffea807d0c:	b4000041 	cbz	x1, ffffffffea807d14 <resume_nsthreads+0x5c>
			thread_resume(nsidlethreads[i]);
ffffffffea807d10:	97fff96e 	bl	ffffffffea8062c8 <thread_resume>
	for (i = 0; i < SMP_MAX_CPUS; i++) {
ffffffffea807d14:	f101027f 	cmp	x19, #0x40
ffffffffea807d18:	54fffec1 	b.ne	ffffffffea807cf0 <resume_nsthreads+0x38>  // b.any
		}
	}
}
ffffffffea807d1c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807d20:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea807d24:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea807d28:	d65f03c0 	ret
ffffffffea807d2c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807d30 <sm_init>:
{
ffffffffea807d30:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
void mutex_destroy(mutex_t *);
status_t mutex_acquire_timeout(mutex_t *, lk_time_t); /* try to acquire the mutex with a timeout value */
status_t mutex_release(mutex_t *);

static inline status_t mutex_acquire(mutex_t *m) {
	return mutex_acquire_timeout(m, INFINITE_TIME);
ffffffffea807d34:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea807d38:	910003fd 	mov	x29, sp
ffffffffea807d3c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea807d40:	b0000094 	adrp	x20, ffffffffea818000 <_mem_phys_base>
ffffffffea807d44:	f90013f5 	str	x21, [sp, #32]
ffffffffea807d48:	91164280 	add	x0, x20, #0x590
ffffffffea807d4c:	aa1e03f5 	mov	x21, x30
ffffffffea807d50:	97fff6e6 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	if (lk_boot_args[1] && lk_boot_args[2]) {
ffffffffea807d54:	d00002b3 	adrp	x19, ffffffffea85d000 <rb_data+0x18>
ffffffffea807d58:	91010260 	add	x0, x19, #0x40
ffffffffea807d5c:	f9400405 	ldr	x5, [x0, #8]
ffffffffea807d60:	b4000065 	cbz	x5, ffffffffea807d6c <sm_init+0x3c>
ffffffffea807d64:	f9400802 	ldr	x2, [x0, #16]
ffffffffea807d68:	b5000442 	cbnz	x2, ffffffffea807df0 <sm_init+0xc0>
	if ((void *)lk_boot_args[3] != NULL){
ffffffffea807d6c:	91010273 	add	x19, x19, #0x40
ffffffffea807d70:	f9400e60 	ldr	x0, [x19, #24]
ffffffffea807d74:	b50002a0 	cbnz	x0, ffffffffea807dc8 <sm_init+0x98>
	stdcallthread = thread_create("sm-stdcall", sm_stdcall_loop, NULL,
ffffffffea807d78:	b00002b3 	adrp	x19, ffffffffea85c000 <idle_threads+0xeb0>
	mutex_release(&boot_args_lock);
ffffffffea807d7c:	91164280 	add	x0, x20, #0x590
ffffffffea807d80:	97fff706 	bl	ffffffffea805998 <mutex_release>
	stdcallthread = thread_create("sm-stdcall", sm_stdcall_loop, NULL,
ffffffffea807d84:	b0000001 	adrp	x1, ffffffffea808000 <sm_return_and_wait_for_next_stdcall.isra.1+0x58>
ffffffffea807d88:	f0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807d8c:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea807d90:	52800043 	mov	w3, #0x2                   	// #2
ffffffffea807d94:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea807d98:	910ac021 	add	x1, x1, #0x2b0
ffffffffea807d9c:	91118000 	add	x0, x0, #0x460
ffffffffea807da0:	97fff8ea 	bl	ffffffffea806148 <thread_create>
ffffffffea807da4:	f9078260 	str	x0, [x19, #3840]
	if (!stdcallthread) {
ffffffffea807da8:	b40006e0 	cbz	x0, ffffffffea807e84 <sm_init+0x154>
	thread_set_real_time(stdcallthread);
ffffffffea807dac:	97fff8ef 	bl	ffffffffea806168 <thread_set_real_time>
	thread_resume(stdcallthread);
ffffffffea807db0:	f9478260 	ldr	x0, [x19, #3840]
ffffffffea807db4:	97fff945 	bl	ffffffffea8062c8 <thread_resume>
}
ffffffffea807db8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea807dbc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807dc0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea807dc4:	d65f03c0 	ret
		ret = tegra_boot_profiler_init(lk_boot_args[3]);
ffffffffea807dc8:	97fffe00 	bl	ffffffffea8075c8 <tegra_boot_profiler_init>
		if(ret) {
ffffffffea807dcc:	34fffd60 	cbz	w0, ffffffffea807d78 <sm_init+0x48>
			TRACEF("Error mapping Profiler boot parameter block: %d\n", ret);
ffffffffea807dd0:	f0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807dd4:	2a0003e3 	mov	w3, w0
ffffffffea807dd8:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807ddc:	528035c2 	mov	w2, #0x1ae                 	// #430
ffffffffea807de0:	910b6021 	add	x1, x1, #0x2d8
ffffffffea807de4:	9110a080 	add	x0, x4, #0x428
ffffffffea807de8:	94002c6e 	bl	ffffffffea812fa0 <_printf>
ffffffffea807dec:	17ffffe3 	b	ffffffffea807d78 <sm_init+0x48>
ffffffffea807df0:	f90017b6 	str	x22, [x29, #40]
		size_t size   = ROUNDUP(lk_boot_args[2] + offset, PAGE_SIZE);
ffffffffea807df4:	913ffc42 	add	x2, x2, #0xfff
		ulong offset = lk_boot_args[1] & (PAGE_SIZE - 1);
ffffffffea807df8:	92402cb6 	and	x22, x5, #0xfff
		err = vmm_alloc_physical(vmm_get_kernel_aspace(), "sm",
ffffffffea807dfc:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
		size_t size   = ROUNDUP(lk_boot_args[2] + offset, PAGE_SIZE);
ffffffffea807e00:	8b160042 	add	x2, x2, x22
		err = vmm_alloc_physical(vmm_get_kernel_aspace(), "sm",
ffffffffea807e04:	d00002a0 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
ffffffffea807e08:	52800607 	mov	w7, #0x30                  	// #48
ffffffffea807e0c:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea807e10:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea807e14:	9100e3a3 	add	x3, x29, #0x38
ffffffffea807e18:	910fa021 	add	x1, x1, #0x3e8
ffffffffea807e1c:	91034000 	add	x0, x0, #0xd0
ffffffffea807e20:	9274cca5 	and	x5, x5, #0xfffffffffffff000
ffffffffea807e24:	9274cc42 	and	x2, x2, #0xfffffffffffff000
ffffffffea807e28:	940024b8 	bl	ffffffffea811108 <vmm_alloc_physical>
		if (!err) {
ffffffffea807e2c:	35000160 	cbnz	w0, ffffffffea807e58 <sm_init+0x128>
			boot_args_refcnt++;
ffffffffea807e30:	b00002a2 	adrp	x2, ffffffffea85c000 <idle_threads+0xeb0>
			boot_args = (uint8_t *)vptr + offset;
ffffffffea807e34:	b00002a3 	adrp	x3, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807e38:	f9401fa1 	ldr	x1, [x29, #56]
			boot_args_refcnt++;
ffffffffea807e3c:	b94cd040 	ldr	w0, [x2, #3280]
			boot_args = (uint8_t *)vptr + offset;
ffffffffea807e40:	8b160021 	add	x1, x1, x22
ffffffffea807e44:	f94017b6 	ldr	x22, [x29, #40]
			boot_args_refcnt++;
ffffffffea807e48:	11000400 	add	w0, w0, #0x1
			boot_args = (uint8_t *)vptr + offset;
ffffffffea807e4c:	f9066461 	str	x1, [x3, #3272]
			boot_args_refcnt++;
ffffffffea807e50:	b90cd040 	str	w0, [x2, #3280]
ffffffffea807e54:	17ffffc6 	b	ffffffffea807d6c <sm_init+0x3c>
			boot_args = NULL;
ffffffffea807e58:	b00002a2 	adrp	x2, ffffffffea85c000 <idle_threads+0xeb0>
			TRACEF("Error mapping initial boot parameter block: %d\n", err);
ffffffffea807e5c:	f0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807e60:	2a0003e3 	mov	w3, w0
ffffffffea807e64:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
			boot_args = NULL;
ffffffffea807e68:	f906645f 	str	xzr, [x2, #3272]
			TRACEF("Error mapping initial boot parameter block: %d\n", err);
ffffffffea807e6c:	910b6021 	add	x1, x1, #0x2d8
ffffffffea807e70:	52803422 	mov	w2, #0x1a1                 	// #417
ffffffffea807e74:	910fc080 	add	x0, x4, #0x3f0
ffffffffea807e78:	94002c4a 	bl	ffffffffea812fa0 <_printf>
ffffffffea807e7c:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea807e80:	17ffffbb 	b	ffffffffea807d6c <sm_init+0x3c>
		panic("failed to create sm-stdcall thread!\n");
ffffffffea807e84:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807e88:	aa1503e0 	mov	x0, x21
ffffffffea807e8c:	9111c021 	add	x1, x1, #0x470
ffffffffea807e90:	f90017b6 	str	x22, [x29, #40]
ffffffffea807e94:	940026dd 	bl	ffffffffea811a08 <_panic>

ffffffffea807e98 <sm_get_api_version>:
{
ffffffffea807e98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea807e9c:	910003fd 	mov	x29, sp
ffffffffea807ea0:	a90153f3 	stp	x19, x20, [sp, #16]
	if (!sm_api_version_locked) {
ffffffffea807ea4:	b00002b3 	adrp	x19, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807ea8:	b00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807eac:	397be260 	ldrb	w0, [x19, #3832]
ffffffffea807eb0:	340000a0 	cbz	w0, ffffffffea807ec4 <sm_get_api_version+0x2c>
	return sm_api_version;
ffffffffea807eb4:	b94eea80 	ldr	w0, [x20, #3816]
}
ffffffffea807eb8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807ebc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea807ec0:	d65f03c0 	ret
ffffffffea807ec4:	a9025bb5 	stp	x21, x22, [x29, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea807ec8:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea807ecc:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea807ed0:	37380060 	tbnz	w0, #7, ffffffffea807edc <sm_get_api_version+0x44>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea807ed4:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea807ed8:	52800035 	mov	w21, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea807edc:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea807ee0:	37300360 	tbnz	w0, #6, ffffffffea807f4c <sm_get_api_version+0xb4>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea807ee4:	321f02b5 	orr	w21, w21, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea807ee8:	d50341df 	msr	daifset, #0x1
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea807eec:	b00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
    arch_spin_lock(lock);
ffffffffea807ef0:	b00002b6 	adrp	x22, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807ef4:	913bc2d6 	add	x22, x22, #0xef0
ffffffffea807ef8:	aa1603e0 	mov	x0, x22
ffffffffea807efc:	97ffea98 	bl	ffffffffea80295c <arch_spin_lock>
ffffffffea807f00:	b94eea83 	ldr	w3, [x20, #3816]
		sm_api_version_locked = true;
ffffffffea807f04:	52800024 	mov	w4, #0x1                   	// #1
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea807f08:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807f0c:	910b0021 	add	x1, x1, #0x2c0
ffffffffea807f10:	52800e42 	mov	w2, #0x72                  	// #114
		sm_api_version_locked = true;
ffffffffea807f14:	393be264 	strb	w4, [x19, #3832]
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea807f18:	f0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807f1c:	910d8000 	add	x0, x0, #0x360
ffffffffea807f20:	94002c20 	bl	ffffffffea812fa0 <_printf>
    arch_spin_unlock(lock);
ffffffffea807f24:	aa1603e0 	mov	x0, x22
ffffffffea807f28:	97ffea95 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea807f2c:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea807f30:	36000315 	tbz	w21, #0, ffffffffea807f90 <sm_get_api_version+0xf8>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea807f34:	d50342ff 	msr	daifclr, #0x2
	return sm_api_version;
ffffffffea807f38:	b94eea80 	ldr	w0, [x20, #3816]
ffffffffea807f3c:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea807f40:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807f44:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea807f48:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea807f4c:	b00002b6 	adrp	x22, ffffffffea85c000 <idle_threads+0xeb0>
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea807f50:	b00002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea807f54:	913bc2d6 	add	x22, x22, #0xef0
ffffffffea807f58:	aa1603e0 	mov	x0, x22
ffffffffea807f5c:	97ffea80 	bl	ffffffffea80295c <arch_spin_lock>
ffffffffea807f60:	b94eea83 	ldr	w3, [x20, #3816]
		sm_api_version_locked = true;
ffffffffea807f64:	52800024 	mov	w4, #0x1                   	// #1
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea807f68:	f0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807f6c:	910b0021 	add	x1, x1, #0x2c0
ffffffffea807f70:	52800e42 	mov	w2, #0x72                  	// #114
ffffffffea807f74:	f0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
		sm_api_version_locked = true;
ffffffffea807f78:	393be264 	strb	w4, [x19, #3832]
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea807f7c:	910d8000 	add	x0, x0, #0x360
ffffffffea807f80:	94002c08 	bl	ffffffffea812fa0 <_printf>
    arch_spin_unlock(lock);
ffffffffea807f84:	aa1603e0 	mov	x0, x22
ffffffffea807f88:	97ffea7d 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea807f8c:	3707fd55 	tbnz	w21, #0, ffffffffea807f34 <sm_get_api_version+0x9c>
	return sm_api_version;
ffffffffea807f90:	b94eea80 	ldr	w0, [x20, #3816]
ffffffffea807f94:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea807f98:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807f9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea807fa0:	d65f03c0 	ret
ffffffffea807fa4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807fa8 <sm_return_and_wait_for_next_stdcall.isra.1>:
static void sm_return_and_wait_for_next_stdcall(long ret, int cpu)
ffffffffea807fa8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea807fac:	910003fd 	mov	x29, sp
ffffffffea807fb0:	a90153f3 	stp	x19, x20, [sp, #16]
		if (args.smc_nr == SMC_SC_NOP) {
ffffffffea807fb4:	52800073 	mov	w19, #0x3                   	// #3
static void sm_return_and_wait_for_next_stdcall(long ret, int cpu)
ffffffffea807fb8:	a9025bf5 	stp	x21, x22, [sp, #32]
		if (args.smc_nr == SMC_SC_NOP) {
ffffffffea807fbc:	72a78013 	movk	w19, #0x3c00, lsl #16
    arch_spin_lock(lock);
ffffffffea807fc0:	b0000095 	adrp	x21, ffffffffea818000 <_mem_phys_base>
		dprintf(CRITICAL, "%s: cpu %d, std call busy\n", __func__, cpu);
ffffffffea807fc4:	f0000076 	adrp	x22, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea807fc8:	911722b4 	add	x20, x21, #0x5c8
ffffffffea807fcc:	910cc2d6 	add	x22, x22, #0x330
	smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);
ffffffffea807fd0:	a9047fbf 	stp	xzr, xzr, [x29, #64]
ffffffffea807fd4:	a9057fbf 	stp	xzr, xzr, [x29, #80]
static void sm_return_and_wait_for_next_stdcall(long ret, int cpu)
ffffffffea807fd8:	f9001bf7 	str	x23, [sp, #48]
ffffffffea807fdc:	14000006 	b	ffffffffea807ff4 <sm_return_and_wait_for_next_stdcall.isra.1+0x4c>
			ret = sm_nopcall_table[SMC_ENTITY(args.params[0])](&args);
ffffffffea807fe0:	39411fa2 	ldrb	w2, [x29, #71]
ffffffffea807fe4:	92401442 	and	x2, x2, #0x3f
ffffffffea807fe8:	f8627821 	ldr	x1, [x1, x2, lsl #3]
ffffffffea807fec:	d63f0020 	blr	x1
	} while (ret);
ffffffffea807ff0:	b40003e0 	cbz	x0, ffffffffea80806c <sm_return_and_wait_for_next_stdcall.isra.1+0xc4>
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea807ff4:	d50341df 	msr	daifset, #0x1
		sm_sched_nonsecure(ret, &args);
ffffffffea807ff8:	910103a1 	add	x1, x29, #0x40
ffffffffea807ffc:	97fffe9d 	bl	ffffffffea807a70 <sm_sched_nonsecure>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea808000:	d50341ff 	msr	daifclr, #0x1
		if (args.smc_nr == SMC_SC_NOP) {
ffffffffea808004:	b94043a2 	ldr	w2, [x29, #64]
			ret = sm_nopcall_table[SMC_ENTITY(args.params[0])](&args);
ffffffffea808008:	90000081 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea80800c:	910103a0 	add	x0, x29, #0x40
ffffffffea808010:	9122c021 	add	x1, x1, #0x8b0
		if (args.smc_nr == SMC_SC_NOP) {
ffffffffea808014:	6b13005f 	cmp	w2, w19
ffffffffea808018:	54fffe40 	b.eq	ffffffffea807fe0 <sm_return_and_wait_for_next_stdcall.isra.1+0x38>  // b.none
	uint cpu = arch_curr_cpu_num();
ffffffffea80801c:	97ffead5 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea808020:	2a0003f7 	mov	w23, w0
ffffffffea808024:	aa1403e0 	mov	x0, x20
ffffffffea808028:	97ffea4d 	bl	ffffffffea80295c <arch_spin_lock>
	if (stdcallstate.event.signalled || stdcallstate.done) {
ffffffffea80802c:	39403280 	ldrb	w0, [x20, #12]
ffffffffea808030:	34000280 	cbz	w0, ffffffffea808080 <sm_return_and_wait_for_next_stdcall.isra.1+0xd8>
ffffffffea808034:	b94043a0 	ldr	w0, [x29, #64]
		if (args->smc_nr == SMC_SC_RESTART_LAST && stdcallstate.active_cpu == -1) {
ffffffffea808038:	52a78001 	mov	w1, #0x3c000000            	// #1006632960
ffffffffea80803c:	6b01001f 	cmp	w0, w1
ffffffffea808040:	54000441 	b.ne	ffffffffea8080c8 <sm_return_and_wait_for_next_stdcall.isra.1+0x120>  // b.any
ffffffffea808044:	b9406680 	ldr	w0, [x20, #100]
ffffffffea808048:	3100041f 	cmn	w0, #0x1
ffffffffea80804c:	540003e1 	b.ne	ffffffffea8080c8 <sm_return_and_wait_for_next_stdcall.isra.1+0x120>  // b.any
			stdcallstate.restart_count++;
ffffffffea808050:	b9407280 	ldr	w0, [x20, #112]
ffffffffea808054:	11000400 	add	w0, w0, #0x1
ffffffffea808058:	b9007280 	str	w0, [x20, #112]
	stdcallstate.active_cpu = cpu;
ffffffffea80805c:	911722b5 	add	x21, x21, #0x5c8
    arch_spin_unlock(lock);
ffffffffea808060:	aa1503e0 	mov	x0, x21
ffffffffea808064:	b90066b7 	str	w23, [x21, #100]
ffffffffea808068:	97ffea45 	bl	ffffffffea80297c <arch_spin_unlock>
}
ffffffffea80806c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808070:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea808074:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea808078:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80807c:	d65f03c0 	ret
	if (stdcallstate.event.signalled || stdcallstate.done) {
ffffffffea808080:	39418281 	ldrb	w1, [x20, #96]
		if (args->smc_nr == SMC_SC_RESTART_LAST) {
ffffffffea808084:	52a78002 	mov	w2, #0x3c000000            	// #1006632960
ffffffffea808088:	b94043a0 	ldr	w0, [x29, #64]
ffffffffea80808c:	6b02001f 	cmp	w0, w2
	if (stdcallstate.event.signalled || stdcallstate.done) {
ffffffffea808090:	35fffd41 	cbnz	w1, ffffffffea808038 <sm_return_and_wait_for_next_stdcall.isra.1+0x90>
		if (args->smc_nr == SMC_SC_RESTART_LAST) {
ffffffffea808094:	540002c0 	b.eq	ffffffffea8080ec <sm_return_and_wait_for_next_stdcall.isra.1+0x144>  // b.none
	stdcallstate.args = *args;
ffffffffea808098:	a94417a4 	ldp	x4, x5, [x29, #64]
	stdcallstate.ret = SM_ERR_INTERNAL_FAILURE;
ffffffffea80809c:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
	stdcallstate.args = *args;
ffffffffea8080a0:	a9450fa2 	ldp	x2, x3, [x29, #80]
ffffffffea8080a4:	a9039684 	stp	x4, x5, [x20, #56]
ffffffffea8080a8:	a9048e82 	stp	x2, x3, [x20, #72]
	event_signal(&stdcallstate.event, false);
ffffffffea8080ac:	52800001 	mov	w1, #0x0                   	// #0
	stdcallstate.ret = SM_ERR_INTERNAL_FAILURE;
ffffffffea8080b0:	f9002e80 	str	x0, [x20, #88]
	event_signal(&stdcallstate.event, false);
ffffffffea8080b4:	91002280 	add	x0, x20, #0x8
	stdcallstate.initial_cpu = cpu;
ffffffffea8080b8:	b9006a97 	str	w23, [x20, #104]
	stdcallstate.restart_count = 0;
ffffffffea8080bc:	b900729f 	str	wzr, [x20, #112]
	event_signal(&stdcallstate.event, false);
ffffffffea8080c0:	97fff5b4 	bl	ffffffffea805790 <event_signal>
ffffffffea8080c4:	17ffffe6 	b	ffffffffea80805c <sm_return_and_wait_for_next_stdcall.isra.1+0xb4>
		dprintf(CRITICAL, "%s: cpu %d, std call busy\n", __func__, cpu);
ffffffffea8080c8:	2a1703e2 	mov	w2, w23
ffffffffea8080cc:	aa1603e1 	mov	x1, x22
ffffffffea8080d0:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8080d4:	9114c000 	add	x0, x0, #0x530
ffffffffea8080d8:	940025ce 	bl	ffffffffea811810 <_dprintf>
ffffffffea8080dc:	aa1403e0 	mov	x0, x20
ffffffffea8080e0:	97ffea27 	bl	ffffffffea80297c <arch_spin_unlock>
		ret = SM_ERR_BUSY;
ffffffffea8080e4:	92800080 	mov	x0, #0xfffffffffffffffb    	// #-5
ffffffffea8080e8:	17ffffc3 	b	ffffffffea807ff4 <sm_return_and_wait_for_next_stdcall.isra.1+0x4c>
			dprintf(CRITICAL, "%s: cpu %d, unexpected restart, no std call active\n",
ffffffffea8080ec:	97ffeaa1 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea8080f0:	2a0003e2 	mov	w2, w0
ffffffffea8080f4:	aa1603e1 	mov	x1, x22
ffffffffea8080f8:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8080fc:	91154000 	add	x0, x0, #0x550
ffffffffea808100:	940025c4 	bl	ffffffffea811810 <_dprintf>
ffffffffea808104:	aa1403e0 	mov	x0, x20
ffffffffea808108:	97ffea1d 	bl	ffffffffea80297c <arch_spin_unlock>
			ret = SM_ERR_UNEXPECTED_RESTART;
ffffffffea80810c:	92800060 	mov	x0, #0xfffffffffffffffc    	// #-4
ffffffffea808110:	17ffffb9 	b	ffffffffea807ff4 <sm_return_and_wait_for_next_stdcall.isra.1+0x4c>
ffffffffea808114:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808118 <sm_wait_for_smcall>:
{
ffffffffea808118:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80811c:	910003fd 	mov	x29, sp
ffffffffea808120:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea808124:	90000093 	adrp	x19, ffffffffea818000 <_mem_phys_base>
ffffffffea808128:	a9025bf5 	stp	x21, x22, [sp, #32]
		if (cpu == stdcallstate.active_cpu) {
ffffffffea80812c:	91172273 	add	x19, x19, #0x5c8
{
ffffffffea808130:	a90363f7 	stp	x23, x24, [sp, #48]
	stdcallstate.active_cpu = -1;
ffffffffea808134:	12800015 	mov	w21, #0xffffffff            	// #-1
ffffffffea808138:	d0000078 	adrp	x24, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80813c:	d0000077 	adrp	x23, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
			ret = SM_ERR_INTERRUPTED;
ffffffffea808140:	92800096 	mov	x22, #0xfffffffffffffffb    	// #-5
ffffffffea808144:	14000004 	b	ffffffffea808154 <sm_wait_for_smcall+0x3c>
		sm_return_and_wait_for_next_stdcall(ret, cpu);
ffffffffea808148:	aa1403e0 	mov	x0, x20
ffffffffea80814c:	97ffff97 	bl	ffffffffea807fa8 <sm_return_and_wait_for_next_stdcall.isra.1>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea808150:	d50342ff 	msr	daifclr, #0x2
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea808154:	d50342df 	msr	daifset, #0x2
		thread_yield();
ffffffffea808158:	97fff832 	bl	ffffffffea806220 <thread_yield>
			ret = SM_ERR_NOP_DONE;
ffffffffea80815c:	928001d4 	mov	x20, #0xfffffffffffffff1    	// #-15
		cpu = arch_curr_cpu_num();
ffffffffea808160:	97ffea84 	bl	ffffffffea802b70 <arch_curr_cpu_num>
		if (cpu == stdcallstate.active_cpu) {
ffffffffea808164:	b9406661 	ldr	w1, [x19, #100]
ffffffffea808168:	6b00003f 	cmp	w1, w0
ffffffffea80816c:	54fffee1 	b.ne	ffffffffea808148 <sm_wait_for_smcall+0x30>  // b.any
	uint cpu = arch_curr_cpu_num();
ffffffffea808170:	97ffea80 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea808174:	2a0003f4 	mov	w20, w0
    arch_spin_lock(lock);
ffffffffea808178:	aa1303e0 	mov	x0, x19
ffffffffea80817c:	97ffe9f8 	bl	ffffffffea80295c <arch_spin_lock>
	if (stdcallstate.active_cpu != (int)cpu) {
ffffffffea808180:	b9406662 	ldr	w2, [x19, #100]
ffffffffea808184:	6b14005f 	cmp	w2, w20
ffffffffea808188:	54000241 	b.ne	ffffffffea8081d0 <sm_wait_for_smcall+0xb8>  // b.any
	if (stdcallstate.done) {
ffffffffea80818c:	39418260 	ldrb	w0, [x19, #96]
	stdcallstate.active_cpu = -1;
ffffffffea808190:	b9006675 	str	w21, [x19, #100]
	stdcallstate.last_cpu = stdcallstate.active_cpu;
ffffffffea808194:	b9006e62 	str	w2, [x19, #108]
	if (stdcallstate.done) {
ffffffffea808198:	340000c0 	cbz	w0, ffffffffea8081b0 <sm_wait_for_smcall+0x98>
		ret = stdcallstate.ret;
ffffffffea80819c:	f9402e74 	ldr	x20, [x19, #88]
		stdcallstate.done = false;
ffffffffea8081a0:	3901827f 	strb	wzr, [x19, #96]
    arch_spin_unlock(lock);
ffffffffea8081a4:	aa1303e0 	mov	x0, x19
ffffffffea8081a8:	97ffe9f5 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea8081ac:	17ffffe7 	b	ffffffffea808148 <sm_wait_for_smcall+0x30>
		if (sm_get_api_version() >= TRUSTY_API_VERSION_SMP) {/* ns using new api */
ffffffffea8081b0:	97ffff3a 	bl	ffffffffea807e98 <sm_get_api_version>
ffffffffea8081b4:	7100041f 	cmp	w0, #0x1
ffffffffea8081b8:	540001a8 	b.hi	ffffffffea8081ec <sm_wait_for_smcall+0xd4>  // b.pmore
		} else if (stdcallstate.restart_count) {
ffffffffea8081bc:	b9407260 	ldr	w0, [x19, #112]
			ret = SM_ERR_INTERRUPTED;
ffffffffea8081c0:	92800054 	mov	x20, #0xfffffffffffffffd    	// #-3
ffffffffea8081c4:	7100001f 	cmp	w0, #0x0
ffffffffea8081c8:	9a9412d4 	csel	x20, x22, x20, ne  // ne = any
ffffffffea8081cc:	17fffff6 	b	ffffffffea8081a4 <sm_wait_for_smcall+0x8c>
		dprintf(CRITICAL, "%s: stdcallcpu, a%d != curr-cpu %d, l%d, i%d\n",
ffffffffea8081d0:	294d1265 	ldp	w5, w4, [x19, #104]
ffffffffea8081d4:	2a1403e3 	mov	w3, w20
ffffffffea8081d8:	910d2301 	add	x1, x24, #0x348
ffffffffea8081dc:	9118a2e0 	add	x0, x23, #0x628
		ret = SM_ERR_INTERNAL_FAILURE;
ffffffffea8081e0:	928000d4 	mov	x20, #0xfffffffffffffff9    	// #-7
		dprintf(CRITICAL, "%s: stdcallcpu, a%d != curr-cpu %d, l%d, i%d\n",
ffffffffea8081e4:	9400258b 	bl	ffffffffea811810 <_dprintf>
ffffffffea8081e8:	17ffffef 	b	ffffffffea8081a4 <sm_wait_for_smcall+0x8c>
			ret = SM_ERR_CPU_IDLE;
ffffffffea8081ec:	92800194 	mov	x20, #0xfffffffffffffff3    	// #-13
ffffffffea8081f0:	17ffffed 	b	ffffffffea8081a4 <sm_wait_for_smcall+0x8c>
ffffffffea8081f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8081f8 <sm_irq_return_ns>:
{
ffffffffea8081f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8081fc:	910003fd 	mov	x29, sp
ffffffffea808200:	a90153f3 	stp	x19, x20, [sp, #16]
    arch_spin_lock(lock);
ffffffffea808204:	90000094 	adrp	x20, ffffffffea818000 <_mem_phys_base>
ffffffffea808208:	91172293 	add	x19, x20, #0x5c8
ffffffffea80820c:	a9025bf5 	stp	x21, x22, [sp, #32]
	cpu = arch_curr_cpu_num();
ffffffffea808210:	97ffea58 	bl	ffffffffea802b70 <arch_curr_cpu_num>
ffffffffea808214:	2a0003f6 	mov	w22, w0
ffffffffea808218:	aa1303e0 	mov	x0, x19
ffffffffea80821c:	97ffe9d0 	bl	ffffffffea80295c <arch_spin_lock>
	if (stdcallstate.active_cpu == cpu) {
ffffffffea808220:	b9406660 	ldr	w0, [x19, #100]
ffffffffea808224:	928001b5 	mov	x21, #0xfffffffffffffff2    	// #-14
ffffffffea808228:	6b16001f 	cmp	w0, w22
ffffffffea80822c:	540000a1 	b.ne	ffffffffea808240 <sm_irq_return_ns+0x48>  // b.any
		stdcallstate.active_cpu = -1;
ffffffffea808230:	12800001 	mov	w1, #0xffffffff            	// #-1
		ret = SM_ERR_INTERRUPTED;
ffffffffea808234:	92800055 	mov	x21, #0xfffffffffffffffd    	// #-3
		stdcallstate.active_cpu = -1;
ffffffffea808238:	b9006661 	str	w1, [x19, #100]
		stdcallstate.last_cpu = stdcallstate.active_cpu;
ffffffffea80823c:	b9006e60 	str	w0, [x19, #108]
    arch_spin_unlock(lock);
ffffffffea808240:	91172280 	add	x0, x20, #0x5c8
ffffffffea808244:	97ffe9ce 	bl	ffffffffea80297c <arch_spin_unlock>
	sm_return_and_wait_for_next_stdcall(ret, cpu);
ffffffffea808248:	aa1503e0 	mov	x0, x21
}
ffffffffea80824c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808250:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea808254:	a8c37bfd 	ldp	x29, x30, [sp], #48
	sm_return_and_wait_for_next_stdcall(ret, cpu);
ffffffffea808258:	17ffff54 	b	ffffffffea807fa8 <sm_return_and_wait_for_next_stdcall.isra.1>
ffffffffea80825c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808260 <sm_irq_loop>:
{
ffffffffea808260:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808264:	910003fd 	mov	x29, sp
ffffffffea808268:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80826c:	aa0003f3 	mov	x19, x0
ffffffffea808270:	d50342df 	msr	daifset, #0x2
	irq_thread_ready[eventcpu] = true;
ffffffffea808274:	900002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea808278:	91336000 	add	x0, x0, #0xcd8
ffffffffea80827c:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808280:	3833c801 	strb	w1, [x0, w19, sxtw]
	cpu = arch_curr_cpu_num();
ffffffffea808284:	97ffea3b 	bl	ffffffffea802b70 <arch_curr_cpu_num>
		event_wait(&nsirqevent[eventcpu]);
ffffffffea808288:	900002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea80828c:	9134a000 	add	x0, x0, #0xd28
ffffffffea808290:	52800601 	mov	w1, #0x30                  	// #48
ffffffffea808294:	9b210273 	smaddl	x19, w19, w1, x0
static inline bool event_initialized(event_t *e) {
	return e->magic == EVENT_MAGIC;
}

static inline status_t event_wait(event_t *e) {
	return event_wait_timeout(e, INFINITE_TIME);
ffffffffea808298:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80829c:	aa1303e0 	mov	x0, x19
ffffffffea8082a0:	97fff518 	bl	ffffffffea805700 <event_wait_timeout>
		sm_irq_return_ns();
ffffffffea8082a4:	97ffffd5 	bl	ffffffffea8081f8 <sm_irq_return_ns>
ffffffffea8082a8:	17fffffc 	b	ffffffffea808298 <sm_irq_loop+0x38>
ffffffffea8082ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8082b0 <sm_stdcall_loop>:
{
ffffffffea8082b0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea8082b4:	910003fd 	mov	x29, sp
ffffffffea8082b8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8082bc:	90000093 	adrp	x19, ffffffffea818000 <_mem_phys_base>
ffffffffea8082c0:	91172273 	add	x19, x19, #0x5c8
ffffffffea8082c4:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8082c8:	91002274 	add	x20, x19, #0x8
		ret = sm_stdcall_table[SMC_ENTITY(stdcallstate.args.smc_nr)](&stdcallstate.args);
ffffffffea8082cc:	9100e276 	add	x22, x19, #0x38
{
ffffffffea8082d0:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea8082d4:	90000098 	adrp	x24, ffffffffea818000 <_mem_phys_base>
		stdcallstate.done = true;
ffffffffea8082d8:	52800037 	mov	w23, #0x1                   	// #1
{
ffffffffea8082dc:	f90023f9 	str	x25, [sp, #64]
		ret = sm_stdcall_table[SMC_ENTITY(stdcallstate.args.smc_nr)](&stdcallstate.args);
ffffffffea8082e0:	912ae315 	add	x21, x24, #0xab8
ffffffffea8082e4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8082e8:	aa1403e0 	mov	x0, x20
ffffffffea8082ec:	97fff505 	bl	ffffffffea805700 <event_wait_timeout>
ffffffffea8082f0:	3940ee61 	ldrb	w1, [x19, #59]
ffffffffea8082f4:	aa1603e0 	mov	x0, x22
ffffffffea8082f8:	92401421 	and	x1, x1, #0x3f
ffffffffea8082fc:	f8617aa1 	ldr	x1, [x21, x1, lsl #3]
ffffffffea808300:	d63f0020 	blr	x1
ffffffffea808304:	aa0003f9 	mov	x25, x0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea808308:	d53b4221 	mrs	x1, daif
    arch_spin_lock(lock);
ffffffffea80830c:	aa1303e0 	mov	x0, x19
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea808310:	37380161 	tbnz	w1, #7, ffffffffea80833c <sm_stdcall_loop+0x8c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea808314:	d50342df 	msr	daifset, #0x2
ffffffffea808318:	97ffe991 	bl	ffffffffea80295c <arch_spin_lock>
		stdcallstate.ret = ret;
ffffffffea80831c:	f9002e79 	str	x25, [x19, #88]
		event_unsignal(&stdcallstate.event);
ffffffffea808320:	aa1403e0 	mov	x0, x20
		stdcallstate.done = true;
ffffffffea808324:	39018277 	strb	w23, [x19, #96]
		event_unsignal(&stdcallstate.event);
ffffffffea808328:	97fff55a 	bl	ffffffffea805890 <event_unsignal>
    arch_spin_unlock(lock);
ffffffffea80832c:	aa1303e0 	mov	x0, x19
ffffffffea808330:	97ffe993 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea808334:	d50342ff 	msr	daifclr, #0x2
ffffffffea808338:	17ffffea 	b	ffffffffea8082e0 <sm_stdcall_loop+0x30>
    arch_spin_lock(lock);
ffffffffea80833c:	97ffe988 	bl	ffffffffea80295c <arch_spin_lock>
		stdcallstate.ret = ret;
ffffffffea808340:	f9002e79 	str	x25, [x19, #88]
		stdcallstate.done = true;
ffffffffea808344:	39018277 	strb	w23, [x19, #96]
		event_unsignal(&stdcallstate.event);
ffffffffea808348:	aa1403e0 	mov	x0, x20
ffffffffea80834c:	97fff551 	bl	ffffffffea805890 <event_unsignal>
    arch_spin_unlock(lock);
ffffffffea808350:	aa1303e0 	mov	x0, x19
ffffffffea808354:	97ffe98a 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea808358:	17ffffe3 	b	ffffffffea8082e4 <sm_stdcall_loop+0x34>
ffffffffea80835c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808360 <smc_sm_api_version>:
{
ffffffffea808360:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea808364:	910003fd 	mov	x29, sp
ffffffffea808368:	a90153f3 	stp	x19, x20, [sp, #16]
    arch_spin_lock(lock);
ffffffffea80836c:	900002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
	uint32_t api_version = args->params[0];
ffffffffea808370:	b9400413 	ldr	w19, [x0, #4]
ffffffffea808374:	913bc280 	add	x0, x20, #0xef0
ffffffffea808378:	97ffe979 	bl	ffffffffea80295c <arch_spin_lock>
	if (!sm_api_version_locked) {
ffffffffea80837c:	900002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea808380:	397be000 	ldrb	w0, [x0, #3832]
ffffffffea808384:	35000180 	cbnz	w0, ffffffffea8083b4 <smc_sm_api_version+0x54>
ffffffffea808388:	71000e7f 	cmp	w19, #0x3
ffffffffea80838c:	52800063 	mov	w3, #0x3                   	// #3
		sm_api_version = api_version;
ffffffffea808390:	900002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea808394:	1a839273 	csel	w19, w19, w3, ls  // ls = plast
ffffffffea808398:	b90ee813 	str	w19, [x0, #3816]
    arch_spin_unlock(lock);
ffffffffea80839c:	913bc280 	add	x0, x20, #0xef0
ffffffffea8083a0:	97ffe977 	bl	ffffffffea80297c <arch_spin_unlock>
}
ffffffffea8083a4:	2a1303e0 	mov	w0, w19
ffffffffea8083a8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8083ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8083b0:	d65f03c0 	ret
ffffffffea8083b4:	f90013b5 	str	x21, [x29, #32]
		TRACEF("ERROR: Tried to select api version %d after use, current version %d\n",
ffffffffea8083b8:	900002b5 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8083bc:	2a1303e3 	mov	w3, w19
ffffffffea8083c0:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8083c4:	b94eeaa4 	ldr	w4, [x21, #3816]
ffffffffea8083c8:	910aa021 	add	x1, x1, #0x2a8
ffffffffea8083cc:	52800ba2 	mov	w2, #0x5d                  	// #93
ffffffffea8083d0:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8083d4:	91196000 	add	x0, x0, #0x658
ffffffffea8083d8:	94002af2 	bl	ffffffffea812fa0 <_printf>
		api_version = sm_api_version;
ffffffffea8083dc:	b94eeab3 	ldr	w19, [x21, #3816]
ffffffffea8083e0:	913bc280 	add	x0, x20, #0xef0
ffffffffea8083e4:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea8083e8:	97ffe965 	bl	ffffffffea80297c <arch_spin_unlock>
}
ffffffffea8083ec:	2a1303e0 	mov	w0, w19
ffffffffea8083f0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8083f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8083f8:	d65f03c0 	ret
ffffffffea8083fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808400 <sm_handle_irq>:
{
ffffffffea808400:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea808404:	910003fd 	mov	x29, sp
	int cpu = arch_curr_cpu_num();
ffffffffea808408:	97ffe9da 	bl	ffffffffea802b70 <arch_curr_cpu_num>
	if (irq_thread_ready[cpu]) {
ffffffffea80840c:	900002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea808410:	91336021 	add	x1, x1, #0xcd8
ffffffffea808414:	3860c821 	ldrb	w1, [x1, w0, sxtw]
ffffffffea808418:	35000161 	cbnz	w1, ffffffffea808444 <sm_handle_irq+0x44>
		TRACEF("warning: got ns irq before irq thread is ready\n");
ffffffffea80841c:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea808420:	910b8021 	add	x1, x1, #0x2e0
ffffffffea808424:	528038a2 	mov	w2, #0x1c5                 	// #453
ffffffffea808428:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80842c:	910ec000 	add	x0, x0, #0x3b0
ffffffffea808430:	94002adc 	bl	ffffffffea812fa0 <_printf>
		sm_irq_return_ns();
ffffffffea808434:	97ffff71 	bl	ffffffffea8081f8 <sm_irq_return_ns>
}
ffffffffea808438:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80843c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea808440:	d65f03c0 	ret
		event_signal(&nsirqevent[cpu], false);
ffffffffea808444:	900002a2 	adrp	x2, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea808448:	9134a042 	add	x2, x2, #0xd28
ffffffffea80844c:	52800603 	mov	w3, #0x30                  	// #48
ffffffffea808450:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea808454:	9b230800 	smaddl	x0, w0, w3, x2
ffffffffea808458:	97fff4ce 	bl	ffffffffea805790 <event_signal>
}
ffffffffea80845c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea808460:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea808464:	d65f03c0 	ret

ffffffffea808468 <sm_handle_fiq>:
{
ffffffffea808468:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80846c:	910003fd 	mov	x29, sp
ffffffffea808470:	a90153f3 	stp	x19, x20, [sp, #16]
	smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);
ffffffffea808474:	a9027fbf 	stp	xzr, xzr, [x29, #32]
ffffffffea808478:	a9037fbf 	stp	xzr, xzr, [x29, #48]
	if (sm_get_api_version() >= TRUSTY_API_VERSION_RESTART_FIQ) {
ffffffffea80847c:	97fffe87 	bl	ffffffffea807e98 <sm_get_api_version>
ffffffffea808480:	340003a0 	cbz	w0, ffffffffea8084f4 <sm_handle_fiq+0x8c>
		sm_sched_nonsecure(SM_ERR_FIQ_INTERRUPTED, &args);
ffffffffea808484:	910083b4 	add	x20, x29, #0x20
		expected_return = SMC_SC_RESTART_FIQ;
ffffffffea808488:	52800053 	mov	w19, #0x2                   	// #2
		sm_sched_nonsecure(SM_ERR_FIQ_INTERRUPTED, &args);
ffffffffea80848c:	92800160 	mov	x0, #0xfffffffffffffff4    	// #-12
ffffffffea808490:	aa1403e1 	mov	x1, x20
		expected_return = SMC_SC_RESTART_FIQ;
ffffffffea808494:	72a78013 	movk	w19, #0x3c00, lsl #16
		sm_sched_nonsecure(SM_ERR_FIQ_INTERRUPTED, &args);
ffffffffea808498:	97fffd76 	bl	ffffffffea807a70 <sm_sched_nonsecure>
	if (args.smc_nr != expected_return) {
ffffffffea80849c:	b94023a3 	ldr	w3, [x29, #32]
ffffffffea8084a0:	6b13007f 	cmp	w3, w19
ffffffffea8084a4:	54000220 	b.eq	ffffffffea8084e8 <sm_handle_fiq+0x80>  // b.none
		TRACEF("got bad restart smc %x, expected %x\n",
ffffffffea8084a8:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8084ac:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8084b0:	2a1303e4 	mov	w4, w19
ffffffffea8084b4:	52803b22 	mov	w2, #0x1d9                 	// #473
ffffffffea8084b8:	910bc021 	add	x1, x1, #0x2f0
ffffffffea8084bc:	910e0000 	add	x0, x0, #0x380
ffffffffea8084c0:	94002ab8 	bl	ffffffffea812fa0 <_printf>
		while (args.smc_nr != expected_return)
ffffffffea8084c4:	b94023a0 	ldr	w0, [x29, #32]
ffffffffea8084c8:	6b00027f 	cmp	w19, w0
ffffffffea8084cc:	540000e0 	b.eq	ffffffffea8084e8 <sm_handle_fiq+0x80>  // b.none
			sm_sched_nonsecure(SM_ERR_INTERLEAVED_SMC, &args);
ffffffffea8084d0:	928000a0 	mov	x0, #0xfffffffffffffffa    	// #-6
ffffffffea8084d4:	aa1403e1 	mov	x1, x20
ffffffffea8084d8:	97fffd66 	bl	ffffffffea807a70 <sm_sched_nonsecure>
		while (args.smc_nr != expected_return)
ffffffffea8084dc:	b94023a0 	ldr	w0, [x29, #32]
ffffffffea8084e0:	6b13001f 	cmp	w0, w19
ffffffffea8084e4:	54ffff61 	b.ne	ffffffffea8084d0 <sm_handle_fiq+0x68>  // b.any
}
ffffffffea8084e8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8084ec:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8084f0:	d65f03c0 	ret
		sm_sched_nonsecure(SM_ERR_INTERRUPTED, &args);
ffffffffea8084f4:	910083b4 	add	x20, x29, #0x20
		expected_return = SMC_SC_RESTART_LAST;
ffffffffea8084f8:	52a78013 	mov	w19, #0x3c000000            	// #1006632960
		sm_sched_nonsecure(SM_ERR_INTERRUPTED, &args);
ffffffffea8084fc:	aa1403e1 	mov	x1, x20
ffffffffea808500:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
ffffffffea808504:	97fffd5b 	bl	ffffffffea807a70 <sm_sched_nonsecure>
ffffffffea808508:	17ffffe5 	b	ffffffffea80849c <sm_handle_fiq+0x34>
ffffffffea80850c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808510 <sm_get_boot_args>:
{
ffffffffea808510:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if (!boot_argsp || !args_sizep) {
ffffffffea808514:	f100001f 	cmp	x0, #0x0
ffffffffea808518:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
{
ffffffffea80851c:	910003fd 	mov	x29, sp
ffffffffea808520:	f90017f6 	str	x22, [sp, #40]
	if (!boot_argsp || !args_sizep) {
ffffffffea808524:	540003c0 	b.eq	ffffffffea80859c <sm_get_boot_args+0x8c>  // b.none
ffffffffea808528:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80852c:	aa0103f4 	mov	x20, x1
ffffffffea808530:	f90013b5 	str	x21, [x29, #32]
ffffffffea808534:	aa0003f3 	mov	x19, x0
ffffffffea808538:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80853c:	90000095 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea808540:	911642a0 	add	x0, x21, #0x590
ffffffffea808544:	97fff4e9 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	if (!boot_args) {
ffffffffea808548:	900002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
		err = ERR_NOT_CONFIGURED;
ffffffffea80854c:	128004b6 	mov	w22, #0xffffffda            	// #-38
	if (!boot_args) {
ffffffffea808550:	f9466400 	ldr	x0, [x0, #3272]
ffffffffea808554:	b4000140 	cbz	x0, ffffffffea80857c <sm_get_boot_args+0x6c>
	boot_args_refcnt++;
ffffffffea808558:	900002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
	*args_sizep = lk_boot_args[2];
ffffffffea80855c:	b00002a2 	adrp	x2, ffffffffea85d000 <rb_data+0x18>
	status_t err = NO_ERROR;
ffffffffea808560:	52800016 	mov	w22, #0x0                   	// #0
	*args_sizep = lk_boot_args[2];
ffffffffea808564:	f9402842 	ldr	x2, [x2, #80]
	*boot_argsp = boot_args;
ffffffffea808568:	f9000260 	str	x0, [x19]
	boot_args_refcnt++;
ffffffffea80856c:	b94cd020 	ldr	w0, [x1, #3280]
	*args_sizep = lk_boot_args[2];
ffffffffea808570:	f9000282 	str	x2, [x20]
	boot_args_refcnt++;
ffffffffea808574:	11000400 	add	w0, w0, #0x1
ffffffffea808578:	b90cd020 	str	w0, [x1, #3280]
	mutex_release(&boot_args_lock);
ffffffffea80857c:	911642a0 	add	x0, x21, #0x590
ffffffffea808580:	97fff506 	bl	ffffffffea805998 <mutex_release>
	return err;
ffffffffea808584:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea808588:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80858c:	2a1603e0 	mov	w0, w22
ffffffffea808590:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea808594:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808598:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80859c:	128000f6 	mov	w22, #0xfffffff8            	// #-8
ffffffffea8085a0:	17fffffb 	b	ffffffffea80858c <sm_get_boot_args+0x7c>
ffffffffea8085a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8085a8 <sm_put_boot_args>:

void sm_put_boot_args(void)
{
ffffffffea8085a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea8085ac:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8085b0:	910003fd 	mov	x29, sp
ffffffffea8085b4:	a90153f3 	stp	x19, x20, [sp, #16]
	mutex_acquire(&boot_args_lock);

	if (!boot_args) {
ffffffffea8085b8:	900002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8085bc:	90000093 	adrp	x19, ffffffffea818000 <_mem_phys_base>
ffffffffea8085c0:	91164260 	add	x0, x19, #0x590
ffffffffea8085c4:	97fff4c9 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
ffffffffea8085c8:	f9466681 	ldr	x1, [x20, #3272]
ffffffffea8085cc:	b40001e1 	cbz	x1, ffffffffea808608 <sm_put_boot_args+0x60>
		TRACEF("WARNING: caller does not own "
			"a reference to boot parameters\n");
		goto unlock;
	}

	boot_args_refcnt--;
ffffffffea8085d0:	900002a2 	adrp	x2, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8085d4:	b94cd040 	ldr	w0, [x2, #3280]
ffffffffea8085d8:	51000400 	sub	w0, w0, #0x1
ffffffffea8085dc:	b90cd040 	str	w0, [x2, #3280]
	if (boot_args_refcnt == 0) {
ffffffffea8085e0:	350000c0 	cbnz	w0, ffffffffea8085f8 <sm_put_boot_args+0x50>
		vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)boot_args);
ffffffffea8085e4:	b00002a0 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
ffffffffea8085e8:	91034000 	add	x0, x0, #0xd0
ffffffffea8085ec:	94002329 	bl	ffffffffea811290 <vmm_free_region>
		boot_args = NULL;
ffffffffea8085f0:	f906669f 	str	xzr, [x20, #3272]
		resume_nsthreads();
ffffffffea8085f4:	97fffdb1 	bl	ffffffffea807cb8 <resume_nsthreads>
	}
unlock:
	mutex_release(&boot_args_lock);
ffffffffea8085f8:	91164260 	add	x0, x19, #0x590
}
ffffffffea8085fc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808600:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_release(&boot_args_lock);
ffffffffea808604:	17fff4e5 	b	ffffffffea805998 <mutex_release>
		TRACEF("WARNING: caller does not own "
ffffffffea808608:	52804162 	mov	w2, #0x20b                 	// #523
ffffffffea80860c:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea808610:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea808614:	910c0021 	add	x1, x1, #0x300
ffffffffea808618:	91126000 	add	x0, x0, #0x498
ffffffffea80861c:	94002a61 	bl	ffffffffea812fa0 <_printf>
	mutex_release(&boot_args_lock);
ffffffffea808620:	91164260 	add	x0, x19, #0x590
}
ffffffffea808624:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808628:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_release(&boot_args_lock);
ffffffffea80862c:	17fff4db 	b	ffffffffea805998 <mutex_release>

ffffffffea808630 <sm_release_boot_args>:

static void sm_release_boot_args(uint level)
{
ffffffffea808630:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808634:	910003fd 	mov	x29, sp
ffffffffea808638:	f9000bf3 	str	x19, [sp, #16]
	if (boot_args) {
ffffffffea80863c:	900002b3 	adrp	x19, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea808640:	f9466660 	ldr	x0, [x19, #3272]
ffffffffea808644:	b40001e0 	cbz	x0, ffffffffea808680 <sm_release_boot_args+0x50>
		sm_put_boot_args();
ffffffffea808648:	97ffffd8 	bl	ffffffffea8085a8 <sm_put_boot_args>
		 * the boot loader didn't pass bootargs
		 */
		resume_nsthreads();
	}

	if (boot_args) {
ffffffffea80864c:	f9466660 	ldr	x0, [x19, #3272]
ffffffffea808650:	b4000120 	cbz	x0, ffffffffea808674 <sm_release_boot_args+0x44>
		TRACEF("WARNING: outstanding reference to boot args"
				"at the end of initialzation!\n");
	}
}
ffffffffea808654:	f9400bf3 	ldr	x19, [sp, #16]
		TRACEF("WARNING: outstanding reference to boot args"
ffffffffea808658:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
}
ffffffffea80865c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		TRACEF("WARNING: outstanding reference to boot args"
ffffffffea808660:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea808664:	528044c2 	mov	w2, #0x226                 	// #550
ffffffffea808668:	910c6021 	add	x1, x1, #0x318
ffffffffea80866c:	91138000 	add	x0, x0, #0x4e0
ffffffffea808670:	14002a4c 	b	ffffffffea812fa0 <_printf>
}
ffffffffea808674:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808678:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80867c:	d65f03c0 	ret
		resume_nsthreads();
ffffffffea808680:	97fffd8e 	bl	ffffffffea807cb8 <resume_nsthreads>
ffffffffea808684:	17fffff2 	b	ffffffffea80864c <sm_release_boot_args+0x1c>

ffffffffea808688 <smc_nop_stdcall>:
 * context switch that will perform other secure work.
 */
static long smc_nop_stdcall(smc32_args_t *args)
{
	return 0;
}
ffffffffea808688:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80868c:	d65f03c0 	ret

ffffffffea808690 <smc_nop_secure_monitor>:
/*
 * parameterized nop call handler
 */
static long smc_nop_secure_monitor(smc32_args_t *args)
{
	return (!args->params[0]) ? 0 : SM_ERR_UNDEFINED_SMC;
ffffffffea808690:	b9400401 	ldr	w1, [x0, #4]
ffffffffea808694:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
ffffffffea808698:	7100003f 	cmp	w1, #0x0
}
ffffffffea80869c:	9a9f1000 	csel	x0, x0, xzr, ne  // ne = any
ffffffffea8086a0:	d65f03c0 	ret
ffffffffea8086a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8086a8 <smc_undefined>:
{
ffffffffea8086a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	TRACE_SMC("Undefined monitor call!", args);
ffffffffea8086ac:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea8086b0:	d0000063 	adrp	x3, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8086b4:	911d4063 	add	x3, x3, #0x750
{
ffffffffea8086b8:	910003fd 	mov	x29, sp
ffffffffea8086bc:	a90153f3 	stp	x19, x20, [sp, #16]
	TRACE_SMC("Undefined monitor call!", args);
ffffffffea8086c0:	aa0003f4 	mov	x20, x0
ffffffffea8086c4:	d0000073 	adrp	x19, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8086c8:	911b4273 	add	x19, x19, #0x6d0
{
ffffffffea8086cc:	a9025bf5 	stp	x21, x22, [sp, #32]
	TRACE_SMC("Undefined monitor call!", args);
ffffffffea8086d0:	aa1303e1 	mov	x1, x19
ffffffffea8086d4:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8086d8:	911da000 	add	x0, x0, #0x768
ffffffffea8086dc:	94002a31 	bl	ffffffffea812fa0 <_printf>
ffffffffea8086e0:	d0000075 	adrp	x21, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8086e4:	b8404683 	ldr	w3, [x20], #4
ffffffffea8086e8:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8086ec:	d0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8086f0:	911d2021 	add	x1, x1, #0x748
ffffffffea8086f4:	7100007f 	cmp	w3, #0x0
ffffffffea8086f8:	911ce084 	add	x4, x4, #0x738
ffffffffea8086fc:	911ea2b5 	add	x21, x21, #0x7a8
ffffffffea808700:	9a81b084 	csel	x4, x4, x1, lt  // lt = tstop
ffffffffea808704:	aa1303f6 	mov	x22, x19
ffffffffea808708:	aa1303e1 	mov	x1, x19
ffffffffea80870c:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea808710:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea808714:	12003c66 	and	w6, w3, #0xffff
ffffffffea808718:	d3587465 	ubfx	x5, x3, #24, #6
ffffffffea80871c:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea808720:	911de000 	add	x0, x0, #0x778
ffffffffea808724:	94002a1f 	bl	ffffffffea812fa0 <_printf>
ffffffffea808728:	b8404684 	ldr	w4, [x20], #4
ffffffffea80872c:	2a1303e3 	mov	w3, w19
ffffffffea808730:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea808734:	aa1603e1 	mov	x1, x22
ffffffffea808738:	aa1503e0 	mov	x0, x21
ffffffffea80873c:	11000673 	add	w19, w19, #0x1
ffffffffea808740:	94002a18 	bl	ffffffffea812fa0 <_printf>
ffffffffea808744:	71001e7f 	cmp	w19, #0x7
ffffffffea808748:	54ffff01 	b.ne	ffffffffea808728 <smc_undefined+0x80>  // b.any
}
ffffffffea80874c:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
ffffffffea808750:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808754:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea808758:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80875c:	d65f03c0 	ret

ffffffffea808760 <smc_restart_stdcall>:
{
ffffffffea808760:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	TRACE_SMC("Unexpected stdcall restart!", args);
ffffffffea808764:	52800922 	mov	w2, #0x49                  	// #73
ffffffffea808768:	d0000063 	adrp	x3, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80876c:	911c6063 	add	x3, x3, #0x718
{
ffffffffea808770:	910003fd 	mov	x29, sp
ffffffffea808774:	a90153f3 	stp	x19, x20, [sp, #16]
	TRACE_SMC("Unexpected stdcall restart!", args);
ffffffffea808778:	aa0003f4 	mov	x20, x0
ffffffffea80877c:	d0000073 	adrp	x19, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea808780:	911b8273 	add	x19, x19, #0x6e0
{
ffffffffea808784:	a9025bf5 	stp	x21, x22, [sp, #32]
	TRACE_SMC("Unexpected stdcall restart!", args);
ffffffffea808788:	aa1303e1 	mov	x1, x19
ffffffffea80878c:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea808790:	911da000 	add	x0, x0, #0x768
ffffffffea808794:	94002a03 	bl	ffffffffea812fa0 <_printf>
ffffffffea808798:	d0000075 	adrp	x21, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80879c:	b8404683 	ldr	w3, [x20], #4
ffffffffea8087a0:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8087a4:	d0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8087a8:	911d2021 	add	x1, x1, #0x748
ffffffffea8087ac:	7100007f 	cmp	w3, #0x0
ffffffffea8087b0:	911ce084 	add	x4, x4, #0x738
ffffffffea8087b4:	911ea2b5 	add	x21, x21, #0x7a8
ffffffffea8087b8:	9a81b084 	csel	x4, x4, x1, lt  // lt = tstop
ffffffffea8087bc:	aa1303f6 	mov	x22, x19
ffffffffea8087c0:	aa1303e1 	mov	x1, x19
ffffffffea8087c4:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea8087c8:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8087cc:	12003c66 	and	w6, w3, #0xffff
ffffffffea8087d0:	d3587465 	ubfx	x5, x3, #24, #6
ffffffffea8087d4:	52800922 	mov	w2, #0x49                  	// #73
ffffffffea8087d8:	911de000 	add	x0, x0, #0x778
ffffffffea8087dc:	940029f1 	bl	ffffffffea812fa0 <_printf>
ffffffffea8087e0:	b8404684 	ldr	w4, [x20], #4
ffffffffea8087e4:	2a1303e3 	mov	w3, w19
ffffffffea8087e8:	52800922 	mov	w2, #0x49                  	// #73
ffffffffea8087ec:	aa1603e1 	mov	x1, x22
ffffffffea8087f0:	aa1503e0 	mov	x0, x21
ffffffffea8087f4:	11000673 	add	w19, w19, #0x1
ffffffffea8087f8:	940029ea 	bl	ffffffffea812fa0 <_printf>
ffffffffea8087fc:	71001e7f 	cmp	w19, #0x7
ffffffffea808800:	54ffff01 	b.ne	ffffffffea8087e0 <smc_restart_stdcall+0x80>  // b.any
}
ffffffffea808804:	92800060 	mov	x0, #0xfffffffffffffffc    	// #-4
ffffffffea808808:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80880c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea808810:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808814:	d65f03c0 	ret

ffffffffea808818 <smc_fiq_exit>:
	}
	return handler_fn(args);
}

long smc_fiq_exit(smc32_args_t *args)
{
ffffffffea808818:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80881c:	910003fd 	mov	x29, sp
	sm_intc_fiq_exit();
ffffffffea808820:	97fff15c 	bl	ffffffffea804d90 <sm_intc_fiq_exit>
	return 1; /* 0: reeenter fiq handler, 1: return */
}
ffffffffea808824:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea808828:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80882c:	d65f03c0 	ret

ffffffffea808830 <smc_register_ns_dram_ranges>:
#endif

#if !defined(DISABLE_NS_DRAM_RANGE_CHECK)
static long smc_register_ns_dram_ranges(smc32_args_t *args)
{
	if (!args)
ffffffffea808830:	b4000080 	cbz	x0, ffffffffea808840 <smc_register_ns_dram_ranges+0x10>
		return ERR_INVALID_ARGS;

	ns_addr_t ns_base =  ((uint64_t)args->params[1] << 32) | args->params[0];

	return platform_register_ns_dram_ranges(ns_base, args->params[2]);
ffffffffea808834:	b9400c01 	ldr	w1, [x0, #12]
ffffffffea808838:	f8404000 	ldur	x0, [x0, #4]
ffffffffea80883c:	17ffe663 	b	ffffffffea8021c8 <platform_register_ns_dram_ranges>
}
ffffffffea808840:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea808844:	d65f03c0 	ret

ffffffffea808848 <smc_get_version_str>:
{
ffffffffea808848:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80884c:	910003fd 	mov	x29, sp
ffffffffea808850:	a90153f3 	stp	x19, x20, [sp, #16]
	size_t version_len = strlen(lk_version);
ffffffffea808854:	90000093 	adrp	x19, ffffffffea818000 <_mem_phys_base>
	int32_t index = args->params[0];
ffffffffea808858:	b9400414 	ldr	w20, [x0, #4]
	size_t version_len = strlen(lk_version);
ffffffffea80885c:	913f6273 	add	x19, x19, #0xfd8
ffffffffea808860:	aa1303e0 	mov	x0, x19
ffffffffea808864:	94002b2d 	bl	ffffffffea813518 <strlen>
	if (index == -1) {
ffffffffea808868:	3100069f 	cmn	w20, #0x1
ffffffffea80886c:	54000080 	b.eq	ffffffffea80887c <smc_get_version_str+0x34>  // b.none
	if ((size_t)index >= version_len) {
ffffffffea808870:	eb34c01f 	cmp	x0, w20, sxtw
ffffffffea808874:	540000a9 	b.ls	ffffffffea808888 <smc_get_version_str+0x40>  // b.plast
	return lk_version[index];
ffffffffea808878:	3874ca60 	ldrb	w0, [x19, w20, sxtw]
}
ffffffffea80887c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808880:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808884:	d65f03c0 	ret
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea808888:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80888c:	17fffffc 	b	ffffffffea80887c <smc_get_version_str+0x34>

ffffffffea808890 <smc_fiq_enter>:
{
ffffffffea808890:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea808894:	910003fd 	mov	x29, sp
	return sm_intc_fiq_enter();
ffffffffea808898:	97fff10c 	bl	ffffffffea804cc8 <sm_intc_fiq_enter>
}
ffffffffea80889c:	93407c00 	sxtw	x0, w0
ffffffffea8088a0:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8088a4:	d65f03c0 	ret

ffffffffea8088a8 <smc_stdcall_secure_monitor>:
{
ffffffffea8088a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8088ac:	910003fd 	mov	x29, sp
ffffffffea8088b0:	f9000bf3 	str	x19, [sp, #16]
	u_int function = SMC_FUNCTION(args->smc_nr);
ffffffffea8088b4:	79400013 	ldrh	w19, [x0]
	if (function < countof(sm_stdcall_function_table)) {
ffffffffea8088b8:	71000e7f 	cmp	w19, #0x3
ffffffffea8088bc:	540000c9 	b.ls	ffffffffea8088d4 <smc_stdcall_secure_monitor+0x2c>  // b.plast
}
ffffffffea8088c0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8088c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
		handler_fn = smc_undefined;
ffffffffea8088c8:	90000001 	adrp	x1, ffffffffea808000 <sm_return_and_wait_for_next_stdcall.isra.1+0x58>
ffffffffea8088cc:	911aa021 	add	x1, x1, #0x6a8
	return handler_fn(args);
ffffffffea8088d0:	d61f0020 	br	x1
ffffffffea8088d4:	f90017a0 	str	x0, [x29, #40]
		platform_arch_speculation_barrier();
ffffffffea8088d8:	97ffe638 	bl	ffffffffea8021b8 <platform_arch_speculation_barrier>
		handler_fn = sm_stdcall_function_table[function];
ffffffffea8088dc:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8088e0:	911be021 	add	x1, x1, #0x6f8
	if (!handler_fn) {
ffffffffea8088e4:	f94017a0 	ldr	x0, [x29, #40]
		handler_fn = sm_stdcall_function_table[function];
ffffffffea8088e8:	f8737821 	ldr	x1, [x1, x19, lsl #3]
	if (!handler_fn) {
ffffffffea8088ec:	b4fffea1 	cbz	x1, ffffffffea8088c0 <smc_stdcall_secure_monitor+0x18>
}
ffffffffea8088f0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8088f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return handler_fn(args);
ffffffffea8088f8:	d61f0020 	br	x1
ffffffffea8088fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808900 <smc_cpu_resume>:
{
ffffffffea808900:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
}

static inline void lk_init_level_all(enum lk_init_flags flags) {
	lk_init_level(flags, LK_INIT_LEVEL_EARLIEST, LK_INIT_LEVEL_LAST);
ffffffffea808904:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea808908:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea80890c:	910003fd 	mov	x29, sp
ffffffffea808910:	f9000bf3 	str	x19, [sp, #16]
ffffffffea808914:	aa0003f3 	mov	x19, x0
ffffffffea808918:	52800100 	mov	w0, #0x8                   	// #8
ffffffffea80891c:	97ffecf5 	bl	ffffffffea803cf0 <lk_init_level>
	if (args->params[0] == MPIDR_MAX_AFFLVL)
ffffffffea808920:	b9400660 	ldr	w0, [x19, #4]
ffffffffea808924:	7100081f 	cmp	w0, #0x2
ffffffffea808928:	540000a0 	b.eq	ffffffffea80893c <smc_cpu_resume+0x3c>  // b.none
}
ffffffffea80892c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea808930:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808934:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808938:	d65f03c0 	ret
ffffffffea80893c:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea808940:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808944:	52800400 	mov	w0, #0x20                  	// #32
ffffffffea808948:	97ffecea 	bl	ffffffffea803cf0 <lk_init_level>
ffffffffea80894c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea808950:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808954:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808958:	d65f03c0 	ret
ffffffffea80895c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808960 <smc_cpu_suspend>:
{
ffffffffea808960:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808964:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea808968:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea80896c:	910003fd 	mov	x29, sp
ffffffffea808970:	f9000bf3 	str	x19, [sp, #16]
ffffffffea808974:	aa0003f3 	mov	x19, x0
ffffffffea808978:	52800080 	mov	w0, #0x4                   	// #4
ffffffffea80897c:	97ffecdd 	bl	ffffffffea803cf0 <lk_init_level>
	if (args->params[0] == MPIDR_MAX_AFFLVL)
ffffffffea808980:	b9400660 	ldr	w0, [x19, #4]
ffffffffea808984:	7100081f 	cmp	w0, #0x2
ffffffffea808988:	540000a0 	b.eq	ffffffffea80899c <smc_cpu_suspend+0x3c>  // b.none
}
ffffffffea80898c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea808990:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808994:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808998:	d65f03c0 	ret
ffffffffea80899c:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea8089a0:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8089a4:	52800200 	mov	w0, #0x10                  	// #16
ffffffffea8089a8:	97ffecd2 	bl	ffffffffea803cf0 <lk_init_level>
ffffffffea8089ac:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea8089b0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8089b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8089b8:	d65f03c0 	ret
ffffffffea8089bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8089c0 <sm_register_entity>:
	[SMC_ENTITY_SECURE_MONITOR] = smc_stdcall_secure_monitor,
	[SMC_ENTITY_SECURE_MONITOR + 1 ... SMC_NUM_ENTITIES - 1] = smc_undefined
};

status_t sm_register_entity(uint entity_nr, smc32_entity_t *entity)
{
ffffffffea8089c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	status_t err = NO_ERROR;

	if (entity_nr >= SMC_NUM_ENTITIES) {
ffffffffea8089c4:	7100fc1f 	cmp	w0, #0x3f
{
ffffffffea8089c8:	910003fd 	mov	x29, sp
ffffffffea8089cc:	f9000bf3 	str	x19, [sp, #16]
	if (entity_nr >= SMC_NUM_ENTITIES) {
ffffffffea8089d0:	54000728 	b.hi	ffffffffea808ab4 <sm_register_entity+0xf4>  // b.pmore
		return ERR_INVALID_ARGS;
	}
	if (entity_nr >= SMC_ENTITY_RESERVED && entity_nr < SMC_ENTITY_TRUSTED_APP) {
ffffffffea8089d4:	51001402 	sub	w2, w0, #0x5
ffffffffea8089d8:	7100a85f 	cmp	w2, #0x2a
ffffffffea8089dc:	54000709 	b.ls	ffffffffea808abc <sm_register_entity+0xfc>  // b.plast
		return ERR_NOT_ALLOWED;
	}
	if (!entity) {
ffffffffea8089e0:	b40006a1 	cbz	x1, ffffffffea808ab4 <sm_register_entity+0xf4>
		return ERR_INVALID_ARGS;
	}
	if (!entity->fastcall_handler && !entity->stdcall_handler){
ffffffffea8089e4:	f9400022 	ldr	x2, [x1]
ffffffffea8089e8:	b4000302 	cbz	x2, ffffffffea808a48 <sm_register_entity+0x88>
ffffffffea8089ec:	2a0003f3 	mov	w19, w0
ffffffffea8089f0:	a901d7b4 	stp	x20, x21, [x29, #24]
ffffffffea8089f4:	aa0103f4 	mov	x20, x1
ffffffffea8089f8:	90000095 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea8089fc:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808a00:	9132e2a0 	add	x0, x21, #0xcb8
ffffffffea808a04:	97fff3b9 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	}

	mutex_acquire(&smc_table_lock);

	/* Check if entity is already claimed */
	if (sm_fastcall_table[entity_nr] != smc_undefined ||
ffffffffea808a08:	2a1303e0 	mov	w0, w19
ffffffffea808a0c:	90000081 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea808a10:	911ac021 	add	x1, x1, #0x6b0
ffffffffea808a14:	90000002 	adrp	x2, ffffffffea808000 <sm_return_and_wait_for_next_stdcall.isra.1+0x58>
ffffffffea808a18:	911aa042 	add	x2, x2, #0x6a8
		sm_nopcall_table[entity_nr] != smc_undefined ||
		sm_stdcall_table[entity_nr] != smc_undefined) {
		err = ERR_ALREADY_EXISTS;
ffffffffea808a1c:	128001b3 	mov	w19, #0xfffffff2            	// #-14
	if (sm_fastcall_table[entity_nr] != smc_undefined ||
ffffffffea808a20:	f8607823 	ldr	x3, [x1, x0, lsl #3]
ffffffffea808a24:	eb02007f 	cmp	x3, x2
ffffffffea808a28:	54000180 	b.eq	ffffffffea808a58 <sm_register_entity+0x98>  // b.none
	}
	if (entity->stdcall_handler) {
		sm_stdcall_table[entity_nr] = entity->stdcall_handler;
	}
unlock:
	mutex_release(&smc_table_lock);
ffffffffea808a2c:	9132e2a0 	add	x0, x21, #0xcb8
ffffffffea808a30:	97fff3da 	bl	ffffffffea805998 <mutex_release>
	return err;
ffffffffea808a34:	a941d7b4 	ldp	x20, x21, [x29, #24]
}
ffffffffea808a38:	2a1303e0 	mov	w0, w19
ffffffffea808a3c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808a40:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808a44:	d65f03c0 	ret
	if (!entity->fastcall_handler && !entity->stdcall_handler){
ffffffffea808a48:	f9400822 	ldr	x2, [x1, #16]
ffffffffea808a4c:	b5fffd02 	cbnz	x2, ffffffffea8089ec <sm_register_entity+0x2c>
		return ERR_NOT_VALID;
ffffffffea808a50:	128000d3 	mov	w19, #0xfffffff9            	// #-7
ffffffffea808a54:	17fffff9 	b	ffffffffea808a38 <sm_register_entity+0x78>
		sm_nopcall_table[entity_nr] != smc_undefined ||
ffffffffea808a58:	90000084 	adrp	x4, ffffffffea818000 <_mem_phys_base>
ffffffffea808a5c:	9122c082 	add	x2, x4, #0x8b0
	if (sm_fastcall_table[entity_nr] != smc_undefined ||
ffffffffea808a60:	f8607842 	ldr	x2, [x2, x0, lsl #3]
ffffffffea808a64:	eb03005f 	cmp	x2, x3
ffffffffea808a68:	54fffe21 	b.ne	ffffffffea808a2c <sm_register_entity+0x6c>  // b.any
		sm_stdcall_table[entity_nr] != smc_undefined) {
ffffffffea808a6c:	90000083 	adrp	x3, ffffffffea818000 <_mem_phys_base>
ffffffffea808a70:	912ae065 	add	x5, x3, #0xab8
		sm_nopcall_table[entity_nr] != smc_undefined ||
ffffffffea808a74:	f86078a5 	ldr	x5, [x5, x0, lsl #3]
ffffffffea808a78:	eb0200bf 	cmp	x5, x2
ffffffffea808a7c:	54fffd81 	b.ne	ffffffffea808a2c <sm_register_entity+0x6c>  // b.any
	if (entity->fastcall_handler) {
ffffffffea808a80:	f9400282 	ldr	x2, [x20]
ffffffffea808a84:	b4000042 	cbz	x2, ffffffffea808a8c <sm_register_entity+0xcc>
		sm_fastcall_table[entity_nr] = entity->fastcall_handler;
ffffffffea808a88:	f8207822 	str	x2, [x1, x0, lsl #3]
	if (entity->nopcall_handler) {
ffffffffea808a8c:	f9400681 	ldr	x1, [x20, #8]
ffffffffea808a90:	b4000061 	cbz	x1, ffffffffea808a9c <sm_register_entity+0xdc>
		sm_nopcall_table[entity_nr] = entity->nopcall_handler;
ffffffffea808a94:	9122c084 	add	x4, x4, #0x8b0
ffffffffea808a98:	f8207881 	str	x1, [x4, x0, lsl #3]
	if (entity->stdcall_handler) {
ffffffffea808a9c:	f9400a81 	ldr	x1, [x20, #16]
	status_t err = NO_ERROR;
ffffffffea808aa0:	52800013 	mov	w19, #0x0                   	// #0
	if (entity->stdcall_handler) {
ffffffffea808aa4:	b4fffc41 	cbz	x1, ffffffffea808a2c <sm_register_entity+0x6c>
		sm_stdcall_table[entity_nr] = entity->stdcall_handler;
ffffffffea808aa8:	912ae063 	add	x3, x3, #0xab8
ffffffffea808aac:	f8207861 	str	x1, [x3, x0, lsl #3]
ffffffffea808ab0:	17ffffdf 	b	ffffffffea808a2c <sm_register_entity+0x6c>
		return ERR_INVALID_ARGS;
ffffffffea808ab4:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea808ab8:	17ffffe0 	b	ffffffffea808a38 <sm_register_entity+0x78>
		return ERR_NOT_ALLOWED;
ffffffffea808abc:	12800213 	mov	w19, #0xffffffef            	// #-17
ffffffffea808ac0:	17ffffde 	b	ffffffffea808a38 <sm_register_entity+0x78>
ffffffffea808ac4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808ac8 <sm_decode_ns_memory_attr>:
status_t sm_decode_ns_memory_attr(struct ns_page_info *pinf,
				  ns_addr_t *ppa, uint *pmmu)
{
	uint mmu_flags = 0;

	if(!pinf) {
ffffffffea808ac8:	b4000420 	cbz	x0, ffffffffea808b4c <sm_decode_ns_memory_attr+0x84>
		pinf->attr,
		NS_PTE_PHYSADDR(pinf->attr),
		(uint)NS_PTE_ATTR_MAIR(pinf->attr),
		(uint)NS_PTE_ATTR_SHAREABLE(pinf->attr));

	if (ppa) {
ffffffffea808acc:	b4000081 	cbz	x1, ffffffffea808adc <sm_decode_ns_memory_attr+0x14>
		*ppa = (ns_addr_t)NS_PTE_PHYSADDR(pinf->attr);
ffffffffea808ad0:	f9400003 	ldr	x3, [x0]
ffffffffea808ad4:	92748c63 	and	x3, x3, #0xfffffffff000
ffffffffea808ad8:	f9000023 	str	x3, [x1]
			mmu_flags |= ARCH_MMU_FLAG_PERM_RO;

		*pmmu = mmu_flags | ARCH_MMU_FLAG_NS | ARCH_MMU_FLAG_PERM_NO_EXECUTE;
	}

	return NO_ERROR;
ffffffffea808adc:	52800003 	mov	w3, #0x0                   	// #0
	if (pmmu) {
ffffffffea808ae0:	b4000282 	cbz	x2, ffffffffea808b30 <sm_decode_ns_memory_attr+0x68>
		switch ((uint)NS_PTE_ATTR_MAIR(pinf->attr)) {
ffffffffea808ae4:	f9400000 	ldr	x0, [x0]
ffffffffea808ae8:	d370dc01 	ubfx	x1, x0, #48, #8
ffffffffea808aec:	7101103f 	cmp	w1, #0x44
ffffffffea808af0:	54000240 	b.eq	ffffffffea808b38 <sm_decode_ns_memory_attr+0x70>  // b.none
ffffffffea808af4:	7103fc3f 	cmp	w1, #0xff
ffffffffea808af8:	54000241 	b.ne	ffffffffea808b40 <sm_decode_ns_memory_attr+0x78>  // b.any
			if(NS_PTE_ATTR_SHAREABLE(pinf->attr) != NS_INNER_SHAREABLE) {
ffffffffea808afc:	d3482401 	ubfx	x1, x0, #8, #2
ffffffffea808b00:	f1000c3f 	cmp	x1, #0x3
ffffffffea808b04:	540001e1 	b.ne	ffffffffea808b40 <sm_decode_ns_memory_attr+0x78>  // b.any
				mmu_flags |= ARCH_MMU_FLAG_CACHED;
ffffffffea808b08:	52800001 	mov	w1, #0x0                   	// #0
			mmu_flags |= ARCH_MMU_FLAG_PERM_USER;
ffffffffea808b0c:	f27a001f 	tst	x0, #0x40
ffffffffea808b10:	321e0023 	orr	w3, w1, #0x4
ffffffffea808b14:	1a811061 	csel	w1, w3, w1, ne  // ne = any
			mmu_flags |= ARCH_MMU_FLAG_PERM_RO;
ffffffffea808b18:	f279001f 	tst	x0, #0x80
ffffffffea808b1c:	321d0020 	orr	w0, w1, #0x8
	return NO_ERROR;
ffffffffea808b20:	52800003 	mov	w3, #0x0                   	// #0
			mmu_flags |= ARCH_MMU_FLAG_PERM_RO;
ffffffffea808b24:	1a811001 	csel	w1, w0, w1, ne  // ne = any
		*pmmu = mmu_flags | ARCH_MMU_FLAG_NS | ARCH_MMU_FLAG_PERM_NO_EXECUTE;
ffffffffea808b28:	321c0421 	orr	w1, w1, #0x30
ffffffffea808b2c:	b9000041 	str	w1, [x2]
}
ffffffffea808b30:	2a0303e0 	mov	w0, w3
ffffffffea808b34:	d65f03c0 	ret
				mmu_flags |= ARCH_MMU_FLAG_UNCACHED;
ffffffffea808b38:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808b3c:	17fffff4 	b	ffffffffea808b0c <sm_decode_ns_memory_attr+0x44>
				return ERR_NOT_SUPPORTED;
ffffffffea808b40:	128002e3 	mov	w3, #0xffffffe8            	// #-24
}
ffffffffea808b44:	2a0303e0 	mov	w0, w3
ffffffffea808b48:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea808b4c:	128000e3 	mov	w3, #0xfffffff8            	// #-8
ffffffffea808b50:	17fffff8 	b	ffffffffea808b30 <sm_decode_ns_memory_attr+0x68>
ffffffffea808b54:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808b58 <smc32_decode_mem_buf_info>:


/* Helper function to get NS memory buffer info out of smc32 call params */
status_t smc32_decode_mem_buf_info(struct smc32_args *args, ns_addr_t *ppa,
                                   ns_size_t *psz, uint *pmmu)
{
ffffffffea808b58:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808b5c:	aa0003e4 	mov	x4, x0
ffffffffea808b60:	aa0203e5 	mov	x5, x2

	DEBUG_ASSERT(args);

	pi.attr = ((uint64_t)args->params[1] << 32) | args->params[0];

	res = sm_decode_ns_memory_attr(&pi, ppa, pmmu);
ffffffffea808b64:	aa0303e2 	mov	x2, x3
{
ffffffffea808b68:	910003fd 	mov	x29, sp
	pi.attr = ((uint64_t)args->params[1] << 32) | args->params[0];
ffffffffea808b6c:	910083a0 	add	x0, x29, #0x20
ffffffffea808b70:	f8404083 	ldur	x3, [x4, #4]
ffffffffea808b74:	f81f8c03 	str	x3, [x0, #-8]!
	res = sm_decode_ns_memory_attr(&pi, ppa, pmmu);
ffffffffea808b78:	97ffffd4 	bl	ffffffffea808ac8 <sm_decode_ns_memory_attr>
	if (res != NO_ERROR)
ffffffffea808b7c:	35000080 	cbnz	w0, ffffffffea808b8c <smc32_decode_mem_buf_info+0x34>
		return res;

	if (psz)
ffffffffea808b80:	b4000065 	cbz	x5, ffffffffea808b8c <smc32_decode_mem_buf_info+0x34>
		*psz = (ns_size_t)args->params[2];
ffffffffea808b84:	b9400c81 	ldr	w1, [x4, #12]
ffffffffea808b88:	b90000a1 	str	w1, [x5]

	return NO_ERROR;
}
ffffffffea808b8c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808b90:	d65f03c0 	ret
ffffffffea808b94:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808b98 <trusty_init>:

static void trusty_init(uint level)
{
	dprintf(INFO, "initializing trusty (%s)\n", lk_version);

	trusty_app_init();
ffffffffea808b98:	14000086 	b	ffffffffea808db0 <trusty_app_init>
ffffffffea808b9c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808ba0 <start_apps>:
		fn(ta, data);
	}
}

static void start_apps(uint level)
{
ffffffffea808ba0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	trusty_app_t *trusty_app;
	u_int i;
	int ret;

	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea808ba4:	900002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
{
ffffffffea808ba8:	910003fd 	mov	x29, sp
ffffffffea808bac:	f90013f5 	str	x21, [sp, #32]
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea808bb0:	900002b5 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
{
ffffffffea808bb4:	f9000bf3 	str	x19, [sp, #16]
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea808bb8:	b94f12a0 	ldr	w0, [x21, #3856]
ffffffffea808bbc:	f9479833 	ldr	x19, [x1, #3888]
ffffffffea808bc0:	340002e0 	cbz	w0, ffffffffea808c1c <start_apps+0x7c>
ffffffffea808bc4:	f9000fb4 	str	x20, [x29, #24]
ffffffffea808bc8:	913c42b5 	add	x21, x21, #0xf10
ffffffffea808bcc:	f90017b6 	str	x22, [x29, #40]
ffffffffea808bd0:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea808bd4:	aa1e03f6 	mov	x22, x30
ffffffffea808bd8:	14000006 	b	ffffffffea808bf0 <start_apps+0x50>
ffffffffea808bdc:	b94002a0 	ldr	w0, [x21]
ffffffffea808be0:	11000694 	add	w20, w20, #0x1
ffffffffea808be4:	9101a273 	add	x19, x19, #0x68
ffffffffea808be8:	6b14001f 	cmp	w0, w20
ffffffffea808bec:	54000149 	b.ls	ffffffffea808c14 <start_apps+0x74>  // b.plast
		if (trusty_app->ut->entry) {
ffffffffea808bf0:	f9402e60 	ldr	x0, [x19, #88]
ffffffffea808bf4:	f9400401 	ldr	x1, [x0, #8]
ffffffffea808bf8:	b4ffff21 	cbz	x1, ffffffffea808bdc <start_apps+0x3c>
			ret = uthread_start(trusty_app->ut);
ffffffffea808bfc:	94002bbf 	bl	ffffffffea813af8 <uthread_start>
			if (ret) {
ffffffffea808c00:	34fffee0 	cbz	w0, ffffffffea808bdc <start_apps+0x3c>
				panic("Cannot start Trusty app!\n");
ffffffffea808c04:	d0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea808c08:	aa1603e0 	mov	x0, x22
ffffffffea808c0c:	91208021 	add	x1, x1, #0x820
ffffffffea808c10:	9400237e 	bl	ffffffffea811a08 <_panic>
ffffffffea808c14:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea808c18:	f94017b6 	ldr	x22, [x29, #40]
			}
		}
	}
	tegra_boot_profiler_record("start_apps: Done");
ffffffffea808c1c:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea808c20:	91210000 	add	x0, x0, #0x840
ffffffffea808c24:	97fffa6f 	bl	ffffffffea8075e0 <tegra_boot_profiler_record>
	/* Debug only: Prints all profiler records to UART during boot */
	/* tegra_boot_profiler_data_printnow(); */
	tegra_boot_profiler_deinit();
}
ffffffffea808c28:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808c2c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea808c30:	a8c37bfd 	ldp	x29, x30, [sp], #48
	tegra_boot_profiler_deinit();
ffffffffea808c34:	17fffa67 	b	ffffffffea8075d0 <tegra_boot_profiler_deinit>

ffffffffea808c38 <trusty_register_app_notifier>:
{
ffffffffea808c38:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea808c3c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808c40:	910003fd 	mov	x29, sp
ffffffffea808c44:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea808c48:	aa0003f3 	mov	x19, x0
ffffffffea808c4c:	90000094 	adrp	x20, ffffffffea818000 <_mem_phys_base>
ffffffffea808c50:	f90013f5 	str	x21, [sp, #32]
ffffffffea808c54:	91340280 	add	x0, x20, #0xd00
ffffffffea808c58:	97fff324 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	if (!apps_started) {
ffffffffea808c5c:	900002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea808c60:	397c2000 	ldrb	w0, [x0, #3848]
ffffffffea808c64:	35000220 	cbnz	w0, ffffffffea808ca8 <trusty_register_app_notifier+0x70>
	item->prev = list->prev;
ffffffffea808c68:	90000080 	adrp	x0, ffffffffea818000 <_mem_phys_base>
ffffffffea808c6c:	9133c001 	add	x1, x0, #0xcf0
	item->next = list;
ffffffffea808c70:	f9000661 	str	x1, [x19, #8]
	status_t ret = NO_ERROR;
ffffffffea808c74:	52800015 	mov	w21, #0x0                   	// #0
	item->prev = list->prev;
ffffffffea808c78:	f9467801 	ldr	x1, [x0, #3312]
ffffffffea808c7c:	f9000261 	str	x1, [x19]
	list->prev->next = item;
ffffffffea808c80:	f9467801 	ldr	x1, [x0, #3312]
	list->prev = item;
ffffffffea808c84:	f9067813 	str	x19, [x0, #3312]
	list->prev->next = item;
ffffffffea808c88:	f9000433 	str	x19, [x1, #8]
	mutex_release(&apps_lock);
ffffffffea808c8c:	91340280 	add	x0, x20, #0xd00
ffffffffea808c90:	97fff342 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea808c94:	2a1503e0 	mov	w0, w21
ffffffffea808c98:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea808c9c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808ca0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808ca4:	d65f03c0 	ret
		ret = ERR_ALREADY_STARTED;
ffffffffea808ca8:	128000b5 	mov	w21, #0xfffffffa            	// #-6
ffffffffea808cac:	17fffff8 	b	ffffffffea808c8c <trusty_register_app_notifier+0x54>

ffffffffea808cb0 <trusty_als_alloc_slot>:
{
ffffffffea808cb0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808cb4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808cb8:	910003fd 	mov	x29, sp
ffffffffea808cbc:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea808cc0:	90000094 	adrp	x20, ffffffffea818000 <_mem_phys_base>
ffffffffea808cc4:	91340280 	add	x0, x20, #0xd00
ffffffffea808cc8:	97fff308 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	if (!apps_started) {
ffffffffea808ccc:	900002a0 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea808cd0:	397c2000 	ldrb	w0, [x0, #3848]
ffffffffea808cd4:	35000180 	cbnz	w0, ffffffffea808d04 <trusty_als_alloc_slot+0x54>
		ret = ++als_slot_cnt;
ffffffffea808cd8:	b00002a1 	adrp	x1, ffffffffea85d000 <rb_data+0x18>
ffffffffea808cdc:	b940cc20 	ldr	w0, [x1, #204]
ffffffffea808ce0:	11000400 	add	w0, w0, #0x1
ffffffffea808ce4:	b900cc20 	str	w0, [x1, #204]
ffffffffea808ce8:	2a0003f3 	mov	w19, w0
	mutex_release(&apps_lock);
ffffffffea808cec:	91340280 	add	x0, x20, #0xd00
ffffffffea808cf0:	97fff32a 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea808cf4:	2a1303e0 	mov	w0, w19
ffffffffea808cf8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808cfc:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808d00:	d65f03c0 	ret
		ret = ERR_ALREADY_STARTED;
ffffffffea808d04:	128000b3 	mov	w19, #0xfffffffa            	// #-6
ffffffffea808d08:	17fffff9 	b	ffffffffea808cec <trusty_als_alloc_slot+0x3c>
ffffffffea808d0c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808d10 <trusty_app_setup_mmio>:
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea808d10:	b9404008 	ldr	w8, [x0, #64]
ffffffffea808d14:	34000148 	cbz	w8, ffffffffea808d3c <trusty_app_setup_mmio+0x2c>
		if (trusty_app->props.config_blob[i] == TRUSTY_APP_CONFIG_KEY_MAP_MEM) {
ffffffffea808d18:	f9402407 	ldr	x7, [x0, #72]
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea808d1c:	52800004 	mov	w4, #0x0                   	// #0
		if (trusty_app->props.config_blob[i] == TRUSTY_APP_CONFIG_KEY_MAP_MEM) {
ffffffffea808d20:	b86458e6 	ldr	w6, [x7, w4, uxtw #2]
ffffffffea808d24:	11000485 	add	w5, w4, #0x1
ffffffffea808d28:	71000cdf 	cmp	w6, #0x3
ffffffffea808d2c:	540000c0 	b.eq	ffffffffea808d44 <trusty_app_setup_mmio+0x34>  // b.none
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea808d30:	110004a4 	add	w4, w5, #0x1
ffffffffea808d34:	6b04011f 	cmp	w8, w4
ffffffffea808d38:	54ffff48 	b.hi	ffffffffea808d20 <trusty_app_setup_mmio+0x10>  // b.pmore
	return ERR_NOT_FOUND;
ffffffffea808d3c:	12800020 	mov	w0, #0xfffffffe            	// #-2
ffffffffea808d40:	d65f03c0 	ret
			id = trusty_app->props.config_blob[++i];
ffffffffea808d44:	b86558e6 	ldr	w6, [x7, w5, uxtw #2]
			size = ROUNDUP(trusty_app->props.config_blob[++i],
ffffffffea808d48:	11000c85 	add	w5, w4, #0x3
			if (id != mmio_id) {
ffffffffea808d4c:	6b0100df 	cmp	w6, w1
ffffffffea808d50:	54ffff01 	b.ne	ffffffffea808d30 <trusty_app_setup_mmio+0x20>  // b.any
			size = ROUNDUP(trusty_app->props.config_blob[++i],
ffffffffea808d54:	b86558e5 	ldr	w5, [x7, w5, uxtw #2]
			map_size = ROUNDUP(map_size, PAGE_SIZE);
ffffffffea808d58:	113ffc63 	add	w3, w3, #0xfff
ffffffffea808d5c:	12144c63 	and	w3, w3, #0xfffff000
			size = ROUNDUP(trusty_app->props.config_blob[++i],
ffffffffea808d60:	113ffca5 	add	w5, w5, #0xfff
ffffffffea808d64:	12144ca5 	and	w5, w5, #0xfffff000
			if (map_size > size) {
ffffffffea808d68:	6b0300bf 	cmp	w5, w3
ffffffffea808d6c:	540001c3 	b.cc	ffffffffea808da4 <trusty_app_setup_mmio+0x94>  // b.lo, b.ul, b.last
{
ffffffffea808d70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
			offset = trusty_app->props.config_blob[++i];
ffffffffea808d74:	11000886 	add	w6, w4, #0x2
ffffffffea808d78:	aa0203e1 	mov	x1, x2
	return uthread_map(ut, vaddrp, &paddr, size, flags, align);
ffffffffea808d7c:	52820005 	mov	w5, #0x1000                	// #4096
{
ffffffffea808d80:	910003fd 	mov	x29, sp
			return uthread_map_contig(trusty_app->ut, vaddr, offset,
ffffffffea808d84:	910083a2 	add	x2, x29, #0x20
ffffffffea808d88:	b86678e6 	ldr	w6, [x7, x6, lsl #2]
ffffffffea808d8c:	f9402c00 	ldr	x0, [x0, #88]
ffffffffea808d90:	52801464 	mov	w4, #0xa3                  	// #163
ffffffffea808d94:	f81f8c46 	str	x6, [x2, #-8]!
ffffffffea808d98:	94002b7c 	bl	ffffffffea813b88 <uthread_map>
}
ffffffffea808d9c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808da0:	d65f03c0 	ret
				return ERR_INVALID_ARGS;
ffffffffea808da4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea808da8:	d65f03c0 	ret
ffffffffea808dac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808db0 <trusty_app_init>:
{
ffffffffea808db0:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
	trusty_app_image_end = (char *)&__trusty_app_end;
ffffffffea808db4:	900002a3 	adrp	x3, ffffffffea85c000 <idle_threads+0xeb0>
	trusty_app_image_start = (char *)&__trusty_app_start;
ffffffffea808db8:	b0000080 	adrp	x0, ffffffffea819000 <__trusty_app_start>
	trusty_app_image_end = (char *)&__trusty_app_end;
ffffffffea808dbc:	f0000201 	adrp	x1, ffffffffea84b000 <__trusty_app_start+0x32000>
{
ffffffffea808dc0:	910003fd 	mov	x29, sp
ffffffffea808dc4:	f9000ff4 	str	x20, [sp, #24]
	trusty_app_image_start = (char *)&__trusty_app_start;
ffffffffea808dc8:	900002b4 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
{
ffffffffea808dcc:	f9002ffc 	str	x28, [sp, #88]
	trusty_app_image_size = (trusty_app_image_end - trusty_app_image_start);
ffffffffea808dd0:	900002bc 	adrp	x28, ffffffffea85c000 <idle_threads+0xeb0>
	trusty_app_image_start = (char *)&__trusty_app_start;
ffffffffea808dd4:	91000000 	add	x0, x0, #0x0
	trusty_app_image_end = (char *)&__trusty_app_end;
ffffffffea808dd8:	91368021 	add	x1, x1, #0xda0
	trusty_app_image_size = (trusty_app_image_end - trusty_app_image_start);
ffffffffea808ddc:	cb000022 	sub	x2, x1, x0
	trusty_app_image_end = (char *)&__trusty_app_end;
ffffffffea808de0:	f9078c61 	str	x1, [x3, #3864]
ffffffffea808de4:	f9000bb3 	str	x19, [x29, #16]
	ASSERT(!((uintptr_t)trusty_app_image_start & PAGE_MASK));
ffffffffea808de8:	f2402c1f 	tst	x0, #0xfff
ffffffffea808dec:	f9003fbe 	str	x30, [x29, #120]
	trusty_app_image_start = (char *)&__trusty_app_start;
ffffffffea808df0:	f9079680 	str	x0, [x20, #3880]
	trusty_app_image_size = (trusty_app_image_end - trusty_app_image_start);
ffffffffea808df4:	b90f2382 	str	w2, [x28, #3872]
	ASSERT(!((uintptr_t)trusty_app_image_start & PAGE_MASK));
ffffffffea808df8:	540037a1 	b.ne	ffffffffea8094ec <trusty_app_init+0x73c>  // b.any
ffffffffea808dfc:	90000093 	adrp	x19, ffffffffea818000 <_mem_phys_base>
ffffffffea808e00:	91340273 	add	x19, x19, #0xd00
ffffffffea808e04:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808e08:	aa1303e0 	mov	x0, x19
ffffffffea808e0c:	97fff2b7 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	apps_started = true;
ffffffffea808e10:	900002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea808e14:	52800022 	mov	w2, #0x1                   	// #1
	mutex_release(&apps_lock);
ffffffffea808e18:	aa1303e0 	mov	x0, x19
ffffffffea808e1c:	900002b3 	adrp	x19, ffffffffea85c000 <idle_threads+0xeb0>
	apps_started = true;
ffffffffea808e20:	393c2022 	strb	w2, [x1, #3848]
	mutex_release(&apps_lock);
ffffffffea808e24:	97fff2dd 	bl	ffffffffea805998 <mutex_release>
	if (trusty_app_image_size) {
ffffffffea808e28:	b94f2380 	ldr	w0, [x28, #3872]
ffffffffea808e2c:	350012e0 	cbnz	w0, ffffffffea809088 <trusty_app_init+0x2d8>
	platform_app_bootloader_epilog();
ffffffffea808e30:	97ffe2fa 	bl	ffffffffea801a18 <platform_app_bootloader_epilog>
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea808e34:	b94f1260 	ldr	w0, [x19, #3856]
ffffffffea808e38:	900002a1 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea808e3c:	f947983c 	ldr	x28, [x1, #3888]
ffffffffea808e40:	340011a0 	cbz	w0, ffffffffea809074 <trusty_app_init+0x2c4>
ffffffffea808e44:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea808e48:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea808e4c:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea808e50:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea808e54:	f9002bbb 	str	x27, [x29, #80]
		snprintf(name, sizeof(name), "trusty_app_%d_%08x-%04x-%04x",
ffffffffea808e58:	79404f86 	ldrh	w6, [x28, #38]
ffffffffea808e5c:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea808e60:	79404b85 	ldrh	w5, [x28, #36]
ffffffffea808e64:	912f4002 	add	x2, x0, #0xbd0
ffffffffea808e68:	b9402384 	ldr	w4, [x28, #32]
ffffffffea808e6c:	2a1703e3 	mov	w3, w23
ffffffffea808e70:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea808e74:	9102c3a0 	add	x0, x29, #0xb0
ffffffffea808e78:	9400282c 	bl	ffffffffea812f28 <snprintf>
		uthread = uthread_create(name, elf_hdr->e_entry,
ffffffffea808e7c:	f9402b80 	ldr	x0, [x28, #80]
ffffffffea808e80:	aa1c03e5 	mov	x5, x28
ffffffffea808e84:	b9403784 	ldr	w4, [x28, #52]
ffffffffea808e88:	d2a02003 	mov	x3, #0x1000000             	// #16777216
ffffffffea808e8c:	52800202 	mov	w2, #0x10                  	// #16
ffffffffea808e90:	b9401801 	ldr	w1, [x0, #24]
ffffffffea808e94:	9102c3a0 	add	x0, x29, #0xb0
ffffffffea808e98:	94002b7c 	bl	ffffffffea813c88 <uthread_create>
ffffffffea808e9c:	aa0003f5 	mov	x21, x0
		if (uthread == NULL) {
ffffffffea808ea0:	b4004b20 	cbz	x0, ffffffffea809804 <trusty_app_init+0xa54>
		tegra_boot_profiler_record("app_init: uthread allocated");
ffffffffea808ea4:	d0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea808ea8:	91304000 	add	x0, x0, #0xc10
ffffffffea808eac:	97fff9cd 	bl	ffffffffea8075e0 <tegra_boot_profiler_record>
	Elf32_Ehdr *elf_hdr = trusty_app->app_img;
ffffffffea808eb0:	f9402b94 	ldr	x20, [x28, #80]
	for (i = 0; i < elf_hdr->e_phnum; i++) {
ffffffffea808eb4:	79405a81 	ldrh	w1, [x20, #44]
		trusty_app->ut = uthread;
ffffffffea808eb8:	f9002f95 	str	x21, [x28, #88]
	for (i = 0; i < elf_hdr->e_phnum; i++) {
ffffffffea808ebc:	34000821 	cbz	w1, ffffffffea808fc0 <trusty_app_init+0x210>
ffffffffea808ec0:	d2800015 	mov	x21, #0x0                   	// #0
ffffffffea808ec4:	52800016 	mov	w22, #0x0                   	// #0
		if ((prg_hdr->p_vaddr < TRUSTY_APP_START_ADDR) ||
ffffffffea808ec8:	528ffff9 	mov	w25, #0x7fff                	// #32767
		vaddr_t stack_bot = TRUSTY_APP_STACK_TOP - trusty_app->props.min_stack_size;
ffffffffea808ecc:	52a02018 	mov	w24, #0x1000000             	// #16777216
		prg_hdr = (Elf32_Phdr *)(trusty_app_image + elf_hdr->e_phoff +
ffffffffea808ed0:	b9401e80 	ldr	w0, [x20, #28]
ffffffffea808ed4:	8b150000 	add	x0, x0, x21
ffffffffea808ed8:	8b00029a 	add	x26, x20, x0
		if (prg_hdr->p_type != PT_LOAD) {
ffffffffea808edc:	b8606a80 	ldr	w0, [x20, x0]
ffffffffea808ee0:	7100041f 	cmp	w0, #0x1
ffffffffea808ee4:	54000661 	b.ne	ffffffffea808fb0 <trusty_app_init+0x200>  // b.any
		if ((prg_hdr->p_vaddr < TRUSTY_APP_START_ADDR) ||
ffffffffea808ee8:	b9400b40 	ldr	w0, [x26, #8]
ffffffffea808eec:	6b19001f 	cmp	w0, w25
ffffffffea808ef0:	54000609 	b.ls	ffffffffea808fb0 <trusty_app_init+0x200>  // b.plast
ffffffffea808ef4:	f9400382 	ldr	x2, [x28]
ffffffffea808ef8:	eb20405f 	cmp	x2, w0, uxtw
ffffffffea808efc:	540005a9 	b.ls	ffffffffea808fb0 <trusty_app_init+0x200>  // b.plast
		ASSERT(!(prg_hdr->p_vaddr & PAGE_MASK) &&
ffffffffea808f00:	f2402c1f 	tst	x0, #0xfff
ffffffffea808f04:	54003901 	b.ne	ffffffffea809624 <trusty_app_init+0x874>  // b.any
ffffffffea808f08:	b9400741 	ldr	w1, [x26, #4]
ffffffffea808f0c:	2a0103e0 	mov	w0, w1
ffffffffea808f10:	f2402c3f 	tst	x1, #0xfff
ffffffffea808f14:	54003881 	b.ne	ffffffffea809624 <trusty_app_init+0x874>  // b.any
		size_t size = (prg_hdr->p_memsz + PAGE_MASK) & ~PAGE_MASK;
ffffffffea808f18:	b940175b 	ldr	w27, [x26, #20]
/* physical to virtual */
void *paddr_to_kvaddr(paddr_t pa);

/* virtual to physical */
paddr_t kvaddr_to_paddr(void *va);
static inline paddr_t vaddr_to_paddr(void *ptr) { return kvaddr_to_paddr(ptr); }
ffffffffea808f1c:	8b000280 	add	x0, x20, x0
ffffffffea808f20:	94001f3a 	bl	ffffffffea810c08 <kvaddr_to_paddr>
		u_int flags = PF_TO_UTM_FLAGS(prg_hdr->p_flags) | UTM_FIXED;
ffffffffea808f24:	b9401b41 	ldr	w1, [x26, #24]
		size_t size = (prg_hdr->p_memsz + PAGE_MASK) & ~PAGE_MASK;
ffffffffea808f28:	913fff7b 	add	x27, x27, #0xfff
		ret = uthread_map_contig(trusty_app->ut, &vaddr, paddr, size,
ffffffffea808f2c:	f9402f82 	ldr	x2, [x28, #88]
		size_t size = (prg_hdr->p_memsz + PAGE_MASK) & ~PAGE_MASK;
ffffffffea808f30:	9274cf7b 	and	x27, x27, #0xfffffffffffff000
		vaddr_t vaddr = prg_hdr->p_vaddr;
ffffffffea808f34:	b9400b43 	ldr	w3, [x26, #8]
ffffffffea808f38:	52820005 	mov	w5, #0x1000                	// #4096
ffffffffea808f3c:	f90053a0 	str	x0, [x29, #160]
ffffffffea808f40:	aa0203e0 	mov	x0, x2
ffffffffea808f44:	f9006ba3 	str	x3, [x29, #208]
		u_int flags = PF_TO_UTM_FLAGS(prg_hdr->p_flags) | UTM_FIXED;
ffffffffea808f48:	d3420822 	ubfx	x2, x1, #2, #1
ffffffffea808f4c:	531e0023 	ubfiz	w3, w1, #2, #1
ffffffffea808f50:	121f0021 	and	w1, w1, #0x2
ffffffffea808f54:	2a030042 	orr	w2, w2, w3
ffffffffea808f58:	32180021 	orr	w1, w1, #0x100
ffffffffea808f5c:	2a010041 	orr	w1, w2, w1
ffffffffea808f60:	aa1b03e3 	mov	x3, x27
ffffffffea808f64:	321b0024 	orr	w4, w1, #0x20
ffffffffea808f68:	910283a2 	add	x2, x29, #0xa0
ffffffffea808f6c:	910343a1 	add	x1, x29, #0xd0
ffffffffea808f70:	94002b06 	bl	ffffffffea813b88 <uthread_map>
		if (ret) {
ffffffffea808f74:	350041a0 	cbnz	w0, ffffffffea8097a8 <trusty_app_init+0x9f8>
		vaddr_t stack_bot = TRUSTY_APP_STACK_TOP - trusty_app->props.min_stack_size;
ffffffffea808f78:	b9403781 	ldr	w1, [x28, #52]
		if (stack_bot < vaddr + size) {
ffffffffea808f7c:	f9406ba0 	ldr	x0, [x29, #208]
		vaddr_t stack_bot = TRUSTY_APP_STACK_TOP - trusty_app->props.min_stack_size;
ffffffffea808f80:	4b010301 	sub	w1, w24, w1
		if (stack_bot < vaddr + size) {
ffffffffea808f84:	8b000360 	add	x0, x27, x0
ffffffffea808f88:	eb00003f 	cmp	x1, x0
ffffffffea808f8c:	54004003 	b.cc	ffffffffea80978c <trusty_app_init+0x9dc>  // b.lo, b.ul, b.last
		first = prg_hdr->p_vaddr;
ffffffffea808f90:	b9400b41 	ldr	w1, [x26, #8]
		last_mem = prg_hdr->p_vaddr + prg_hdr->p_memsz;
ffffffffea808f94:	b9401740 	ldr	w0, [x26, #20]
		if (last_mem > trusty_app->start_brk) {
ffffffffea808f98:	f9400782 	ldr	x2, [x28, #8]
		last_mem = prg_hdr->p_vaddr + prg_hdr->p_memsz;
ffffffffea808f9c:	0b000023 	add	w3, w1, w0
		if (last_mem > trusty_app->start_brk) {
ffffffffea808fa0:	eb02007f 	cmp	x3, x2
ffffffffea808fa4:	540032a8 	b.hi	ffffffffea8095f8 <trusty_app_init+0x848>  // b.pmore
ffffffffea808fa8:	79405a81 	ldrh	w1, [x20, #44]
ffffffffea808fac:	d503201f 	nop
	for (i = 0; i < elf_hdr->e_phnum; i++) {
ffffffffea808fb0:	110006d6 	add	w22, w22, #0x1
ffffffffea808fb4:	910082b5 	add	x21, x21, #0x20
ffffffffea808fb8:	6b0102df 	cmp	w22, w1
ffffffffea808fbc:	54fff8a3 	b.cc	ffffffffea808ed0 <trusty_app_init+0x120>  // b.lo, b.ul, b.last
	trusty_app->cur_brk = trusty_app->start_brk;
ffffffffea808fc0:	f9400782 	ldr	x2, [x28, #8]
	if ((trusty_app->end_brk - trusty_app->start_brk) >=
ffffffffea808fc4:	f9400f80 	ldr	x0, [x28, #24]
	    trusty_app->props.min_heap_size) {
ffffffffea808fc8:	b9403b81 	ldr	w1, [x28, #56]
	trusty_app->cur_brk = trusty_app->start_brk;
ffffffffea808fcc:	f9000b82 	str	x2, [x28, #16]
	if ((trusty_app->end_brk - trusty_app->start_brk) >=
ffffffffea808fd0:	cb020000 	sub	x0, x0, x2
ffffffffea808fd4:	eb01001f 	cmp	x0, x1
ffffffffea808fd8:	54003a03 	b.cc	ffffffffea809718 <trusty_app_init+0x968>  // b.lo, b.ul, b.last
		trusty_app->als = calloc(1, als_slot_cnt * sizeof(void*));
ffffffffea808fdc:	b00002a1 	adrp	x1, ffffffffea85d000 <rb_data+0x18>
ffffffffea808fe0:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea808fe4:	b940cc21 	ldr	w1, [x1, #204]
ffffffffea808fe8:	d37df021 	lsl	x1, x1, #3
ffffffffea808fec:	9400281b 	bl	ffffffffea813058 <calloc>
ffffffffea808ff0:	f9003380 	str	x0, [x28, #96]
		if (!trusty_app->als) {
ffffffffea808ff4:	b4004000 	cbz	x0, ffffffffea8097f4 <trusty_app_init+0xa44>
		list_for_every_entry(&app_notifier_list, n, trusty_app_notifier_t, node) {
ffffffffea808ff8:	90000095 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea808ffc:	9133c2b5 	add	x21, x21, #0xcf0
ffffffffea809000:	f94006b4 	ldr	x20, [x21, #8]
ffffffffea809004:	eb15029f 	cmp	x20, x21
ffffffffea809008:	54000140 	b.eq	ffffffffea809030 <trusty_app_init+0x280>  // b.none
ffffffffea80900c:	d503201f 	nop
			if (n->startup) {
ffffffffea809010:	f9400a81 	ldr	x1, [x20, #16]
ffffffffea809014:	b4000081 	cbz	x1, ffffffffea809024 <trusty_app_init+0x274>
				ret = n->startup(trusty_app);
ffffffffea809018:	aa1c03e0 	mov	x0, x28
ffffffffea80901c:	d63f0020 	blr	x1
				if (ret != NO_ERROR) {
ffffffffea809020:	35003fa0 	cbnz	w0, ffffffffea809814 <trusty_app_init+0xa64>
		list_for_every_entry(&app_notifier_list, n, trusty_app_notifier_t, node) {
ffffffffea809024:	f9400694 	ldr	x20, [x20, #8]
ffffffffea809028:	eb15029f 	cmp	x20, x21
ffffffffea80902c:	54ffff21 	b.ne	ffffffffea809010 <trusty_app_init+0x260>  // b.any
		snprintf(profiler_print, sizeof(profiler_print), "Loaded app: %s", name);
ffffffffea809030:	9102c3a3 	add	x3, x29, #0xb0
ffffffffea809034:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809038:	91362042 	add	x2, x2, #0xd88
ffffffffea80903c:	d2800801 	mov	x1, #0x40                  	// #64
ffffffffea809040:	910343a0 	add	x0, x29, #0xd0
ffffffffea809044:	940027b9 	bl	ffffffffea812f28 <snprintf>
		tegra_boot_profiler_record(profiler_print);
ffffffffea809048:	910343a0 	add	x0, x29, #0xd0
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea80904c:	110006f7 	add	w23, w23, #0x1
		tegra_boot_profiler_record(profiler_print);
ffffffffea809050:	97fff964 	bl	ffffffffea8075e0 <tegra_boot_profiler_record>
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea809054:	9101a39c 	add	x28, x28, #0x68
ffffffffea809058:	b94f1260 	ldr	w0, [x19, #3856]
ffffffffea80905c:	6b17001f 	cmp	w0, w23
ffffffffea809060:	54ffefc8 	b.hi	ffffffffea808e58 <trusty_app_init+0xa8>  // b.pmore
ffffffffea809064:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea809068:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80906c:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea809070:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea809074:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea809078:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80907c:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea809080:	a8d17bfd 	ldp	x29, x30, [sp], #272
ffffffffea809084:	d65f03c0 	ret
		trusty_app_list = (trusty_app_t *)memalign(PAGE_SIZE, PAGE_SIZE);
ffffffffea809088:	d2820001 	mov	x1, #0x1000                	// #4096
ffffffffea80908c:	f9001bb7 	str	x23, [x29, #48]
ffffffffea809090:	aa0103e0 	mov	x0, x1
	trusty_app_image_addr = trusty_app_image_start;
ffffffffea809094:	f9479694 	ldr	x20, [x20, #3880]
		trusty_app_list = (trusty_app_t *)memalign(PAGE_SIZE, PAGE_SIZE);
ffffffffea809098:	940027ec 	bl	ffffffffea813048 <memalign>
ffffffffea80909c:	aa0003f7 	mov	x23, x0
ffffffffea8090a0:	f0000281 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
		memset(trusty_app, 0, PAGE_SIZE);
ffffffffea8090a4:	d2820002 	mov	x2, #0x1000                	// #4096
		trusty_app_list = (trusty_app_t *)memalign(PAGE_SIZE, PAGE_SIZE);
ffffffffea8090a8:	f9079820 	str	x0, [x1, #3888]
		memset(trusty_app, 0, PAGE_SIZE);
ffffffffea8090ac:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8090b0:	940028b8 	bl	ffffffffea813390 <memset>
	while (trusty_app_image_size > 0) {
ffffffffea8090b4:	b94f2380 	ldr	w0, [x28, #3872]
ffffffffea8090b8:	340039a0 	cbz	w0, ffffffffea8097ec <trusty_app_init+0xa3c>
		guest_count++;
ffffffffea8090bc:	f0000280 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8090c0:	910082f7 	add	x23, x23, #0x20
ffffffffea8090c4:	913c3000 	add	x0, x0, #0xf0c
ffffffffea8090c8:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8090cc:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea8090d0:	a904efba 	stp	x26, x27, [x29, #72]
			if (!strcmp((shstbl + shdr[i].sh_name), ".bss")) {
ffffffffea8090d4:	b000007b 	adrp	x27, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
		guest_count++;
ffffffffea8090d8:	f90033a0 	str	x0, [x29, #96]
			if (!strcmp((shstbl + shdr[i].sh_name), ".bss")) {
ffffffffea8090dc:	9125e360 	add	x0, x27, #0x978
	while (trusty_app_image_size > 0) {
ffffffffea8090e0:	b9006fbf 	str	wzr, [x29, #108]
			if (!strcmp((shstbl + shdr[i].sh_name), ".bss")) {
ffffffffea8090e4:	f9004ba0 	str	x0, [x29, #144]
	if (!strcmp(*task_image_addr, NV_GUEST_TASK_MAGIC_STR)) {
ffffffffea8090e8:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8090ec:	9122e001 	add	x1, x0, #0x8b8
ffffffffea8090f0:	aa1403e0 	mov	x0, x20
ffffffffea8090f4:	940028c7 	bl	ffffffffea813410 <strcmp>
ffffffffea8090f8:	35000340 	cbnz	w0, ffffffffea809160 <trusty_app_init+0x3b0>
		guest_count++;
ffffffffea8090fc:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea809100:	b9400020 	ldr	w0, [x1]
ffffffffea809104:	11000400 	add	w0, w0, #0x1
ffffffffea809108:	b9000020 	str	w0, [x1]
		if (guest_count == 1) {
ffffffffea80910c:	7100041f 	cmp	w0, #0x1
ffffffffea809110:	54001ea0 	b.eq	ffffffffea8094e4 <trusty_app_init+0x734>  // b.none
		*task_vmid = strtoul(task_header, &endp, 0);
ffffffffea809114:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea809118:	910343a1 	add	x1, x29, #0xd0
ffffffffea80911c:	91003280 	add	x0, x20, #0xc
ffffffffea809120:	9400241c 	bl	ffffffffea812190 <strtoul>
ffffffffea809124:	b9006fa0 	str	w0, [x29, #108]
		if (*endp) {
ffffffffea809128:	f9406ba0 	ldr	x0, [x29, #208]
ffffffffea80912c:	39400000 	ldrb	w0, [x0]
ffffffffea809130:	35002e60 	cbnz	w0, ffffffffea8096fc <trusty_app_init+0x94c>
		trusty_app_image_end -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809134:	f0000280 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
		trusty_app_image_size -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809138:	b94f2382 	ldr	w2, [x28, #3872]
		trusty_app_image_end -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea80913c:	f0000284 	adrp	x4, ffffffffea85c000 <idle_threads+0xeb0>
		memmove(*task_image_addr, new_task_image_addr, trusty_app_image_size);
ffffffffea809140:	91008281 	add	x1, x20, #0x20
		trusty_app_image_end -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809144:	f9478c03 	ldr	x3, [x0, #3864]
		trusty_app_image_size -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809148:	51008042 	sub	w2, w2, #0x20
		memmove(*task_image_addr, new_task_image_addr, trusty_app_image_size);
ffffffffea80914c:	aa1403e0 	mov	x0, x20
		trusty_app_image_size -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809150:	b90f2382 	str	w2, [x28, #3872]
		trusty_app_image_end -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809154:	d1008063 	sub	x3, x3, #0x20
ffffffffea809158:	f9078c83 	str	x3, [x4, #3864]
		memmove(*task_image_addr, new_task_image_addr, trusty_app_image_size);
ffffffffea80915c:	94002811 	bl	ffffffffea8131a0 <memmove>
		if (strncmp((char *)ehdr->e_ident, ELFMAG, SELFMAG)) {
ffffffffea809160:	b0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809164:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea809168:	91244021 	add	x1, x1, #0x910
ffffffffea80916c:	aa1403e0 	mov	x0, x20
ffffffffea809170:	940028fe 	bl	ffffffffea813568 <strncmp>
ffffffffea809174:	35002b20 	cbnz	w0, ffffffffea8096d8 <trusty_app_init+0x928>
		shdr = (Elf32_Shdr *) ((intptr_t)ehdr + ehdr->e_shoff);
ffffffffea809178:	b9402282 	ldr	w2, [x20, #32]
		shstbl = (char *)((intptr_t)ehdr + shdr[ehdr->e_shstrndx].sh_offset);
ffffffffea80917c:	52800516 	mov	w22, #0x28                  	// #40
ffffffffea809180:	79406681 	ldrh	w1, [x20, #50]
		shdr = (Elf32_Shdr *) ((intptr_t)ehdr + ehdr->e_shoff);
ffffffffea809184:	8b140042 	add	x2, x2, x20
		for (i = 0; i < ehdr->e_shnum; i++) {
ffffffffea809188:	79406280 	ldrh	w0, [x20, #48]
		shstbl = (char *)((intptr_t)ehdr + shdr[ehdr->e_shstrndx].sh_offset);
ffffffffea80918c:	d503201f 	nop
ffffffffea809190:	9bb60821 	umaddl	x1, w1, w22, x2
ffffffffea809194:	b9401038 	ldr	w24, [x1, #16]
ffffffffea809198:	8b140301 	add	x1, x24, x20
ffffffffea80919c:	f9004fa1 	str	x1, [x29, #152]
		for (i = 0; i < ehdr->e_shnum; i++) {
ffffffffea8091a0:	34001740 	cbz	w0, ffffffffea809488 <trusty_app_init+0x6d8>
ffffffffea8091a4:	9100a041 	add	x1, x2, #0x28
ffffffffea8091a8:	51000400 	sub	w0, w0, #0x1
ffffffffea8091ac:	aa0203fb 	mov	x27, x2
			else if (!strcmp((shstbl + shdr[i].sh_name), ".bss-pad")) {
ffffffffea8091b0:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8091b4:	91260082 	add	x2, x4, #0x980
			else if (!strcmp((shstbl + shdr[i].sh_name),
ffffffffea8091b8:	b0000063 	adrp	x3, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
		bss_shdr = bss_pad_shdr = manifest_shdr = NULL;
ffffffffea8091bc:	a9087fa2 	stp	x2, xzr, [x29, #128]
ffffffffea8091c0:	d2800019 	mov	x25, #0x0                   	// #0
			else if (!strcmp((shstbl + shdr[i].sh_name),
ffffffffea8091c4:	91264062 	add	x2, x3, #0x990
ffffffffea8091c8:	9bb60416 	umaddl	x22, w0, w22, x1
		bss_shdr = bss_pad_shdr = manifest_shdr = NULL;
ffffffffea8091cc:	d280001a 	mov	x26, #0x0                   	// #0
		trusty_app_max_extent = 0;
ffffffffea8091d0:	52800015 	mov	w21, #0x0                   	// #0
			else if (!strcmp((shstbl + shdr[i].sh_name),
ffffffffea8091d4:	f9003ba2 	str	x2, [x29, #112]
ffffffffea8091d8:	1400000f 	b	ffffffffea809214 <trusty_app_init+0x464>
				trusty_app->end_bss = bss_shdr->sh_addr + bss_shdr->sh_size;
ffffffffea8091dc:	b9400f60 	ldr	w0, [x27, #12]
ffffffffea8091e0:	aa1b03fa 	mov	x26, x27
ffffffffea8091e4:	b9401761 	ldr	w1, [x27, #20]
ffffffffea8091e8:	0b010000 	add	w0, w0, w1
ffffffffea8091ec:	f81e02e0 	stur	x0, [x23, #-32]
			if (shdr[i].sh_type != SHT_NOBITS) {
ffffffffea8091f0:	7100231f 	cmp	w24, #0x8
ffffffffea8091f4:	540000a0 	b.eq	ffffffffea809208 <trusty_app_init+0x458>  // b.none
				extent = shdr[i].sh_offset + shdr[i].sh_size;
ffffffffea8091f8:	29420760 	ldp	w0, w1, [x27, #16]
ffffffffea8091fc:	0b010000 	add	w0, w0, w1
ffffffffea809200:	6b0002bf 	cmp	w21, w0
ffffffffea809204:	1a8022b5 	csel	w21, w21, w0, cs  // cs = hs, nlast
ffffffffea809208:	9100a37b 	add	x27, x27, #0x28
		for (i = 0; i < ehdr->e_shnum; i++) {
ffffffffea80920c:	eb1b02df 	cmp	x22, x27
ffffffffea809210:	540002a0 	b.eq	ffffffffea809264 <trusty_app_init+0x4b4>  // b.none
			if (shdr[i].sh_type == SHT_NULL) {
ffffffffea809214:	b9400778 	ldr	w24, [x27, #4]
ffffffffea809218:	34ffff98 	cbz	w24, ffffffffea809208 <trusty_app_init+0x458>
			if (!strcmp((shstbl + shdr[i].sh_name), ".bss")) {
ffffffffea80921c:	a94903a1 	ldp	x1, x0, [x29, #144]
ffffffffea809220:	b9400373 	ldr	w19, [x27]
ffffffffea809224:	8b130013 	add	x19, x0, x19
ffffffffea809228:	aa1303e0 	mov	x0, x19
ffffffffea80922c:	94002879 	bl	ffffffffea813410 <strcmp>
ffffffffea809230:	34fffd60 	cbz	w0, ffffffffea8091dc <trusty_app_init+0x42c>
			else if (!strcmp((shstbl + shdr[i].sh_name), ".bss-pad")) {
ffffffffea809234:	f94043a1 	ldr	x1, [x29, #128]
ffffffffea809238:	aa1303e0 	mov	x0, x19
ffffffffea80923c:	94002875 	bl	ffffffffea813410 <strcmp>
ffffffffea809240:	340000e0 	cbz	w0, ffffffffea80925c <trusty_app_init+0x4ac>
			else if (!strcmp((shstbl + shdr[i].sh_name),
ffffffffea809244:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea809248:	aa1303e0 	mov	x0, x19
ffffffffea80924c:	94002871 	bl	ffffffffea813410 <strcmp>
ffffffffea809250:	7100001f 	cmp	w0, #0x0
ffffffffea809254:	9a9b1339 	csel	x25, x25, x27, ne  // ne = any
ffffffffea809258:	17ffffe6 	b	ffffffffea8091f0 <trusty_app_init+0x440>
			else if (!strcmp((shstbl + shdr[i].sh_name), ".bss-pad")) {
ffffffffea80925c:	f90047bb 	str	x27, [x29, #136]
ffffffffea809260:	17ffffe4 	b	ffffffffea8091f0 <trusty_app_init+0x440>
		ASSERT(bss_shdr && bss_pad_shdr && manifest_shdr);
ffffffffea809264:	f94047a0 	ldr	x0, [x29, #136]
ffffffffea809268:	f100035f 	cmp	x26, #0x0
ffffffffea80926c:	fa401804 	ccmp	x0, #0x0, #0x4, ne  // ne = any
ffffffffea809270:	fa401b24 	ccmp	x25, #0x0, #0x4, ne  // ne = any
ffffffffea809274:	540010a0 	b.eq	ffffffffea809488 <trusty_app_init+0x6d8>  // b.none
		ASSERT((bss_shdr->sh_offset + bss_shdr->sh_size) <= trusty_app_max_extent);
ffffffffea809278:	29420b40 	ldp	w0, w2, [x26, #16]
ffffffffea80927c:	0b020001 	add	w1, w0, w2
ffffffffea809280:	6b15003f 	cmp	w1, w21
ffffffffea809284:	540014e8 	b.hi	ffffffffea809520 <trusty_app_init+0x770>  // b.pmore
		memset((uint8_t *)trusty_app_image_addr + bss_shdr->sh_offset, 0, bss_shdr->sh_size);
ffffffffea809288:	2a0203e2 	mov	w2, w2
ffffffffea80928c:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea809290:	8b204280 	add	x0, x20, w0, uxtw
ffffffffea809294:	9400283f 	bl	ffffffffea813390 <memset>
	ASSERT(shdr->sh_size >= sizeof(uuid_t));
ffffffffea809298:	29420323 	ldp	w3, w0, [x25, #16]
ffffffffea80929c:	71003c1f 	cmp	w0, #0xf
ffffffffea8092a0:	54001529 	b.ls	ffffffffea809544 <trusty_app_init+0x794>  // b.plast
	trusty_app->props.vmid = task_vmid;
ffffffffea8092a4:	b9406fa2 	ldr	w2, [x29, #108]
	trusty_app->props.min_heap_size = 4 * PAGE_SIZE;
ffffffffea8092a8:	52880000 	mov	w0, #0x4000                	// #16384
	trusty_app->props.min_stack_size = DEFAULT_STACK_SIZE;
ffffffffea8092ac:	52820001 	mov	w1, #0x1000                	// #4096
ffffffffea8092b0:	290206e2 	stp	w2, w1, [x23, #16]
	trusty_app->props.min_heap_size = 4 * PAGE_SIZE;
ffffffffea8092b4:	b9001ae0 	str	w0, [x23, #24]
	manifest_data = (char *)(trusty_app_image_addr + shdr->sh_offset);
ffffffffea8092b8:	8b234293 	add	x19, x20, w3, uxtw
	memcpy(&trusty_app->props.uuid,
ffffffffea8092bc:	aa1303e1 	mov	x1, x19
ffffffffea8092c0:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea8092c4:	aa1703e0 	mov	x0, x23
ffffffffea8092c8:	94002776 	bl	ffffffffea8130a0 <memcpy>
	config_blob_size = (shdr->sh_size - sizeof(uuid_t));
ffffffffea8092cc:	b9401721 	ldr	w1, [x25, #20]
ffffffffea8092d0:	51004021 	sub	w1, w1, #0x10
	trusty_app->props.config_entry_cnt = config_blob_size / sizeof (u_int);
ffffffffea8092d4:	53027c21 	lsr	w1, w1, #2
ffffffffea8092d8:	b90022e1 	str	w1, [x23, #32]
	if (trusty_app->props.config_entry_cnt == 0) {
ffffffffea8092dc:	340004e1 	cbz	w1, ffffffffea809378 <trusty_app_init+0x5c8>
	manifest_data += sizeof(trusty_app->props.uuid);
ffffffffea8092e0:	91004263 	add	x3, x19, #0x10
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea8092e4:	52800000 	mov	w0, #0x0                   	// #0
	trusty_app->props.config_blob = config_blob;
ffffffffea8092e8:	f90016e3 	str	x3, [x23, #40]
ffffffffea8092ec:	d503201f 	nop
		switch (config_blob[i]) {
ffffffffea8092f0:	b8605862 	ldr	w2, [x3, w0, uxtw #2]
ffffffffea8092f4:	7100085f 	cmp	w2, #0x2
ffffffffea8092f8:	54000260 	b.eq	ffffffffea809344 <trusty_app_init+0x594>  // b.none
ffffffffea8092fc:	71000c5f 	cmp	w2, #0x3
ffffffffea809300:	54000b40 	b.eq	ffffffffea809468 <trusty_app_init+0x6b8>  // b.none
ffffffffea809304:	7100045f 	cmp	w2, #0x1
ffffffffea809308:	540008c0 	b.eq	ffffffffea809420 <trusty_app_init+0x670>  // b.none
			dprintf(CRITICAL,
ffffffffea80930c:	b0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809310:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809314:	91202021 	add	x1, x1, #0x808
ffffffffea809318:	912b0000 	add	x0, x0, #0xac0
ffffffffea80931c:	9400213d 	bl	ffffffffea811810 <_dprintf>
			ASSERT(0);
ffffffffea809320:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809324:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809328:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80932c:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809330:	52801be3 	mov	w3, #0xdf                  	// #223
ffffffffea809334:	912b8084 	add	x4, x4, #0xae0
ffffffffea809338:	91224042 	add	x2, x2, #0x890
ffffffffea80933c:	91330021 	add	x1, x1, #0xcc0
ffffffffea809340:	940021b2 	bl	ffffffffea811a08 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 1);
ffffffffea809344:	4b000022 	sub	w2, w1, w0
ffffffffea809348:	7100045f 	cmp	w2, #0x1
ffffffffea80934c:	540010e9 	b.ls	ffffffffea809568 <trusty_app_init+0x7b8>  // b.plast
			trusty_app->props.min_heap_size =
ffffffffea809350:	11000400 	add	w0, w0, #0x1
				ROUNDUP(config_blob[++i], 4096);
ffffffffea809354:	b8605862 	ldr	w2, [x3, w0, uxtw #2]
ffffffffea809358:	113ffc42 	add	w2, w2, #0xfff
ffffffffea80935c:	12144c42 	and	w2, w2, #0xfffff000
			trusty_app->props.min_heap_size =
ffffffffea809360:	b9001ae2 	str	w2, [x23, #24]
			ASSERT(trusty_app->props.min_heap_size > 0);
ffffffffea809364:	34001382 	cbz	w2, ffffffffea8095d4 <trusty_app_init+0x824>
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea809368:	11000400 	add	w0, w0, #0x1
ffffffffea80936c:	6b00003f 	cmp	w1, w0
ffffffffea809370:	54fffc08 	b.hi	ffffffffea8092f0 <trusty_app_init+0x540>  // b.pmore
ffffffffea809374:	d503201f 	nop
	ASSERT(ROUNDUP(max_extent, 4) == elf_hdr->e_shoff);
ffffffffea809378:	b9402280 	ldr	w0, [x20, #32]
ffffffffea80937c:	11000eb5 	add	w21, w21, #0x3
		trusty_app->app_img = ehdr;
ffffffffea809380:	f9001af4 	str	x20, [x23, #48]
	ASSERT(ROUNDUP(max_extent, 4) == elf_hdr->e_shoff);
ffffffffea809384:	121e76b5 	and	w21, w21, #0xfffffffc
ffffffffea809388:	6b0002bf 	cmp	w21, w0
ffffffffea80938c:	540015e1 	b.ne	ffffffffea809648 <trusty_app_init+0x898>  // b.any
	max_extent = (elf_hdr->e_shoff + (elf_hdr->e_shnum * elf_hdr->e_shentsize)) - 1;
ffffffffea809390:	79406281 	ldrh	w1, [x20, #48]
	ASSERT((trusty_app_image_addr + max_extent + 1) <= trusty_app_image_end);
ffffffffea809394:	f0000280 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
	max_extent = (elf_hdr->e_shoff + (elf_hdr->e_shnum * elf_hdr->e_shentsize)) - 1;
ffffffffea809398:	79405e82 	ldrh	w2, [x20, #46]
	ASSERT((trusty_app_image_addr + max_extent + 1) <= trusty_app_image_end);
ffffffffea80939c:	f9478c00 	ldr	x0, [x0, #3864]
	max_extent = (elf_hdr->e_shoff + (elf_hdr->e_shnum * elf_hdr->e_shentsize)) - 1;
ffffffffea8093a0:	1b025435 	madd	w21, w1, w2, w21
ffffffffea8093a4:	510006b6 	sub	w22, w21, #0x1
ffffffffea8093a8:	aa1603f5 	mov	x21, x22
	ASSERT((trusty_app_image_addr + max_extent + 1) <= trusty_app_image_end);
ffffffffea8093ac:	910006d6 	add	x22, x22, #0x1
ffffffffea8093b0:	8b160281 	add	x1, x20, x22
ffffffffea8093b4:	eb00003f 	cmp	x1, x0
ffffffffea8093b8:	540015a8 	b.hi	ffffffffea80966c <trusty_app_init+0x8bc>  // b.pmore
	next_trusty_app_align_start = trusty_app_image_addr + pad_hdr->sh_offset + pad_hdr->sh_size;
ffffffffea8093bc:	f94047a2 	ldr	x2, [x29, #136]
ffffffffea8093c0:	29420858 	ldp	w24, w2, [x2, #16]
ffffffffea8093c4:	8b020318 	add	x24, x24, x2
ffffffffea8093c8:	8b180294 	add	x20, x20, x24
	ASSERT(next_trusty_app_align_start <= next_trusty_app_fsize_start);
ffffffffea8093cc:	eb14003f 	cmp	x1, x20
ffffffffea8093d0:	54001603 	b.cc	ffffffffea809690 <trusty_app_init+0x8e0>  // b.lo, b.ul, b.last
	copy_size = trusty_app_image_end - next_trusty_app_fsize_start;
ffffffffea8093d4:	cb010000 	sub	x0, x0, x1
	if (copy_size) {
ffffffffea8093d8:	350006a0 	cbnz	w0, ffffffffea8094ac <trusty_app_init+0x6fc>
	trusty_app_image_size -= (max_extent + 1);
ffffffffea8093dc:	b94f2380 	ldr	w0, [x28, #3872]
		ASSERT((trusty_app_count + 1) < MAX_TRUSTY_APP_COUNT);
ffffffffea8093e0:	f0000293 	adrp	x19, ffffffffea85c000 <idle_threads+0xeb0>
	trusty_app_image_size -= (max_extent + 1);
ffffffffea8093e4:	51000400 	sub	w0, w0, #0x1
		ASSERT((trusty_app_count + 1) < MAX_TRUSTY_APP_COUNT);
ffffffffea8093e8:	b94f1261 	ldr	w1, [x19, #3856]
	trusty_app_image_size -= (max_extent + 1);
ffffffffea8093ec:	4b150015 	sub	w21, w0, w21
ffffffffea8093f0:	b90f2395 	str	w21, [x28, #3872]
		ASSERT((trusty_app_count + 1) < MAX_TRUSTY_APP_COUNT);
ffffffffea8093f4:	11000420 	add	w0, w1, #0x1
ffffffffea8093f8:	7100981f 	cmp	w0, #0x26
ffffffffea8093fc:	540015c8 	b.hi	ffffffffea8096b4 <trusty_app_init+0x904>  // b.pmore
		trusty_app_count++;
ffffffffea809400:	b90f1260 	str	w0, [x19, #3856]
ffffffffea809404:	9101a2f7 	add	x23, x23, #0x68
	while (trusty_app_image_size > 0) {
ffffffffea809408:	35ffe715 	cbnz	w21, ffffffffea8090e8 <trusty_app_init+0x338>
ffffffffea80940c:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea809410:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea809414:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea809418:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea80941c:	17fffe85 	b	ffffffffea808e30 <trusty_app_init+0x80>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 1);
ffffffffea809420:	4b000022 	sub	w2, w1, w0
ffffffffea809424:	7100045f 	cmp	w2, #0x1
ffffffffea809428:	54000b29 	b.ls	ffffffffea80958c <trusty_app_init+0x7dc>  // b.plast
			trusty_app->props.min_stack_size =
ffffffffea80942c:	11000400 	add	w0, w0, #0x1
				ROUNDUP(config_blob[++i], 4096);
ffffffffea809430:	b8605862 	ldr	w2, [x3, w0, uxtw #2]
ffffffffea809434:	113ffc42 	add	w2, w2, #0xfff
ffffffffea809438:	12144c42 	and	w2, w2, #0xfffff000
			trusty_app->props.min_stack_size =
ffffffffea80943c:	b90016e2 	str	w2, [x23, #20]
			ASSERT(trusty_app->props.min_stack_size > 0);
ffffffffea809440:	35fff942 	cbnz	w2, ffffffffea809368 <trusty_app_init+0x5b8>
ffffffffea809444:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809448:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80944c:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809450:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809454:	91290084 	add	x4, x4, #0xa40
ffffffffea809458:	52801983 	mov	w3, #0xcc                  	// #204
ffffffffea80945c:	91224042 	add	x2, x2, #0x890
ffffffffea809460:	91330021 	add	x1, x1, #0xcc0
ffffffffea809464:	94002169 	bl	ffffffffea811a08 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 3);
ffffffffea809468:	4b000022 	sub	w2, w1, w0
ffffffffea80946c:	71000c5f 	cmp	w2, #0x3
ffffffffea809470:	54000a09 	b.ls	ffffffffea8095b0 <trusty_app_init+0x800>  // b.plast
			trusty_app->props.map_io_mem_cnt++;
ffffffffea809474:	b9401ee2 	ldr	w2, [x23, #28]
			i += 3;
ffffffffea809478:	11000c00 	add	w0, w0, #0x3
			trusty_app->props.map_io_mem_cnt++;
ffffffffea80947c:	11000442 	add	w2, w2, #0x1
ffffffffea809480:	b9001ee2 	str	w2, [x23, #28]
ffffffffea809484:	17ffffb9 	b	ffffffffea809368 <trusty_app_init+0x5b8>
		ASSERT(bss_shdr && bss_pad_shdr && manifest_shdr);
ffffffffea809488:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea80948c:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809490:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809494:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809498:	91252084 	add	x4, x4, #0x948
ffffffffea80949c:	52804723 	mov	w3, #0x239                 	// #569
ffffffffea8094a0:	91224042 	add	x2, x2, #0x890
ffffffffea8094a4:	91330021 	add	x1, x1, #0xcc0
ffffffffea8094a8:	94002158 	bl	ffffffffea811a08 <_panic>
		memcpy(next_trusty_app_align_start, next_trusty_app_fsize_start, copy_size);
ffffffffea8094ac:	92407c13 	and	x19, x0, #0xffffffff
ffffffffea8094b0:	aa1403e0 	mov	x0, x20
ffffffffea8094b4:	aa1303e2 	mov	x2, x19
ffffffffea8094b8:	940026fa 	bl	ffffffffea8130a0 <memcpy>
		arch_sync_cache_range((addr_t)next_trusty_app_align_start,
ffffffffea8094bc:	aa1403e0 	mov	x0, x20
ffffffffea8094c0:	aa1303e1 	mov	x1, x19
		trusty_app_image_end -= (next_trusty_app_fsize_start - next_trusty_app_align_start);
ffffffffea8094c4:	cb1802d6 	sub	x22, x22, x24
		arch_sync_cache_range((addr_t)next_trusty_app_align_start,
ffffffffea8094c8:	97ffe152 	bl	ffffffffea801a10 <arch_sync_cache_range>
		trusty_app_image_end -= (next_trusty_app_fsize_start - next_trusty_app_align_start);
ffffffffea8094cc:	f0000280 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8094d0:	f9478c00 	ldr	x0, [x0, #3864]
ffffffffea8094d4:	cb160016 	sub	x22, x0, x22
ffffffffea8094d8:	f0000280 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8094dc:	f9078c16 	str	x22, [x0, #3864]
ffffffffea8094e0:	17ffffbf 	b	ffffffffea8093dc <trusty_app_init+0x62c>
			platform_disable_debug_intf();
ffffffffea8094e4:	97ffe31f 	bl	ffffffffea802160 <platform_disable_debug_intf>
ffffffffea8094e8:	17ffff0b 	b	ffffffffea809114 <trusty_app_init+0x364>
	ASSERT(!((uintptr_t)trusty_app_image_start & PAGE_MASK));
ffffffffea8094ec:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8094f0:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8094f4:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8094f8:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8094fc:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea809500:	91216084 	add	x4, x4, #0x858
ffffffffea809504:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea809508:	52804f23 	mov	w3, #0x279                 	// #633
ffffffffea80950c:	91224042 	add	x2, x2, #0x890
ffffffffea809510:	91330021 	add	x1, x1, #0xcc0
ffffffffea809514:	aa1e03e0 	mov	x0, x30
ffffffffea809518:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80951c:	9400213b 	bl	ffffffffea811a08 <_panic>
		ASSERT((bss_shdr->sh_offset + bss_shdr->sh_size) <= trusty_app_max_extent);
ffffffffea809520:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809524:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809528:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80952c:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809530:	9126a084 	add	x4, x4, #0x9a8
ffffffffea809534:	52804783 	mov	w3, #0x23c                 	// #572
ffffffffea809538:	91224042 	add	x2, x2, #0x890
ffffffffea80953c:	91330021 	add	x1, x1, #0xcc0
ffffffffea809540:	94002132 	bl	ffffffffea811a08 <_panic>
	ASSERT(shdr->sh_size >= sizeof(uuid_t));
ffffffffea809544:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809548:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80954c:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809550:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809554:	9127c084 	add	x4, x4, #0x9f0
ffffffffea809558:	528013e3 	mov	w3, #0x9f                  	// #159
ffffffffea80955c:	91224042 	add	x2, x2, #0x890
ffffffffea809560:	91330021 	add	x1, x1, #0xcc0
ffffffffea809564:	94002129 	bl	ffffffffea811a08 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 1);
ffffffffea809568:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea80956c:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809570:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809574:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809578:	91284084 	add	x4, x4, #0xa10
ffffffffea80957c:	52801a03 	mov	w3, #0xd0                  	// #208
ffffffffea809580:	91224042 	add	x2, x2, #0x890
ffffffffea809584:	91330021 	add	x1, x1, #0xcc0
ffffffffea809588:	94002120 	bl	ffffffffea811a08 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 1);
ffffffffea80958c:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809590:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809594:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809598:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80959c:	91284084 	add	x4, x4, #0xa10
ffffffffea8095a0:	52801923 	mov	w3, #0xc9                  	// #201
ffffffffea8095a4:	91224042 	add	x2, x2, #0x890
ffffffffea8095a8:	91330021 	add	x1, x1, #0xcc0
ffffffffea8095ac:	94002117 	bl	ffffffffea811a08 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 3);
ffffffffea8095b0:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea8095b4:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8095b8:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8095bc:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8095c0:	912a4084 	add	x4, x4, #0xa90
ffffffffea8095c4:	52801ae3 	mov	w3, #0xd7                  	// #215
ffffffffea8095c8:	91224042 	add	x2, x2, #0x890
ffffffffea8095cc:	91330021 	add	x1, x1, #0xcc0
ffffffffea8095d0:	9400210e 	bl	ffffffffea811a08 <_panic>
			ASSERT(trusty_app->props.min_heap_size > 0);
ffffffffea8095d4:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea8095d8:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8095dc:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8095e0:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8095e4:	9129a084 	add	x4, x4, #0xa68
ffffffffea8095e8:	52801a63 	mov	w3, #0xd3                  	// #211
ffffffffea8095ec:	91224042 	add	x2, x2, #0x890
ffffffffea8095f0:	91330021 	add	x1, x1, #0xcc0
ffffffffea8095f4:	94002105 	bl	ffffffffea811a08 <_panic>
			void *segment_start = trusty_app_image + prg_hdr->p_offset;
ffffffffea8095f8:	b9400744 	ldr	w4, [x26, #4]
			trusty_app->end_brk = prg_hdr->p_vaddr + size;
ffffffffea8095fc:	8b214361 	add	x1, x27, w1, uxtw
			memset(segment_start + prg_hdr->p_memsz, 0,
ffffffffea809600:	2a0003e2 	mov	w2, w0
			trusty_app->start_brk = last_mem;
ffffffffea809604:	f9000783 	str	x3, [x28, #8]
			trusty_app->end_brk = prg_hdr->p_vaddr + size;
ffffffffea809608:	f9000f81 	str	x1, [x28, #24]
			memset(segment_start + prg_hdr->p_memsz, 0,
ffffffffea80960c:	8b020080 	add	x0, x4, x2
ffffffffea809610:	8b000280 	add	x0, x20, x0
ffffffffea809614:	cb020362 	sub	x2, x27, x2
ffffffffea809618:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80961c:	9400275d 	bl	ffffffffea813390 <memset>
ffffffffea809620:	17fffe62 	b	ffffffffea808fa8 <trusty_app_init+0x1f8>
		ASSERT(!(prg_hdr->p_vaddr & PAGE_MASK) &&
ffffffffea809624:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809628:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80962c:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809630:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809634:	9130c084 	add	x4, x4, #0xc30
ffffffffea809638:	528027e3 	mov	w3, #0x13f                 	// #319
ffffffffea80963c:	91224042 	add	x2, x2, #0x890
ffffffffea809640:	91330021 	add	x1, x1, #0xcc0
ffffffffea809644:	940020f1 	bl	ffffffffea811a08 <_panic>
	ASSERT(ROUNDUP(max_extent, 4) == elf_hdr->e_shoff);
ffffffffea809648:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea80964c:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809650:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809654:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea809658:	912ba084 	add	x4, x4, #0xae8
ffffffffea80965c:	52803523 	mov	w3, #0x1a9                 	// #425
ffffffffea809660:	91224042 	add	x2, x2, #0x890
ffffffffea809664:	91330021 	add	x1, x1, #0xcc0
ffffffffea809668:	940020e8 	bl	ffffffffea811a08 <_panic>
	ASSERT((trusty_app_image_addr + max_extent + 1) <= trusty_app_image_end);
ffffffffea80966c:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809670:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809674:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809678:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80967c:	912c6084 	add	x4, x4, #0xb18
ffffffffea809680:	528035c3 	mov	w3, #0x1ae                 	// #430
ffffffffea809684:	91224042 	add	x2, x2, #0x890
ffffffffea809688:	91330021 	add	x1, x1, #0xcc0
ffffffffea80968c:	940020df 	bl	ffffffffea811a08 <_panic>
	ASSERT(next_trusty_app_align_start <= next_trusty_app_fsize_start);
ffffffffea809690:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809694:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809698:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80969c:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8096a0:	912d8084 	add	x4, x4, #0xb60
ffffffffea8096a4:	52803643 	mov	w3, #0x1b2                 	// #434
ffffffffea8096a8:	91224042 	add	x2, x2, #0x890
ffffffffea8096ac:	91330021 	add	x1, x1, #0xcc0
ffffffffea8096b0:	940020d6 	bl	ffffffffea811a08 <_panic>
		ASSERT((trusty_app_count + 1) < MAX_TRUSTY_APP_COUNT);
ffffffffea8096b4:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea8096b8:	b0000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8096bc:	b0000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8096c0:	90000061 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8096c4:	912e8084 	add	x4, x4, #0xba0
ffffffffea8096c8:	528048a3 	mov	w3, #0x245                 	// #581
ffffffffea8096cc:	91224042 	add	x2, x2, #0x890
ffffffffea8096d0:	91330021 	add	x1, x1, #0xcc0
ffffffffea8096d4:	940020cd 	bl	ffffffffea811a08 <_panic>
			dprintf(CRITICAL, "trusty_app_bootloader: ELF header not found\n");
ffffffffea8096d8:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8096dc:	f0000293 	adrp	x19, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8096e0:	91246000 	add	x0, x0, #0x918
ffffffffea8096e4:	9400204b 	bl	ffffffffea811810 <_dprintf>
ffffffffea8096e8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8096ec:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea8096f0:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea8096f4:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea8096f8:	17fffdce 	b	ffffffffea808e30 <trusty_app_init+0x80>
			dprintf(CRITICAL, "VMID convert fail\n");
ffffffffea8096fc:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809700:	91232000 	add	x0, x0, #0x8c8
ffffffffea809704:	94002043 	bl	ffffffffea811810 <_dprintf>
			panic("failed to get trusty app image address \n");
ffffffffea809708:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea80970c:	b0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809710:	91238021 	add	x1, x1, #0x8e0
ffffffffea809714:	940020bd 	bl	ffffffffea811a08 <_panic>
	heap = memalign(PAGE_SIZE, trusty_app->props.min_heap_size);
ffffffffea809718:	d2820000 	mov	x0, #0x1000                	// #4096
ffffffffea80971c:	9400264b 	bl	ffffffffea813048 <memalign>
ffffffffea809720:	aa0003f4 	mov	x20, x0
	if (heap == 0) {
ffffffffea809724:	b40005c0 	cbz	x0, ffffffffea8097dc <trusty_app_init+0xa2c>
	memset(heap, 0, trusty_app->props.min_heap_size);
ffffffffea809728:	b9403b82 	ldr	w2, [x28, #56]
ffffffffea80972c:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea809730:	94002718 	bl	ffffffffea813390 <memset>
	status = uthread_map_contig(trusty_app->ut, &vaddr,
ffffffffea809734:	f9402f95 	ldr	x21, [x28, #88]
	vaddr = trusty_app->end_brk;
ffffffffea809738:	f9400f80 	ldr	x0, [x28, #24]
ffffffffea80973c:	f9006ba0 	str	x0, [x29, #208]
ffffffffea809740:	aa1403e0 	mov	x0, x20
ffffffffea809744:	94001d31 	bl	ffffffffea810c08 <kvaddr_to_paddr>
	status = uthread_map_contig(trusty_app->ut, &vaddr,
ffffffffea809748:	b9403b83 	ldr	w3, [x28, #56]
ffffffffea80974c:	52820005 	mov	w5, #0x1000                	// #4096
ffffffffea809750:	f90057a0 	str	x0, [x29, #168]
ffffffffea809754:	52802464 	mov	w4, #0x123                 	// #291
ffffffffea809758:	9102a3a2 	add	x2, x29, #0xa8
ffffffffea80975c:	910343a1 	add	x1, x29, #0xd0
ffffffffea809760:	aa1503e0 	mov	x0, x21
ffffffffea809764:	94002909 	bl	ffffffffea813b88 <uthread_map>
	if (status != NO_ERROR || vaddr != trusty_app->end_brk) {
ffffffffea809768:	35000280 	cbnz	w0, ffffffffea8097b8 <trusty_app_init+0xa08>
ffffffffea80976c:	f9400f81 	ldr	x1, [x28, #24]
ffffffffea809770:	f9406ba0 	ldr	x0, [x29, #208]
ffffffffea809774:	eb00003f 	cmp	x1, x0
ffffffffea809778:	54000201 	b.ne	ffffffffea8097b8 <trusty_app_init+0xa08>  // b.any
	trusty_app->end_brk += trusty_app->props.min_heap_size;
ffffffffea80977c:	b9403b80 	ldr	w0, [x28, #56]
ffffffffea809780:	8b010000 	add	x0, x0, x1
ffffffffea809784:	f9000f80 	str	x0, [x28, #24]
ffffffffea809788:	17fffe15 	b	ffffffffea808fdc <trusty_app_init+0x22c>
			dprintf(CRITICAL,
ffffffffea80978c:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809790:	91324000 	add	x0, x0, #0xc90
ffffffffea809794:	9400201f 	bl	ffffffffea811810 <_dprintf>
			panic("failed to load address map\n");
ffffffffea809798:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea80979c:	b0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8097a0:	91346021 	add	x1, x1, #0xd18
ffffffffea8097a4:	94002099 	bl	ffffffffea811a08 <_panic>
			dprintf(CRITICAL, "cannot map the segment\n");
ffffffffea8097a8:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8097ac:	9131e000 	add	x0, x0, #0xc78
ffffffffea8097b0:	94002018 	bl	ffffffffea811810 <_dprintf>
ffffffffea8097b4:	17fffff9 	b	ffffffffea809798 <trusty_app_init+0x9e8>
		dprintf(CRITICAL, "cannot map brk\n");
ffffffffea8097b8:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8097bc:	91332000 	add	x0, x0, #0xcc8
ffffffffea8097c0:	94002014 	bl	ffffffffea811810 <_dprintf>
		free(heap);
ffffffffea8097c4:	aa1403e0 	mov	x0, x20
ffffffffea8097c8:	94002634 	bl	ffffffffea813098 <free>
		dprintf(CRITICAL, "failed to load trusty_app: trusty_app heap creation error\n");
ffffffffea8097cc:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8097d0:	91336000 	add	x0, x0, #0xcd8
ffffffffea8097d4:	9400200f 	bl	ffffffffea811810 <_dprintf>
ffffffffea8097d8:	17fffff0 	b	ffffffffea809798 <trusty_app_init+0x9e8>
ffffffffea8097dc:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8097e0:	91336000 	add	x0, x0, #0xcd8
ffffffffea8097e4:	9400200b 	bl	ffffffffea811810 <_dprintf>
ffffffffea8097e8:	17ffffec 	b	ffffffffea809798 <trusty_app_init+0x9e8>
ffffffffea8097ec:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea8097f0:	17fffd90 	b	ffffffffea808e30 <trusty_app_init+0x80>
			panic("allocate app local storage failed\n");
ffffffffea8097f4:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea8097f8:	b0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea8097fc:	9134e021 	add	x1, x1, #0xd38
ffffffffea809800:	94002082 	bl	ffffffffea811a08 <_panic>
			panic("allocate user thread failed\n");
ffffffffea809804:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809808:	b0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80980c:	912fc021 	add	x1, x1, #0xbf0
ffffffffea809810:	9400207e 	bl	ffffffffea811a08 <_panic>
					panic("failed (%d) to invoke startup notifier\n", ret);
ffffffffea809814:	2a0003e2 	mov	w2, w0
ffffffffea809818:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea80981c:	b0000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809820:	91358021 	add	x1, x1, #0xd60
ffffffffea809824:	94002079 	bl	ffffffffea811a08 <_panic>

ffffffffea809828 <sys_std_write>:
	return uthread_is_valid_range(uthread_get_current(), addr, size);
}

/* handle stdout/stderr */
static int32_t sys_std_write(uint32_t fd, user_addr_t user_ptr, uint32_t size)
{
ffffffffea809828:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80982c:	910003fd 	mov	x29, sp
ffffffffea809830:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea809834:	2a0203f5 	mov	w21, w2
ffffffffea809838:	f90017f6 	str	x22, [sp, #40]
	/* check buffer is in task's address space */
	if (!valid_address((vaddr_t)user_ptr, size)) {
ffffffffea80983c:	2a0103f4 	mov	w20, w1
{
ffffffffea809840:	2a0003f6 	mov	w22, w0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea809844:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea809848:	f9415800 	ldr	x0, [x0, #688]
ffffffffea80984c:	aa1503e2 	mov	x2, x21
ffffffffea809850:	aa1403e1 	mov	x1, x20
ffffffffea809854:	94002a7f 	bl	ffffffffea814250 <uthread_is_valid_range>
	if (!valid_address((vaddr_t)user_ptr, size)) {
ffffffffea809858:	72001c1f 	tst	w0, #0xff
ffffffffea80985c:	540001e0 	b.eq	ffffffffea809898 <sys_std_write+0x70>  // b.none
ffffffffea809860:	f9000bb3 	str	x19, [x29, #16]
		return ERR_INVALID_ARGS;
	}
	/* always send out error logs */
	dwrite((fd == 2) ? ALWAYS : INFO, (const void *)(uintptr_t)user_ptr, size);
ffffffffea809864:	71000adf 	cmp	w22, #0x2
ffffffffea809868:	aa1503f3 	mov	x19, x21
ffffffffea80986c:	540000e0 	b.eq	ffffffffea809888 <sys_std_write+0x60>  // b.none

	return size;
ffffffffea809870:	2a1303e0 	mov	w0, w19
ffffffffea809874:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea809878:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80987c:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea809880:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809884:	d65f03c0 	ret
	dwrite((fd == 2) ? ALWAYS : INFO, (const void *)(uintptr_t)user_ptr, size);
ffffffffea809888:	aa1503e1 	mov	x1, x21
ffffffffea80988c:	aa1403e0 	mov	x0, x20
ffffffffea809890:	94001fb6 	bl	ffffffffea811768 <_dwrite>
ffffffffea809894:	17fffff7 	b	ffffffffea809870 <sys_std_write+0x48>
		return ERR_INVALID_ARGS;
ffffffffea809898:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80989c:	17fffff7 	b	ffffffffea809878 <sys_std_write+0x50>

ffffffffea8098a0 <sys_write>:
	if (fd >= countof(sys_fds)) {
ffffffffea8098a0:	7100241f 	cmp	w0, #0x9
ffffffffea8098a4:	540001c8 	b.hi	ffffffffea8098dc <sys_write+0x3c>  // b.pmore
ffffffffea8098a8:	2a0003e4 	mov	w4, w0
	return sys_fds[fd];
ffffffffea8098ac:	f0000063 	adrp	x3, ffffffffea818000 <_mem_phys_base>
ffffffffea8098b0:	9134e063 	add	x3, x3, #0xd38
ffffffffea8098b4:	f8645863 	ldr	x3, [x3, w4, uxtw #3]

long sys_write(uint32_t fd, user_addr_t user_ptr, uint32_t size)
{
	const struct sys_fd_ops *ops = get_sys_fd_handler(fd);

	if (ops && ops->write) {
ffffffffea8098b8:	b4000123 	cbz	x3, ffffffffea8098dc <sys_write+0x3c>
ffffffffea8098bc:	f9400463 	ldr	x3, [x3, #8]
ffffffffea8098c0:	b40000e3 	cbz	x3, ffffffffea8098dc <sys_write+0x3c>
{
ffffffffea8098c4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea8098c8:	910003fd 	mov	x29, sp
		return ops->write(fd, user_ptr, size);
ffffffffea8098cc:	d63f0060 	blr	x3
ffffffffea8098d0:	93407c00 	sxtw	x0, w0
	}
	return ERR_NOT_SUPPORTED;
}
ffffffffea8098d4:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8098d8:	d65f03c0 	ret
	return ERR_NOT_SUPPORTED;
ffffffffea8098dc:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
}
ffffffffea8098e0:	d65f03c0 	ret
ffffffffea8098e4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8098e8 <sys_brk>:
ffffffffea8098e8:	d538d081 	mrs	x1, tpidr_el1

long sys_brk(u_int brk)
{
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea8098ec:	f9415821 	ldr	x1, [x1, #688]

	/* update brk, if within range */
	if ((brk >= trusty_app->start_brk) && (brk <= trusty_app->end_brk)) {
ffffffffea8098f0:	2a0003e0 	mov	w0, w0
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea8098f4:	f9404821 	ldr	x1, [x1, #144]
	if ((brk >= trusty_app->start_brk) && (brk <= trusty_app->end_brk)) {
ffffffffea8098f8:	f9400422 	ldr	x2, [x1, #8]
ffffffffea8098fc:	eb02001f 	cmp	x0, x2
ffffffffea809900:	540000c3 	b.cc	ffffffffea809918 <sys_brk+0x30>  // b.lo, b.ul, b.last
ffffffffea809904:	f9400c22 	ldr	x2, [x1, #24]
ffffffffea809908:	eb02001f 	cmp	x0, x2
ffffffffea80990c:	54000068 	b.hi	ffffffffea809918 <sys_brk+0x30>  // b.pmore
		trusty_app->cur_brk = brk;
ffffffffea809910:	f9000820 	str	x0, [x1, #16]
	}
	return (long) trusty_app->cur_brk;
}
ffffffffea809914:	d65f03c0 	ret
ffffffffea809918:	f9400820 	ldr	x0, [x1, #16]
ffffffffea80991c:	d65f03c0 	ret

ffffffffea809920 <sys_exit_group>:

long sys_exit_group(void)
{
ffffffffea809920:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809924:	910003fd 	mov	x29, sp
ffffffffea809928:	d538d081 	mrs	x1, tpidr_el1
	thread_t *current = get_current_thread();
	dprintf(CRITICAL, "exit called, thread %p, name %s\n",
ffffffffea80992c:	910ae022 	add	x2, x1, #0x2b8
ffffffffea809930:	b0000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea809934:	91366000 	add	x0, x0, #0xd98
ffffffffea809938:	94001fb6 	bl	ffffffffea811810 <_dprintf>
		current, current->name);
	uthread_exit(0);
ffffffffea80993c:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea809940:	94002874 	bl	ffffffffea813b10 <uthread_exit>
ffffffffea809944:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809948 <sys_read>:
	if (fd >= countof(sys_fds)) {
ffffffffea809948:	7100241f 	cmp	w0, #0x9
ffffffffea80994c:	540001c8 	b.hi	ffffffffea809984 <sys_read+0x3c>  // b.pmore
ffffffffea809950:	2a0003e4 	mov	w4, w0
	return sys_fds[fd];
ffffffffea809954:	f0000063 	adrp	x3, ffffffffea818000 <_mem_phys_base>
ffffffffea809958:	9134e063 	add	x3, x3, #0xd38
ffffffffea80995c:	f8645863 	ldr	x3, [x3, w4, uxtw #3]

long sys_read(uint32_t fd, user_addr_t user_ptr, uint32_t size)
{
	const struct sys_fd_ops *ops = get_sys_fd_handler(fd);

	if (ops && ops->read) {
ffffffffea809960:	b4000123 	cbz	x3, ffffffffea809984 <sys_read+0x3c>
ffffffffea809964:	f9400063 	ldr	x3, [x3]
ffffffffea809968:	b40000e3 	cbz	x3, ffffffffea809984 <sys_read+0x3c>
{
ffffffffea80996c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809970:	910003fd 	mov	x29, sp
		return ops->read(fd, user_ptr, size);
ffffffffea809974:	d63f0060 	blr	x3
ffffffffea809978:	93407c00 	sxtw	x0, w0
	}
	return ERR_NOT_SUPPORTED;
}
ffffffffea80997c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809980:	d65f03c0 	ret
	return ERR_NOT_SUPPORTED;
ffffffffea809984:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
}
ffffffffea809988:	d65f03c0 	ret
ffffffffea80998c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809990 <sys_ioctl>:
	if (fd >= countof(sys_fds)) {
ffffffffea809990:	7100241f 	cmp	w0, #0x9
ffffffffea809994:	540001c8 	b.hi	ffffffffea8099cc <sys_ioctl+0x3c>  // b.pmore
ffffffffea809998:	2a0003e4 	mov	w4, w0
	return sys_fds[fd];
ffffffffea80999c:	f0000063 	adrp	x3, ffffffffea818000 <_mem_phys_base>
ffffffffea8099a0:	9134e063 	add	x3, x3, #0xd38
ffffffffea8099a4:	f8645863 	ldr	x3, [x3, w4, uxtw #3]

long sys_ioctl(uint32_t fd, uint32_t req, user_addr_t user_ptr)
{
	const struct sys_fd_ops *ops = get_sys_fd_handler(fd);

	if (ops && ops->ioctl) {
ffffffffea8099a8:	b4000123 	cbz	x3, ffffffffea8099cc <sys_ioctl+0x3c>
ffffffffea8099ac:	f9400863 	ldr	x3, [x3, #16]
ffffffffea8099b0:	b40000e3 	cbz	x3, ffffffffea8099cc <sys_ioctl+0x3c>
{
ffffffffea8099b4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea8099b8:	910003fd 	mov	x29, sp
		return ops->ioctl(fd, req, user_ptr);
ffffffffea8099bc:	d63f0060 	blr	x3
ffffffffea8099c0:	93407c00 	sxtw	x0, w0
	}
	return ERR_NOT_SUPPORTED;
}
ffffffffea8099c4:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8099c8:	d65f03c0 	ret
	return ERR_NOT_SUPPORTED;
ffffffffea8099cc:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
}
ffffffffea8099d0:	d65f03c0 	ret
ffffffffea8099d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8099d8 <sys_nanosleep>:
#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))

long sys_nanosleep(uint32_t clock_id, uint32_t flags,
		   uint32_t sleep_time_l, uint32_t sleep_time_h)
{
	uint64_t sleep_time = sleep_time_l + ((uint64_t)sleep_time_h << 32);
ffffffffea8099d8:	2a0203e2 	mov	w2, w2
	thread_sleep((lk_time_t)(DIV_ROUND_UP(sleep_time, 1000 * 1000)));
ffffffffea8099dc:	d2869b61 	mov	x1, #0x34db                	// #13531
	uint64_t sleep_time = sleep_time_l + ((uint64_t)sleep_time_h << 32);
ffffffffea8099e0:	8b038040 	add	x0, x2, x3, lsl #32
	thread_sleep((lk_time_t)(DIV_ROUND_UP(sleep_time, 1000 * 1000)));
ffffffffea8099e4:	f2baf6c1 	movk	x1, #0xd7b6, lsl #16
ffffffffea8099e8:	9143d000 	add	x0, x0, #0xf4, lsl #12
ffffffffea8099ec:	f2dbd041 	movk	x1, #0xde82, lsl #32
ffffffffea8099f0:	9108fc00 	add	x0, x0, #0x23f
ffffffffea8099f4:	f2e86361 	movk	x1, #0x431b, lsl #48
{
ffffffffea8099f8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	thread_sleep((lk_time_t)(DIV_ROUND_UP(sleep_time, 1000 * 1000)));
ffffffffea8099fc:	9bc17c00 	umulh	x0, x0, x1
{
ffffffffea809a00:	910003fd 	mov	x29, sp
	thread_sleep((lk_time_t)(DIV_ROUND_UP(sleep_time, 1000 * 1000)));
ffffffffea809a04:	d352c400 	ubfx	x0, x0, #18, #32
ffffffffea809a08:	97fff2ac 	bl	ffffffffea8064b8 <thread_sleep>

	return NO_ERROR;
}
ffffffffea809a0c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea809a10:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809a14:	d65f03c0 	ret

ffffffffea809a18 <sys_gettime>:

long sys_gettime(uint32_t clock_id, uint32_t flags, user_addr_t time)
{
ffffffffea809a18:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea809a1c:	910003fd 	mov	x29, sp
ffffffffea809a20:	f9000bf3 	str	x19, [sp, #16]
ffffffffea809a24:	2a0203f3 	mov	w19, w2
	// return time in nanoseconds
	lk_bigtime_t t = current_time_hires() * 1000;
ffffffffea809a28:	97ffee56 	bl	ffffffffea805380 <current_time_hires>
ffffffffea809a2c:	aa0003e4 	mov	x4, x0
ffffffffea809a30:	9100c3a1 	add	x1, x29, #0x30
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea809a34:	2a1303e0 	mov	w0, w19
ffffffffea809a38:	d37be883 	lsl	x3, x4, #5
ffffffffea809a3c:	d2800102 	mov	x2, #0x8                   	// #8
ffffffffea809a40:	cb040063 	sub	x3, x3, x4
ffffffffea809a44:	8b030883 	add	x3, x4, x3, lsl #2
ffffffffea809a48:	d37df063 	lsl	x3, x3, #3
ffffffffea809a4c:	f81f8c23 	str	x3, [x1, #-8]!
ffffffffea809a50:	94002706 	bl	ffffffffea813668 <arch_copy_to_user>

	return copy_to_user(time, &t, sizeof(uint64_t));
}
ffffffffea809a54:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea809a58:	93407c00 	sxtw	x0, w0
ffffffffea809a5c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809a60:	d65f03c0 	ret
ffffffffea809a64:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809a68 <sys_mmap>:

long sys_mmap(user_addr_t uaddr, uint32_t size, uint32_t flags, uint32_t handle)
{
ffffffffea809a68:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea809a6c:	2a0303e5 	mov	w5, w3
ffffffffea809a70:	910003fd 	mov	x29, sp
ffffffffea809a74:	d538d083 	mrs	x3, tpidr_el1
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea809a78:	f9415863 	ldr	x3, [x3, #688]
ffffffffea809a7c:	f9404864 	ldr	x4, [x3, #144]
	long ret;

	/*
	 * Allocate and map memory with Device attributes
	 */
	if (flags & MMAP_FLAG_DEVICE_MEM) {
ffffffffea809a80:	370801e2 	tbnz	w2, #1, ffffffffea809abc <sys_mmap+0x54>
	/*
	 * Only allows mapping on IO region specified by handle (id) and uaddr
	 * must be 0 for now.
	 * TBD: Add support in uthread_map to use uaddr as a hint.
	 */
	if (flags != MMAP_FLAG_IO_HANDLE || uaddr != 0) {
ffffffffea809a84:	7100001f 	cmp	w0, #0x0
ffffffffea809a88:	7a410840 	ccmp	w2, #0x1, #0x0, eq  // eq = none
ffffffffea809a8c:	54000301 	b.ne	ffffffffea809aec <sys_mmap+0x84>  // b.any
		return ERR_INVALID_ARGS;
	}
	ret = trusty_app_setup_mmio(trusty_app, handle, &vaddr, size);
ffffffffea809a90:	2a0103e3 	mov	w3, w1
ffffffffea809a94:	910063a2 	add	x2, x29, #0x18
ffffffffea809a98:	2a0503e1 	mov	w1, w5
ffffffffea809a9c:	aa0403e0 	mov	x0, x4
ffffffffea809aa0:	97fffc9c 	bl	ffffffffea808d10 <trusty_app_setup_mmio>
ffffffffea809aa4:	93407c00 	sxtw	x0, w0
	if (ret != NO_ERROR) {
		return ret;
	}
	return vaddr;
ffffffffea809aa8:	f9400fa1 	ldr	x1, [x29, #24]
ffffffffea809aac:	f100001f 	cmp	x0, #0x0
ffffffffea809ab0:	9a800020 	csel	x0, x1, x0, eq  // eq = none
}
ffffffffea809ab4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea809ab8:	d65f03c0 	ret
		ret = uthread_pmm_alloc_and_map(trusty_app->ut, &vaddr, size,
ffffffffea809abc:	f9402c80 	ldr	x0, [x4, #88]
ffffffffea809ac0:	2a0203e3 	mov	w3, w2
ffffffffea809ac4:	52800024 	mov	w4, #0x1                   	// #1
ffffffffea809ac8:	2a0103e2 	mov	w2, w1
ffffffffea809acc:	910063a1 	add	x1, x29, #0x18
ffffffffea809ad0:	94002902 	bl	ffffffffea813ed8 <uthread_pmm_alloc_and_map>
ffffffffea809ad4:	93407c00 	sxtw	x0, w0
		return vaddr;
ffffffffea809ad8:	f9400fa1 	ldr	x1, [x29, #24]
ffffffffea809adc:	f100001f 	cmp	x0, #0x0
}
ffffffffea809ae0:	a8c27bfd 	ldp	x29, x30, [sp], #32
		return vaddr;
ffffffffea809ae4:	9a800020 	csel	x0, x1, x0, eq  // eq = none
}
ffffffffea809ae8:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea809aec:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea809af0:	17fffff1 	b	ffffffffea809ab4 <sys_mmap+0x4c>
ffffffffea809af4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809af8 <sys_munmap>:

long sys_munmap(user_addr_t uaddr, uint32_t size)
{
ffffffffea809af8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809afc:	910003fd 	mov	x29, sp
ffffffffea809b00:	d538d082 	mrs	x2, tpidr_el1
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea809b04:	f9415843 	ldr	x3, [x2, #688]

	/*
	 * uthread_unmap always unmaps whole region.
	 * TBD: Add support to unmap partial region when there's use case.
	 */
	return uthread_unmap(trusty_app->ut, uaddr, size);
ffffffffea809b08:	2a0103e2 	mov	w2, w1
ffffffffea809b0c:	2a0003e1 	mov	w1, w0
ffffffffea809b10:	f9404860 	ldr	x0, [x3, #144]
ffffffffea809b14:	f9402c00 	ldr	x0, [x0, #88]
ffffffffea809b18:	94002964 	bl	ffffffffea8140a8 <uthread_unmap>
}
ffffffffea809b1c:	93407c00 	sxtw	x0, w0
ffffffffea809b20:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809b24:	d65f03c0 	ret

ffffffffea809b28 <sys_prepare_dma>:

#if UTHREAD_WITH_MEMORY_MAPPING_SUPPORT

long sys_prepare_dma(user_addr_t uaddr, uint32_t size, uint32_t flags,
		user_addr_t pmem)
{
ffffffffea809b28:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea809b2c:	910003fd 	mov	x29, sp
ffffffffea809b30:	f9000ff4 	str	x20, [sp, #24]
ffffffffea809b34:	2a0103f4 	mov	w20, w1
ffffffffea809b38:	f9001bf7 	str	x23, [sp, #48]
ffffffffea809b3c:	d538d081 	mrs	x1, tpidr_el1
}

static inline uthread_t *uthread_get_current(void)
{
	return (uthread_t *)tls_get(TLS_ENTRY_UTHREAD);
ffffffffea809b40:	f9415837 	ldr	x23, [x1, #688]
	long ret;

	LTRACEF("uaddr 0x%x, size 0x%x, flags 0x%x, pmem 0x%x\n",
	        uaddr, size, flags, pmem);

	if (size == 0 || !valid_address((vaddr_t)uaddr, size)) {
ffffffffea809b44:	340009b4 	cbz	w20, ffffffffea809c78 <sys_prepare_dma+0x150>
ffffffffea809b48:	f9000bb3 	str	x19, [x29, #16]
ffffffffea809b4c:	2a0303f3 	mov	w19, w3
ffffffffea809b50:	f90017b6 	str	x22, [x29, #40]
ffffffffea809b54:	2a0003f6 	mov	w22, w0
ffffffffea809b58:	f90027ba 	str	x26, [x29, #72]
ffffffffea809b5c:	2a0203fa 	mov	w26, w2
ffffffffea809b60:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea809b64:	f9415800 	ldr	x0, [x0, #688]
ffffffffea809b68:	2a1403e2 	mov	w2, w20
ffffffffea809b6c:	aa1603e1 	mov	x1, x22
ffffffffea809b70:	940029b8 	bl	ffffffffea814250 <uthread_is_valid_range>
	if (size == 0 || !valid_address((vaddr_t)uaddr, size)) {
ffffffffea809b74:	72001c1f 	tst	w0, #0xff
ffffffffea809b78:	540007a0 	b.eq	ffffffffea809c6c <sys_prepare_dma+0x144>  // b.none
ffffffffea809b7c:	f90013b5 	str	x21, [x29, #32]
	uint32_t entries = 0;
ffffffffea809b80:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea809b84:	a903e7b8 	stp	x24, x25, [x29, #56]
		pmem += sizeof(struct dma_pmem);

		mapped_size += kpmem.size;
		entries++;

	} while (mapped_size < size && (flags & DMA_FLAG_MULTI_PMEM));
ffffffffea809b88:	121e0359 	and	w25, w26, #0x4
ffffffffea809b8c:	f9002bbb 	str	x27, [x29, #80]
		kpmem.size = MIN(size - mapped_size,
ffffffffea809b90:	d2820018 	mov	x24, #0x1000                	// #4096
	uint32_t mapped_size = 0;
ffffffffea809b94:	5280001b 	mov	w27, #0x0                   	// #0
ffffffffea809b98:	14000014 	b	ffffffffea809be8 <sys_prepare_dma+0xc0>
		kpmem.size = MIN(size - mapped_size,
ffffffffea809b9c:	f94033a3 	ldr	x3, [x29, #96]
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea809ba0:	2a1303e0 	mov	w0, w19
ffffffffea809ba4:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea809ba8:	910183a1 	add	x1, x29, #0x60
ffffffffea809bac:	92402c63 	and	x3, x3, #0xfff
		pmem += sizeof(struct dma_pmem);
ffffffffea809bb0:	11004273 	add	w19, w19, #0x10
		kpmem.size = MIN(size - mapped_size,
ffffffffea809bb4:	cb030303 	sub	x3, x24, x3
		entries++;
ffffffffea809bb8:	110006b5 	add	w21, w21, #0x1
		kpmem.size = MIN(size - mapped_size,
ffffffffea809bbc:	eb04007f 	cmp	x3, x4
ffffffffea809bc0:	9a849063 	csel	x3, x3, x4, ls  // ls = plast
ffffffffea809bc4:	b9006ba3 	str	w3, [x29, #104]
ffffffffea809bc8:	940026a8 	bl	ffffffffea813668 <arch_copy_to_user>
		ret = copy_to_user(pmem, &kpmem, sizeof(struct dma_pmem));
ffffffffea809bcc:	93407c00 	sxtw	x0, w0
		if (ret != NO_ERROR) {
ffffffffea809bd0:	b50001a0 	cbnz	x0, ffffffffea809c04 <sys_prepare_dma+0xdc>
		mapped_size += kpmem.size;
ffffffffea809bd4:	b9406ba0 	ldr	w0, [x29, #104]
ffffffffea809bd8:	0b00037b 	add	w27, w27, w0
	} while (mapped_size < size && (flags & DMA_FLAG_MULTI_PMEM));
ffffffffea809bdc:	6b1b029f 	cmp	w20, w27
ffffffffea809be0:	54000229 	b.ls	ffffffffea809c24 <sys_prepare_dma+0xfc>  // b.plast
ffffffffea809be4:	34000219 	cbz	w25, ffffffffea809c24 <sys_prepare_dma+0xfc>
		ret = uthread_virt_to_phys(current,
ffffffffea809be8:	8b3b42c1 	add	x1, x22, w27, uxtw
ffffffffea809bec:	910183a2 	add	x2, x29, #0x60
ffffffffea809bf0:	aa1703e0 	mov	x0, x23
ffffffffea809bf4:	940029c1 	bl	ffffffffea8142f8 <uthread_virt_to_phys>
		kpmem.size = MIN(size - mapped_size,
ffffffffea809bf8:	4b1b0284 	sub	w4, w20, w27
		ret = uthread_virt_to_phys(current,
ffffffffea809bfc:	93407c00 	sxtw	x0, w0
		if (ret != NO_ERROR) {
ffffffffea809c00:	b4fffce0 	cbz	x0, ffffffffea809b9c <sys_prepare_dma+0x74>
ffffffffea809c04:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea809c08:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea809c0c:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea809c10:	a944efba 	ldp	x26, x27, [x29, #72]
	}
	if (!(flags & DMA_FLAG_ALLOW_PARTIAL) && mapped_size != size) {
		return ERR_BAD_LEN;
	}
	return entries;
}
ffffffffea809c14:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea809c18:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea809c1c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea809c20:	d65f03c0 	ret
ffffffffea809c24:	2a1b03e1 	mov	w1, w27
		arch_clean_invalidate_cache_range(uaddr, mapped_size);
ffffffffea809c28:	aa1603e0 	mov	x0, x22
	if (flags & DMA_FLAG_FROM_DEVICE) {
ffffffffea809c2c:	360801da 	tbz	w26, #1, ffffffffea809c64 <sys_prepare_dma+0x13c>
		arch_clean_invalidate_cache_range(uaddr, mapped_size);
ffffffffea809c30:	97ffe35d 	bl	ffffffffea8029a4 <arch_clean_invalidate_cache_range>
	if (!(flags & DMA_FLAG_ALLOW_PARTIAL) && mapped_size != size) {
ffffffffea809c34:	f27d035f 	tst	x26, #0x8
	return entries;
ffffffffea809c38:	f9400bb3 	ldr	x19, [x29, #16]
	if (!(flags & DMA_FLAG_ALLOW_PARTIAL) && mapped_size != size) {
ffffffffea809c3c:	7a5b0284 	ccmp	w20, w27, #0x4, eq  // eq = none
}
ffffffffea809c40:	f9401bf7 	ldr	x23, [sp, #48]
	return entries;
ffffffffea809c44:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea809c48:	928003e0 	mov	x0, #0xffffffffffffffe0    	// #-32
ffffffffea809c4c:	a944efba 	ldp	x26, x27, [x29, #72]
ffffffffea809c50:	9a8002a0 	csel	x0, x21, x0, eq  // eq = none
ffffffffea809c54:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea809c58:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea809c5c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea809c60:	d65f03c0 	ret
		arch_clean_cache_range(uaddr, mapped_size);
ffffffffea809c64:	97ffe348 	bl	ffffffffea802984 <arch_clean_cache_range>
ffffffffea809c68:	17fffff3 	b	ffffffffea809c34 <sys_prepare_dma+0x10c>
ffffffffea809c6c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea809c70:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea809c74:	f94027ba 	ldr	x26, [x29, #72]
		return ERR_INVALID_ARGS;
ffffffffea809c78:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea809c7c:	17ffffe6 	b	ffffffffea809c14 <sys_prepare_dma+0xec>

ffffffffea809c80 <sys_finish_dma>:

long sys_finish_dma(user_addr_t uaddr, uint32_t size, uint32_t flags)
{
ffffffffea809c80:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea809c84:	910003fd 	mov	x29, sp
ffffffffea809c88:	a90153f3 	stp	x19, x20, [sp, #16]
	LTRACEF("uaddr 0x%x, size 0x%x, flags 0x%x\n", uaddr, size, flags);

	/* check buffer is in task's address space */
	if (!valid_address((vaddr_t)uaddr, size)) {
ffffffffea809c8c:	2a0003f3 	mov	w19, w0
{
ffffffffea809c90:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (!valid_address((vaddr_t)uaddr, size)) {
ffffffffea809c94:	2a0103f4 	mov	w20, w1
{
ffffffffea809c98:	2a0203f6 	mov	w22, w2
ffffffffea809c9c:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea809ca0:	f9415800 	ldr	x0, [x0, #688]
ffffffffea809ca4:	aa1403e2 	mov	x2, x20
ffffffffea809ca8:	aa1303e1 	mov	x1, x19
ffffffffea809cac:	94002969 	bl	ffffffffea814250 <uthread_is_valid_range>
	if (!valid_address((vaddr_t)uaddr, size)) {
ffffffffea809cb0:	72001c1f 	tst	w0, #0xff
ffffffffea809cb4:	54000160 	b.eq	ffffffffea809ce0 <sys_finish_dma+0x60>  // b.none
		return ERR_INVALID_ARGS;
	}
	if (flags & DMA_FLAG_FROM_DEVICE) {
		arch_clean_invalidate_cache_range(uaddr, size);
	}
	return NO_ERROR;
ffffffffea809cb8:	d2800015 	mov	x21, #0x0                   	// #0
	if (flags & DMA_FLAG_FROM_DEVICE) {
ffffffffea809cbc:	36080096 	tbz	w22, #1, ffffffffea809ccc <sys_finish_dma+0x4c>
		arch_clean_invalidate_cache_range(uaddr, size);
ffffffffea809cc0:	aa1403e1 	mov	x1, x20
ffffffffea809cc4:	aa1303e0 	mov	x0, x19
ffffffffea809cc8:	97ffe337 	bl	ffffffffea8029a4 <arch_clean_invalidate_cache_range>
}
ffffffffea809ccc:	aa1503e0 	mov	x0, x21
ffffffffea809cd0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809cd4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea809cd8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809cdc:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea809ce0:	928000f5 	mov	x21, #0xfffffffffffffff8    	// #-8
ffffffffea809ce4:	17fffffa 	b	ffffffffea809ccc <sys_finish_dma+0x4c>

ffffffffea809ce8 <_finish_wait_handle>:
	spin_unlock_restore(&handle->slock, state, SPIN_LOCK_FLAG_INTERRUPTS);
	return ret;
}

static void _finish_wait_handle(handle_t *handle)
{
ffffffffea809ce8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea809cec:	910003fd 	mov	x29, sp
ffffffffea809cf0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea809cf4:	aa0003f4 	mov	x20, x0
	spin_lock_saved_state_t state;

	/* clear out our event ptr */
	spin_lock_save(&handle->slock, &state, SPIN_LOCK_FLAG_INTERRUPTS);
ffffffffea809cf8:	91006013 	add	x19, x0, #0x18
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea809cfc:	d53b4220 	mrs	x0, daif
ffffffffea809d00:	37380160 	tbnz	w0, #7, ffffffffea809d2c <_finish_wait_handle+0x44>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea809d04:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea809d08:	aa1303e0 	mov	x0, x19
ffffffffea809d0c:	97ffe314 	bl	ffffffffea80295c <arch_spin_lock>
	handle->wait_event = NULL;
ffffffffea809d10:	f9000a9f 	str	xzr, [x20, #16]
    arch_spin_unlock(lock);
ffffffffea809d14:	aa1303e0 	mov	x0, x19
ffffffffea809d18:	97ffe319 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea809d1c:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&handle->slock, state, SPIN_LOCK_FLAG_INTERRUPTS);
}
ffffffffea809d20:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809d24:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea809d28:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea809d2c:	aa1303e0 	mov	x0, x19
ffffffffea809d30:	97ffe30b 	bl	ffffffffea80295c <arch_spin_lock>
	handle->wait_event = NULL;
ffffffffea809d34:	f9000a9f 	str	xzr, [x20, #16]
    arch_spin_unlock(lock);
ffffffffea809d38:	aa1303e0 	mov	x0, x19
}
ffffffffea809d3c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809d40:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea809d44:	17ffe30e 	b	ffffffffea80297c <arch_spin_unlock>

ffffffffea809d48 <_prepare_wait_handle>:
{
ffffffffea809d48:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea809d4c:	910003fd 	mov	x29, sp
ffffffffea809d50:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea809d54:	aa0103f3 	mov	x19, x1
ffffffffea809d58:	f90013f5 	str	x21, [sp, #32]
	spin_lock_save(&handle->slock, &state, SPIN_LOCK_FLAG_INTERRUPTS);
ffffffffea809d5c:	91006034 	add	x20, x1, #0x18
{
ffffffffea809d60:	aa0003f5 	mov	x21, x0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea809d64:	d53b4220 	mrs	x0, daif
ffffffffea809d68:	373801e0 	tbnz	w0, #7, ffffffffea809da4 <_prepare_wait_handle+0x5c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea809d6c:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea809d70:	aa1403e0 	mov	x0, x20
ffffffffea809d74:	97ffe2fa 	bl	ffffffffea80295c <arch_spin_lock>
	if (unlikely(handle->wait_event)) {
ffffffffea809d78:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea809d7c:	b50003a0 	cbnz	x0, ffffffffea809df0 <_prepare_wait_handle+0xa8>
		handle->wait_event = ev;
ffffffffea809d80:	f9000a75 	str	x21, [x19, #16]
    arch_spin_unlock(lock);
ffffffffea809d84:	aa1403e0 	mov	x0, x20
ffffffffea809d88:	97ffe2fd 	bl	ffffffffea80297c <arch_spin_unlock>
	int ret = 0;
ffffffffea809d8c:	52800000 	mov	w0, #0x0                   	// #0
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea809d90:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea809d94:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809d98:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea809d9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809da0:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea809da4:	aa1403e0 	mov	x0, x20
ffffffffea809da8:	97ffe2ed 	bl	ffffffffea80295c <arch_spin_lock>
	if (unlikely(handle->wait_event)) {
ffffffffea809dac:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea809db0:	b5000120 	cbnz	x0, ffffffffea809dd4 <_prepare_wait_handle+0x8c>
		handle->wait_event = ev;
ffffffffea809db4:	f9000a75 	str	x21, [x19, #16]
    arch_spin_unlock(lock);
ffffffffea809db8:	aa1403e0 	mov	x0, x20
ffffffffea809dbc:	97ffe2f0 	bl	ffffffffea80297c <arch_spin_unlock>
}
ffffffffea809dc0:	f94013f5 	ldr	x21, [sp, #32]
	int ret = 0;
ffffffffea809dc4:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea809dc8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809dcc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809dd0:	d65f03c0 	ret
ffffffffea809dd4:	aa1403e0 	mov	x0, x20
ffffffffea809dd8:	97ffe2e9 	bl	ffffffffea80297c <arch_spin_unlock>
		ret = ERR_ALREADY_STARTED;
ffffffffea809ddc:	128000a0 	mov	w0, #0xfffffffa            	// #-6
}
ffffffffea809de0:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea809de4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809de8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809dec:	d65f03c0 	ret
ffffffffea809df0:	aa1403e0 	mov	x0, x20
ffffffffea809df4:	97ffe2e2 	bl	ffffffffea80297c <arch_spin_unlock>
		ret = ERR_ALREADY_STARTED;
ffffffffea809df8:	128000a0 	mov	w0, #0xfffffffa            	// #-6
ffffffffea809dfc:	d50342ff 	msr	daifclr, #0x2
ffffffffea809e00:	17ffffe5 	b	ffffffffea809d94 <_prepare_wait_handle+0x4c>
ffffffffea809e04:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809e08 <_hlist_do_poll_locked>:
 *  handle until the ready one is found and return it to caller.
 *  Undo prepare op if ready handle is found or en error occured.
 */
static int _hlist_do_poll_locked(handle_list_t *hlist, handle_t **handle_ptr,
				 uint32_t *event_ptr, bool prepare)
{
ffffffffea809e08:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea809e0c:	910003fd 	mov	x29, sp
ffffffffea809e10:	f9000bf3 	str	x19, [sp, #16]
ffffffffea809e14:	f90023f9 	str	x25, [sp, #64]
	return (list->next == list) ? true : false;
ffffffffea809e18:	f9400413 	ldr	x19, [x0, #8]
	int ret = 0;

	DEBUG_ASSERT(hlist->wait_event);

	if (list_is_empty(&hlist->handles))
ffffffffea809e1c:	eb13001f 	cmp	x0, x19
ffffffffea809e20:	54000840 	b.eq	ffffffffea809f28 <_hlist_do_poll_locked+0x120>  // b.none
ffffffffea809e24:	a901d7b4 	stp	x20, x21, [x29, #24]
		return ERR_NOT_FOUND;  /* no handles in the list */

	handle_t *next;
	handle_t *last_prep = NULL;
	list_for_every_entry(&hlist->handles, next, handle_t, hlist_node) {
ffffffffea809e28:	d1008273 	sub	x19, x19, #0x20
ffffffffea809e2c:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea809e30:	12001c75 	and	w21, w3, #0xff
ffffffffea809e34:	aa0203f7 	mov	x23, x2
ffffffffea809e38:	aa0103f6 	mov	x22, x1
ffffffffea809e3c:	aa0003f4 	mov	x20, x0
ffffffffea809e40:	f9001fb8 	str	x24, [x29, #56]
	handle_t *last_prep = NULL;
ffffffffea809e44:	d2800018 	mov	x24, #0x0                   	// #0
		if (prepare) {
ffffffffea809e48:	35000275 	cbnz	w21, ffffffffea809e94 <_hlist_do_poll_locked+0x8c>
			if (ret)
				break;
			last_prep = next;
		}

		uint32_t event = next->ops->poll(next);
ffffffffea809e4c:	f9400663 	ldr	x3, [x19, #8]
ffffffffea809e50:	aa1303e0 	mov	x0, x19
ffffffffea809e54:	f9400063 	ldr	x3, [x3]
ffffffffea809e58:	d63f0060 	blr	x3
		if (event) {
ffffffffea809e5c:	35000320 	cbnz	w0, ffffffffea809ec0 <_hlist_do_poll_locked+0xb8>
	list_for_every_entry(&hlist->handles, next, handle_t, hlist_node) {
ffffffffea809e60:	f9401663 	ldr	x3, [x19, #40]
ffffffffea809e64:	d1008073 	sub	x19, x3, #0x20
ffffffffea809e68:	eb03029f 	cmp	x20, x3
ffffffffea809e6c:	54fffee1 	b.ne	ffffffffea809e48 <_hlist_do_poll_locked+0x40>  // b.any
			*event_ptr = event;
			*handle_ptr = next;
			ret = 1;
ffffffffea809e70:	52800019 	mov	w25, #0x0                   	// #0
ffffffffea809e74:	f9401fb8 	ldr	x24, [x29, #56]
	if (ret && prepare && last_prep) {
		/* need to undo prepare */
		_hlist_finish_wait_locked(hlist, last_prep);
	}
	return ret;
}
ffffffffea809e78:	2a1903e0 	mov	w0, w25
ffffffffea809e7c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea809e80:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea809e84:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea809e88:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea809e8c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea809e90:	d65f03c0 	ret
			ret = _prepare_wait_handle(hlist->wait_event, next);
ffffffffea809e94:	f9402680 	ldr	x0, [x20, #72]
ffffffffea809e98:	aa1303e1 	mov	x1, x19
ffffffffea809e9c:	97ffffab 	bl	ffffffffea809d48 <_prepare_wait_handle>
ffffffffea809ea0:	2a0003f9 	mov	w25, w0
			if (ret)
ffffffffea809ea4:	35000160 	cbnz	w0, ffffffffea809ed0 <_hlist_do_poll_locked+0xc8>
		uint32_t event = next->ops->poll(next);
ffffffffea809ea8:	f9400663 	ldr	x3, [x19, #8]
ffffffffea809eac:	aa1303f8 	mov	x24, x19
ffffffffea809eb0:	aa1303e0 	mov	x0, x19
ffffffffea809eb4:	f9400063 	ldr	x3, [x3]
ffffffffea809eb8:	d63f0060 	blr	x3
		if (event) {
ffffffffea809ebc:	34fffd20 	cbz	w0, ffffffffea809e60 <_hlist_do_poll_locked+0x58>
			*event_ptr = event;
ffffffffea809ec0:	b90002e0 	str	w0, [x23]
			ret = 1;
ffffffffea809ec4:	52800039 	mov	w25, #0x1                   	// #1
			*handle_ptr = next;
ffffffffea809ec8:	f90002d3 	str	x19, [x22]
	if (ret && prepare && last_prep) {
ffffffffea809ecc:	340001f5 	cbz	w21, ffffffffea809f08 <_hlist_do_poll_locked+0x100>
ffffffffea809ed0:	b40001d8 	cbz	x24, ffffffffea809f08 <_hlist_do_poll_locked+0x100>
	list_for_every_entry(&hlist->handles, handle, handle_t, hlist_node) {
ffffffffea809ed4:	f9400680 	ldr	x0, [x20, #8]
ffffffffea809ed8:	d1008013 	sub	x19, x0, #0x20
ffffffffea809edc:	eb00029f 	cmp	x20, x0
ffffffffea809ee0:	540000c1 	b.ne	ffffffffea809ef8 <_hlist_do_poll_locked+0xf0>  // b.any
ffffffffea809ee4:	14000009 	b	ffffffffea809f08 <_hlist_do_poll_locked+0x100>
ffffffffea809ee8:	f9401660 	ldr	x0, [x19, #40]
ffffffffea809eec:	d1008013 	sub	x19, x0, #0x20
ffffffffea809ef0:	eb00029f 	cmp	x20, x0
ffffffffea809ef4:	540000a0 	b.eq	ffffffffea809f08 <_hlist_do_poll_locked+0x100>  // b.none
		_finish_wait_handle(handle);
ffffffffea809ef8:	aa1303e0 	mov	x0, x19
ffffffffea809efc:	97ffff7b 	bl	ffffffffea809ce8 <_finish_wait_handle>
		if (handle == last) {
ffffffffea809f00:	eb18027f 	cmp	x19, x24
ffffffffea809f04:	54ffff21 	b.ne	ffffffffea809ee8 <_hlist_do_poll_locked+0xe0>  // b.any
ffffffffea809f08:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea809f0c:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea809f10:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea809f14:	2a1903e0 	mov	w0, w25
ffffffffea809f18:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea809f1c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea809f20:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea809f24:	d65f03c0 	ret
		return ERR_NOT_FOUND;  /* no handles in the list */
ffffffffea809f28:	12800039 	mov	w25, #0xfffffffe            	// #-2
ffffffffea809f2c:	17fffffa 	b	ffffffffea809f14 <_hlist_do_poll_locked+0x10c>

ffffffffea809f30 <handle_init>:
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea809f30:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea809f34:	885f7c03 	ldxr	w3, [x0]
ffffffffea809f38:	88047c02 	stxr	w4, w2, [x0]
ffffffffea809f3c:	35ffffc4 	cbnz	w4, ffffffffea809f34 <handle_init+0x4>
    return __atomic_fetch_add(ptr, val, __ATOMIC_RELAXED);
ffffffffea809f40:	885f7c02 	ldxr	w2, [x0]
ffffffffea809f44:	11000442 	add	w2, w2, #0x1
ffffffffea809f48:	88037c02 	stxr	w3, w2, [x0]
ffffffffea809f4c:	35ffffa3 	cbnz	w3, ffffffffea809f40 <handle_init+0x10>
	handle->wait_event = NULL;
ffffffffea809f50:	a900fc01 	stp	x1, xzr, [x0, #8]
	handle->guest_id = DEFAULT_GUEST_ID;
ffffffffea809f54:	529fdda1 	mov	w1, #0xfeed                	// #65261
ffffffffea809f58:	72bbd5a1 	movk	w1, #0xdead, lsl #16
	item->prev = item->next = 0;
ffffffffea809f5c:	a901fc1f 	stp	xzr, xzr, [x0, #24]
	handle->cookie = NULL;
ffffffffea809f60:	a902fc1f 	stp	xzr, xzr, [x0, #40]
	handle->guest_id = DEFAULT_GUEST_ID;
ffffffffea809f64:	b9003801 	str	w1, [x0, #56]
}
ffffffffea809f68:	d65f03c0 	ret
ffffffffea809f6c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809f70 <handle_incref>:
ffffffffea809f70:	885f7c01 	ldxr	w1, [x0]
ffffffffea809f74:	11000421 	add	w1, w1, #0x1
ffffffffea809f78:	88027c01 	stxr	w2, w1, [x0]
ffffffffea809f7c:	35ffffa2 	cbnz	w2, ffffffffea809f70 <handle_incref>
}
ffffffffea809f80:	d65f03c0 	ret
ffffffffea809f84:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809f88 <handle_decref>:
{
ffffffffea809f88:	aa0003e1 	mov	x1, x0
ffffffffea809f8c:	885f7c22 	ldxr	w2, [x1]
ffffffffea809f90:	51000443 	sub	w3, w2, #0x1
ffffffffea809f94:	88047c23 	stxr	w4, w3, [x1]
ffffffffea809f98:	35ffffa4 	cbnz	w4, ffffffffea809f8c <handle_decref+0x4>

static inline __ALWAYS_INLINE
void refcount_dec(refcount_t *ref, refcount_destroy_func destroy)
{
	/* decerementing from 1? destroy */
	if (atomic_add(&ref->cnt, -1) == 1)
ffffffffea809f9c:	7100045f 	cmp	w2, #0x1
ffffffffea809fa0:	54000081 	b.ne	ffffffffea809fb0 <handle_decref+0x28>  // b.any
	handle->ops->destroy(handle);
ffffffffea809fa4:	f9400421 	ldr	x1, [x1, #8]
ffffffffea809fa8:	f9400c21 	ldr	x1, [x1, #24]
ffffffffea809fac:	d61f0020 	br	x1
}
ffffffffea809fb0:	d65f03c0 	ret
ffffffffea809fb4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809fb8 <_handle_list_del_locked>:
{
ffffffffea809fb8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea809fbc:	910003fd 	mov	x29, sp
ffffffffea809fc0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea809fc4:	aa0003f4 	mov	x20, x0
	item->next->prev = item->prev;
ffffffffea809fc8:	a9420022 	ldp	x2, x0, [x1, #32]
ffffffffea809fcc:	aa0103f3 	mov	x19, x1
	if (hlist->wait_event) {
ffffffffea809fd0:	f9402681 	ldr	x1, [x20, #72]
ffffffffea809fd4:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea809fd8:	f9401262 	ldr	x2, [x19, #32]
ffffffffea809fdc:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea809fe0:	a9027e7f 	stp	xzr, xzr, [x19, #32]
ffffffffea809fe4:	b40000c1 	cbz	x1, ffffffffea809ffc <_handle_list_del_locked+0x44>
		_finish_wait_handle(handle);
ffffffffea809fe8:	aa1303e0 	mov	x0, x19
ffffffffea809fec:	97ffff3f 	bl	ffffffffea809ce8 <_finish_wait_handle>
		if (list_is_empty(&hlist->handles)) {
ffffffffea809ff0:	f9400680 	ldr	x0, [x20, #8]
ffffffffea809ff4:	eb00029f 	cmp	x20, x0
ffffffffea809ff8:	540000a0 	b.eq	ffffffffea80a00c <_handle_list_del_locked+0x54>  // b.none
	handle_decref(handle);
ffffffffea809ffc:	aa1303e0 	mov	x0, x19
}
ffffffffea80a000:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a004:	a8c27bfd 	ldp	x29, x30, [sp], #32
	handle_decref(handle);
ffffffffea80a008:	17ffffe0 	b	ffffffffea809f88 <handle_decref>
			event_signal(hlist->wait_event, true);
ffffffffea80a00c:	f9402680 	ldr	x0, [x20, #72]
ffffffffea80a010:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea80a014:	97ffeddf 	bl	ffffffffea805790 <event_signal>
	handle_decref(handle);
ffffffffea80a018:	aa1303e0 	mov	x0, x19
}
ffffffffea80a01c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a020:	a8c27bfd 	ldp	x29, x30, [sp], #32
	handle_decref(handle);
ffffffffea80a024:	17ffffd9 	b	ffffffffea809f88 <handle_decref>

ffffffffea80a028 <handle_close>:
{
ffffffffea80a028:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80a02c:	910003fd 	mov	x29, sp
	if (handle->ops->shutdown) {
ffffffffea80a030:	f9400401 	ldr	x1, [x0, #8]
ffffffffea80a034:	f9400821 	ldr	x1, [x1, #16]
{
ffffffffea80a038:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80a03c:	aa0003f3 	mov	x19, x0
	if (handle->ops->shutdown) {
ffffffffea80a040:	b4000041 	cbz	x1, ffffffffea80a048 <handle_close+0x20>
		handle->ops->shutdown(handle);
ffffffffea80a044:	d63f0020 	blr	x1
	handle_decref(handle);
ffffffffea80a048:	aa1303e0 	mov	x0, x19
}
ffffffffea80a04c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80a050:	a8c27bfd 	ldp	x29, x30, [sp], #32
	handle_decref(handle);
ffffffffea80a054:	17ffffcd 	b	ffffffffea809f88 <handle_decref>

ffffffffea80a058 <handle_wait>:
{
ffffffffea80a058:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
	if (!handle || !handle_event) {
ffffffffea80a05c:	f100001f 	cmp	x0, #0x0
ffffffffea80a060:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
{
ffffffffea80a064:	910003fd 	mov	x29, sp
ffffffffea80a068:	f90017f6 	str	x22, [sp, #40]
	if (!handle || !handle_event) {
ffffffffea80a06c:	54000620 	b.eq	ffffffffea80a130 <handle_wait+0xd8>  // b.none
ffffffffea80a070:	f90013b5 	str	x21, [x29, #32]
ffffffffea80a074:	2a0203f5 	mov	w21, w2
	event_init(&ev, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea80a078:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80a07c:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80a080:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80a084:	aa0003f3 	mov	x19, x0
ffffffffea80a088:	aa0103f7 	mov	x23, x1
ffffffffea80a08c:	910103a0 	add	x0, x29, #0x40
ffffffffea80a090:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80a094:	97ffed65 	bl	ffffffffea805628 <event_init>
	ret = _prepare_wait_handle(&ev, handle);
ffffffffea80a098:	aa1303e1 	mov	x1, x19
ffffffffea80a09c:	910103a0 	add	x0, x29, #0x40
ffffffffea80a0a0:	97ffff2a 	bl	ffffffffea809d48 <_prepare_wait_handle>
ffffffffea80a0a4:	2a0003f6 	mov	w22, w0
	if (ret) {
ffffffffea80a0a8:	350002e0 	cbnz	w0, ffffffffea80a104 <handle_wait+0xac>
ffffffffea80a0ac:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80a0b0:	14000005 	b	ffffffffea80a0c4 <handle_wait+0x6c>
	ret = event_wait_timeout(ev, timeout);
ffffffffea80a0b4:	2a1503e1 	mov	w1, w21
ffffffffea80a0b8:	910103a0 	add	x0, x29, #0x40
ffffffffea80a0bc:	97ffed91 	bl	ffffffffea805700 <event_wait_timeout>
		if (ret < 0) {
ffffffffea80a0c0:	37f80340 	tbnz	w0, #31, ffffffffea80a128 <handle_wait+0xd0>
		event = handle->ops->poll(handle);
ffffffffea80a0c4:	f9400663 	ldr	x3, [x19, #8]
ffffffffea80a0c8:	aa1303e0 	mov	x0, x19
ffffffffea80a0cc:	f9400063 	ldr	x3, [x3]
ffffffffea80a0d0:	d63f0060 	blr	x3
ffffffffea80a0d4:	2a0003f4 	mov	w20, w0
		if (event) {
ffffffffea80a0d8:	34fffee0 	cbz	w0, ffffffffea80a0b4 <handle_wait+0x5c>
	if (handle->ops->finalize_event) {
ffffffffea80a0dc:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80a0e0:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80a0e4:	b4000082 	cbz	x2, ffffffffea80a0f4 <handle_wait+0x9c>
		handle->ops->finalize_event(handle, event);
ffffffffea80a0e8:	2a1403e1 	mov	w1, w20
ffffffffea80a0ec:	aa1303e0 	mov	x0, x19
ffffffffea80a0f0:	d63f0040 	blr	x2
	*handle_event = event;
ffffffffea80a0f4:	b90002f4 	str	w20, [x23]
	_finish_wait_handle(handle);
ffffffffea80a0f8:	aa1303e0 	mov	x0, x19
ffffffffea80a0fc:	97fffefb 	bl	ffffffffea809ce8 <_finish_wait_handle>
ffffffffea80a100:	f9400fb4 	ldr	x20, [x29, #24]
	event_destroy(&ev);
ffffffffea80a104:	910103a0 	add	x0, x29, #0x40
ffffffffea80a108:	97ffed54 	bl	ffffffffea805658 <event_destroy>
	return ret;
ffffffffea80a10c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80a110:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80a114:	f9401bb7 	ldr	x23, [x29, #48]
}
ffffffffea80a118:	2a1603e0 	mov	w0, w22
ffffffffea80a11c:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80a120:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80a124:	d65f03c0 	ret
	ret = event_wait_timeout(ev, timeout);
ffffffffea80a128:	2a0003f6 	mov	w22, w0
ffffffffea80a12c:	17fffff3 	b	ffffffffea80a0f8 <handle_wait+0xa0>
		return ERR_INVALID_ARGS;
ffffffffea80a130:	128000f6 	mov	w22, #0xfffffff8            	// #-8
ffffffffea80a134:	17fffff9 	b	ffffffffea80a118 <handle_wait+0xc0>

ffffffffea80a138 <handle_notify>:
{
ffffffffea80a138:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80a13c:	910003fd 	mov	x29, sp
ffffffffea80a140:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a144:	aa0003f3 	mov	x19, x0
	spin_lock_save(&handle->slock, &state, SPIN_LOCK_FLAG_INTERRUPTS);
ffffffffea80a148:	91006014 	add	x20, x0, #0x18
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80a14c:	d53b4220 	mrs	x0, daif
ffffffffea80a150:	373801c0 	tbnz	w0, #7, ffffffffea80a188 <handle_notify+0x50>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80a154:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80a158:	aa1403e0 	mov	x0, x20
ffffffffea80a15c:	97ffe200 	bl	ffffffffea80295c <arch_spin_lock>
	if (handle->wait_event) {
ffffffffea80a160:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80a164:	b4000060 	cbz	x0, ffffffffea80a170 <handle_notify+0x38>
		event_signal(handle->wait_event, false);
ffffffffea80a168:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80a16c:	97ffed89 	bl	ffffffffea805790 <event_signal>
    arch_spin_unlock(lock);
ffffffffea80a170:	aa1403e0 	mov	x0, x20
ffffffffea80a174:	97ffe202 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80a178:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea80a17c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a180:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80a184:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea80a188:	aa1403e0 	mov	x0, x20
ffffffffea80a18c:	97ffe1f4 	bl	ffffffffea80295c <arch_spin_lock>
	if (handle->wait_event) {
ffffffffea80a190:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80a194:	b50000a0 	cbnz	x0, ffffffffea80a1a8 <handle_notify+0x70>
    arch_spin_unlock(lock);
ffffffffea80a198:	aa1403e0 	mov	x0, x20
}
ffffffffea80a19c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a1a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80a1a4:	17ffe1f6 	b	ffffffffea80297c <arch_spin_unlock>
		event_signal(handle->wait_event, false);
ffffffffea80a1a8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80a1ac:	97ffed79 	bl	ffffffffea805790 <event_signal>
ffffffffea80a1b0:	17fffffa 	b	ffffffffea80a198 <handle_notify+0x60>
ffffffffea80a1b4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a1b8 <handle_list_init>:
	*hlist = (handle_list_t)HANDLE_LIST_INITIAL_VALUE(*hlist);
ffffffffea80a1b8:	a9017c1f 	stp	xzr, xzr, [x0, #16]
ffffffffea80a1bc:	528e8f03 	mov	w3, #0x7478                	// #29816
ffffffffea80a1c0:	a9027c1f 	stp	xzr, xzr, [x0, #32]
ffffffffea80a1c4:	528d2e82 	mov	w2, #0x6974                	// #26996
ffffffffea80a1c8:	72adaea3 	movk	w3, #0x6d75, lsl #16
ffffffffea80a1cc:	9100c001 	add	x1, x0, #0x30
ffffffffea80a1d0:	72aeec22 	movk	w2, #0x7761, lsl #16
ffffffffea80a1d4:	a9000000 	stp	x0, x0, [x0]
ffffffffea80a1d8:	b9001003 	str	w3, [x0, #16]
ffffffffea80a1dc:	b9002802 	str	w2, [x0, #40]
ffffffffea80a1e0:	a9030401 	stp	x1, x1, [x0, #48]
ffffffffea80a1e4:	a9047c1f 	stp	xzr, xzr, [x0, #64]
}
ffffffffea80a1e8:	d65f03c0 	ret
ffffffffea80a1ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a1f0 <handle_list_add>:
{
ffffffffea80a1f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a1f4:	910003fd 	mov	x29, sp
ffffffffea80a1f8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a1fc:	aa0003f4 	mov	x20, x0
ffffffffea80a200:	aa0103f3 	mov	x19, x1
ffffffffea80a204:	f90013f5 	str	x21, [sp, #32]
    return __atomic_fetch_add(ptr, val, __ATOMIC_RELAXED);
ffffffffea80a208:	885f7e60 	ldxr	w0, [x19]
ffffffffea80a20c:	11000400 	add	w0, w0, #0x1
ffffffffea80a210:	88017e60 	stxr	w1, w0, [x19]
ffffffffea80a214:	35ffffa1 	cbnz	w1, ffffffffea80a208 <handle_list_add+0x18>
	mutex_acquire(&hlist->lock);
ffffffffea80a218:	91004295 	add	x21, x20, #0x10
ffffffffea80a21c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80a220:	aa1503e0 	mov	x0, x21
ffffffffea80a224:	97ffedb1 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	item->prev = list->prev;
ffffffffea80a228:	f9400280 	ldr	x0, [x20]
	list_add_tail(&hlist->handles, &handle->hlist_node);
ffffffffea80a22c:	91008261 	add	x1, x19, #0x20
	item->next = list;
ffffffffea80a230:	a9025260 	stp	x0, x20, [x19, #32]
	if (hlist->wait_event) {
ffffffffea80a234:	f9402680 	ldr	x0, [x20, #72]
	list->prev->next = item;
ffffffffea80a238:	f9400282 	ldr	x2, [x20]
ffffffffea80a23c:	f9000441 	str	x1, [x2, #8]
	list->prev = item;
ffffffffea80a240:	f9000281 	str	x1, [x20]
ffffffffea80a244:	b4000100 	cbz	x0, ffffffffea80a264 <handle_list_add+0x74>
		_prepare_wait_handle(hlist->wait_event, handle);
ffffffffea80a248:	aa1303e1 	mov	x1, x19
ffffffffea80a24c:	97fffebf 	bl	ffffffffea809d48 <_prepare_wait_handle>
		uint32_t event = handle->ops->poll(handle);
ffffffffea80a250:	f9400661 	ldr	x1, [x19, #8]
ffffffffea80a254:	aa1303e0 	mov	x0, x19
ffffffffea80a258:	f9400021 	ldr	x1, [x1]
ffffffffea80a25c:	d63f0020 	blr	x1
		if (event) {
ffffffffea80a260:	350000c0 	cbnz	w0, ffffffffea80a278 <handle_list_add+0x88>
	mutex_release(&hlist->lock);
ffffffffea80a264:	aa1503e0 	mov	x0, x21
}
ffffffffea80a268:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80a26c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a270:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&hlist->lock);
ffffffffea80a274:	17ffedc9 	b	ffffffffea805998 <mutex_release>
			handle_notify(handle);
ffffffffea80a278:	aa1303e0 	mov	x0, x19
ffffffffea80a27c:	97ffffaf 	bl	ffffffffea80a138 <handle_notify>
	mutex_release(&hlist->lock);
ffffffffea80a280:	aa1503e0 	mov	x0, x21
}
ffffffffea80a284:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80a288:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a28c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&hlist->lock);
ffffffffea80a290:	17ffedc2 	b	ffffffffea805998 <mutex_release>
ffffffffea80a294:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a298 <handle_list_del>:
{
ffffffffea80a298:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a29c:	910003fd 	mov	x29, sp
ffffffffea80a2a0:	a90153f3 	stp	x19, x20, [sp, #16]
	mutex_acquire(&hlist->lock);
ffffffffea80a2a4:	91004013 	add	x19, x0, #0x10
{
ffffffffea80a2a8:	f90013f5 	str	x21, [sp, #32]
ffffffffea80a2ac:	aa0003f4 	mov	x20, x0
ffffffffea80a2b0:	aa0103f5 	mov	x21, x1
ffffffffea80a2b4:	aa1303e0 	mov	x0, x19
ffffffffea80a2b8:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80a2bc:	97ffed8b 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	_handle_list_del_locked(hlist, handle);
ffffffffea80a2c0:	aa1503e1 	mov	x1, x21
ffffffffea80a2c4:	aa1403e0 	mov	x0, x20
ffffffffea80a2c8:	97ffff3c 	bl	ffffffffea809fb8 <_handle_list_del_locked>
}
ffffffffea80a2cc:	f94013f5 	ldr	x21, [sp, #32]
	mutex_release(&hlist->lock);
ffffffffea80a2d0:	aa1303e0 	mov	x0, x19
}
ffffffffea80a2d4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a2d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&hlist->lock);
ffffffffea80a2dc:	17ffedaf 	b	ffffffffea805998 <mutex_release>

ffffffffea80a2e0 <handle_list_wait>:
/* fills in the handle that has a pending event. The reference taken by the list
 * is not dropped until the caller has had a chance to process the handle.
 */
int handle_list_wait(handle_list_t *hlist, handle_t **handle_ptr,
                     uint32_t *event_ptr, lk_time_t timeout)
{
ffffffffea80a2e0:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea80a2e4:	910003fd 	mov	x29, sp
ffffffffea80a2e8:	f90023f9 	str	x25, [sp, #64]
ffffffffea80a2ec:	aa0203f9 	mov	x25, x2
ffffffffea80a2f0:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80a2f4:	aa0103f8 	mov	x24, x1

	DEBUG_ASSERT(hlist);
	DEBUG_ASSERT(handle_ptr);
	DEBUG_ASSERT(event_ptr);

	event_init(&ev, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea80a2f8:	910143b7 	add	x23, x29, #0x50
{
ffffffffea80a2fc:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a300:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80a304:	aa0003f4 	mov	x20, x0
ffffffffea80a308:	2a0303f5 	mov	w21, w3
	event_init(&ev, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea80a30c:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80a310:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80a314:	aa1703e0 	mov	x0, x23
ffffffffea80a318:	97ffecc4 	bl	ffffffffea805628 <event_init>

	*event_ptr = 0;
ffffffffea80a31c:	b900033f 	str	wzr, [x25]
	*handle_ptr = 0;
ffffffffea80a320:	f900031f 	str	xzr, [x24]

	mutex_acquire(&hlist->lock);
ffffffffea80a324:	91004296 	add	x22, x20, #0x10
ffffffffea80a328:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80a32c:	aa1603e0 	mov	x0, x22
ffffffffea80a330:	97ffed6e 	bl	ffffffffea8058e8 <mutex_acquire_timeout>

	DEBUG_ASSERT(hlist->wait_event == NULL);

	hlist->wait_event = &ev;
ffffffffea80a334:	f9002697 	str	x23, [x20, #72]
	ret = _hlist_do_poll_locked(hlist, handle_ptr, event_ptr, true);
ffffffffea80a338:	52800023 	mov	w3, #0x1                   	// #1
ffffffffea80a33c:	aa1903e2 	mov	x2, x25
ffffffffea80a340:	aa1803e1 	mov	x1, x24
ffffffffea80a344:	aa1403e0 	mov	x0, x20
ffffffffea80a348:	97fffeb0 	bl	ffffffffea809e08 <_hlist_do_poll_locked>
ffffffffea80a34c:	2a0003f3 	mov	w19, w0
	if (ret < 0) {
ffffffffea80a350:	7100001f 	cmp	w0, #0x0
ffffffffea80a354:	5400008b 	b.lt	ffffffffea80a364 <handle_list_wait+0x84>  // b.tstop
		goto err_do_poll;
	}
	if (ret == 0) {
ffffffffea80a358:	540002c0 	b.eq	ffffffffea80a3b0 <handle_list_wait+0xd0>  // b.none
		} while (!ret);

		_hlist_finish_wait_locked(hlist, NULL);
	}

	if (ret == 1) {
ffffffffea80a35c:	7100067f 	cmp	w19, #0x1
ffffffffea80a360:	54000580 	b.eq	ffffffffea80a410 <handle_list_wait+0x130>  // b.none

		ret = NO_ERROR;
	}

err_do_poll:
	hlist->wait_event = NULL;
ffffffffea80a364:	f900269f 	str	xzr, [x20, #72]
	mutex_release(&hlist->lock);
ffffffffea80a368:	aa1603e0 	mov	x0, x22
ffffffffea80a36c:	97ffed8b 	bl	ffffffffea805998 <mutex_release>
	event_destroy(&ev);
ffffffffea80a370:	aa1703e0 	mov	x0, x23
ffffffffea80a374:	97ffecb9 	bl	ffffffffea805658 <event_destroy>
	return ret;
}
ffffffffea80a378:	2a1303e0 	mov	w0, w19
ffffffffea80a37c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80a380:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a384:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80a388:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80a38c:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80a390:	d65f03c0 	ret
			ret = _hlist_do_poll_locked(hlist, handle_ptr,
ffffffffea80a394:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea80a398:	aa1903e2 	mov	x2, x25
ffffffffea80a39c:	aa1803e1 	mov	x1, x24
ffffffffea80a3a0:	aa1403e0 	mov	x0, x20
ffffffffea80a3a4:	97fffe99 	bl	ffffffffea809e08 <_hlist_do_poll_locked>
ffffffffea80a3a8:	2a0003f3 	mov	w19, w0
		} while (!ret);
ffffffffea80a3ac:	35000620 	cbnz	w0, ffffffffea80a470 <handle_list_wait+0x190>
			mutex_release(&hlist->lock);
ffffffffea80a3b0:	aa1603e0 	mov	x0, x22
ffffffffea80a3b4:	97ffed79 	bl	ffffffffea805998 <mutex_release>
	ret = event_wait_timeout(ev, timeout);
ffffffffea80a3b8:	2a1503e1 	mov	w1, w21
ffffffffea80a3bc:	aa1703e0 	mov	x0, x23
ffffffffea80a3c0:	97ffecd0 	bl	ffffffffea805700 <event_wait_timeout>
ffffffffea80a3c4:	2a0003f3 	mov	w19, w0
ffffffffea80a3c8:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80a3cc:	aa1603e0 	mov	x0, x22
ffffffffea80a3d0:	97ffed46 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
			if (ret < 0) {
ffffffffea80a3d4:	36fffe13 	tbz	w19, #31, ffffffffea80a394 <handle_list_wait+0xb4>
	list_for_every_entry(&hlist->handles, handle, handle_t, hlist_node) {
ffffffffea80a3d8:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80a3dc:	d1008015 	sub	x21, x0, #0x20
ffffffffea80a3e0:	eb00029f 	cmp	x20, x0
ffffffffea80a3e4:	540000c1 	b.ne	ffffffffea80a3fc <handle_list_wait+0x11c>  // b.any
ffffffffea80a3e8:	17ffffdf 	b	ffffffffea80a364 <handle_list_wait+0x84>
ffffffffea80a3ec:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80a3f0:	d1008015 	sub	x21, x0, #0x20
ffffffffea80a3f4:	eb00029f 	cmp	x20, x0
ffffffffea80a3f8:	54fffb20 	b.eq	ffffffffea80a35c <handle_list_wait+0x7c>  // b.none
		_finish_wait_handle(handle);
ffffffffea80a3fc:	aa1503e0 	mov	x0, x21
ffffffffea80a400:	97fffe3a 	bl	ffffffffea809ce8 <_finish_wait_handle>
		if (handle == last) {
ffffffffea80a404:	b5ffff55 	cbnz	x21, ffffffffea80a3ec <handle_list_wait+0x10c>
	if (ret == 1) {
ffffffffea80a408:	7100067f 	cmp	w19, #0x1
ffffffffea80a40c:	54fffac1 	b.ne	ffffffffea80a364 <handle_list_wait+0x84>  // b.any
		handle_t *handle = *handle_ptr;
ffffffffea80a410:	f9400315 	ldr	x21, [x24]
		if (handle->ops->finalize_event) {
ffffffffea80a414:	f94006a0 	ldr	x0, [x21, #8]
ffffffffea80a418:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80a41c:	b4000082 	cbz	x2, ffffffffea80a42c <handle_list_wait+0x14c>
			handle->ops->finalize_event(handle, *event_ptr);
ffffffffea80a420:	b9400321 	ldr	w1, [x25]
ffffffffea80a424:	aa1503e0 	mov	x0, x21
ffffffffea80a428:	d63f0040 	blr	x2
ffffffffea80a42c:	885f7ea0 	ldxr	w0, [x21]
ffffffffea80a430:	11000400 	add	w0, w0, #0x1
ffffffffea80a434:	88017ea0 	stxr	w1, w0, [x21]
ffffffffea80a438:	35ffffa1 	cbnz	w1, ffffffffea80a42c <handle_list_wait+0x14c>
	item->next->prev = item->prev;
ffffffffea80a43c:	a9400282 	ldp	x2, x0, [x20]
		list_add_head(&handle->hlist_node, &hlist->handles);
ffffffffea80a440:	910082a1 	add	x1, x21, #0x20
		ret = NO_ERROR;
ffffffffea80a444:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea80a448:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea80a44c:	f9400282 	ldr	x2, [x20]
ffffffffea80a450:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80a454:	f900069f 	str	xzr, [x20, #8]
	item->next = list->next;
ffffffffea80a458:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80a45c:	a9000281 	stp	x1, x0, [x20]
	list->next->prev = item;
ffffffffea80a460:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80a464:	f9000014 	str	x20, [x0]
	list->next = item;
ffffffffea80a468:	f90016b4 	str	x20, [x21, #40]
ffffffffea80a46c:	17ffffbe 	b	ffffffffea80a364 <handle_list_wait+0x84>
	list_for_every_entry(&hlist->handles, handle, handle_t, hlist_node) {
ffffffffea80a470:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80a474:	d1008015 	sub	x21, x0, #0x20
ffffffffea80a478:	eb00029f 	cmp	x20, x0
ffffffffea80a47c:	54fffc01 	b.ne	ffffffffea80a3fc <handle_list_wait+0x11c>  // b.any
ffffffffea80a480:	17ffffb7 	b	ffffffffea80a35c <handle_list_wait+0x7c>
ffffffffea80a484:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a488 <uctx_init>:
	trusty_als_set(app, _uctx_slot_id, uctx);
	return NO_ERROR;
}

static void uctx_init(uint level)
{
ffffffffea80a488:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80a48c:	910003fd 	mov	x29, sp
ffffffffea80a490:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80a494:	aa1e03f3 	mov	x19, x30
	int res;

	/* allocate als slot */
	res = trusty_als_alloc_slot();
ffffffffea80a498:	97fffa06 	bl	ffffffffea808cb0 <trusty_als_alloc_slot>
ffffffffea80a49c:	2a0003e2 	mov	w2, w0
	if (res < 0) {
ffffffffea80a4a0:	37f80140 	tbnz	w0, #31, ffffffffea80a4c8 <uctx_init+0x40>
		panic("failed (%d) to alloc als slot\n", res);
	}
	_uctx_slot_id = res;
ffffffffea80a4a4:	d0000281 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>

	/* register notifier */
	res = trusty_register_app_notifier(&_uctx_notifier);
ffffffffea80a4a8:	d0000060 	adrp	x0, ffffffffea818000 <_mem_phys_base>
ffffffffea80a4ac:	91362000 	add	x0, x0, #0xd88
	_uctx_slot_id = res;
ffffffffea80a4b0:	b90f3822 	str	w2, [x1, #3896]
	res = trusty_register_app_notifier(&_uctx_notifier);
ffffffffea80a4b4:	97fff9e1 	bl	ffffffffea808c38 <trusty_register_app_notifier>
	if (res < 0) {
ffffffffea80a4b8:	37f80100 	tbnz	w0, #31, ffffffffea80a4d8 <uctx_init+0x50>
		panic("failed (%d) to register uctx notifier\n", res);
	}
}
ffffffffea80a4bc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80a4c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80a4c4:	d65f03c0 	ret
		panic("failed (%d) to alloc als slot\n", res);
ffffffffea80a4c8:	90000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a4cc:	aa1303e0 	mov	x0, x19
ffffffffea80a4d0:	913b4021 	add	x1, x1, #0xed0
ffffffffea80a4d4:	94001d4d 	bl	ffffffffea811a08 <_panic>
		panic("failed (%d) to register uctx notifier\n", res);
ffffffffea80a4d8:	90000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a4dc:	2a0003e2 	mov	w2, w0
ffffffffea80a4e0:	913bc021 	add	x1, x1, #0xef0
ffffffffea80a4e4:	aa1303e0 	mov	x0, x19
ffffffffea80a4e8:	94001d48 	bl	ffffffffea811a08 <_panic>
ffffffffea80a4ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a4f0 <_check_handle_id>:
 */
static int _check_handle_id(uctx_t *ctx, handle_id_t handle_id)
{
	DEBUG_ASSERT(ctx);

	if (unlikely(handle_id >= IPC_MAX_HANDLES)) {
ffffffffea80a4f0:	7101fc3f 	cmp	w1, #0x7f
ffffffffea80a4f4:	540002e8 	b.hi	ffffffffea80a550 <_check_handle_id+0x60>  // b.pmore
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80a4f8:	2a0103e2 	mov	w2, w1
ffffffffea80a4fc:	aa0003e4 	mov	x4, x0
ffffffffea80a500:	d346fc43 	lsr	x3, x2, #6
ffffffffea80a504:	f8637803 	ldr	x3, [x0, x3, lsl #3]
ffffffffea80a508:	9ac12461 	lsr	x1, x3, x1
		LTRACEF("%d is invalid handle id\n", handle_id);
		return ERR_BAD_HANDLE;
	}

	if (!bitmap_test(ctx->inuse, handle_id)) {
ffffffffea80a50c:	36000261 	tbz	w1, #0, ffffffffea80a558 <_check_handle_id+0x68>
		LTRACEF("%d is unused handle id\n", handle_id);
		return ERR_NOT_FOUND;
	}

	/* there should be a handle there */
	ASSERT(ctx->handles[handle_id]);
ffffffffea80a510:	91000842 	add	x2, x2, #0x2

	return NO_ERROR;
ffffffffea80a514:	52800000 	mov	w0, #0x0                   	// #0
	ASSERT(ctx->handles[handle_id]);
ffffffffea80a518:	f8627881 	ldr	x1, [x4, x2, lsl #3]
ffffffffea80a51c:	b4000041 	cbz	x1, ffffffffea80a524 <_check_handle_id+0x34>
}
ffffffffea80a520:	d65f03c0 	ret
{
ffffffffea80a524:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(ctx->handles[handle_id]);
ffffffffea80a528:	90000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a52c:	90000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a530:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
{
ffffffffea80a534:	910003fd 	mov	x29, sp
ffffffffea80a538:	aa1e03e0 	mov	x0, x30
	ASSERT(ctx->handles[handle_id]);
ffffffffea80a53c:	91382084 	add	x4, x4, #0xe08
ffffffffea80a540:	52801283 	mov	w3, #0x94                  	// #148
ffffffffea80a544:	91388042 	add	x2, x2, #0xe20
ffffffffea80a548:	91330021 	add	x1, x1, #0xcc0
ffffffffea80a54c:	94001d2f 	bl	ffffffffea811a08 <_panic>
		return ERR_BAD_HANDLE;
ffffffffea80a550:	12800520 	mov	w0, #0xffffffd6            	// #-42
ffffffffea80a554:	d65f03c0 	ret
		return ERR_NOT_FOUND;
ffffffffea80a558:	12800020 	mov	w0, #0xfffffffe            	// #-2
}
ffffffffea80a55c:	d65f03c0 	ret

ffffffffea80a560 <set_current_guest>:
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80a560:	d538d083 	mrs	x3, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80a564:	d0000281 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
extern uint als_slot_cnt;

static inline void *trusty_als_get(struct trusty_app *app, int slot_id)
{
	uint slot = slot_id - 1;
	ASSERT(slot < als_slot_cnt);
ffffffffea80a568:	f0000282 	adrp	x2, ffffffffea85d000 <rb_data+0x18>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80a56c:	f9415863 	ldr	x3, [x3, #688]
	uint slot = slot_id - 1;
ffffffffea80a570:	b94f3821 	ldr	w1, [x1, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a574:	b940cc42 	ldr	w2, [x2, #204]
	uint slot = slot_id - 1;
ffffffffea80a578:	51000421 	sub	w1, w1, #0x1
ffffffffea80a57c:	f9404863 	ldr	x3, [x3, #144]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a580:	6b02003f 	cmp	w1, w2
ffffffffea80a584:	540001e2 	b.cs	ffffffffea80a5c0 <set_current_guest+0x60>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80a588:	f9403062 	ldr	x2, [x3, #96]
ffffffffea80a58c:	f8615841 	ldr	x1, [x2, w1, uxtw #3]

static void set_current_guest(handle_t *handle)
{
	uctx_t *ctx = current_uctx();

	if (handle == NULL) {
ffffffffea80a590:	b4000080 	cbz	x0, ffffffffea80a5a0 <set_current_guest+0x40>
		TRACEF("%s: handle pointer NULL\n", __func__);
		return;
	}

	ctx->cur_guest = handle->guest_id;
ffffffffea80a594:	b9403800 	ldr	w0, [x0, #56]
ffffffffea80a598:	b9046820 	str	w0, [x1, #1128]
ffffffffea80a59c:	d65f03c0 	ret
		TRACEF("%s: handle pointer NULL\n", __func__);
ffffffffea80a5a0:	90000063 	adrp	x3, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a5a4:	90000061 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a5a8:	90000060 	adrp	x0, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a5ac:	9137c063 	add	x3, x3, #0xdf0
ffffffffea80a5b0:	52802762 	mov	w2, #0x13b                 	// #315
ffffffffea80a5b4:	91376021 	add	x1, x1, #0xdd8
ffffffffea80a5b8:	913a4000 	add	x0, x0, #0xe90
ffffffffea80a5bc:	14002279 	b	ffffffffea812fa0 <_printf>
{
ffffffffea80a5c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(slot < als_slot_cnt);
ffffffffea80a5c4:	90000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a5c8:	90000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a5cc:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80a5d0:	910003fd 	mov	x29, sp
ffffffffea80a5d4:	aa1e03e0 	mov	x0, x30
ffffffffea80a5d8:	91390084 	add	x4, x4, #0xe40
ffffffffea80a5dc:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80a5e0:	91396042 	add	x2, x2, #0xe58
ffffffffea80a5e4:	91330021 	add	x1, x1, #0xcc0
ffffffffea80a5e8:	94001d08 	bl	ffffffffea811a08 <_panic>
ffffffffea80a5ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a5f0 <uctx_get_current_guest>:
ffffffffea80a5f0:	d538d083 	mrs	x3, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80a5f4:	d0000281 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea80a5f8:	f0000282 	adrp	x2, ffffffffea85d000 <rb_data+0x18>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80a5fc:	f9415863 	ldr	x3, [x3, #688]
	uint slot = slot_id - 1;
ffffffffea80a600:	b94f3821 	ldr	w1, [x1, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a604:	b940cc42 	ldr	w2, [x2, #204]
	uint slot = slot_id - 1;
ffffffffea80a608:	51000421 	sub	w1, w1, #0x1
ffffffffea80a60c:	f9404863 	ldr	x3, [x3, #144]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a610:	6b02003f 	cmp	w1, w2
ffffffffea80a614:	540000a2 	b.cs	ffffffffea80a628 <uctx_get_current_guest+0x38>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80a618:	f9403060 	ldr	x0, [x3, #96]
	return ctx->cur_guest;
ffffffffea80a61c:	f8615800 	ldr	x0, [x0, w1, uxtw #3]
}
ffffffffea80a620:	b9446800 	ldr	w0, [x0, #1128]
ffffffffea80a624:	d65f03c0 	ret
{
ffffffffea80a628:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(slot < als_slot_cnt);
ffffffffea80a62c:	90000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a630:	90000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a634:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80a638:	910003fd 	mov	x29, sp
ffffffffea80a63c:	aa1e03e0 	mov	x0, x30
ffffffffea80a640:	91390084 	add	x4, x4, #0xe40
ffffffffea80a644:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80a648:	91396042 	add	x2, x2, #0xe58
ffffffffea80a64c:	91330021 	add	x1, x1, #0xcc0
ffffffffea80a650:	94001cee 	bl	ffffffffea811a08 <_panic>
ffffffffea80a654:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a658 <current_uctx>:
ffffffffea80a658:	d538d083 	mrs	x3, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80a65c:	d0000281 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea80a660:	f0000282 	adrp	x2, ffffffffea85d000 <rb_data+0x18>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80a664:	f9415863 	ldr	x3, [x3, #688]
	uint slot = slot_id - 1;
ffffffffea80a668:	b94f3821 	ldr	w1, [x1, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a66c:	b940cc42 	ldr	w2, [x2, #204]
	uint slot = slot_id - 1;
ffffffffea80a670:	51000421 	sub	w1, w1, #0x1
ffffffffea80a674:	f9404863 	ldr	x3, [x3, #144]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a678:	6b02003f 	cmp	w1, w2
ffffffffea80a67c:	54000082 	b.cs	ffffffffea80a68c <current_uctx+0x34>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80a680:	f9403060 	ldr	x0, [x3, #96]
}
ffffffffea80a684:	f8615800 	ldr	x0, [x0, w1, uxtw #3]
ffffffffea80a688:	d65f03c0 	ret
{
ffffffffea80a68c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(slot < als_slot_cnt);
ffffffffea80a690:	90000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a694:	90000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a698:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80a69c:	910003fd 	mov	x29, sp
ffffffffea80a6a0:	aa1e03e0 	mov	x0, x30
ffffffffea80a6a4:	91390084 	add	x4, x4, #0xe40
ffffffffea80a6a8:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80a6ac:	91396042 	add	x2, x2, #0xe58
ffffffffea80a6b0:	91330021 	add	x1, x1, #0xcc0
ffffffffea80a6b4:	94001cd5 	bl	ffffffffea811a08 <_panic>

ffffffffea80a6b8 <uctx_create>:
{
ffffffffea80a6b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a6bc:	910003fd 	mov	x29, sp
ffffffffea80a6c0:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea80a6c4:	aa0003f5 	mov	x21, x0
ffffffffea80a6c8:	aa0103f4 	mov	x20, x1
	new_ctx = calloc(1, sizeof(uctx_t));
ffffffffea80a6cc:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80a6d0:	d2808e01 	mov	x1, #0x470                 	// #1136
ffffffffea80a6d4:	94002261 	bl	ffffffffea813058 <calloc>
	if (!new_ctx) {
ffffffffea80a6d8:	b40001e0 	cbz	x0, ffffffffea80a714 <uctx_create+0x5c>
ffffffffea80a6dc:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80a6e0:	aa0003f3 	mov	x19, x0
	new_ctx->cur_guest = DEFAULT_GUEST_ID;
ffffffffea80a6e4:	529fdda1 	mov	w1, #0xfeed                	// #65261
	handle_list_init(&new_ctx->handle_list);
ffffffffea80a6e8:	91106000 	add	x0, x0, #0x418
	new_ctx->cur_guest = DEFAULT_GUEST_ID;
ffffffffea80a6ec:	72bbd5a1 	movk	w1, #0xdead, lsl #16
	new_ctx->priv = priv;
ffffffffea80a6f0:	f9020a75 	str	x21, [x19, #1040]
	new_ctx->cur_guest = DEFAULT_GUEST_ID;
ffffffffea80a6f4:	b9046a61 	str	w1, [x19, #1128]
	handle_list_init(&new_ctx->handle_list);
ffffffffea80a6f8:	97fffeb0 	bl	ffffffffea80a1b8 <handle_list_init>
	*ctx = new_ctx;
ffffffffea80a6fc:	f9000293 	str	x19, [x20]
	return NO_ERROR;
ffffffffea80a700:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80a704:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea80a708:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80a70c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a710:	d65f03c0 	ret
		return ERR_NO_MEMORY;
ffffffffea80a714:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea80a718:	17fffffc 	b	ffffffffea80a708 <uctx_create+0x50>
ffffffffea80a71c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a720 <_uctx_startup>:
{
ffffffffea80a720:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a724:	910003fd 	mov	x29, sp
ffffffffea80a728:	a90153f3 	stp	x19, x20, [sp, #16]
	int err = uctx_create(app, &uctx);
ffffffffea80a72c:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80a730:	aa1e03f4 	mov	x20, x30
{
ffffffffea80a734:	aa0003f3 	mov	x19, x0
	int err = uctx_create(app, &uctx);
ffffffffea80a738:	97ffffe0 	bl	ffffffffea80a6b8 <uctx_create>
	if (err) {
ffffffffea80a73c:	34000080 	cbz	w0, ffffffffea80a74c <_uctx_startup+0x2c>
}
ffffffffea80a740:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a744:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a748:	d65f03c0 	ret
	trusty_als_set(app, _uctx_slot_id, uctx);
ffffffffea80a74c:	d0000281 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
}

static inline void trusty_als_set(struct trusty_app *app, int slot_id, void *ptr)
{
	uint slot = slot_id - 1;
	ASSERT(slot < als_slot_cnt);
ffffffffea80a750:	f0000282 	adrp	x2, ffffffffea85d000 <rb_data+0x18>
ffffffffea80a754:	f94017a3 	ldr	x3, [x29, #40]
	uint slot = slot_id - 1;
ffffffffea80a758:	b94f3821 	ldr	w1, [x1, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a75c:	b940cc42 	ldr	w2, [x2, #204]
	uint slot = slot_id - 1;
ffffffffea80a760:	51000421 	sub	w1, w1, #0x1
	ASSERT(slot < als_slot_cnt);
ffffffffea80a764:	6b02003f 	cmp	w1, w2
ffffffffea80a768:	540000c2 	b.cs	ffffffffea80a780 <_uctx_startup+0x60>  // b.hs, b.nlast
	app->als[slot] = ptr;
ffffffffea80a76c:	f9403262 	ldr	x2, [x19, #96]
}
ffffffffea80a770:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a774:	f8215843 	str	x3, [x2, w1, uxtw #3]
ffffffffea80a778:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a77c:	d65f03c0 	ret
	ASSERT(slot < als_slot_cnt);
ffffffffea80a780:	90000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a784:	90000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a788:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80a78c:	91390084 	add	x4, x4, #0xe40
ffffffffea80a790:	52800d63 	mov	w3, #0x6b                  	// #107
ffffffffea80a794:	91396042 	add	x2, x2, #0xe58
ffffffffea80a798:	91330021 	add	x1, x1, #0xcc0
ffffffffea80a79c:	aa1403e0 	mov	x0, x20
ffffffffea80a7a0:	94001c9a 	bl	ffffffffea811a08 <_panic>
ffffffffea80a7a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a7a8 <uctx_handle_install>:
{
ffffffffea80a7a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80a7ac:	910003fd 	mov	x29, sp
ffffffffea80a7b0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a7b4:	52800013 	mov	w19, #0x0                   	// #0
{
	uint i;
	int bit;

	for (i = 0; i < BITMAP_NUM_WORDS(numbits); i++) {
		if (bitmap[i] == ~0UL)
ffffffffea80a7b8:	f9400004 	ldr	x4, [x0]
ffffffffea80a7bc:	b100049f 	cmn	x4, #0x1
ffffffffea80a7c0:	54000380 	b.eq	ffffffffea80a830 <uctx_handle_install+0x88>  // b.none
	return __builtin_ffsl(~x) - 1;
ffffffffea80a7c4:	aa2403e4 	mvn	x4, x4
ffffffffea80a7c8:	aa0203f4 	mov	x20, x2
ffffffffea80a7cc:	dac00083 	rbit	x3, x4
ffffffffea80a7d0:	f100009f 	cmp	x4, #0x0
ffffffffea80a7d4:	dac01063 	clz	x3, x3
ffffffffea80a7d8:	5a9f1063 	csinv	w3, w3, wzr, ne  // ne = any
			continue;
		bit = i * BITMAP_BITS_PER_WORD + _ffz(bitmap[i]);
ffffffffea80a7dc:	0b130063 	add	w3, w3, w19
ffffffffea80a7e0:	aa0303f3 	mov	x19, x3
ffffffffea80a7e4:	8b030c04 	add	x4, x0, x3, lsl #3
	ASSERT(ctx->handles[new_id] == NULL);
ffffffffea80a7e8:	f9400882 	ldr	x2, [x4, #16]
ffffffffea80a7ec:	b50002c2 	cbnz	x2, ffffffffea80a844 <uctx_handle_install+0x9c>
	return atomic_or(&((int*)bitmap)[BITMAP_INT(bit)], mask) & mask ? 1 : 0;
ffffffffea80a7f0:	d345fc63 	lsr	x3, x3, #5
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80a7f4:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80a7f8:	1ad32042 	lsl	w2, w2, w19
    return __atomic_fetch_or(ptr, val, __ATOMIC_RELAXED);
ffffffffea80a7fc:	8b030803 	add	x3, x0, x3, lsl #2
ffffffffea80a800:	885f7c65 	ldxr	w5, [x3]
ffffffffea80a804:	2a0200a5 	orr	w5, w5, w2
ffffffffea80a808:	88067c65 	stxr	w6, w5, [x3]
ffffffffea80a80c:	35ffffa6 	cbnz	w6, ffffffffea80a800 <uctx_handle_install+0x58>
	ctx->handles[new_id] = handle;
ffffffffea80a810:	f9000881 	str	x1, [x4, #16]
	handle_list_add(&ctx->handle_list, handle);
ffffffffea80a814:	91106000 	add	x0, x0, #0x418
ffffffffea80a818:	97fffe76 	bl	ffffffffea80a1f0 <handle_list_add>
	*id = (handle_id_t) new_id;
ffffffffea80a81c:	b9000293 	str	w19, [x20]
	return NO_ERROR;
ffffffffea80a820:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea80a824:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a828:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80a82c:	d65f03c0 	ret
		if (bitmap[i] == ~0UL)
ffffffffea80a830:	f9400404 	ldr	x4, [x0, #8]
ffffffffea80a834:	b100049f 	cmn	x4, #0x1
ffffffffea80a838:	54000180 	b.eq	ffffffffea80a868 <uctx_handle_install+0xc0>  // b.none
ffffffffea80a83c:	52800813 	mov	w19, #0x40                  	// #64
ffffffffea80a840:	17ffffe1 	b	ffffffffea80a7c4 <uctx_handle_install+0x1c>
	ASSERT(ctx->handles[new_id] == NULL);
ffffffffea80a844:	90000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a848:	90000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80a84c:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80a850:	913ac084 	add	x4, x4, #0xeb0
ffffffffea80a854:	52801e23 	mov	w3, #0xf1                  	// #241
ffffffffea80a858:	91388042 	add	x2, x2, #0xe20
ffffffffea80a85c:	91330021 	add	x1, x1, #0xcc0
ffffffffea80a860:	aa1e03e0 	mov	x0, x30
ffffffffea80a864:	94001c69 	bl	ffffffffea811a08 <_panic>
		return ERR_NO_RESOURCES;
ffffffffea80a868:	12800500 	mov	w0, #0xffffffd7            	// #-41
ffffffffea80a86c:	17ffffee 	b	ffffffffea80a824 <uctx_handle_install+0x7c>

ffffffffea80a870 <uctx_handle_get>:
{
ffffffffea80a870:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a874:	910003fd 	mov	x29, sp
ffffffffea80a878:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a87c:	2a0103f4 	mov	w20, w1
ffffffffea80a880:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80a884:	aa0003f6 	mov	x22, x0
ffffffffea80a888:	aa0203f5 	mov	x21, x2
	int ret = _check_handle_id (ctx, handle_id);
ffffffffea80a88c:	97ffff19 	bl	ffffffffea80a4f0 <_check_handle_id>
ffffffffea80a890:	2a0003f3 	mov	w19, w0
	if (ret == NO_ERROR) {
ffffffffea80a894:	350000e0 	cbnz	w0, ffffffffea80a8b0 <uctx_handle_get+0x40>
		handle_t *handle = ctx->handles[handle_id];
ffffffffea80a898:	8b344ed4 	add	x20, x22, w20, uxtw #3
		platform_arch_speculation_barrier();
ffffffffea80a89c:	97ffde47 	bl	ffffffffea8021b8 <platform_arch_speculation_barrier>
		handle_t *handle = ctx->handles[handle_id];
ffffffffea80a8a0:	f9400a94 	ldr	x20, [x20, #16]
		handle_incref(handle);
ffffffffea80a8a4:	aa1403e0 	mov	x0, x20
ffffffffea80a8a8:	97fffdb2 	bl	ffffffffea809f70 <handle_incref>
		*handle_ptr = handle;
ffffffffea80a8ac:	f90002b4 	str	x20, [x21]
}
ffffffffea80a8b0:	2a1303e0 	mov	w0, w19
ffffffffea80a8b4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a8b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80a8bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a8c0:	d65f03c0 	ret
ffffffffea80a8c4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a8c8 <uctx_handle_remove>:
{
ffffffffea80a8c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a8cc:	910003fd 	mov	x29, sp
ffffffffea80a8d0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a8d4:	aa0003f4 	mov	x20, x0
ffffffffea80a8d8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80a8dc:	2a0103f5 	mov	w21, w1
ffffffffea80a8e0:	aa0203f6 	mov	x22, x2
	int ret = _check_handle_id(ctx, handle_id);
ffffffffea80a8e4:	97ffff03 	bl	ffffffffea80a4f0 <_check_handle_id>
ffffffffea80a8e8:	2a0003f3 	mov	w19, w0
	if (ret == NO_ERROR) {
ffffffffea80a8ec:	340000c0 	cbz	w0, ffffffffea80a904 <uctx_handle_remove+0x3c>
}
ffffffffea80a8f0:	2a1303e0 	mov	w0, w19
ffffffffea80a8f4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a8f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80a8fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a900:	d65f03c0 	ret
		platform_arch_speculation_barrier();
ffffffffea80a904:	97ffde2d 	bl	ffffffffea8021b8 <platform_arch_speculation_barrier>
ffffffffea80a908:	8b354e82 	add	x2, x20, w21, uxtw #3
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80a90c:	93437ea0 	sbfx	x0, x21, #3, #29
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80a910:	52800021 	mov	w1, #0x1                   	// #1
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea80a914:	927ee800 	and	x0, x0, #0x1ffffffffffffffc
ffffffffea80a918:	1ad52021 	lsl	w1, w1, w21
ffffffffea80a91c:	8b000280 	add	x0, x20, x0
		handle_t *handle = ctx->handles[handle_id];
ffffffffea80a920:	f9400855 	ldr	x21, [x2, #16]
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80a924:	2a2103e1 	mvn	w1, w1
ffffffffea80a928:	885f7c03 	ldxr	w3, [x0]
ffffffffea80a92c:	0a010063 	and	w3, w3, w1
ffffffffea80a930:	88047c03 	stxr	w4, w3, [x0]
ffffffffea80a934:	35ffffa4 	cbnz	w4, ffffffffea80a928 <uctx_handle_remove+0x60>
		ctx->handles[handle_id] = NULL;
ffffffffea80a938:	f900085f 	str	xzr, [x2, #16]
		handle_list_del(&ctx->handle_list, handle);
ffffffffea80a93c:	aa1503e1 	mov	x1, x21
ffffffffea80a940:	91106280 	add	x0, x20, #0x418
ffffffffea80a944:	97fffe55 	bl	ffffffffea80a298 <handle_list_del>
		*handle_ptr = handle;
ffffffffea80a948:	f90002d5 	str	x21, [x22]
}
ffffffffea80a94c:	2a1303e0 	mov	w0, w19
ffffffffea80a950:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a954:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80a958:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a95c:	d65f03c0 	ret

ffffffffea80a960 <sys_wait>:
/*
 *   wait on single handle specified by handle id
 */
long __SYSCALL sys_wait(uint32_t handle_id, user_addr_t user_event,
                        unsigned long timeout_msecs)
{
ffffffffea80a960:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80a964:	910003fd 	mov	x29, sp
ffffffffea80a968:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a96c:	2a0003f4 	mov	w20, w0
ffffffffea80a970:	f90013f5 	str	x21, [sp, #32]
ffffffffea80a974:	aa0203f3 	mov	x19, x2
ffffffffea80a978:	2a0103f5 	mov	w21, w1
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80a97c:	d538d082 	mrs	x2, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80a980:	d0000280 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
	ASSERT(slot < als_slot_cnt);
ffffffffea80a984:	f0000281 	adrp	x1, ffffffffea85d000 <rb_data+0x18>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80a988:	f9415842 	ldr	x2, [x2, #688]
	uint slot = slot_id - 1;
ffffffffea80a98c:	b94f3800 	ldr	w0, [x0, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a990:	b940cc21 	ldr	w1, [x1, #204]
	uint slot = slot_id - 1;
ffffffffea80a994:	51000400 	sub	w0, w0, #0x1
ffffffffea80a998:	f9404842 	ldr	x2, [x2, #144]
	ASSERT(slot < als_slot_cnt);
ffffffffea80a99c:	6b01001f 	cmp	w0, w1
ffffffffea80a9a0:	540004e2 	b.cs	ffffffffea80aa3c <sys_wait+0xdc>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80a9a4:	f9403043 	ldr	x3, [x2, #96]
	int ret;

	LTRACEF("[%p][%d]: %ld msec\n", uthread_get_current(),
	                                handle_id, timeout_msecs);

	ret = uctx_handle_get(ctx, handle_id, &handle);
ffffffffea80a9a8:	2a1403e1 	mov	w1, w20
ffffffffea80a9ac:	9100e3a2 	add	x2, x29, #0x38
ffffffffea80a9b0:	f8605860 	ldr	x0, [x3, w0, uxtw #3]
ffffffffea80a9b4:	97ffffaf 	bl	ffffffffea80a870 <uctx_handle_get>
	if (ret != NO_ERROR) {
ffffffffea80a9b8:	340000c0 	cbz	w0, ffffffffea80a9d0 <sys_wait+0x70>
	handle_decref(handle);

	LTRACEF("[%p][%d]: ret = %d\n", uthread_get_current(),
	                                handle_id, ret);
	return ret;
}
ffffffffea80a9bc:	a94153f3 	ldp	x19, x20, [sp, #16]
		return ret;
ffffffffea80a9c0:	93407c00 	sxtw	x0, w0
}
ffffffffea80a9c4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80a9c8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80a9cc:	d65f03c0 	ret
	ret = handle_wait(handle, &tmp_event.event,
ffffffffea80a9d0:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80a9d4:	2a1303e2 	mov	w2, w19
ffffffffea80a9d8:	910113a1 	add	x1, x29, #0x44
ffffffffea80a9dc:	97fffd9f 	bl	ffffffffea80a058 <handle_wait>
ffffffffea80a9e0:	2a0003f3 	mov	w19, w0
	if (ret < 0) {
ffffffffea80a9e4:	36f80100 	tbz	w0, #31, ffffffffea80aa04 <sys_wait+0xa4>
	handle_decref(handle);
ffffffffea80a9e8:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80a9ec:	97fffd67 	bl	ffffffffea809f88 <handle_decref>
	return ret;
ffffffffea80a9f0:	93407e60 	sxtw	x0, w19
}
ffffffffea80a9f4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a9f8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80a9fc:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80aa00:	d65f03c0 	ret
	handle->cookie = cookie;
}

static inline void *handle_get_cookie(handle_t *handle)
{
	return handle->cookie;
ffffffffea80aa04:	f9401fa3 	ldr	x3, [x29, #56]
ffffffffea80aa08:	d2800182 	mov	x2, #0xc                   	// #12
ffffffffea80aa0c:	910103a1 	add	x1, x29, #0x40
ffffffffea80aa10:	2a1503e0 	mov	w0, w21
	tmp_event.handle = handle_id;
ffffffffea80aa14:	b90043b4 	str	w20, [x29, #64]
	tmp_event.cookie = (user_addr_t)(uintptr_t)handle_get_cookie(handle);
ffffffffea80aa18:	f9401863 	ldr	x3, [x3, #48]
ffffffffea80aa1c:	b9004ba3 	str	w3, [x29, #72]
ffffffffea80aa20:	94002312 	bl	ffffffffea813668 <arch_copy_to_user>
	if (status) {
ffffffffea80aa24:	340001e0 	cbz	w0, ffffffffea80aa60 <sys_wait+0x100>
ffffffffea80aa28:	2a0003f3 	mov	w19, w0
	handle_decref(handle);
ffffffffea80aa2c:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80aa30:	97fffd56 	bl	ffffffffea809f88 <handle_decref>
	return ret;
ffffffffea80aa34:	93407e60 	sxtw	x0, w19
ffffffffea80aa38:	17ffffef 	b	ffffffffea80a9f4 <sys_wait+0x94>
	ASSERT(slot < als_slot_cnt);
ffffffffea80aa3c:	90000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80aa40:	90000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80aa44:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80aa48:	91390084 	add	x4, x4, #0xe40
ffffffffea80aa4c:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80aa50:	91396042 	add	x2, x2, #0xe58
ffffffffea80aa54:	91330021 	add	x1, x1, #0xcc0
ffffffffea80aa58:	aa1e03e0 	mov	x0, x30
ffffffffea80aa5c:	94001beb 	bl	ffffffffea811a08 <_panic>
		set_current_guest(handle);
ffffffffea80aa60:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80aa64:	97fffebf 	bl	ffffffffea80a560 <set_current_guest>
out:
ffffffffea80aa68:	17ffffe0 	b	ffffffffea80a9e8 <sys_wait+0x88>
ffffffffea80aa6c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80aa70 <sys_wait_any>:

/*
 *   Wait on any handle existing in user context.
 */
long __SYSCALL sys_wait_any(user_addr_t user_event, unsigned long timeout_msecs)
{
ffffffffea80aa70:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80aa74:	910003fd 	mov	x29, sp
ffffffffea80aa78:	f90013f5 	str	x21, [sp, #32]
ffffffffea80aa7c:	2a0003f5 	mov	w21, w0
ffffffffea80aa80:	d538d084 	mrs	x4, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80aa84:	d0000280 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80aa88:	f9415884 	ldr	x4, [x4, #688]
ffffffffea80aa8c:	f0000282 	adrp	x2, ffffffffea85d000 <rb_data+0x18>
	uint slot = slot_id - 1;
ffffffffea80aa90:	b94f3800 	ldr	w0, [x0, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80aa94:	b940cc42 	ldr	w2, [x2, #204]
ffffffffea80aa98:	f9404883 	ldr	x3, [x4, #144]
	uint slot = slot_id - 1;
ffffffffea80aa9c:	51000400 	sub	w0, w0, #0x1
ffffffffea80aaa0:	a90153b3 	stp	x19, x20, [x29, #16]
	ASSERT(slot < als_slot_cnt);
ffffffffea80aaa4:	6b02001f 	cmp	w0, w2
ffffffffea80aaa8:	54000562 	b.cs	ffffffffea80ab54 <sys_wait_any+0xe4>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80aaac:	f9403064 	ldr	x4, [x3, #96]
	                            timeout_msecs);
	/*
	 * Get a handle that has a pending event. The returned handle has
	 * extra ref taken.
	 */
	ret = handle_list_wait(&ctx->handle_list, &handle, &tmp_event.event,
ffffffffea80aab0:	910113a2 	add	x2, x29, #0x44
ffffffffea80aab4:	2a0103e3 	mov	w3, w1
ffffffffea80aab8:	9100e3a1 	add	x1, x29, #0x38
ffffffffea80aabc:	f8605893 	ldr	x19, [x4, w0, uxtw #3]
ffffffffea80aac0:	91106260 	add	x0, x19, #0x418
ffffffffea80aac4:	97fffe07 	bl	ffffffffea80a2e0 <handle_list_wait>
ffffffffea80aac8:	2a0003f4 	mov	w20, w0
			       timeout_msecs);
	if (ret < 0) {
ffffffffea80aacc:	37f802c0 	tbnz	w0, #31, ffffffffea80ab24 <sys_wait_any+0xb4>
ffffffffea80aad0:	91004261 	add	x1, x19, #0x10
	for (int i = 0; i < IPC_MAX_HANDLES; i++) {
ffffffffea80aad4:	52800002 	mov	w2, #0x0                   	// #0
		goto out;
	}

	DEBUG_ASSERT(handle); /* there should be a handle */

	tmp_event.handle = _handle_to_id_locked(ctx, handle);
ffffffffea80aad8:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80aadc:	14000005 	b	ffffffffea80aaf0 <sys_wait_any+0x80>
	for (int i = 0; i < IPC_MAX_HANDLES; i++) {
ffffffffea80aae0:	11000442 	add	w2, w2, #0x1
ffffffffea80aae4:	91002021 	add	x1, x1, #0x8
ffffffffea80aae8:	7102005f 	cmp	w2, #0x80
ffffffffea80aaec:	54000460 	b.eq	ffffffffea80ab78 <sys_wait_any+0x108>  // b.none
		if (ctx->handles[i] == handle) {
ffffffffea80aaf0:	f9400023 	ldr	x3, [x1]
ffffffffea80aaf4:	eb03001f 	cmp	x0, x3
ffffffffea80aaf8:	54ffff41 	b.ne	ffffffffea80aae0 <sys_wait_any+0x70>  // b.any
	tmp_event.cookie = (user_addr_t)(uintptr_t)handle_get_cookie(handle);
ffffffffea80aafc:	f9401801 	ldr	x1, [x0, #48]
	tmp_event.handle = _handle_to_id_locked(ctx, handle);
ffffffffea80ab00:	b90043a2 	str	w2, [x29, #64]
	tmp_event.cookie = (user_addr_t)(uintptr_t)handle_get_cookie(handle);
ffffffffea80ab04:	b9004ba1 	str	w1, [x29, #72]

	/* drop the reference that was taken by wait_any */
	handle_decref(handle);
ffffffffea80ab08:	97fffd20 	bl	ffffffffea809f88 <handle_decref>
ffffffffea80ab0c:	d2800182 	mov	x2, #0xc                   	// #12
ffffffffea80ab10:	910103a1 	add	x1, x29, #0x40
ffffffffea80ab14:	2a1503e0 	mov	w0, w21
ffffffffea80ab18:	940022d4 	bl	ffffffffea813668 <arch_copy_to_user>

	/* there should be a handle id */
	DEBUG_ASSERT(tmp_event.handle < IPC_MAX_HANDLES);

	status = copy_to_user(user_event, &tmp_event, sizeof(tmp_event));
	if (status) {
ffffffffea80ab1c:	340000e0 	cbz	w0, ffffffffea80ab38 <sys_wait_any+0xc8>
ffffffffea80ab20:	2a0003f4 	mov	w20, w0
	}
out:
	LTRACEF("[%p][%d]: ret = %d\n", uthread_get_current(),
	                                tmp_event.handle, ret);
	return ret;
}
ffffffffea80ab24:	93407e80 	sxtw	x0, w20
ffffffffea80ab28:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ab2c:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80ab30:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80ab34:	d65f03c0 	ret
		set_current_guest(handle);
ffffffffea80ab38:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80ab3c:	97fffe89 	bl	ffffffffea80a560 <set_current_guest>
}
ffffffffea80ab40:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ab44:	93407e80 	sxtw	x0, w20
ffffffffea80ab48:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80ab4c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80ab50:	d65f03c0 	ret
	ASSERT(slot < als_slot_cnt);
ffffffffea80ab54:	90000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80ab58:	90000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80ab5c:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80ab60:	91390084 	add	x4, x4, #0xe40
ffffffffea80ab64:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80ab68:	91396042 	add	x2, x2, #0xe58
ffffffffea80ab6c:	91330021 	add	x1, x1, #0xcc0
ffffffffea80ab70:	aa1e03e0 	mov	x0, x30
ffffffffea80ab74:	94001ba5 	bl	ffffffffea811a08 <_panic>
	return INVALID_HANDLE_ID;
ffffffffea80ab78:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea80ab7c:	17ffffe0 	b	ffffffffea80aafc <sys_wait_any+0x8c>

ffffffffea80ab80 <sys_close>:

long __SYSCALL sys_close(uint32_t handle_id)
{
ffffffffea80ab80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80ab84:	910003fd 	mov	x29, sp
ffffffffea80ab88:	d538d084 	mrs	x4, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80ab8c:	d0000283 	adrp	x3, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea80ab90:	f0000282 	adrp	x2, ffffffffea85d000 <rb_data+0x18>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80ab94:	f9415884 	ldr	x4, [x4, #688]
	uint slot = slot_id - 1;
ffffffffea80ab98:	b94f3863 	ldr	w3, [x3, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80ab9c:	b940cc42 	ldr	w2, [x2, #204]
	uint slot = slot_id - 1;
ffffffffea80aba0:	51000463 	sub	w3, w3, #0x1
ffffffffea80aba4:	f9404881 	ldr	x1, [x4, #144]
	ASSERT(slot < als_slot_cnt);
ffffffffea80aba8:	6b02007f 	cmp	w3, w2
ffffffffea80abac:	540001e2 	b.cs	ffffffffea80abe8 <sys_close+0x68>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80abb0:	f9403024 	ldr	x4, [x1, #96]
	handle_t *handle;

	LTRACEF("[%p][%d]\n", uthread_get_current(),
	                      handle_id);

	int ret = uctx_handle_remove(current_uctx(), handle_id, &handle);
ffffffffea80abb4:	2a0003e1 	mov	w1, w0
ffffffffea80abb8:	910063a2 	add	x2, x29, #0x18
ffffffffea80abbc:	f8635880 	ldr	x0, [x4, w3, uxtw #3]
ffffffffea80abc0:	97ffff42 	bl	ffffffffea80a8c8 <uctx_handle_remove>
	if (ret != NO_ERROR) {
ffffffffea80abc4:	34000080 	cbz	w0, ffffffffea80abd4 <sys_close+0x54>
		return ret;
ffffffffea80abc8:	93407c00 	sxtw	x0, w0
	}
	handle_close(handle);
	return NO_ERROR;
}
ffffffffea80abcc:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80abd0:	d65f03c0 	ret
	handle_close(handle);
ffffffffea80abd4:	f9400fa0 	ldr	x0, [x29, #24]
ffffffffea80abd8:	97fffd14 	bl	ffffffffea80a028 <handle_close>
	return NO_ERROR;
ffffffffea80abdc:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80abe0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80abe4:	d65f03c0 	ret
	ASSERT(slot < als_slot_cnt);
ffffffffea80abe8:	90000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80abec:	90000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80abf0:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80abf4:	91390084 	add	x4, x4, #0xe40
ffffffffea80abf8:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80abfc:	91396042 	add	x2, x2, #0xe58
ffffffffea80ac00:	91330021 	add	x1, x1, #0xcc0
ffffffffea80ac04:	aa1e03e0 	mov	x0, x30
ffffffffea80ac08:	94001b80 	bl	ffffffffea811a08 <_panic>
ffffffffea80ac0c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80ac10 <sys_set_cookie>:

long __SYSCALL sys_set_cookie(uint32_t handle_id, user_addr_t cookie)
{
ffffffffea80ac10:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80ac14:	910003fd 	mov	x29, sp
ffffffffea80ac18:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80ac1c:	2a0103f3 	mov	w19, w1
ffffffffea80ac20:	d538d082 	mrs	x2, tpidr_el1
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80ac24:	d0000283 	adrp	x3, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea80ac28:	f0000281 	adrp	x1, ffffffffea85d000 <rb_data+0x18>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80ac2c:	f9415842 	ldr	x2, [x2, #688]
	uint slot = slot_id - 1;
ffffffffea80ac30:	b94f3863 	ldr	w3, [x3, #3896]
	ASSERT(slot < als_slot_cnt);
ffffffffea80ac34:	b940cc21 	ldr	w1, [x1, #204]
	uint slot = slot_id - 1;
ffffffffea80ac38:	51000463 	sub	w3, w3, #0x1
ffffffffea80ac3c:	f9404842 	ldr	x2, [x2, #144]
	ASSERT(slot < als_slot_cnt);
ffffffffea80ac40:	6b01007f 	cmp	w3, w1
ffffffffea80ac44:	54000262 	b.cs	ffffffffea80ac90 <sys_set_cookie+0x80>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80ac48:	f9403044 	ldr	x4, [x2, #96]
	handle_t *handle;

	LTRACEF("[%p][%d]: cookie = 0x%08x\n", uthread_get_current(),
	                              handle_id, (uint) cookie);

	int ret = uctx_handle_get(current_uctx(), handle_id, &handle);
ffffffffea80ac4c:	2a0003e1 	mov	w1, w0
ffffffffea80ac50:	9100a3a2 	add	x2, x29, #0x28
ffffffffea80ac54:	f8635880 	ldr	x0, [x4, w3, uxtw #3]
ffffffffea80ac58:	97ffff06 	bl	ffffffffea80a870 <uctx_handle_get>
	if (ret != NO_ERROR) {
ffffffffea80ac5c:	340000a0 	cbz	w0, ffffffffea80ac70 <sys_set_cookie+0x60>
	}
	handle_set_cookie(handle, (void *)(uintptr_t)cookie);

	handle_decref(handle);
	return NO_ERROR;
}
ffffffffea80ac60:	f9400bf3 	ldr	x19, [sp, #16]
		return ret;
ffffffffea80ac64:	93407c00 	sxtw	x0, w0
}
ffffffffea80ac68:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ac6c:	d65f03c0 	ret
	handle_set_cookie(handle, (void *)(uintptr_t)cookie);
ffffffffea80ac70:	f94017a1 	ldr	x1, [x29, #40]
	handle_decref(handle);
ffffffffea80ac74:	aa0103e0 	mov	x0, x1
	handle_set_cookie(handle, (void *)(uintptr_t)cookie);
ffffffffea80ac78:	f9001833 	str	x19, [x1, #48]
	handle_decref(handle);
ffffffffea80ac7c:	97fffcc3 	bl	ffffffffea809f88 <handle_decref>
}
ffffffffea80ac80:	f9400bf3 	ldr	x19, [sp, #16]
	return NO_ERROR;
ffffffffea80ac84:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80ac88:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ac8c:	d65f03c0 	ret
	ASSERT(slot < als_slot_cnt);
ffffffffea80ac90:	90000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80ac94:	90000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80ac98:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80ac9c:	91390084 	add	x4, x4, #0xe40
ffffffffea80aca0:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80aca4:	91396042 	add	x2, x2, #0xe58
ffffffffea80aca8:	91330021 	add	x1, x1, #0xcc0
ffffffffea80acac:	aa1e03e0 	mov	x0, x30
ffffffffea80acb0:	94001b56 	bl	ffffffffea811a08 <_panic>
ffffffffea80acb4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80acb8 <port_poll>:
	}
	return NULL;
}

static uint32_t port_poll(handle_t *phandle)
{
ffffffffea80acb8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80acbc:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80acc0:	910003fd 	mov	x29, sp
ffffffffea80acc4:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80acc8:	aa0003f3 	mov	x19, x0
ffffffffea80accc:	d0000074 	adrp	x20, ffffffffea818000 <_mem_phys_base>
ffffffffea80acd0:	91372280 	add	x0, x20, #0xdc8
ffffffffea80acd4:	97ffeb05 	bl	ffffffffea8058e8 <mutex_acquire_timeout>

	ipc_port_t *port = containerof(phandle, ipc_port_t, handle);
	uint32_t events = 0;

	mutex_acquire(&ipc_lock);
	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80acd8:	b85e8260 	ldur	w0, [x19, #-24]
ffffffffea80acdc:	7100041f 	cmp	w0, #0x1
ffffffffea80ace0:	54000161 	b.ne	ffffffffea80ad0c <port_poll+0x54>  // b.any
		events |= IPC_HANDLE_POLL_ERROR;
	} else if (!list_is_empty(&port->pending_list)) {
ffffffffea80ace4:	f9402660 	ldr	x0, [x19, #72]
ffffffffea80ace8:	91010273 	add	x19, x19, #0x40
ffffffffea80acec:	eb13001f 	cmp	x0, x19
		events |= IPC_HANDLE_POLL_READY;
	} else {
		/* All if-else chains must end with an else clause */
	}
	LTRACEF("%s in state %d events %x\n", port->path, port->state, events);
	mutex_release(&ipc_lock);
ffffffffea80acf0:	91372280 	add	x0, x20, #0xdc8
	} else if (!list_is_empty(&port->pending_list)) {
ffffffffea80acf4:	1a9f07f3 	cset	w19, ne  // ne = any
	mutex_release(&ipc_lock);
ffffffffea80acf8:	97ffeb28 	bl	ffffffffea805998 <mutex_release>

	return events;
}
ffffffffea80acfc:	2a1303e0 	mov	w0, w19
ffffffffea80ad00:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ad04:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80ad08:	d65f03c0 	ret
		events |= IPC_HANDLE_POLL_ERROR;
ffffffffea80ad0c:	52800053 	mov	w19, #0x2                   	// #2
	mutex_release(&ipc_lock);
ffffffffea80ad10:	91372280 	add	x0, x20, #0xdc8
ffffffffea80ad14:	97ffeb21 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea80ad18:	2a1303e0 	mov	w0, w19
ffffffffea80ad1c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ad20:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80ad24:	d65f03c0 	ret

ffffffffea80ad28 <chan_poll>:

/*
 *  Poll channel state
 */
static uint32_t chan_poll(handle_t *chandle)
{
ffffffffea80ad28:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80ad2c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80ad30:	910003fd 	mov	x29, sp
ffffffffea80ad34:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80ad38:	aa0003f4 	mov	x20, x0
ffffffffea80ad3c:	f90013f5 	str	x21, [sp, #32]
ffffffffea80ad40:	d0000075 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea80ad44:	913722a0 	add	x0, x21, #0xdc8
ffffffffea80ad48:	97ffeae8 	bl	ffffffffea8058e8 <mutex_acquire_timeout>

	ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);

	uint32_t events = 0;

	if (chan->state == IPC_CHAN_STATE_INVALID) {
ffffffffea80ad4c:	b85e0293 	ldur	w19, [x20, #-32]
ffffffffea80ad50:	340002f3 	cbz	w19, ffffffffea80adac <chan_poll+0x84>
	if (chan->state == IPC_CHAN_STATE_DISCONNECTING) {
		events |= IPC_HANDLE_POLL_HUP;
	}

	/* server accepted our connection */
	if (chan->aux_state & IPC_CHAN_AUX_STATE_CONNECTED) {
ffffffffea80ad54:	b85e8281 	ldur	w1, [x20, #-24]
	uint32_t events = 0;
ffffffffea80ad58:	7100127f 	cmp	w19, #0x4
		events |= IPC_HANDLE_POLL_READY;
	}

	/* have a pending message? */
	if (chan->msg_queue && !ipc_msg_queue_is_empty(chan->msg_queue)) {
ffffffffea80ad5c:	f9403280 	ldr	x0, [x20, #96]
	uint32_t events = 0;
ffffffffea80ad60:	1a9f0273 	csel	w19, w19, wzr, eq  // eq = none
		events |= IPC_HANDLE_POLL_READY;
ffffffffea80ad64:	32000262 	orr	w2, w19, #0x1
ffffffffea80ad68:	f27e003f 	tst	x1, #0x4
ffffffffea80ad6c:	1a931053 	csel	w19, w2, w19, ne  // ne = any
	if (chan->msg_queue && !ipc_msg_queue_is_empty(chan->msg_queue)) {
ffffffffea80ad70:	b40000a0 	cbz	x0, ffffffffea80ad84 <chan_poll+0x5c>
ffffffffea80ad74:	940006d9 	bl	ffffffffea80c8d8 <ipc_msg_queue_is_empty>
ffffffffea80ad78:	72001c1f 	tst	w0, #0xff
ffffffffea80ad7c:	b85e8281 	ldur	w1, [x20, #-24]
ffffffffea80ad80:	54000260 	b.eq	ffffffffea80adcc <chan_poll+0xa4>  // b.none
		events |= IPC_HANDLE_POLL_MSG;
	}

	/* check if we were send blocked */
	if (chan->aux_state & IPC_CHAN_AUX_STATE_SEND_UNBLOCKED) {
		events |= IPC_HANDLE_POLL_SEND_UNBLOCKED;
ffffffffea80ad84:	f27f003f 	tst	x1, #0x2
ffffffffea80ad88:	321c0260 	orr	w0, w19, #0x10
ffffffffea80ad8c:	1a931013 	csel	w19, w0, w19, ne  // ne = any
	}

done:
	mutex_release(&ipc_lock);
ffffffffea80ad90:	913722a0 	add	x0, x21, #0xdc8
ffffffffea80ad94:	97ffeb01 	bl	ffffffffea805998 <mutex_release>
	return events;
}
ffffffffea80ad98:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ad9c:	2a1303e0 	mov	w0, w19
ffffffffea80ada0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ada4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ada8:	d65f03c0 	ret
		events |= IPC_HANDLE_POLL_ERROR;
ffffffffea80adac:	52800053 	mov	w19, #0x2                   	// #2
	mutex_release(&ipc_lock);
ffffffffea80adb0:	913722a0 	add	x0, x21, #0xdc8
ffffffffea80adb4:	97ffeaf9 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea80adb8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80adbc:	2a1303e0 	mov	w0, w19
ffffffffea80adc0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80adc4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80adc8:	d65f03c0 	ret
		events |= IPC_HANDLE_POLL_MSG;
ffffffffea80adcc:	321d0273 	orr	w19, w19, #0x8
ffffffffea80add0:	17ffffed 	b	ffffffffea80ad84 <chan_poll+0x5c>
ffffffffea80add4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80add8 <chan_alloc>:
{
ffffffffea80add8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80addc:	910003fd 	mov	x29, sp
ffffffffea80ade0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80ade4:	2a0003f4 	mov	w20, w0
ffffffffea80ade8:	f90013f5 	str	x21, [sp, #32]
ffffffffea80adec:	aa0203f3 	mov	x19, x2
ffffffffea80adf0:	aa0103f5 	mov	x21, x1
	chan = calloc(1, sizeof(ipc_chan_t));
ffffffffea80adf4:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80adf8:	d2801801 	mov	x1, #0xc0                  	// #192
ffffffffea80adfc:	94002097 	bl	ffffffffea813058 <calloc>
	if (!chan) {
ffffffffea80ae00:	b4000100 	cbz	x0, ffffffffea80ae20 <chan_alloc+0x48>
	list->prev->next = item;
ffffffffea80ae04:	a9004c13 	stp	x19, x19, [x0]
}

static inline __ALWAYS_INLINE
void obj_ref_init(obj_ref_t *ref)
{
	*ref = (obj_ref_t)OBJ_REF_INITIAL_VALUE(*ref);
ffffffffea80ae08:	a9017c1f 	stp	xzr, xzr, [x0, #16]
	chan->uuid  = uuid;
ffffffffea80ae0c:	f9001415 	str	x21, [x0, #40]
	chan->flags = flags;
ffffffffea80ae10:	2906501f 	stp	wzr, w20, [x0, #48]
ffffffffea80ae14:	a9047c1f 	stp	xzr, xzr, [x0, #64]
ffffffffea80ae18:	a9097c1f 	stp	xzr, xzr, [x0, #144]
	item->next = list;
ffffffffea80ae1c:	a9000260 	stp	x0, x0, [x19]
}
ffffffffea80ae20:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ae24:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ae28:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ae2c:	d65f03c0 	ret

ffffffffea80ae30 <port_find_locked>:
{
ffffffffea80ae30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80ae34:	910003fd 	mov	x29, sp
ffffffffea80ae38:	a90153f3 	stp	x19, x20, [sp, #16]
	list_for_every_entry(&ipc_port_list, port, ipc_port_t, node) {
ffffffffea80ae3c:	d0000074 	adrp	x20, ffffffffea818000 <_mem_phys_base>
ffffffffea80ae40:	91388294 	add	x20, x20, #0xe20
ffffffffea80ae44:	f9400681 	ldr	x1, [x20, #8]
ffffffffea80ae48:	eb01029f 	cmp	x20, x1
ffffffffea80ae4c:	54000300 	b.eq	ffffffffea80aeac <port_find_locked+0x7c>  // b.none
ffffffffea80ae50:	f90013b5 	str	x21, [x29, #32]
ffffffffea80ae54:	d102c033 	sub	x19, x1, #0xb0
ffffffffea80ae58:	aa0003f5 	mov	x21, x0
ffffffffea80ae5c:	14000005 	b	ffffffffea80ae70 <port_find_locked+0x40>
ffffffffea80ae60:	f9405e61 	ldr	x1, [x19, #184]
ffffffffea80ae64:	d102c033 	sub	x19, x1, #0xb0
ffffffffea80ae68:	eb01029f 	cmp	x20, x1
ffffffffea80ae6c:	54000140 	b.eq	ffffffffea80ae94 <port_find_locked+0x64>  // b.none
		if (!strcmp(path, port->path)) {
ffffffffea80ae70:	aa1303e1 	mov	x1, x19
ffffffffea80ae74:	aa1503e0 	mov	x0, x21
ffffffffea80ae78:	94002166 	bl	ffffffffea813410 <strcmp>
ffffffffea80ae7c:	35ffff20 	cbnz	w0, ffffffffea80ae60 <port_find_locked+0x30>
ffffffffea80ae80:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80ae84:	aa1303e0 	mov	x0, x19
ffffffffea80ae88:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ae8c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ae90:	d65f03c0 	ret
	return NULL;
ffffffffea80ae94:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea80ae98:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80ae9c:	aa1303e0 	mov	x0, x19
ffffffffea80aea0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80aea4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80aea8:	d65f03c0 	ret
	return NULL;
ffffffffea80aeac:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea80aeb0:	17fffff5 	b	ffffffffea80ae84 <port_find_locked+0x54>
ffffffffea80aeb4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80aeb8 <chan_finalize_event>:
static void chan_finalize_event(handle_t *chandle, uint32_t event)
{
	DEBUG_ASSERT(chandle);
	DEBUG_ASSERT(ipc_is_channel(chandle));

	if (event & (IPC_HANDLE_POLL_SEND_UNBLOCKED | IPC_HANDLE_POLL_READY)) {
ffffffffea80aeb8:	52800222 	mov	w2, #0x11                  	// #17
ffffffffea80aebc:	6a02003f 	tst	w1, w2
ffffffffea80aec0:	54000041 	b.ne	ffffffffea80aec8 <chan_finalize_event+0x10>  // b.any
ffffffffea80aec4:	d65f03c0 	ret
{
ffffffffea80aec8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80aecc:	910003fd 	mov	x29, sp
ffffffffea80aed0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80aed4:	2a0103f3 	mov	w19, w1
ffffffffea80aed8:	f90013f5 	str	x21, [sp, #32]
ffffffffea80aedc:	aa0003f4 	mov	x20, x0
ffffffffea80aee0:	d0000075 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea80aee4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80aee8:	913722a0 	add	x0, x21, #0xdc8
ffffffffea80aeec:	97ffea7f 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
		mutex_acquire(&ipc_lock);
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		if (event & IPC_HANDLE_POLL_SEND_UNBLOCKED) {
ffffffffea80aef0:	36200093 	tbz	w19, #4, ffffffffea80af00 <chan_finalize_event+0x48>
			chan->aux_state &= ~IPC_CHAN_AUX_STATE_SEND_UNBLOCKED;
ffffffffea80aef4:	b85e8280 	ldur	w0, [x20, #-24]
ffffffffea80aef8:	121e7800 	and	w0, w0, #0xfffffffd
ffffffffea80aefc:	b81e8280 	stur	w0, [x20, #-24]
		}
		if (event & IPC_HANDLE_POLL_READY) {
ffffffffea80af00:	36000093 	tbz	w19, #0, ffffffffea80af10 <chan_finalize_event+0x58>
			chan->aux_state &= ~IPC_CHAN_AUX_STATE_CONNECTED;
ffffffffea80af04:	b85e8280 	ldur	w0, [x20, #-24]
ffffffffea80af08:	121d7800 	and	w0, w0, #0xfffffffb
ffffffffea80af0c:	b81e8280 	stur	w0, [x20, #-24]
		}
		mutex_release(&ipc_lock);
ffffffffea80af10:	913722a0 	add	x0, x21, #0xdc8
	}
}
ffffffffea80af14:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80af18:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80af1c:	a8c37bfd 	ldp	x29, x30, [sp], #48
		mutex_release(&ipc_lock);
ffffffffea80af20:	17ffea9e 	b	ffffffffea805998 <mutex_release>
ffffffffea80af24:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80af28 <port_handle_destroy>:
{
ffffffffea80af28:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80af2c:	910003fd 	mov	x29, sp
	ASSERT(phandle);
ffffffffea80af30:	b4000120 	cbz	x0, ffffffffea80af54 <port_handle_destroy+0x2c>
	ASSERT(ipc_is_port(phandle));
ffffffffea80af34:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80af38:	d0000061 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea80af3c:	91380021 	add	x1, x1, #0xe00
ffffffffea80af40:	eb01005f 	cmp	x2, x1
ffffffffea80af44:	540001a1 	b.ne	ffffffffea80af78 <port_handle_destroy+0x50>  // b.any
}
ffffffffea80af48:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(port);
ffffffffea80af4c:	d1018000 	sub	x0, x0, #0x60
ffffffffea80af50:	14002052 	b	ffffffffea813098 <free>
	ASSERT(phandle);
ffffffffea80af54:	90000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80af58:	90000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80af5c:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80af60:	913f4084 	add	x4, x4, #0xfd0
ffffffffea80af64:	52801b83 	mov	w3, #0xdc                  	// #220
ffffffffea80af68:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80af6c:	91330021 	add	x1, x1, #0xcc0
ffffffffea80af70:	aa1e03e0 	mov	x0, x30
ffffffffea80af74:	94001aa5 	bl	ffffffffea811a08 <_panic>
	ASSERT(ipc_is_port(phandle));
ffffffffea80af78:	90000064 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80af7c:	90000062 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80af80:	f0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80af84:	913fe084 	add	x4, x4, #0xff8
ffffffffea80af88:	52801ba3 	mov	w3, #0xdd                  	// #221
ffffffffea80af8c:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80af90:	91330021 	add	x1, x1, #0xcc0
ffffffffea80af94:	aa1e03e0 	mov	x0, x30
ffffffffea80af98:	94001a9c 	bl	ffffffffea811a08 <_panic>
ffffffffea80af9c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80afa0 <chan_handle_destroy>:
{
ffffffffea80afa0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80afa4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80afa8:	910003fd 	mov	x29, sp
ffffffffea80afac:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80afb0:	aa0003f3 	mov	x19, x0
ffffffffea80afb4:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80afb8:	d0000074 	adrp	x20, ffffffffea818000 <_mem_phys_base>
ffffffffea80afbc:	aa1e03f6 	mov	x22, x30
ffffffffea80afc0:	91372280 	add	x0, x20, #0xdc8
ffffffffea80afc4:	97ffea49 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
ffffffffea80afc8:	d1014275 	sub	x21, x19, #0x50
	item->next->prev = item->prev;
ffffffffea80afcc:	a97f0261 	ldp	x1, x0, [x19, #-16]
ffffffffea80afd0:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80afd4:	f85f0261 	ldur	x1, [x19, #-16]
ffffffffea80afd8:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80afdc:	a93f7e7f 	stp	xzr, xzr, [x19, #-16]
	assert(list_in_list(&ref->ref_node));
	assert(destroy);

	list_delete(&ref->ref_node);
	dead = list_is_empty(&obj->ref_list);
	if (dead)
ffffffffea80afe0:	f85b8260 	ldur	x0, [x19, #-72]
ffffffffea80afe4:	eb0002bf 	cmp	x21, x0
ffffffffea80afe8:	540000c0 	b.eq	ffffffffea80b000 <chan_handle_destroy+0x60>  // b.none
	mutex_release(&ipc_lock);
ffffffffea80afec:	91372280 	add	x0, x20, #0xdc8
}
ffffffffea80aff0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80aff4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80aff8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&ipc_lock);
ffffffffea80affc:	17ffea67 	b	ffffffffea805998 <mutex_release>
	ASSERT(chan->peer == NULL);
ffffffffea80b000:	f85d0260 	ldur	x0, [x19, #-48]
ffffffffea80b004:	b5000380 	cbnz	x0, ffffffffea80b074 <chan_handle_destroy+0xd4>
	if (item->prev == 0 && item->next == 0)
ffffffffea80b008:	f94052a0 	ldr	x0, [x21, #160]
ffffffffea80b00c:	b4000140 	cbz	x0, ffffffffea80b034 <chan_handle_destroy+0x94>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b010:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b014:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b018:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b01c:	913de084 	add	x4, x4, #0xf78
ffffffffea80b020:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b024:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b028:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b02c:	aa1603e0 	mov	x0, x22
ffffffffea80b030:	94001a76 	bl	ffffffffea811a08 <_panic>
ffffffffea80b034:	f94056a0 	ldr	x0, [x21, #168]
ffffffffea80b038:	b5fffec0 	cbnz	x0, ffffffffea80b010 <chan_handle_destroy+0x70>
	if (chan->path) {
ffffffffea80b03c:	f9405ea0 	ldr	x0, [x21, #184]
ffffffffea80b040:	b4000040 	cbz	x0, ffffffffea80b048 <chan_handle_destroy+0xa8>
		free((void *)chan->path);
ffffffffea80b044:	94002015 	bl	ffffffffea813098 <free>
	if (chan->msg_queue) {
ffffffffea80b048:	f9405aa0 	ldr	x0, [x21, #176]
ffffffffea80b04c:	b4000060 	cbz	x0, ffffffffea80b058 <chan_handle_destroy+0xb8>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b050:	94000618 	bl	ffffffffea80c8b0 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b054:	f9005abf 	str	xzr, [x21, #176]
	free(chan);
ffffffffea80b058:	aa1503e0 	mov	x0, x21
ffffffffea80b05c:	9400200f 	bl	ffffffffea813098 <free>
	mutex_release(&ipc_lock);
ffffffffea80b060:	91372280 	add	x0, x20, #0xdc8
}
ffffffffea80b064:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b068:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80b06c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&ipc_lock);
ffffffffea80b070:	17ffea4a 	b	ffffffffea805998 <mutex_release>
	ASSERT(chan->peer == NULL);
ffffffffea80b074:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b078:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b07c:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b080:	913d8084 	add	x4, x4, #0xf60
ffffffffea80b084:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b088:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b08c:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b090:	aa1603e0 	mov	x0, x22
ffffffffea80b094:	94001a5d 	bl	ffffffffea811a08 <_panic>

ffffffffea80b098 <_chan_shutdown_locked>:
	switch (chan->state) {
ffffffffea80b098:	b9403001 	ldr	w1, [x0, #48]
ffffffffea80b09c:	71000c3f 	cmp	w1, #0x3
ffffffffea80b0a0:	54000188 	b.hi	ffffffffea80b0d0 <_chan_shutdown_locked+0x38>  // b.pmore
ffffffffea80b0a4:	7100083f 	cmp	w1, #0x2
ffffffffea80b0a8:	540000c2 	b.cs	ffffffffea80b0c0 <_chan_shutdown_locked+0x28>  // b.hs, b.nlast
ffffffffea80b0ac:	7100043f 	cmp	w1, #0x1
ffffffffea80b0b0:	54000581 	b.ne	ffffffffea80b160 <_chan_shutdown_locked+0xc8>  // b.any
		chan->state = IPC_CHAN_STATE_DISCONNECTING;
ffffffffea80b0b4:	52800081 	mov	w1, #0x4                   	// #4
ffffffffea80b0b8:	b9003001 	str	w1, [x0, #48]
ffffffffea80b0bc:	d65f03c0 	ret
		chan->state = IPC_CHAN_STATE_DISCONNECTING;
ffffffffea80b0c0:	52800081 	mov	w1, #0x4                   	// #4
ffffffffea80b0c4:	b9003001 	str	w1, [x0, #48]
		handle_notify(&chan->handle);
ffffffffea80b0c8:	91014000 	add	x0, x0, #0x50
ffffffffea80b0cc:	17fffc1b 	b	ffffffffea80a138 <handle_notify>
	switch (chan->state) {
ffffffffea80b0d0:	7100143f 	cmp	w1, #0x5
ffffffffea80b0d4:	54000481 	b.ne	ffffffffea80b164 <_chan_shutdown_locked+0xcc>  // b.any
{
ffffffffea80b0d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80b0dc:	910003fd 	mov	x29, sp
ffffffffea80b0e0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80b0e4:	aa0003f3 	mov	x19, x0
ffffffffea80b0e8:	a94a0001 	ldp	x1, x0, [x0, #160]
ffffffffea80b0ec:	b4000261 	cbz	x1, ffffffffea80b138 <_chan_shutdown_locked+0xa0>
	item->next->prev = item->prev;
ffffffffea80b0f0:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b0f4:	f9405262 	ldr	x2, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80b0f8:	f9404a61 	ldr	x1, [x19, #144]
	item->prev->next = item->next;
ffffffffea80b0fc:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80b100:	a90a7e7f 	stp	xzr, xzr, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80b104:	f9404e60 	ldr	x0, [x19, #152]
ffffffffea80b108:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b10c:	f9404a61 	ldr	x1, [x19, #144]
ffffffffea80b110:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b114:	a9097e7f 	stp	xzr, xzr, [x19, #144]
ffffffffea80b118:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80b11c:	eb00027f 	cmp	x19, x0
ffffffffea80b120:	54000240 	b.eq	ffffffffea80b168 <_chan_shutdown_locked+0xd0>  // b.none
		chan->state = IPC_CHAN_STATE_DISCONNECTING;
ffffffffea80b124:	52800080 	mov	w0, #0x4                   	// #4
ffffffffea80b128:	b9003260 	str	w0, [x19, #48]
}
ffffffffea80b12c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80b130:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80b134:	d65f03c0 	ret
	if (item->prev == 0 && item->next == 0)
ffffffffea80b138:	b5fffdc0 	cbnz	x0, ffffffffea80b0f0 <_chan_shutdown_locked+0x58>
		ASSERT(list_in_list(&chan->node));
ffffffffea80b13c:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b140:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b144:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b148:	913d0084 	add	x4, x4, #0xf40
ffffffffea80b14c:	52803b43 	mov	w3, #0x1da                 	// #474
ffffffffea80b150:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b154:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b158:	aa1e03e0 	mov	x0, x30
ffffffffea80b15c:	94001a2b 	bl	ffffffffea811a08 <_panic>
ffffffffea80b160:	d65f03c0 	ret
ffffffffea80b164:	d65f03c0 	ret
	ASSERT(chan->peer == NULL);
ffffffffea80b168:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80b16c:	b5000300 	cbnz	x0, ffffffffea80b1cc <_chan_shutdown_locked+0x134>
ffffffffea80b170:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80b174:	b4000140 	cbz	x0, ffffffffea80b19c <_chan_shutdown_locked+0x104>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b178:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b17c:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b180:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b184:	913de084 	add	x4, x4, #0xf78
ffffffffea80b188:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b18c:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b190:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b194:	aa1e03e0 	mov	x0, x30
ffffffffea80b198:	94001a1c 	bl	ffffffffea811a08 <_panic>
ffffffffea80b19c:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80b1a0:	b5fffec0 	cbnz	x0, ffffffffea80b178 <_chan_shutdown_locked+0xe0>
	if (chan->path) {
ffffffffea80b1a4:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80b1a8:	b4000040 	cbz	x0, ffffffffea80b1b0 <_chan_shutdown_locked+0x118>
		free((void *)chan->path);
ffffffffea80b1ac:	94001fbb 	bl	ffffffffea813098 <free>
	if (chan->msg_queue) {
ffffffffea80b1b0:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80b1b4:	b4000060 	cbz	x0, ffffffffea80b1c0 <_chan_shutdown_locked+0x128>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b1b8:	940005be 	bl	ffffffffea80c8b0 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b1bc:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80b1c0:	aa1303e0 	mov	x0, x19
ffffffffea80b1c4:	94001fb5 	bl	ffffffffea813098 <free>
ffffffffea80b1c8:	17ffffd7 	b	ffffffffea80b124 <_chan_shutdown_locked+0x8c>
	ASSERT(chan->peer == NULL);
ffffffffea80b1cc:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b1d0:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b1d4:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b1d8:	913d8084 	add	x4, x4, #0xf60
ffffffffea80b1dc:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b1e0:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b1e4:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b1e8:	aa1e03e0 	mov	x0, x30
ffffffffea80b1ec:	94001a07 	bl	ffffffffea811a08 <_panic>

ffffffffea80b1f0 <chan_shutdown_locked>:
{
ffffffffea80b1f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80b1f4:	910003fd 	mov	x29, sp
ffffffffea80b1f8:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80b1fc:	aa0003f3 	mov	x19, x0
ffffffffea80b200:	f90013f5 	str	x21, [sp, #32]
ffffffffea80b204:	aa1e03f5 	mov	x21, x30
	_chan_shutdown_locked(chan);
ffffffffea80b208:	97ffffa4 	bl	ffffffffea80b098 <_chan_shutdown_locked>
	if (chan->peer) {
ffffffffea80b20c:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80b210:	b40001c0 	cbz	x0, ffffffffea80b248 <chan_shutdown_locked+0x58>
ffffffffea80b214:	f9000fb4 	str	x20, [x29, #24]
		_chan_shutdown_locked(chan->peer);
ffffffffea80b218:	97ffffa0 	bl	ffffffffea80b098 <_chan_shutdown_locked>
	item->next->prev = item->prev;
ffffffffea80b21c:	a9410261 	ldp	x1, x0, [x19, #16]
		chan_del_ref(chan->peer, &chan->peer_ref);
ffffffffea80b220:	f9401274 	ldr	x20, [x19, #32]
ffffffffea80b224:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b228:	f9400a61 	ldr	x1, [x19, #16]
ffffffffea80b22c:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b230:	a9017e7f 	stp	xzr, xzr, [x19, #16]
ffffffffea80b234:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80b238:	eb00029f 	cmp	x20, x0
ffffffffea80b23c:	540000e0 	b.eq	ffffffffea80b258 <chan_shutdown_locked+0x68>  // b.none
		chan->peer = NULL;
ffffffffea80b240:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80b244:	f900127f 	str	xzr, [x19, #32]
}
ffffffffea80b248:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80b24c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80b250:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b254:	d65f03c0 	ret
	ASSERT(chan->peer == NULL);
ffffffffea80b258:	f9401280 	ldr	x0, [x20, #32]
ffffffffea80b25c:	b5000300 	cbnz	x0, ffffffffea80b2bc <chan_shutdown_locked+0xcc>
	if (item->prev == 0 && item->next == 0)
ffffffffea80b260:	f9405280 	ldr	x0, [x20, #160]
ffffffffea80b264:	b4000140 	cbz	x0, ffffffffea80b28c <chan_shutdown_locked+0x9c>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b268:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b26c:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b270:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b274:	913de084 	add	x4, x4, #0xf78
ffffffffea80b278:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b27c:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b280:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b284:	aa1503e0 	mov	x0, x21
ffffffffea80b288:	940019e0 	bl	ffffffffea811a08 <_panic>
ffffffffea80b28c:	f9405680 	ldr	x0, [x20, #168]
ffffffffea80b290:	b5fffec0 	cbnz	x0, ffffffffea80b268 <chan_shutdown_locked+0x78>
	if (chan->path) {
ffffffffea80b294:	f9405e80 	ldr	x0, [x20, #184]
ffffffffea80b298:	b4000040 	cbz	x0, ffffffffea80b2a0 <chan_shutdown_locked+0xb0>
		free((void *)chan->path);
ffffffffea80b29c:	94001f7f 	bl	ffffffffea813098 <free>
	if (chan->msg_queue) {
ffffffffea80b2a0:	f9405a80 	ldr	x0, [x20, #176]
ffffffffea80b2a4:	b4000060 	cbz	x0, ffffffffea80b2b0 <chan_shutdown_locked+0xc0>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b2a8:	94000582 	bl	ffffffffea80c8b0 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b2ac:	f9005a9f 	str	xzr, [x20, #176]
	free(chan);
ffffffffea80b2b0:	aa1403e0 	mov	x0, x20
ffffffffea80b2b4:	94001f79 	bl	ffffffffea813098 <free>
ffffffffea80b2b8:	17ffffe2 	b	ffffffffea80b240 <chan_shutdown_locked+0x50>
	ASSERT(chan->peer == NULL);
ffffffffea80b2bc:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b2c0:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b2c4:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b2c8:	913d8084 	add	x4, x4, #0xf60
ffffffffea80b2cc:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b2d0:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b2d4:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b2d8:	aa1503e0 	mov	x0, x21
ffffffffea80b2dc:	940019cb 	bl	ffffffffea811a08 <_panic>

ffffffffea80b2e0 <chan_shutdown>:
{
ffffffffea80b2e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80b2e4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b2e8:	910003fd 	mov	x29, sp
ffffffffea80b2ec:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b2f0:	b0000073 	adrp	x19, ffffffffea818000 <_mem_phys_base>
ffffffffea80b2f4:	91372273 	add	x19, x19, #0xdc8
ffffffffea80b2f8:	aa0003f4 	mov	x20, x0
ffffffffea80b2fc:	aa1303e0 	mov	x0, x19
ffffffffea80b300:	97ffe97a 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	chan_shutdown_locked(chan);
ffffffffea80b304:	d1014280 	sub	x0, x20, #0x50
ffffffffea80b308:	97ffffba 	bl	ffffffffea80b1f0 <chan_shutdown_locked>
	mutex_release(&ipc_lock);
ffffffffea80b30c:	aa1303e0 	mov	x0, x19
}
ffffffffea80b310:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b314:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_release(&ipc_lock);
ffffffffea80b318:	17ffe9a0 	b	ffffffffea805998 <mutex_release>
ffffffffea80b31c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b320 <port_shutdown>:
{
ffffffffea80b320:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80b324:	910003fd 	mov	x29, sp
ffffffffea80b328:	f9001ff8 	str	x24, [sp, #56]
ffffffffea80b32c:	aa1e03f8 	mov	x24, x30
	ASSERT(phandle);
ffffffffea80b330:	b4000b80 	cbz	x0, ffffffffea80b4a0 <port_shutdown+0x180>
ffffffffea80b334:	f90017b6 	str	x22, [x29, #40]
ffffffffea80b338:	aa0003f6 	mov	x22, x0
	ASSERT(ipc_is_port(phandle));
ffffffffea80b33c:	b0000060 	adrp	x0, ffffffffea818000 <_mem_phys_base>
ffffffffea80b340:	91380000 	add	x0, x0, #0xe00
ffffffffea80b344:	f94006c1 	ldr	x1, [x22, #8]
ffffffffea80b348:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80b34c:	f90013b5 	str	x21, [x29, #32]
ffffffffea80b350:	eb00003f 	cmp	x1, x0
ffffffffea80b354:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80b358:	54000bc1 	b.ne	ffffffffea80b4d0 <port_shutdown+0x1b0>  // b.any
	ipc_port_t *port = containerof(phandle, ipc_port_t, handle);
ffffffffea80b35c:	d10182d5 	sub	x21, x22, #0x60
ffffffffea80b360:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b364:	b0000077 	adrp	x23, ffffffffea818000 <_mem_phys_base>
ffffffffea80b368:	913722e0 	add	x0, x23, #0xdc8
ffffffffea80b36c:	97ffe95f 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
ffffffffea80b370:	f9405aa0 	ldr	x0, [x21, #176]
	port->state = IPC_PORT_STATE_CLOSING;
ffffffffea80b374:	52800041 	mov	w1, #0x2                   	// #2
ffffffffea80b378:	b81e82c1 	stur	w1, [x22, #-24]
ffffffffea80b37c:	f9405ea1 	ldr	x1, [x21, #184]
ffffffffea80b380:	b4000740 	cbz	x0, ffffffffea80b468 <port_shutdown+0x148>
	item->next->prev = item->prev;
ffffffffea80b384:	f9000020 	str	x0, [x1]
		handle_decref(phandle);
ffffffffea80b388:	aa1603e0 	mov	x0, x22
	item->prev->next = item->next;
ffffffffea80b38c:	f9405aa2 	ldr	x2, [x21, #176]
ffffffffea80b390:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80b394:	a90b7ebf 	stp	xzr, xzr, [x21, #176]
ffffffffea80b398:	97fffafc 	bl	ffffffffea809f88 <handle_decref>
	list_for_every_entry_safe(&port->pending_list, server, temp, ipc_chan_t, node) {
ffffffffea80b39c:	f94056b3 	ldr	x19, [x21, #168]
ffffffffea80b3a0:	d1028273 	sub	x19, x19, #0xa0
ffffffffea80b3a4:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80b3a8:	eb1302bf 	cmp	x21, x19
ffffffffea80b3ac:	d1028014 	sub	x20, x0, #0xa0
ffffffffea80b3b0:	54000141 	b.ne	ffffffffea80b3d8 <port_shutdown+0xb8>  // b.any
ffffffffea80b3b4:	14000026 	b	ffffffffea80b44c <port_shutdown+0x12c>
		handle_decref(phandle);
ffffffffea80b3b8:	aa1603e0 	mov	x0, x22
ffffffffea80b3bc:	97fffaf3 	bl	ffffffffea809f88 <handle_decref>
	list_for_every_entry_safe(&port->pending_list, server, temp, ipc_chan_t, node) {
ffffffffea80b3c0:	f9405680 	ldr	x0, [x20, #168]
ffffffffea80b3c4:	aa1403f3 	mov	x19, x20
ffffffffea80b3c8:	eb15029f 	cmp	x20, x21
ffffffffea80b3cc:	d1028000 	sub	x0, x0, #0xa0
ffffffffea80b3d0:	540003e0 	b.eq	ffffffffea80b44c <port_shutdown+0x12c>  // b.none
ffffffffea80b3d4:	aa0003f4 	mov	x20, x0
		chan_shutdown_locked(server);
ffffffffea80b3d8:	aa1303e0 	mov	x0, x19
ffffffffea80b3dc:	97ffff85 	bl	ffffffffea80b1f0 <chan_shutdown_locked>
	item->next->prev = item->prev;
ffffffffea80b3e0:	a94a0261 	ldp	x1, x0, [x19, #160]
ffffffffea80b3e4:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b3e8:	f9405262 	ldr	x2, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80b3ec:	f9404a61 	ldr	x1, [x19, #144]
	item->prev->next = item->next;
ffffffffea80b3f0:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80b3f4:	a90a7e7f 	stp	xzr, xzr, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80b3f8:	f9404e60 	ldr	x0, [x19, #152]
ffffffffea80b3fc:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b400:	f9404a61 	ldr	x1, [x19, #144]
ffffffffea80b404:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b408:	a9097e7f 	stp	xzr, xzr, [x19, #144]
ffffffffea80b40c:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80b410:	eb00027f 	cmp	x19, x0
ffffffffea80b414:	54fffd21 	b.ne	ffffffffea80b3b8 <port_shutdown+0x98>  // b.any
	ASSERT(chan->peer == NULL);
ffffffffea80b418:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80b41c:	b50006c0 	cbnz	x0, ffffffffea80b4f4 <port_shutdown+0x1d4>
	if (item->prev == 0 && item->next == 0)
ffffffffea80b420:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80b424:	b4000260 	cbz	x0, ffffffffea80b470 <port_shutdown+0x150>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b428:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b42c:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b430:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b434:	913de084 	add	x4, x4, #0xf78
ffffffffea80b438:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b43c:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b440:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b444:	aa1803e0 	mov	x0, x24
ffffffffea80b448:	94001970 	bl	ffffffffea811a08 <_panic>
	mutex_release(&ipc_lock);
ffffffffea80b44c:	913722e0 	add	x0, x23, #0xdc8
}
ffffffffea80b450:	f9401ff8 	ldr	x24, [sp, #56]
	mutex_release(&ipc_lock);
ffffffffea80b454:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80b458:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80b45c:	f9401bb7 	ldr	x23, [x29, #48]
}
ffffffffea80b460:	a8c47bfd 	ldp	x29, x30, [sp], #64
	mutex_release(&ipc_lock);
ffffffffea80b464:	17ffe94d 	b	ffffffffea805998 <mutex_release>
ffffffffea80b468:	b5fff8e1 	cbnz	x1, ffffffffea80b384 <port_shutdown+0x64>
ffffffffea80b46c:	17ffffcc 	b	ffffffffea80b39c <port_shutdown+0x7c>
ffffffffea80b470:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80b474:	b5fffda0 	cbnz	x0, ffffffffea80b428 <port_shutdown+0x108>
	if (chan->path) {
ffffffffea80b478:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80b47c:	b4000040 	cbz	x0, ffffffffea80b484 <port_shutdown+0x164>
		free((void *)chan->path);
ffffffffea80b480:	94001f06 	bl	ffffffffea813098 <free>
	if (chan->msg_queue) {
ffffffffea80b484:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80b488:	b4000060 	cbz	x0, ffffffffea80b494 <port_shutdown+0x174>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b48c:	94000509 	bl	ffffffffea80c8b0 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b490:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80b494:	aa1303e0 	mov	x0, x19
ffffffffea80b498:	94001f00 	bl	ffffffffea813098 <free>
ffffffffea80b49c:	17ffffc7 	b	ffffffffea80b3b8 <port_shutdown+0x98>
	ASSERT(phandle);
ffffffffea80b4a0:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b4a4:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b4a8:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b4ac:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80b4b0:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80b4b4:	913f4084 	add	x4, x4, #0xfd0
ffffffffea80b4b8:	528015a3 	mov	w3, #0xad                  	// #173
ffffffffea80b4bc:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b4c0:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b4c4:	aa1e03e0 	mov	x0, x30
ffffffffea80b4c8:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80b4cc:	9400194f 	bl	ffffffffea811a08 <_panic>
	ASSERT(ipc_is_port(phandle));
ffffffffea80b4d0:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b4d4:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b4d8:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b4dc:	913fe084 	add	x4, x4, #0xff8
ffffffffea80b4e0:	528015c3 	mov	w3, #0xae                  	// #174
ffffffffea80b4e4:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b4e8:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b4ec:	aa1e03e0 	mov	x0, x30
ffffffffea80b4f0:	94001946 	bl	ffffffffea811a08 <_panic>
	ASSERT(chan->peer == NULL);
ffffffffea80b4f4:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b4f8:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b4fc:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b500:	913d8084 	add	x4, x4, #0xf60
ffffffffea80b504:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b508:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b50c:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b510:	aa1803e0 	mov	x0, x24
ffffffffea80b514:	9400193d 	bl	ffffffffea811a08 <_panic>

ffffffffea80b518 <port_attach_client>:

	return ERR_ACCESS_DENIED;
}

static int port_attach_client(ipc_port_t *port, ipc_chan_t *client)
{
ffffffffea80b518:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80b51c:	910003fd 	mov	x29, sp
	int ret;
	ipc_chan_t *server;
	obj_ref_t   tmp_server_ref = OBJ_REF_INITIAL_VALUE(tmp_server_ref);

	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80b520:	b9404802 	ldr	w2, [x0, #72]
{
ffffffffea80b524:	f9001bf7 	str	x23, [sp, #48]
	obj_ref_t   tmp_server_ref = OBJ_REF_INITIAL_VALUE(tmp_server_ref);
ffffffffea80b528:	a9047fbf 	stp	xzr, xzr, [x29, #64]
	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80b52c:	7100045f 	cmp	w2, #0x1
ffffffffea80b530:	54000ca1 	b.ne	ffffffffea80b6c4 <port_attach_client+0x1ac>  // b.any
ffffffffea80b534:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80b538:	aa0003f3 	mov	x19, x0
			 port->path, port->state);
		return ERR_NOT_READY;
	}

	/* check if we are allowed to connect */
	ret = check_access(port, client->uuid);
ffffffffea80b53c:	f9401420 	ldr	x0, [x1, #40]
	if (!uuid) {
ffffffffea80b540:	b4000500 	cbz	x0, ffffffffea80b5e0 <port_attach_client+0xc8>
ffffffffea80b544:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80b548:	aa0103f4 	mov	x20, x1
ffffffffea80b54c:	f90017b6 	str	x22, [x29, #40]
ffffffffea80b550:	aa1e03f6 	mov	x22, x30
	if (is_ns_client(uuid)) {
ffffffffea80b554:	9400132d 	bl	ffffffffea810208 <is_ns_client>
ffffffffea80b558:	72001c1f 	tst	w0, #0xff
		if (port->flags & IPC_PORT_ALLOW_NS_CONNECT) {
ffffffffea80b55c:	b9404e60 	ldr	w0, [x19, #76]
	if (is_ns_client(uuid)) {
ffffffffea80b560:	540003a1 	b.ne	ffffffffea80b5d4 <port_attach_client+0xbc>  // b.any
		if (port->flags & IPC_PORT_ALLOW_TA_CONNECT) {
ffffffffea80b564:	360003a0 	tbz	w0, #0, ffffffffea80b5d8 <port_attach_client+0xc0>
	if (ret != NO_ERROR) {
		LTRACEF("access denied: %d\n", ret);
		return ret;
	}

	server = chan_alloc(IPC_CHAN_FLAG_SERVER, port->uuid, &tmp_server_ref);
ffffffffea80b568:	f9402261 	ldr	x1, [x19, #64]
ffffffffea80b56c:	910103a2 	add	x2, x29, #0x40
ffffffffea80b570:	f90013b5 	str	x21, [x29, #32]
ffffffffea80b574:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80b578:	97fffe18 	bl	ffffffffea80add8 <chan_alloc>
ffffffffea80b57c:	aa0003f5 	mov	x21, x0
	if (!server) {
ffffffffea80b580:	b40001c0 	cbz	x0, ffffffffea80b5b8 <port_attach_client+0xa0>
		LTRACEF("failed to alloc server: %d\n", ret);
		return ERR_NO_MEMORY;
	}

	/* allocate msg queues */
	ret = ipc_msg_queue_create(port->num_recv_bufs,
ffffffffea80b584:	b9405260 	ldr	w0, [x19, #80]
ffffffffea80b588:	9102c282 	add	x2, x20, #0xb0
ffffffffea80b58c:	f9402e61 	ldr	x1, [x19, #88]
ffffffffea80b590:	94000484 	bl	ffffffffea80c7a0 <ipc_msg_queue_create>
				   port->recv_buf_size,
				   &client->msg_queue);
	if (ret != NO_ERROR) {
ffffffffea80b594:	340002c0 	cbz	w0, ffffffffea80b5ec <port_attach_client+0xd4>
	item->next->prev = item->prev;
ffffffffea80b598:	a94403a1 	ldp	x1, x0, [x29, #64]
ffffffffea80b59c:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b5a0:	f94023a1 	ldr	x1, [x29, #64]
ffffffffea80b5a4:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b5a8:	a9047fbf 	stp	xzr, xzr, [x29, #64]
	return (list->next == list) ? true : false;
ffffffffea80b5ac:	f94006b3 	ldr	x19, [x21, #8]
ffffffffea80b5b0:	eb15027f 	cmp	x19, x21
ffffffffea80b5b4:	54000b00 	b.eq	ffffffffea80b714 <port_attach_client+0x1fc>  // b.none
ffffffffea80b5b8:	a94153b3 	ldp	x19, x20, [x29, #16]
		return ERR_NO_MEMORY;
ffffffffea80b5bc:	12800097 	mov	w23, #0xfffffffb            	// #-5
ffffffffea80b5c0:	a9425bb5 	ldp	x21, x22, [x29, #32]
	ipc_msg_queue_destroy(client->msg_queue);
	client->msg_queue = NULL;
err_client_mq:
	chan_del_ref(server, &tmp_server_ref);
	return ERR_NO_MEMORY;
}
ffffffffea80b5c4:	2a1703e0 	mov	w0, w23
ffffffffea80b5c8:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80b5cc:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80b5d0:	d65f03c0 	ret
		if (port->flags & IPC_PORT_ALLOW_NS_CONNECT) {
ffffffffea80b5d4:	370ffca0 	tbnz	w0, #1, ffffffffea80b568 <port_attach_client+0x50>
ffffffffea80b5d8:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80b5dc:	f94017b6 	ldr	x22, [x29, #40]
		return ERR_ACCESS_DENIED;
ffffffffea80b5e0:	12800557 	mov	w23, #0xffffffd5            	// #-43
ffffffffea80b5e4:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80b5e8:	17fffff7 	b	ffffffffea80b5c4 <port_attach_client+0xac>
	ret = ipc_msg_queue_create(port->num_recv_bufs,
ffffffffea80b5ec:	b9405260 	ldr	w0, [x19, #80]
ffffffffea80b5f0:	9102c2a2 	add	x2, x21, #0xb0
ffffffffea80b5f4:	f9402e61 	ldr	x1, [x19, #88]
ffffffffea80b5f8:	9400046a 	bl	ffffffffea80c7a0 <ipc_msg_queue_create>
ffffffffea80b5fc:	2a0003f7 	mov	w23, w0
	if (ret != NO_ERROR) {
ffffffffea80b600:	35000660 	cbnz	w0, ffffffffea80b6cc <port_attach_client+0x1b4>
	item->prev = list->prev;
ffffffffea80b604:	f94002a1 	ldr	x1, [x21]
	server->state = IPC_CHAN_STATE_ACCEPTING;
ffffffffea80b608:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80b60c:	f9001fb8 	str	x24, [x29, #56]
	list_add_tail(&obj->ref_list, &ref->ref_node);
ffffffffea80b610:	91004285 	add	x5, x20, #0x10
ffffffffea80b614:	b90032a0 	str	w0, [x21, #48]
	client->state = IPC_CHAN_STATE_CONNECTING;
ffffffffea80b618:	52800040 	mov	w0, #0x2                   	// #2
	item->next = list;
ffffffffea80b61c:	a9015681 	stp	x1, x21, [x20, #16]
ffffffffea80b620:	910042a4 	add	x4, x21, #0x10
ffffffffea80b624:	b9003280 	str	w0, [x20, #48]
	list->prev = item;
ffffffffea80b628:	aa1503e1 	mov	x1, x21
	list->prev->next = item;
ffffffffea80b62c:	f94002a0 	ldr	x0, [x21]
ffffffffea80b630:	910242a3 	add	x3, x21, #0x90
	item->prev = list->prev;
ffffffffea80b634:	aa1303e2 	mov	x2, x19
	handle_incref(&port->handle);
ffffffffea80b638:	91018278 	add	x24, x19, #0x60
	list->prev->next = item;
ffffffffea80b63c:	f9000405 	str	x5, [x0, #8]
ffffffffea80b640:	aa1803e0 	mov	x0, x24
	list->prev = item;
ffffffffea80b644:	f90002a5 	str	x5, [x21]
	client->peer = server;
ffffffffea80b648:	f9001295 	str	x21, [x20, #32]
	item->prev = list->prev;
ffffffffea80b64c:	f9400285 	ldr	x5, [x20]
	item->next = list;
ffffffffea80b650:	a90152a5 	stp	x5, x20, [x21, #16]
	list->prev->next = item;
ffffffffea80b654:	f9400285 	ldr	x5, [x20]
ffffffffea80b658:	f90004a4 	str	x4, [x5, #8]
	list->prev = item;
ffffffffea80b65c:	f9000284 	str	x4, [x20]
	server->peer = client;
ffffffffea80b660:	f90012b4 	str	x20, [x21, #32]
	item->prev = list->prev;
ffffffffea80b664:	f94002a4 	ldr	x4, [x21]
	item->next = list;
ffffffffea80b668:	a90956a4 	stp	x4, x21, [x21, #144]
	list->prev->next = item;
ffffffffea80b66c:	f9000483 	str	x3, [x4, #8]
	list->prev = item;
ffffffffea80b670:	f80a0423 	str	x3, [x1], #160
	item->prev = list->prev;
ffffffffea80b674:	f84a0c43 	ldr	x3, [x2, #160]!
	item->next = list;
ffffffffea80b678:	a90a0aa3 	stp	x3, x2, [x21, #160]
	list->prev->next = item;
ffffffffea80b67c:	f9405262 	ldr	x2, [x19, #160]
ffffffffea80b680:	f9000441 	str	x1, [x2, #8]
	list->prev = item;
ffffffffea80b684:	f9005261 	str	x1, [x19, #160]
	handle_incref(&port->handle);
ffffffffea80b688:	97fffa3a 	bl	ffffffffea809f70 <handle_incref>
	handle_notify(&port->handle);
ffffffffea80b68c:	aa1803e0 	mov	x0, x24
ffffffffea80b690:	97fffaaa 	bl	ffffffffea80a138 <handle_notify>
	item->next->prev = item->prev;
ffffffffea80b694:	a94403a1 	ldp	x1, x0, [x29, #64]
ffffffffea80b698:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b69c:	f94023a1 	ldr	x1, [x29, #64]
ffffffffea80b6a0:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b6a4:	a9047fbf 	stp	xzr, xzr, [x29, #64]
	if (dead)
ffffffffea80b6a8:	f94006a0 	ldr	x0, [x21, #8]
ffffffffea80b6ac:	eb15001f 	cmp	x0, x21
ffffffffea80b6b0:	54000160 	b.eq	ffffffffea80b6dc <port_attach_client+0x1c4>  // b.none
ffffffffea80b6b4:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80b6b8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80b6bc:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80b6c0:	17ffffc1 	b	ffffffffea80b5c4 <port_attach_client+0xac>
		return ERR_NOT_READY;
ffffffffea80b6c4:	12800057 	mov	w23, #0xfffffffd            	// #-3
ffffffffea80b6c8:	17ffffbf 	b	ffffffffea80b5c4 <port_attach_client+0xac>
	ipc_msg_queue_destroy(client->msg_queue);
ffffffffea80b6cc:	f9405a80 	ldr	x0, [x20, #176]
ffffffffea80b6d0:	94000478 	bl	ffffffffea80c8b0 <ipc_msg_queue_destroy>
	client->msg_queue = NULL;
ffffffffea80b6d4:	f9005a9f 	str	xzr, [x20, #176]
ffffffffea80b6d8:	17ffffb0 	b	ffffffffea80b598 <port_attach_client+0x80>
	ASSERT(chan->peer == NULL);
ffffffffea80b6dc:	f9401000 	ldr	x0, [x0, #32]
ffffffffea80b6e0:	b5000460 	cbnz	x0, ffffffffea80b76c <port_attach_client+0x254>
	if (item->prev == 0 && item->next == 0)
ffffffffea80b6e4:	f94052a0 	ldr	x0, [x21, #160]
ffffffffea80b6e8:	b4000540 	cbz	x0, ffffffffea80b790 <port_attach_client+0x278>
ffffffffea80b6ec:	d503201f 	nop
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b6f0:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b6f4:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b6f8:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b6fc:	913de084 	add	x4, x4, #0xf78
ffffffffea80b700:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b704:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b708:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b70c:	aa1603e0 	mov	x0, x22
ffffffffea80b710:	940018be 	bl	ffffffffea811a08 <_panic>
	ASSERT(chan->peer == NULL);
ffffffffea80b714:	f94012a0 	ldr	x0, [x21, #32]
ffffffffea80b718:	b5000280 	cbnz	x0, ffffffffea80b768 <port_attach_client+0x250>
ffffffffea80b71c:	f94052a0 	ldr	x0, [x21, #160]
ffffffffea80b720:	b4000060 	cbz	x0, ffffffffea80b72c <port_attach_client+0x214>
ffffffffea80b724:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80b728:	17fffff2 	b	ffffffffea80b6f0 <port_attach_client+0x1d8>
ffffffffea80b72c:	f94056a0 	ldr	x0, [x21, #168]
ffffffffea80b730:	b5ffffa0 	cbnz	x0, ffffffffea80b724 <port_attach_client+0x20c>
	if (chan->path) {
ffffffffea80b734:	f9405ea0 	ldr	x0, [x21, #184]
ffffffffea80b738:	b4000040 	cbz	x0, ffffffffea80b740 <port_attach_client+0x228>
		free((void *)chan->path);
ffffffffea80b73c:	94001e57 	bl	ffffffffea813098 <free>
	if (chan->msg_queue) {
ffffffffea80b740:	f9405aa0 	ldr	x0, [x21, #176]
ffffffffea80b744:	b4000060 	cbz	x0, ffffffffea80b750 <port_attach_client+0x238>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b748:	9400045a 	bl	ffffffffea80c8b0 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b74c:	f9005abf 	str	xzr, [x21, #176]
	free(chan);
ffffffffea80b750:	aa1303e0 	mov	x0, x19
	return ERR_NO_MEMORY;
ffffffffea80b754:	12800097 	mov	w23, #0xfffffffb            	// #-5
	free(chan);
ffffffffea80b758:	94001e50 	bl	ffffffffea813098 <free>
ffffffffea80b75c:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80b760:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80b764:	17ffff98 	b	ffffffffea80b5c4 <port_attach_client+0xac>
ffffffffea80b768:	f9001fb8 	str	x24, [x29, #56]
	ASSERT(chan->peer == NULL);
ffffffffea80b76c:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b770:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b774:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80b778:	913d8084 	add	x4, x4, #0xf60
ffffffffea80b77c:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b780:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80b784:	91330021 	add	x1, x1, #0xcc0
ffffffffea80b788:	aa1603e0 	mov	x0, x22
ffffffffea80b78c:	9400189f 	bl	ffffffffea811a08 <_panic>
ffffffffea80b790:	f94056a0 	ldr	x0, [x21, #168]
ffffffffea80b794:	b5fffae0 	cbnz	x0, ffffffffea80b6f0 <port_attach_client+0x1d8>
	if (chan->path) {
ffffffffea80b798:	f9405ea0 	ldr	x0, [x21, #184]
ffffffffea80b79c:	b4000040 	cbz	x0, ffffffffea80b7a4 <port_attach_client+0x28c>
		free((void *)chan->path);
ffffffffea80b7a0:	94001e3e 	bl	ffffffffea813098 <free>
	if (chan->msg_queue) {
ffffffffea80b7a4:	f9405aa0 	ldr	x0, [x21, #176]
ffffffffea80b7a8:	b4000060 	cbz	x0, ffffffffea80b7b4 <port_attach_client+0x29c>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b7ac:	94000441 	bl	ffffffffea80c8b0 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b7b0:	f9005abf 	str	xzr, [x21, #176]
	free(chan);
ffffffffea80b7b4:	aa1503e0 	mov	x0, x21
ffffffffea80b7b8:	94001e38 	bl	ffffffffea813098 <free>
ffffffffea80b7bc:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80b7c0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80b7c4:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80b7c8:	17ffff7f 	b	ffffffffea80b5c4 <port_attach_client+0xac>
ffffffffea80b7cc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b7d0 <ipc_is_channel>:
	return likely(handle->ops == &ipc_chan_handle_ops);
ffffffffea80b7d0:	f9400401 	ldr	x1, [x0, #8]
ffffffffea80b7d4:	b0000060 	adrp	x0, ffffffffea818000 <_mem_phys_base>
ffffffffea80b7d8:	9136a000 	add	x0, x0, #0xda8
ffffffffea80b7dc:	eb00003f 	cmp	x1, x0
}
ffffffffea80b7e0:	1a9f17e0 	cset	w0, eq  // eq = none
ffffffffea80b7e4:	d65f03c0 	ret

ffffffffea80b7e8 <ipc_port_create>:
{
ffffffffea80b7e8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80b7ec:	910003fd 	mov	x29, sp
ffffffffea80b7f0:	f9000ff4 	str	x20, [sp, #24]
	if (!sid) {
ffffffffea80b7f4:	b40007e0 	cbz	x0, ffffffffea80b8f0 <ipc_port_create+0x108>
	if (!num_recv_bufs || num_recv_bufs > IPC_CHAN_MAX_BUFS ||
ffffffffea80b7f8:	51000446 	sub	w6, w2, #0x1
ffffffffea80b7fc:	71007cdf 	cmp	w6, #0x1f
ffffffffea80b800:	54000788 	b.hi	ffffffffea80b8f0 <ipc_port_create+0x108>  // b.pmore
	    !recv_buf_size || recv_buf_size > IPC_CHAN_MAX_BUF_SIZE) {
ffffffffea80b804:	d1000466 	sub	x6, x3, #0x1
ffffffffea80b808:	f13ffcdf 	cmp	x6, #0xfff
ffffffffea80b80c:	54000728 	b.hi	ffffffffea80b8f0 <ipc_port_create+0x108>  // b.pmore
ffffffffea80b810:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80b814:	aa0103f4 	mov	x20, x1
ffffffffea80b818:	a9025bb5 	stp	x21, x22, [x29, #32]
	new_port = calloc(1, sizeof(ipc_port_t));
ffffffffea80b81c:	d2801801 	mov	x1, #0xc0                  	// #192
ffffffffea80b820:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80b824:	2a0203f6 	mov	w22, w2
ffffffffea80b828:	f90023b9 	str	x25, [x29, #64]
ffffffffea80b82c:	aa0503f7 	mov	x23, x5
ffffffffea80b830:	2a0403f8 	mov	w24, w4
ffffffffea80b834:	aa0003f5 	mov	x21, x0
ffffffffea80b838:	aa0303f9 	mov	x25, x3
ffffffffea80b83c:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80b840:	94001e06 	bl	ffffffffea813058 <calloc>
ffffffffea80b844:	aa0003f3 	mov	x19, x0
	if (!new_port) {
ffffffffea80b848:	b4000580 	cbz	x0, ffffffffea80b8f8 <ipc_port_create+0x110>
	ret = strlcpy(new_port->path, path, sizeof(new_port->path));
ffffffffea80b84c:	d2800802 	mov	x2, #0x40                  	// #64
ffffffffea80b850:	aa1403e1 	mov	x1, x20
ffffffffea80b854:	94001f11 	bl	ffffffffea813498 <strlcpy>
	if (ret == 0) {
ffffffffea80b858:	340001c0 	cbz	w0, ffffffffea80b890 <ipc_port_create+0xa8>
		ret = ERR_TOO_BIG;
ffffffffea80b85c:	12800314 	mov	w20, #0xffffffe7            	// #-25
	if ((uint) ret >= sizeof(new_port->path)) {
ffffffffea80b860:	7100fc1f 	cmp	w0, #0x3f
ffffffffea80b864:	540001a9 	b.ls	ffffffffea80b898 <ipc_port_create+0xb0>  // b.plast
	free(new_port);
ffffffffea80b868:	aa1303e0 	mov	x0, x19
ffffffffea80b86c:	94001e0b 	bl	ffffffffea813098 <free>
	return ret;
ffffffffea80b870:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80b874:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80b878:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80b87c:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea80b880:	2a1403e0 	mov	w0, w20
ffffffffea80b884:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80b888:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80b88c:	d65f03c0 	ret
		ret = ERR_INVALID_ARGS;
ffffffffea80b890:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80b894:	17fffff5 	b	ffffffffea80b868 <ipc_port_create+0x80>
ffffffffea80b898:	f90027ba 	str	x26, [x29, #72]
	list_initialize(&new_port->pending_list);
ffffffffea80b89c:	91028260 	add	x0, x19, #0xa0
	handle_init(&new_port->handle, &ipc_port_handle_ops);
ffffffffea80b8a0:	9101827a 	add	x26, x19, #0x60
	new_port->uuid = sid;
ffffffffea80b8a4:	f9002275 	str	x21, [x19, #64]
	new_port->flags = flags;
ffffffffea80b8a8:	2909627f 	stp	wzr, w24, [x19, #72]
	handle_init(&new_port->handle, &ipc_port_handle_ops);
ffffffffea80b8ac:	b0000061 	adrp	x1, ffffffffea818000 <_mem_phys_base>
	new_port->num_recv_bufs = num_recv_bufs;
ffffffffea80b8b0:	b9005276 	str	w22, [x19, #80]
	handle_init(&new_port->handle, &ipc_port_handle_ops);
ffffffffea80b8b4:	91380021 	add	x1, x1, #0xe00
	new_port->recv_buf_size = recv_buf_size;
ffffffffea80b8b8:	f9002e79 	str	x25, [x19, #88]
	return NO_ERROR;
ffffffffea80b8bc:	52800014 	mov	w20, #0x0                   	// #0
	list->prev = list->next = list;
ffffffffea80b8c0:	a90a0260 	stp	x0, x0, [x19, #160]
	handle_init(&new_port->handle, &ipc_port_handle_ops);
ffffffffea80b8c4:	aa1a03e0 	mov	x0, x26
ffffffffea80b8c8:	97fff99a 	bl	ffffffffea809f30 <handle_init>
	return NO_ERROR;
ffffffffea80b8cc:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80b8d0:	a9425bb5 	ldp	x21, x22, [x29, #32]
	*phandle_ptr = &new_port->handle;
ffffffffea80b8d4:	f90002fa 	str	x26, [x23]
}
ffffffffea80b8d8:	2a1403e0 	mov	w0, w20
ffffffffea80b8dc:	f9400ff4 	ldr	x20, [sp, #24]
	return NO_ERROR;
ffffffffea80b8e0:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80b8e4:	a9446bb9 	ldp	x25, x26, [x29, #64]
}
ffffffffea80b8e8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80b8ec:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80b8f0:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80b8f4:	17ffffe3 	b	ffffffffea80b880 <ipc_port_create+0x98>
		return ERR_NO_MEMORY;
ffffffffea80b8f8:	12800094 	mov	w20, #0xfffffffb            	// #-5
ffffffffea80b8fc:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80b900:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80b904:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80b908:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80b90c:	17ffffdd 	b	ffffffffea80b880 <ipc_port_create+0x98>

ffffffffea80b910 <ipc_port_publish>:
{
ffffffffea80b910:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea80b914:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b918:	910003fd 	mov	x29, sp
ffffffffea80b91c:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80b920:	aa0003f3 	mov	x19, x0
ffffffffea80b924:	a9025bf5 	stp	x21, x22, [sp, #32]
	ipc_port_t *port = containerof(phandle, ipc_port_t, handle);
ffffffffea80b928:	d1018015 	sub	x21, x0, #0x60
{
ffffffffea80b92c:	f9002bfb 	str	x27, [sp, #80]
ffffffffea80b930:	b000007b 	adrp	x27, ffffffffea818000 <_mem_phys_base>
ffffffffea80b934:	f90037be 	str	x30, [x29, #104]
ffffffffea80b938:	91372360 	add	x0, x27, #0xdc8
ffffffffea80b93c:	97ffe7eb 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	if (port_find_locked(port->path)) {
ffffffffea80b940:	aa1503e0 	mov	x0, x21
ffffffffea80b944:	97fffd3b 	bl	ffffffffea80ae30 <port_find_locked>
ffffffffea80b948:	b5001520 	cbnz	x0, ffffffffea80bbec <ipc_port_publish+0x2dc>
	item->prev = list->prev;
ffffffffea80b94c:	b0000061 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea80b950:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80b954:	f9001bb7 	str	x23, [x29, #48]
		port->state = IPC_PORT_STATE_LISTENING;
ffffffffea80b958:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80b95c:	f9471022 	ldr	x2, [x1, #3616]
		list_add_tail(&ipc_port_list, &port->node);
ffffffffea80b960:	91014263 	add	x3, x19, #0x50
		port->state = IPC_PORT_STATE_LISTENING;
ffffffffea80b964:	b81e8260 	stur	w0, [x19, #-24]
ffffffffea80b968:	91388020 	add	x0, x1, #0xe20
	item->next = list;
ffffffffea80b96c:	a90b02a2 	stp	x2, x0, [x21, #176]
		handle_incref(&port->handle); /* and inc usage count */
ffffffffea80b970:	aa1303e0 	mov	x0, x19
	list->prev->next = item;
ffffffffea80b974:	f9000443 	str	x3, [x2, #8]
		list_for_every_entry_safe(&waiting_for_port_chan_list, client, temp, ipc_chan_t, node) {
ffffffffea80b978:	b0000077 	adrp	x23, ffffffffea818000 <_mem_phys_base>
	list->prev = item;
ffffffffea80b97c:	f9071023 	str	x3, [x1, #3616]
		handle_incref(&port->handle); /* and inc usage count */
ffffffffea80b980:	97fff97c 	bl	ffffffffea809f70 <handle_incref>
		obj_ref_t tmp_client_ref = OBJ_REF_INITIAL_VALUE(tmp_client_ref);
ffffffffea80b984:	a9077fbf 	stp	xzr, xzr, [x29, #112]
		list_for_every_entry_safe(&waiting_for_port_chan_list, client, temp, ipc_chan_t, node) {
ffffffffea80b988:	9138c2e1 	add	x1, x23, #0xe30
ffffffffea80b98c:	f9400420 	ldr	x0, [x1, #8]
ffffffffea80b990:	d1028013 	sub	x19, x0, #0xa0
ffffffffea80b994:	eb00003f 	cmp	x1, x0
ffffffffea80b998:	f9405674 	ldr	x20, [x19, #168]
ffffffffea80b99c:	d1028294 	sub	x20, x20, #0xa0
ffffffffea80b9a0:	54000fe0 	b.eq	ffffffffea80bb9c <ipc_port_publish+0x28c>  // b.none
ffffffffea80b9a4:	a903e7b8 	stp	x24, x25, [x29, #56]
	int ret = NO_ERROR;
ffffffffea80b9a8:	52800016 	mov	w22, #0x0                   	// #0
				TRACEF("guest %u access to port denied, ret = %d\n",
ffffffffea80b9ac:	f0000059 	adrp	x25, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b9b0:	f90027ba 	str	x26, [x29, #72]
	list->prev->next = item;
ffffffffea80b9b4:	9101c3b8 	add	x24, x29, #0x70
ffffffffea80b9b8:	f000005a 	adrp	x26, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80b9bc:	913e6339 	add	x25, x25, #0xf98
ffffffffea80b9c0:	f9002fbc 	str	x28, [x29, #88]
ffffffffea80b9c4:	913c635a 	add	x26, x26, #0xf18
ffffffffea80b9c8:	14000016 	b	ffffffffea80ba20 <ipc_port_publish+0x110>
ffffffffea80b9cc:	b9408a63 	ldr	w3, [x19, #136]
ffffffffea80b9d0:	2a0003e4 	mov	w4, w0
ffffffffea80b9d4:	52802382 	mov	w2, #0x11c                 	// #284
ffffffffea80b9d8:	aa1a03e1 	mov	x1, x26
ffffffffea80b9dc:	aa1903e0 	mov	x0, x25
ffffffffea80b9e0:	94001d70 	bl	ffffffffea812fa0 <_printf>
	item->next->prev = item->prev;
ffffffffea80b9e4:	a94703a1 	ldp	x1, x0, [x29, #112]
ffffffffea80b9e8:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b9ec:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea80b9f0:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b9f4:	a9077fbf 	stp	xzr, xzr, [x29, #112]
ffffffffea80b9f8:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80b9fc:	eb00027f 	cmp	x19, x0
ffffffffea80ba00:	54000700 	b.eq	ffffffffea80bae0 <ipc_port_publish+0x1d0>  // b.none
		list_for_every_entry_safe(&waiting_for_port_chan_list, client, temp, ipc_chan_t, node) {
ffffffffea80ba04:	f9405681 	ldr	x1, [x20, #168]
ffffffffea80ba08:	91028282 	add	x2, x20, #0xa0
ffffffffea80ba0c:	9138c2e0 	add	x0, x23, #0xe30
ffffffffea80ba10:	aa1403f3 	mov	x19, x20
ffffffffea80ba14:	eb02001f 	cmp	x0, x2
ffffffffea80ba18:	d1028034 	sub	x20, x1, #0xa0
ffffffffea80ba1c:	540008e0 	b.eq	ffffffffea80bb38 <ipc_port_publish+0x228>  // b.none
			if (strcmp(client->path, port->path)) {
ffffffffea80ba20:	f9405e7c 	ldr	x28, [x19, #184]
ffffffffea80ba24:	aa1503e1 	mov	x1, x21
ffffffffea80ba28:	aa1c03e0 	mov	x0, x28
ffffffffea80ba2c:	94001e79 	bl	ffffffffea813410 <strcmp>
ffffffffea80ba30:	35fffea0 	cbnz	w0, ffffffffea80ba04 <ipc_port_publish+0xf4>
			free((void *)client->path);
ffffffffea80ba34:	aa1c03e0 	mov	x0, x28
ffffffffea80ba38:	94001d98 	bl	ffffffffea813098 <free>
	item->prev = list->prev;
ffffffffea80ba3c:	f9400260 	ldr	x0, [x19]
	item->next = list;
ffffffffea80ba40:	a9074fa0 	stp	x0, x19, [x29, #112]
			client->path = NULL;
ffffffffea80ba44:	f9005e7f 	str	xzr, [x19, #184]
	list->prev->next = item;
ffffffffea80ba48:	f9400260 	ldr	x0, [x19]
	item->next->prev = item->prev;
ffffffffea80ba4c:	f9405261 	ldr	x1, [x19, #160]
	list->prev->next = item;
ffffffffea80ba50:	f9000418 	str	x24, [x0, #8]
	list->prev = item;
ffffffffea80ba54:	f9000278 	str	x24, [x19]
	item->next->prev = item->prev;
ffffffffea80ba58:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80ba5c:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80ba60:	f9405262 	ldr	x2, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80ba64:	f9404a61 	ldr	x1, [x19, #144]
	item->prev->next = item->next;
ffffffffea80ba68:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80ba6c:	a90a7e7f 	stp	xzr, xzr, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80ba70:	f9404e60 	ldr	x0, [x19, #152]
ffffffffea80ba74:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80ba78:	f9404a61 	ldr	x1, [x19, #144]
ffffffffea80ba7c:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80ba80:	a9097e7f 	stp	xzr, xzr, [x19, #144]
ffffffffea80ba84:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80ba88:	eb13001f 	cmp	x0, x19
ffffffffea80ba8c:	540006e0 	b.eq	ffffffffea80bb68 <ipc_port_publish+0x258>  // b.none
			ret = trusty_hyp_check_guest_access(client->handle.guest_id, port->uuid);
ffffffffea80ba90:	b9408a60 	ldr	w0, [x19, #136]
ffffffffea80ba94:	f94022a1 	ldr	x1, [x21, #64]
ffffffffea80ba98:	97ffdb20 	bl	ffffffffea802718 <trusty_hyp_check_guest_access>
ffffffffea80ba9c:	2a0003f6 	mov	w22, w0
			if (ret) {
ffffffffea80baa0:	35fff960 	cbnz	w0, ffffffffea80b9cc <ipc_port_publish+0xbc>
				int err = port_attach_client(port, client);
ffffffffea80baa4:	aa1303e1 	mov	x1, x19
ffffffffea80baa8:	aa1503e0 	mov	x0, x21
ffffffffea80baac:	97fffe9b 	bl	ffffffffea80b518 <port_attach_client>
				if (err) {
ffffffffea80bab0:	34fff9a0 	cbz	w0, ffffffffea80b9e4 <ipc_port_publish+0xd4>
					chan_shutdown_locked(client);
ffffffffea80bab4:	aa1303e0 	mov	x0, x19
ffffffffea80bab8:	97fffdce 	bl	ffffffffea80b1f0 <chan_shutdown_locked>
	item->next->prev = item->prev;
ffffffffea80babc:	a94703a1 	ldp	x1, x0, [x29, #112]
ffffffffea80bac0:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80bac4:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea80bac8:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80bacc:	a9077fbf 	stp	xzr, xzr, [x29, #112]
ffffffffea80bad0:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80bad4:	eb00027f 	cmp	x19, x0
ffffffffea80bad8:	54fff961 	b.ne	ffffffffea80ba04 <ipc_port_publish+0xf4>  // b.any
ffffffffea80badc:	d503201f 	nop
	ASSERT(chan->peer == NULL);
ffffffffea80bae0:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80bae4:	b5000880 	cbnz	x0, ffffffffea80bbf4 <ipc_port_publish+0x2e4>
	if (item->prev == 0 && item->next == 0)
ffffffffea80bae8:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80baec:	b5000460 	cbnz	x0, ffffffffea80bb78 <ipc_port_publish+0x268>
ffffffffea80baf0:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80baf4:	b5000420 	cbnz	x0, ffffffffea80bb78 <ipc_port_publish+0x268>
	if (chan->path) {
ffffffffea80baf8:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80bafc:	b4000040 	cbz	x0, ffffffffea80bb04 <ipc_port_publish+0x1f4>
		free((void *)chan->path);
ffffffffea80bb00:	94001d66 	bl	ffffffffea813098 <free>
	if (chan->msg_queue) {
ffffffffea80bb04:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80bb08:	b4000060 	cbz	x0, ffffffffea80bb14 <ipc_port_publish+0x204>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80bb0c:	94000369 	bl	ffffffffea80c8b0 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80bb10:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80bb14:	aa1303e0 	mov	x0, x19
ffffffffea80bb18:	94001d60 	bl	ffffffffea813098 <free>
		list_for_every_entry_safe(&waiting_for_port_chan_list, client, temp, ipc_chan_t, node) {
ffffffffea80bb1c:	f9405681 	ldr	x1, [x20, #168]
ffffffffea80bb20:	91028282 	add	x2, x20, #0xa0
ffffffffea80bb24:	9138c2e0 	add	x0, x23, #0xe30
ffffffffea80bb28:	aa1403f3 	mov	x19, x20
ffffffffea80bb2c:	eb02001f 	cmp	x0, x2
ffffffffea80bb30:	d1028034 	sub	x20, x1, #0xa0
ffffffffea80bb34:	54fff761 	b.ne	ffffffffea80ba20 <ipc_port_publish+0x110>  // b.any
ffffffffea80bb38:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80bb3c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80bb40:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80bb44:	f9402fbc 	ldr	x28, [x29, #88]
	mutex_release(&ipc_lock);
ffffffffea80bb48:	91372360 	add	x0, x27, #0xdc8
ffffffffea80bb4c:	97ffe793 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea80bb50:	2a1603e0 	mov	w0, w22
ffffffffea80bb54:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80bb58:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80bb5c:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea80bb60:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80bb64:	d65f03c0 	ret
	ASSERT(chan->peer == NULL);
ffffffffea80bb68:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80bb6c:	b5000440 	cbnz	x0, ffffffffea80bbf4 <ipc_port_publish+0x2e4>
ffffffffea80bb70:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80bb74:	b40002a0 	cbz	x0, ffffffffea80bbc8 <ipc_port_publish+0x2b8>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80bb78:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea80bb7c:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80bb80:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80bb84:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80bb88:	913de084 	add	x4, x4, #0xf78
ffffffffea80bb8c:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80bb90:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80bb94:	91330021 	add	x1, x1, #0xcc0
ffffffffea80bb98:	9400179c 	bl	ffffffffea811a08 <_panic>
ffffffffea80bb9c:	f9400fb4 	ldr	x20, [x29, #24]
	int ret = NO_ERROR;
ffffffffea80bba0:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea80bba4:	f9401bb7 	ldr	x23, [x29, #48]
	mutex_release(&ipc_lock);
ffffffffea80bba8:	91372360 	add	x0, x27, #0xdc8
ffffffffea80bbac:	97ffe77b 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea80bbb0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80bbb4:	2a1603e0 	mov	w0, w22
ffffffffea80bbb8:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea80bbbc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80bbc0:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80bbc4:	d65f03c0 	ret
ffffffffea80bbc8:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80bbcc:	b5fffd60 	cbnz	x0, ffffffffea80bb78 <ipc_port_publish+0x268>
	if (chan->msg_queue) {
ffffffffea80bbd0:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80bbd4:	b4000060 	cbz	x0, ffffffffea80bbe0 <ipc_port_publish+0x2d0>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80bbd8:	94000336 	bl	ffffffffea80c8b0 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80bbdc:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80bbe0:	aa1303e0 	mov	x0, x19
ffffffffea80bbe4:	94001d2d 	bl	ffffffffea813098 <free>
ffffffffea80bbe8:	17ffffaa 	b	ffffffffea80ba90 <ipc_port_publish+0x180>
		ret = ERR_ALREADY_EXISTS;
ffffffffea80bbec:	128001b6 	mov	w22, #0xfffffff2            	// #-14
ffffffffea80bbf0:	17ffffd6 	b	ffffffffea80bb48 <ipc_port_publish+0x238>
	ASSERT(chan->peer == NULL);
ffffffffea80bbf4:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea80bbf8:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80bbfc:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80bc00:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80bc04:	913d8084 	add	x4, x4, #0xf60
ffffffffea80bc08:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80bc0c:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80bc10:	91330021 	add	x1, x1, #0xcc0
ffffffffea80bc14:	9400177d 	bl	ffffffffea811a08 <_panic>

ffffffffea80bc18 <sys_port_create>:
{
ffffffffea80bc18:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
ffffffffea80bc1c:	910003fd 	mov	x29, sp
ffffffffea80bc20:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80bc24:	2a0003f3 	mov	w19, w0
ffffffffea80bc28:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80bc2c:	2a0103f5 	mov	w21, w1
ffffffffea80bc30:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80bc34:	aa0203f6 	mov	x22, x2
ffffffffea80bc38:	2a0303f7 	mov	w23, w3
ffffffffea80bc3c:	d538d080 	mrs	x0, tpidr_el1
	trusty_app_t *tapp = ut->private_data;
ffffffffea80bc40:	f9415800 	ldr	x0, [x0, #688]
ffffffffea80bc44:	f9404814 	ldr	x20, [x0, #144]
	uctx_t *ctx = current_uctx();
ffffffffea80bc48:	97fffa84 	bl	ffffffffea80a658 <current_uctx>
	handle_t *port_handle = NULL;
ffffffffea80bc4c:	f90027bf 	str	xzr, [x29, #72]
	uctx_t *ctx = current_uctx();
ffffffffea80bc50:	aa0003f8 	mov	x24, x0
	return arch_strlcpy_from_user(kdest, usrc, len);
ffffffffea80bc54:	d2800802 	mov	x2, #0x40                  	// #64
ffffffffea80bc58:	910143a0 	add	x0, x29, #0x50
ffffffffea80bc5c:	2a1303e1 	mov	w1, w19
ffffffffea80bc60:	94001e92 	bl	ffffffffea8136a8 <arch_strlcpy_from_user>
	if (ret < 0) {
ffffffffea80bc64:	37f803c0 	tbnz	w0, #31, ffffffffea80bcdc <sys_port_create+0xc4>
	if ((uint)ret >= sizeof(tmp_path)) {
ffffffffea80bc68:	7100fc1f 	cmp	w0, #0x3f
ffffffffea80bc6c:	54000528 	b.hi	ffffffffea80bd10 <sys_port_create+0xf8>  // b.pmore
	ret = ipc_port_create(&tapp->props.uuid, tmp_path,
ffffffffea80bc70:	2a1703e4 	mov	w4, w23
ffffffffea80bc74:	910123a5 	add	x5, x29, #0x48
ffffffffea80bc78:	aa1603e3 	mov	x3, x22
ffffffffea80bc7c:	2a1503e2 	mov	w2, w21
ffffffffea80bc80:	910143a1 	add	x1, x29, #0x50
ffffffffea80bc84:	91008280 	add	x0, x20, #0x20
ffffffffea80bc88:	97fffed8 	bl	ffffffffea80b7e8 <ipc_port_create>
ffffffffea80bc8c:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80bc90:	340000e0 	cbz	w0, ffffffffea80bcac <sys_port_create+0x94>
	return (long) ret;
ffffffffea80bc94:	93407e60 	sxtw	x0, w19
}
ffffffffea80bc98:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80bc9c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80bca0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80bca4:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80bca8:	d65f03c0 	ret
	ret = uctx_handle_install(ctx, port_handle, &handle_id);
ffffffffea80bcac:	f94027a1 	ldr	x1, [x29, #72]
ffffffffea80bcb0:	910113a2 	add	x2, x29, #0x44
ffffffffea80bcb4:	aa1803e0 	mov	x0, x24
ffffffffea80bcb8:	97fffabc 	bl	ffffffffea80a7a8 <uctx_handle_install>
ffffffffea80bcbc:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80bcc0:	35000220 	cbnz	w0, ffffffffea80bd04 <sys_port_create+0xec>
	ret = ipc_port_publish(port_handle);
ffffffffea80bcc4:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80bcc8:	97ffff12 	bl	ffffffffea80b910 <ipc_port_publish>
ffffffffea80bccc:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80bcd0:	35000120 	cbnz	w0, ffffffffea80bcf4 <sys_port_create+0xdc>
	return (long) handle_id;
ffffffffea80bcd4:	b94047a0 	ldr	w0, [x29, #68]
ffffffffea80bcd8:	17fffff0 	b	ffffffffea80bc98 <sys_port_create+0x80>
}
ffffffffea80bcdc:	a94153f3 	ldp	x19, x20, [sp, #16]
		return (long) ret;
ffffffffea80bce0:	93407c00 	sxtw	x0, w0
}
ffffffffea80bce4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80bce8:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80bcec:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80bcf0:	d65f03c0 	ret
	(void) uctx_handle_remove(ctx, handle_id, &port_handle);
ffffffffea80bcf4:	b94047a1 	ldr	w1, [x29, #68]
ffffffffea80bcf8:	910123a2 	add	x2, x29, #0x48
ffffffffea80bcfc:	aa1803e0 	mov	x0, x24
ffffffffea80bd00:	97fffaf2 	bl	ffffffffea80a8c8 <uctx_handle_remove>
	handle_decref(port_handle);
ffffffffea80bd04:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80bd08:	97fff8a0 	bl	ffffffffea809f88 <handle_decref>
ffffffffea80bd0c:	17ffffe2 	b	ffffffffea80bc94 <sys_port_create+0x7c>
		return ERR_INVALID_ARGS;
ffffffffea80bd10:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80bd14:	17ffffe1 	b	ffffffffea80bc98 <sys_port_create+0x80>

ffffffffea80bd18 <ipc_port_connect_async>:
 * Client requests a connection to a port. It can be called in context
 * of user task as well as vdev RX thread.
 */
int ipc_port_connect_async(uint32_t guest, const uuid_t *cid, const char *path, size_t max_path,
			   uint flags, handle_t **chandle_ptr)
{
ffffffffea80bd18:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80bd1c:	910003fd 	mov	x29, sp
ffffffffea80bd20:	f90013f5 	str	x21, [sp, #32]
	ipc_port_t *port;
	ipc_chan_t *client;
	obj_ref_t   tmp_client_ref = OBJ_REF_INITIAL_VALUE(tmp_client_ref);
ffffffffea80bd24:	a9067fbf 	stp	xzr, xzr, [x29, #96]
	int ret;

	if (!cid) {
ffffffffea80bd28:	b4001281 	cbz	x1, ffffffffea80bf78 <ipc_port_connect_async+0x260>
ffffffffea80bd2c:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80bd30:	aa0103f5 	mov	x21, x1
ffffffffea80bd34:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea80bd38:	aa0303f3 	mov	x19, x3
ffffffffea80bd3c:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea80bd40:	2a0403f7 	mov	w23, w4
ffffffffea80bd44:	aa0503f8 	mov	x24, x5
ffffffffea80bd48:	aa0203f4 	mov	x20, x2
ffffffffea80bd4c:	2a0003f6 	mov	w22, w0
ffffffffea80bd50:	aa1e03f9 	mov	x25, x30
		/* client uuid is required */
		LTRACEF("client uuid is required\n");
		return ERR_INVALID_ARGS;
	}

	size_t len = strnlen(path, max_path);
ffffffffea80bd54:	aa0303e1 	mov	x1, x3
ffffffffea80bd58:	aa0203e0 	mov	x0, x2
ffffffffea80bd5c:	94001e19 	bl	ffffffffea8135c0 <strnlen>
	if (len == 0 || len >= max_path) {
ffffffffea80bd60:	f100001f 	cmp	x0, #0x0
ffffffffea80bd64:	fa401260 	ccmp	x19, x0, #0x0, ne  // ne = any
ffffffffea80bd68:	54000e29 	b.ls	ffffffffea80bf2c <ipc_port_connect_async+0x214>  // b.plast
		return ERR_INVALID_ARGS;
	}
	/* After this point path is zero terminated */

	/* allocate channel pair */
	client = chan_alloc(0, cid, &tmp_client_ref);
ffffffffea80bd6c:	910183a2 	add	x2, x29, #0x60
ffffffffea80bd70:	aa1503e1 	mov	x1, x21
ffffffffea80bd74:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80bd78:	97fffc18 	bl	ffffffffea80add8 <chan_alloc>
ffffffffea80bd7c:	aa0003f3 	mov	x19, x0
	if (!client) {
ffffffffea80bd80:	b4000e00 	cbz	x0, ffffffffea80bf40 <ipc_port_connect_async+0x228>
ffffffffea80bd84:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80bd88:	a904efba 	stp	x26, x27, [x29, #72]
ffffffffea80bd8c:	b000007a 	adrp	x26, ffffffffea818000 <_mem_phys_base>
ffffffffea80bd90:	91372340 	add	x0, x26, #0xdc8
ffffffffea80bd94:	97ffe6d5 	bl	ffffffffea8058e8 <mutex_acquire_timeout>

	LTRACEF("Connecting to '%s'\n", path);

	mutex_acquire(&ipc_lock);

	port = port_find_locked(path);
ffffffffea80bd98:	aa1403e0 	mov	x0, x20
ffffffffea80bd9c:	97fffc25 	bl	ffffffffea80ae30 <port_find_locked>
ffffffffea80bda0:	aa0003fb 	mov	x27, x0
	if (port) {
ffffffffea80bda4:	b4000300 	cbz	x0, ffffffffea80be04 <ipc_port_connect_async+0xec>
		/* found  */
		ret = trusty_hyp_check_guest_access(guest, port->uuid);
ffffffffea80bda8:	f9402361 	ldr	x1, [x27, #64]
ffffffffea80bdac:	2a1603e0 	mov	w0, w22
ffffffffea80bdb0:	97ffda5a 	bl	ffffffffea802718 <trusty_hyp_check_guest_access>
ffffffffea80bdb4:	2a0003f5 	mov	w21, w0
		if (ret) {
ffffffffea80bdb8:	34000520 	cbz	w0, ffffffffea80be5c <ipc_port_connect_async+0x144>
	item->next->prev = item->prev;
ffffffffea80bdbc:	a94603a1 	ldp	x1, x0, [x29, #96]
ffffffffea80bdc0:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80bdc4:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea80bdc8:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80bdcc:	a9067fbf 	stp	xzr, xzr, [x29, #96]
	return (list->next == list) ? true : false;
ffffffffea80bdd0:	f9400674 	ldr	x20, [x19, #8]
ffffffffea80bdd4:	eb13029f 	cmp	x20, x19
ffffffffea80bdd8:	54000780 	b.eq	ffffffffea80bec8 <ipc_port_connect_async+0x1b0>  // b.none

err_alloc_path:
err_attach_client:
err_find_ports:
	chan_del_ref(client, &tmp_client_ref);
	mutex_release(&ipc_lock);
ffffffffea80bddc:	91372340 	add	x0, x26, #0xdc8
ffffffffea80bde0:	97ffe6ee 	bl	ffffffffea805998 <mutex_release>
	return ret;
ffffffffea80bde4:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80bde8:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80bdec:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80bdf0:	a944efba 	ldp	x26, x27, [x29, #72]
}
ffffffffea80bdf4:	2a1503e0 	mov	w0, w21
ffffffffea80bdf8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80bdfc:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80be00:	d65f03c0 	ret
			ret = ERR_NOT_FOUND;
ffffffffea80be04:	12800035 	mov	w21, #0xfffffffe            	// #-2
		if (!(flags & IPC_CONNECT_WAIT_FOR_PORT)) {
ffffffffea80be08:	3607fdb7 	tbz	w23, #0, ffffffffea80bdbc <ipc_port_connect_async+0xa4>
		client->path = strdup(path);
ffffffffea80be0c:	aa1403e0 	mov	x0, x20
ffffffffea80be10:	94001d8e 	bl	ffffffffea813448 <strdup>
ffffffffea80be14:	f9005e60 	str	x0, [x19, #184]
			ret = ERR_NO_MEMORY;
ffffffffea80be18:	12800095 	mov	w21, #0xfffffffb            	// #-5
		if (!client->path) {
ffffffffea80be1c:	b4fffd00 	cbz	x0, ffffffffea80bdbc <ipc_port_connect_async+0xa4>
	item->prev = list->prev;
ffffffffea80be20:	b0000061 	adrp	x1, ffffffffea818000 <_mem_phys_base>
		list_add_tail(&waiting_for_port_chan_list, &client->node);
ffffffffea80be24:	91028260 	add	x0, x19, #0xa0
ffffffffea80be28:	9138c023 	add	x3, x1, #0xe30
		client->state = IPC_CHAN_STATE_WAITING_FOR_PORT;
ffffffffea80be2c:	528000a4 	mov	w4, #0x5                   	// #5
ffffffffea80be30:	f9471822 	ldr	x2, [x1, #3632]
	list->prev = item;
ffffffffea80be34:	f9071820 	str	x0, [x1, #3632]
ffffffffea80be38:	b9003264 	str	w4, [x19, #48]
	item->prev = list->prev;
ffffffffea80be3c:	f9400261 	ldr	x1, [x19]
	item->next = list;
ffffffffea80be40:	a90a0e62 	stp	x2, x3, [x19, #160]
	list->prev->next = item;
ffffffffea80be44:	f9000440 	str	x0, [x2, #8]
	list_add_tail(&obj->ref_list, &ref->ref_node);
ffffffffea80be48:	91024260 	add	x0, x19, #0x90
	item->next = list;
ffffffffea80be4c:	a9094e61 	stp	x1, x19, [x19, #144]
	list->prev->next = item;
ffffffffea80be50:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea80be54:	f9000260 	str	x0, [x19]
ffffffffea80be58:	14000007 	b	ffffffffea80be74 <ipc_port_connect_async+0x15c>
		port->handle.guest_id = guest;
ffffffffea80be5c:	b9009b76 	str	w22, [x27, #152]
		ret = port_attach_client(port, client);
ffffffffea80be60:	aa1303e1 	mov	x1, x19
ffffffffea80be64:	aa1b03e0 	mov	x0, x27
ffffffffea80be68:	97fffdac 	bl	ffffffffea80b518 <port_attach_client>
ffffffffea80be6c:	2a0003f5 	mov	w21, w0
		if (ret) {
ffffffffea80be70:	35fffa60 	cbnz	w0, ffffffffea80bdbc <ipc_port_connect_async+0xa4>
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80be74:	91014274 	add	x20, x19, #0x50
ffffffffea80be78:	b0000061 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea80be7c:	aa1403e0 	mov	x0, x20
ffffffffea80be80:	9136a021 	add	x1, x1, #0xda8
ffffffffea80be84:	97fff82b 	bl	ffffffffea809f30 <handle_init>
	ret = NO_ERROR;
ffffffffea80be88:	52800015 	mov	w21, #0x0                   	// #0
	item->prev = list->prev;
ffffffffea80be8c:	f9400261 	ldr	x1, [x19]
ffffffffea80be90:	91010260 	add	x0, x19, #0x40
	item->next = list;
ffffffffea80be94:	a9044e61 	stp	x1, x19, [x19, #64]
	list->prev->next = item;
ffffffffea80be98:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea80be9c:	f9000260 	str	x0, [x19]
	*chandle_ptr = chan_handle_init(client);
ffffffffea80bea0:	f9000314 	str	x20, [x24]
	item->next->prev = item->prev;
ffffffffea80bea4:	a94603a1 	ldp	x1, x0, [x29, #96]
	client->handle.guest_id = guest;
ffffffffea80bea8:	b9008a76 	str	w22, [x19, #136]
ffffffffea80beac:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80beb0:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea80beb4:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80beb8:	a9067fbf 	stp	xzr, xzr, [x29, #96]
	return (list->next == list) ? true : false;
ffffffffea80bebc:	f9400674 	ldr	x20, [x19, #8]
	if (dead)
ffffffffea80bec0:	eb13029f 	cmp	x20, x19
ffffffffea80bec4:	54fff8c1 	b.ne	ffffffffea80bddc <ipc_port_connect_async+0xc4>  // b.any
	ASSERT(chan->peer == NULL);
ffffffffea80bec8:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80becc:	b5000440 	cbnz	x0, ffffffffea80bf54 <ipc_port_connect_async+0x23c>
	if (item->prev == 0 && item->next == 0)
ffffffffea80bed0:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80bed4:	b4000140 	cbz	x0, ffffffffea80befc <ipc_port_connect_async+0x1e4>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80bed8:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80bedc:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80bee0:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80bee4:	913de084 	add	x4, x4, #0xf78
ffffffffea80bee8:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80beec:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80bef0:	91330021 	add	x1, x1, #0xcc0
ffffffffea80bef4:	aa1903e0 	mov	x0, x25
ffffffffea80bef8:	940016c4 	bl	ffffffffea811a08 <_panic>
ffffffffea80befc:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80bf00:	b5fffec0 	cbnz	x0, ffffffffea80bed8 <ipc_port_connect_async+0x1c0>
	if (chan->path) {
ffffffffea80bf04:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80bf08:	b4000040 	cbz	x0, ffffffffea80bf10 <ipc_port_connect_async+0x1f8>
		free((void *)chan->path);
ffffffffea80bf0c:	94001c63 	bl	ffffffffea813098 <free>
	if (chan->msg_queue) {
ffffffffea80bf10:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80bf14:	b4000060 	cbz	x0, ffffffffea80bf20 <ipc_port_connect_async+0x208>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80bf18:	94000266 	bl	ffffffffea80c8b0 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80bf1c:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80bf20:	aa1403e0 	mov	x0, x20
ffffffffea80bf24:	94001c5d 	bl	ffffffffea813098 <free>
ffffffffea80bf28:	17ffffad 	b	ffffffffea80bddc <ipc_port_connect_async+0xc4>
		return ERR_INVALID_ARGS;
ffffffffea80bf2c:	128000f5 	mov	w21, #0xfffffff8            	// #-8
ffffffffea80bf30:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80bf34:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80bf38:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80bf3c:	17ffffae 	b	ffffffffea80bdf4 <ipc_port_connect_async+0xdc>
		return ERR_NO_MEMORY;
ffffffffea80bf40:	12800095 	mov	w21, #0xfffffffb            	// #-5
ffffffffea80bf44:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80bf48:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80bf4c:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80bf50:	17ffffa9 	b	ffffffffea80bdf4 <ipc_port_connect_async+0xdc>
	ASSERT(chan->peer == NULL);
ffffffffea80bf54:	f0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80bf58:	f0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80bf5c:	d0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80bf60:	913d8084 	add	x4, x4, #0xf60
ffffffffea80bf64:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80bf68:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80bf6c:	91330021 	add	x1, x1, #0xcc0
ffffffffea80bf70:	aa1903e0 	mov	x0, x25
ffffffffea80bf74:	940016a5 	bl	ffffffffea811a08 <_panic>
		return ERR_INVALID_ARGS;
ffffffffea80bf78:	128000f5 	mov	w21, #0xfffffff8            	// #-8
ffffffffea80bf7c:	17ffff9e 	b	ffffffffea80bdf4 <ipc_port_connect_async+0xdc>

ffffffffea80bf80 <sys_connect>:
#ifndef DEFAULT_IPC_CONNECT_WARN_TIMEOUT
#define DEFAULT_IPC_CONNECT_WARN_TIMEOUT   INFINITE_TIME
#endif

long __SYSCALL sys_connect(user_addr_t path, uint flags)
{
ffffffffea80bf80:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea80bf84:	910003fd 	mov	x29, sp
ffffffffea80bf88:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80bf8c:	2a0003f4 	mov	w20, w0
ffffffffea80bf90:	2a0103f3 	mov	w19, w1
ffffffffea80bf94:	f90013f5 	str	x21, [sp, #32]
ffffffffea80bf98:	d538d080 	mrs	x0, tpidr_el1
	uthread_t *ut = uthread_get_current();
	trusty_app_t *tapp = ut->private_data;
ffffffffea80bf9c:	f9415800 	ldr	x0, [x0, #688]
ffffffffea80bfa0:	f9404815 	ldr	x21, [x0, #144]
	uctx_t *ctx = current_uctx();
ffffffffea80bfa4:	97fff9ad 	bl	ffffffffea80a658 <current_uctx>
	char tmp_path[IPC_PORT_PATH_MAX];
	int ret;
	handle_id_t handle_id;
	uint32_t cur_guest;

	if (flags & ~IPC_CONNECT_MASK) {
ffffffffea80bfa8:	721e767f 	tst	w19, #0xfffffffc
ffffffffea80bfac:	540007a1 	b.ne	ffffffffea80c0a0 <sys_connect+0x120>  // b.any
ffffffffea80bfb0:	f90017b6 	str	x22, [x29, #40]
ffffffffea80bfb4:	d2800802 	mov	x2, #0x40                  	// #64
ffffffffea80bfb8:	aa0003f6 	mov	x22, x0
ffffffffea80bfbc:	2a1403e1 	mov	w1, w20
ffffffffea80bfc0:	8b0203a0 	add	x0, x29, x2
ffffffffea80bfc4:	94001db9 	bl	ffffffffea8136a8 <arch_strlcpy_from_user>
		/* unsupported flags specified */
		return ERR_INVALID_ARGS;
	}

	ret = (int) strncpy_from_user(tmp_path, path, sizeof(tmp_path));
	if (ret < 0) {
ffffffffea80bfc8:	37f804e0 	tbnz	w0, #31, ffffffffea80c064 <sys_connect+0xe4>
		return (long) ret;
	}
	if ((uint)ret >= sizeof(tmp_path)) {
ffffffffea80bfcc:	7100fc1f 	cmp	w0, #0x3f
ffffffffea80bfd0:	54000668 	b.hi	ffffffffea80c09c <sys_connect+0x11c>  // b.pmore
		return (long) ERR_INVALID_ARGS;
	}
	cur_guest = uctx_get_current_guest();
ffffffffea80bfd4:	97fff987 	bl	ffffffffea80a5f0 <uctx_get_current_guest>

	ret = ipc_port_connect_async(cur_guest, &tapp->props.uuid,
ffffffffea80bfd8:	d2800803 	mov	x3, #0x40                  	// #64
ffffffffea80bfdc:	9100e3a5 	add	x5, x29, #0x38
ffffffffea80bfe0:	2a1303e4 	mov	w4, w19
ffffffffea80bfe4:	8b0303a2 	add	x2, x29, x3
ffffffffea80bfe8:	910082a1 	add	x1, x21, #0x20
ffffffffea80bfec:	97ffff4b 	bl	ffffffffea80bd18 <ipc_port_connect_async>
				     tmp_path, sizeof(tmp_path),
				     flags, &chandle);
	if (ret != NO_ERROR) {
ffffffffea80bff0:	350003a0 	cbnz	w0, ffffffffea80c064 <sys_connect+0xe4>
	}
	if (!(flags & IPC_CONNECT_ASYNC)) {
		uint32_t event;
		lk_time_t timeout_msecs = DEFAULT_IPC_CONNECT_WARN_TIMEOUT;

		ret = handle_wait(chandle, &event, timeout_msecs);
ffffffffea80bff4:	9100d3b4 	add	x20, x29, #0x34
ffffffffea80bff8:	f9401fa0 	ldr	x0, [x29, #56]
	if (!(flags & IPC_CONNECT_ASYNC)) {
ffffffffea80bffc:	370801d3 	tbnz	w19, #1, ffffffffea80c034 <sys_connect+0xb4>
		ret = handle_wait(chandle, &event, timeout_msecs);
ffffffffea80c000:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea80c004:	aa1403e1 	mov	x1, x20
ffffffffea80c008:	97fff814 	bl	ffffffffea80a058 <handle_wait>
ffffffffea80c00c:	2a0003f3 	mov	w19, w0
		if (ret == ERR_TIMED_OUT) {
ffffffffea80c010:	3100341f 	cmn	w0, #0xd
ffffffffea80c014:	540004a0 	b.eq	ffffffffea80c0a8 <sys_connect+0x128>  // b.none
			TRACEF("Timedout connecting to %s\n", tmp_path);
			ret = handle_wait(chandle, &event, INFINITE_TIME);
		}

		if (ret < 0) {
ffffffffea80c018:	37f80333 	tbnz	w19, #31, ffffffffea80c07c <sys_connect+0xfc>
			/* timeout or other error */
			handle_close(chandle);
			return ret;
		}

		if ((event & IPC_HANDLE_POLL_HUP) &&
ffffffffea80c01c:	b94037a3 	ldr	w3, [x29, #52]
ffffffffea80c020:	121e0460 	and	w0, w3, #0xc
ffffffffea80c024:	7100101f 	cmp	w0, #0x4
ffffffffea80c028:	54000700 	b.eq	ffffffffea80c108 <sys_connect+0x188>  // b.none
			/* hangup and no pending messages */
			handle_close(chandle);
			return ERR_CHANNEL_CLOSED;
		}

		if (!(event & IPC_HANDLE_POLL_READY)) {
ffffffffea80c02c:	36000583 	tbz	w3, #0, ffffffffea80c0dc <sys_connect+0x15c>
ffffffffea80c030:	f9401fa0 	ldr	x0, [x29, #56]
			handle_close(chandle);
			return ERR_NOT_READY;
		}
	}

	ret = uctx_handle_install(ctx, chandle, &handle_id);
ffffffffea80c034:	aa0003e1 	mov	x1, x0
ffffffffea80c038:	aa1403e2 	mov	x2, x20
ffffffffea80c03c:	aa1603e0 	mov	x0, x22
ffffffffea80c040:	97fff9da 	bl	ffffffffea80a7a8 <uctx_handle_install>
ffffffffea80c044:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c048:	350001a0 	cbnz	w0, ffffffffea80c07c <sys_connect+0xfc>
		/* Failed to install handle into user context */
		handle_close(chandle);
		return (long) ret;
	}

	return (long) handle_id;
ffffffffea80c04c:	b94037a0 	ldr	w0, [x29, #52]
ffffffffea80c050:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea80c054:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c058:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80c05c:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80c060:	d65f03c0 	ret
		return (long) ret;
ffffffffea80c064:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c068:	93407c00 	sxtw	x0, w0
}
ffffffffea80c06c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c070:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80c074:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80c078:	d65f03c0 	ret
		handle_close(chandle);
ffffffffea80c07c:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c080:	97fff7ea 	bl	ffffffffea80a028 <handle_close>
		return (long) ret;
ffffffffea80c084:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c088:	93407e60 	sxtw	x0, w19
}
ffffffffea80c08c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80c090:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c094:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80c098:	d65f03c0 	ret
ffffffffea80c09c:	f94017b6 	ldr	x22, [x29, #40]
		return ERR_INVALID_ARGS;
ffffffffea80c0a0:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80c0a4:	17fffff2 	b	ffffffffea80c06c <sys_connect+0xec>
			TRACEF("Timedout connecting to %s\n", tmp_path);
ffffffffea80c0a8:	910103a3 	add	x3, x29, #0x40
ffffffffea80c0ac:	528066e2 	mov	w2, #0x337                 	// #823
ffffffffea80c0b0:	d0000041 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80c0b4:	f0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80c0b8:	913cc021 	add	x1, x1, #0xf30
ffffffffea80c0bc:	91004000 	add	x0, x0, #0x10
ffffffffea80c0c0:	94001bb8 	bl	ffffffffea812fa0 <_printf>
			ret = handle_wait(chandle, &event, INFINITE_TIME);
ffffffffea80c0c4:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c0c8:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea80c0cc:	aa1403e1 	mov	x1, x20
ffffffffea80c0d0:	97fff7e2 	bl	ffffffffea80a058 <handle_wait>
ffffffffea80c0d4:	2a0003f3 	mov	w19, w0
ffffffffea80c0d8:	17ffffd0 	b	ffffffffea80c018 <sys_connect+0x98>
			TRACEF("Unexpected channel state: event = 0x%x\n", event);
ffffffffea80c0dc:	52806942 	mov	w2, #0x34a                 	// #842
ffffffffea80c0e0:	d0000041 	adrp	x1, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80c0e4:	f0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80c0e8:	913cc021 	add	x1, x1, #0xf30
ffffffffea80c0ec:	9100e000 	add	x0, x0, #0x38
ffffffffea80c0f0:	94001bac 	bl	ffffffffea812fa0 <_printf>
			handle_close(chandle);
ffffffffea80c0f4:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c0f8:	97fff7cc 	bl	ffffffffea80a028 <handle_close>
			return ERR_NOT_READY;
ffffffffea80c0fc:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c100:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
ffffffffea80c104:	17ffffda 	b	ffffffffea80c06c <sys_connect+0xec>
			handle_close(chandle);
ffffffffea80c108:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c10c:	97fff7c7 	bl	ffffffffea80a028 <handle_close>
			return ERR_CHANNEL_CLOSED;
ffffffffea80c110:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c114:	928001c0 	mov	x0, #0xfffffffffffffff1    	// #-15
ffffffffea80c118:	17ffffd5 	b	ffffffffea80c06c <sys_connect+0xec>
ffffffffea80c11c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80c120 <ipc_port_accept>:
/*
 *  Called by user task to accept incomming connection
 */
int ipc_port_accept(handle_t *phandle, handle_t **chandle_ptr,
                    const uuid_t **uuid_ptr)
{
ffffffffea80c120:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80c124:	910003fd 	mov	x29, sp
ffffffffea80c128:	f90017f6 	str	x22, [sp, #40]
	ipc_port_t *port;
	ipc_chan_t *server = NULL;
	ipc_chan_t *client = NULL;
	obj_ref_t tmp_server_ref = OBJ_REF_INITIAL_VALUE(tmp_server_ref);
ffffffffea80c12c:	a9067fbf 	stp	xzr, xzr, [x29, #96]
	int ret = NO_ERROR;

	DEBUG_ASSERT(chandle_ptr);
	DEBUG_ASSERT(uuid_ptr);

	if (!phandle || !ipc_is_port(phandle)) {
ffffffffea80c130:	b4000aa0 	cbz	x0, ffffffffea80c284 <ipc_port_accept+0x164>
ffffffffea80c134:	f9400404 	ldr	x4, [x0, #8]
ffffffffea80c138:	90000063 	adrp	x3, ffffffffea818000 <_mem_phys_base>
ffffffffea80c13c:	91380063 	add	x3, x3, #0xe00
ffffffffea80c140:	eb03009f 	cmp	x4, x3
ffffffffea80c144:	54000a01 	b.ne	ffffffffea80c284 <ipc_port_accept+0x164>  // b.any
ffffffffea80c148:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80c14c:	aa0003f3 	mov	x19, x0
ffffffffea80c150:	f90013b5 	str	x21, [x29, #32]
ffffffffea80c154:	90000075 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea80c158:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80c15c:	913722a0 	add	x0, x21, #0xdc8
ffffffffea80c160:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea80c164:	aa0203f8 	mov	x24, x2
ffffffffea80c168:	aa0103f9 	mov	x25, x1
ffffffffea80c16c:	aa1e03f7 	mov	x23, x30
ffffffffea80c170:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80c174:	97ffe5dd 	bl	ffffffffea8058e8 <mutex_acquire_timeout>

	port = containerof(phandle, ipc_port_t, handle);

	mutex_acquire(&ipc_lock);

	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80c178:	b85e8260 	ldur	w0, [x19, #-24]
		/* Not in listening state: caller should close port.
		 * is it really possible to get here?
		 */
		ret = ERR_CHANNEL_CLOSED;
ffffffffea80c17c:	128001d6 	mov	w22, #0xfffffff1            	// #-15
	port = containerof(phandle, ipc_port_t, handle);
ffffffffea80c180:	d101827a 	sub	x26, x19, #0x60
	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80c184:	7100041f 	cmp	w0, #0x1
ffffffffea80c188:	54000160 	b.eq	ffffffffea80c1b4 <ipc_port_accept+0x94>  // b.none

err_bad_chan_state:
	chan_del_ref(server, &tmp_server_ref);
err_no_connections:
err_bad_port_state:
	mutex_release(&ipc_lock);
ffffffffea80c18c:	913722a0 	add	x0, x21, #0xdc8
ffffffffea80c190:	97ffe602 	bl	ffffffffea805998 <mutex_release>
	return ret;
}
ffffffffea80c194:	2a1603e0 	mov	w0, w22
	return ret;
ffffffffea80c198:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80c19c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c1a0:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80c1a4:	a9446bb9 	ldp	x25, x26, [x29, #64]
}
ffffffffea80c1a8:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80c1ac:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80c1b0:	d65f03c0 	ret
ffffffffea80c1b4:	f9000fb4 	str	x20, [x29, #24]
	server = list_remove_head_type(&port->pending_list, ipc_chan_t, node);
ffffffffea80c1b8:	91010260 	add	x0, x19, #0x40
	if (list->next != list) {
ffffffffea80c1bc:	f9405754 	ldr	x20, [x26, #168]
ffffffffea80c1c0:	eb00029f 	cmp	x20, x0
ffffffffea80c1c4:	540005a0 	b.eq	ffffffffea80c278 <ipc_port_accept+0x158>  // b.none
	item->next->prev = item->prev;
ffffffffea80c1c8:	a9400281 	ldp	x1, x0, [x20]
	item->prev = item->next = 0;
ffffffffea80c1cc:	aa1403f3 	mov	x19, x20
	if (!server) {
ffffffffea80c1d0:	f102829f 	cmp	x20, #0xa0
	item->next->prev = item->prev;
ffffffffea80c1d4:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c1d8:	f9400281 	ldr	x1, [x20]
ffffffffea80c1dc:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c1e0:	f900069f 	str	xzr, [x20, #8]
ffffffffea80c1e4:	f816067f 	str	xzr, [x19], #-160
ffffffffea80c1e8:	54000480 	b.eq	ffffffffea80c278 <ipc_port_accept+0x158>  // b.none
	item->prev = list->prev;
ffffffffea80c1ec:	f8560280 	ldur	x0, [x20, #-160]
	item->next = list;
ffffffffea80c1f0:	a9064fa0 	stp	x0, x19, [x29, #96]
	list->prev->next = item;
ffffffffea80c1f4:	910183a0 	add	x0, x29, #0x60
	item->next->prev = item->prev;
ffffffffea80c1f8:	f85f0281 	ldur	x1, [x20, #-16]
	list->prev->next = item;
ffffffffea80c1fc:	f8560282 	ldur	x2, [x20, #-160]
ffffffffea80c200:	f9000440 	str	x0, [x2, #8]
	list->prev = item;
ffffffffea80c204:	f8160280 	stur	x0, [x20, #-160]
	item->next->prev = item->prev;
ffffffffea80c208:	f85f8280 	ldur	x0, [x20, #-8]
ffffffffea80c20c:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c210:	f85f0281 	ldur	x1, [x20, #-16]
ffffffffea80c214:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c218:	a93f7e9f 	stp	xzr, xzr, [x20, #-16]
ffffffffea80c21c:	f8568280 	ldur	x0, [x20, #-152]
ffffffffea80c220:	eb13001f 	cmp	x0, x19
ffffffffea80c224:	54000760 	b.eq	ffffffffea80c310 <ipc_port_accept+0x1f0>  // b.none
	handle_decref(&port->handle);
ffffffffea80c228:	91018340 	add	x0, x26, #0x60
ffffffffea80c22c:	97fff757 	bl	ffffffffea809f88 <handle_decref>
	client = server->peer;
ffffffffea80c230:	f858029a 	ldur	x26, [x20, #-128]
	if (!client ||
ffffffffea80c234:	b400009a 	cbz	x26, ffffffffea80c244 <ipc_port_accept+0x124>
ffffffffea80c238:	b8590280 	ldur	w0, [x20, #-112]
ffffffffea80c23c:	7100041f 	cmp	w0, #0x1
ffffffffea80c240:	540002c0 	b.eq	ffffffffea80c298 <ipc_port_accept+0x178>  // b.none
		chan_shutdown_locked(server);
ffffffffea80c244:	aa1303e0 	mov	x0, x19
		ret = ERR_CHANNEL_CLOSED;
ffffffffea80c248:	128001d6 	mov	w22, #0xfffffff1            	// #-15
		chan_shutdown_locked(server);
ffffffffea80c24c:	97fffbe9 	bl	ffffffffea80b1f0 <chan_shutdown_locked>
	item->next->prev = item->prev;
ffffffffea80c250:	a94603a1 	ldp	x1, x0, [x29, #96]
ffffffffea80c254:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c258:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea80c25c:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c260:	a9067fbf 	stp	xzr, xzr, [x29, #96]
ffffffffea80c264:	f8568280 	ldur	x0, [x20, #-152]
ffffffffea80c268:	eb00027f 	cmp	x19, x0
ffffffffea80c26c:	540006e0 	b.eq	ffffffffea80c348 <ipc_port_accept+0x228>  // b.none
ffffffffea80c270:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80c274:	17ffffc6 	b	ffffffffea80c18c <ipc_port_accept+0x6c>
		ret = ERR_NO_MSG;
ffffffffea80c278:	12800076 	mov	w22, #0xfffffffc            	// #-4
ffffffffea80c27c:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80c280:	17ffffc3 	b	ffffffffea80c18c <ipc_port_accept+0x6c>
		return ERR_INVALID_ARGS;
ffffffffea80c284:	128000f6 	mov	w22, #0xfffffff8            	// #-8
}
ffffffffea80c288:	2a1603e0 	mov	w0, w22
ffffffffea80c28c:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80c290:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80c294:	d65f03c0 	ret
	    server->state != IPC_CHAN_STATE_ACCEPTING ||
ffffffffea80c298:	b9403340 	ldr	w0, [x26, #48]
ffffffffea80c29c:	7100081f 	cmp	w0, #0x2
ffffffffea80c2a0:	54fffd21 	b.ne	ffffffffea80c244 <ipc_port_accept+0x124>  // b.any
	client->aux_state |= IPC_CHAN_AUX_STATE_CONNECTED;
ffffffffea80c2a4:	b9403b40 	ldr	w0, [x26, #56]
	server->state = IPC_CHAN_STATE_CONNECTED;
ffffffffea80c2a8:	52800061 	mov	w1, #0x3                   	// #3
ffffffffea80c2ac:	f9002bbb 	str	x27, [x29, #80]
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c2b0:	9101427b 	add	x27, x19, #0x50
	server->state = IPC_CHAN_STATE_CONNECTED;
ffffffffea80c2b4:	b8190281 	stur	w1, [x20, #-112]
	client->aux_state |= IPC_CHAN_AUX_STATE_CONNECTED;
ffffffffea80c2b8:	321e0000 	orr	w0, w0, #0x4
	client->state = IPC_CHAN_STATE_CONNECTED;
ffffffffea80c2bc:	b9003341 	str	w1, [x26, #48]
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c2c0:	90000061 	adrp	x1, ffffffffea818000 <_mem_phys_base>
	client->aux_state |= IPC_CHAN_AUX_STATE_CONNECTED;
ffffffffea80c2c4:	b9003b40 	str	w0, [x26, #56]
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c2c8:	9136a021 	add	x1, x1, #0xda8
ffffffffea80c2cc:	aa1b03e0 	mov	x0, x27
	ret = NO_ERROR;
ffffffffea80c2d0:	52800016 	mov	w22, #0x0                   	// #0
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c2d4:	97fff717 	bl	ffffffffea809f30 <handle_init>
	item->prev = list->prev;
ffffffffea80c2d8:	f8560281 	ldur	x1, [x20, #-160]
	list_add_tail(&obj->ref_list, &ref->ref_node);
ffffffffea80c2dc:	91010260 	add	x0, x19, #0x40
	*uuid_ptr = client->uuid;
ffffffffea80c2e0:	f9401742 	ldr	x2, [x26, #40]
	item->next = list;
ffffffffea80c2e4:	a93a4e81 	stp	x1, x19, [x20, #-96]
	list->prev->next = item;
ffffffffea80c2e8:	f9000420 	str	x0, [x1, #8]
	server->handle.guest_id = client->handle.guest_id;
ffffffffea80c2ec:	b9408b41 	ldr	w1, [x26, #136]
	list->prev = item;
ffffffffea80c2f0:	f8160280 	stur	x0, [x20, #-160]
	handle_notify(&client->handle);
ffffffffea80c2f4:	91014340 	add	x0, x26, #0x50
	*chandle_ptr = chan_handle_init(server);
ffffffffea80c2f8:	f900033b 	str	x27, [x25]
	*uuid_ptr = client->uuid;
ffffffffea80c2fc:	f9000302 	str	x2, [x24]
	server->handle.guest_id = client->handle.guest_id;
ffffffffea80c300:	b81e8281 	stur	w1, [x20, #-24]
	handle_notify(&client->handle);
ffffffffea80c304:	97fff78d 	bl	ffffffffea80a138 <handle_notify>
ffffffffea80c308:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea80c30c:	17ffffd1 	b	ffffffffea80c250 <ipc_port_accept+0x130>
	ASSERT(chan->peer == NULL);
ffffffffea80c310:	f9401000 	ldr	x0, [x0, #32]
ffffffffea80c314:	b5000540 	cbnz	x0, ffffffffea80c3bc <ipc_port_accept+0x29c>
	if (item->prev == 0 && item->next == 0)
ffffffffea80c318:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80c31c:	b4000380 	cbz	x0, ffffffffea80c38c <ipc_port_accept+0x26c>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80c320:	d0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80c324:	d0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80c328:	b0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80c32c:	913de084 	add	x4, x4, #0xf78
ffffffffea80c330:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80c334:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80c338:	91330021 	add	x1, x1, #0xcc0
ffffffffea80c33c:	aa1703e0 	mov	x0, x23
ffffffffea80c340:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80c344:	940015b1 	bl	ffffffffea811a08 <_panic>
	ASSERT(chan->peer == NULL);
ffffffffea80c348:	f8580280 	ldur	x0, [x20, #-128]
ffffffffea80c34c:	b5000380 	cbnz	x0, ffffffffea80c3bc <ipc_port_accept+0x29c>
ffffffffea80c350:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80c354:	b5fffe60 	cbnz	x0, ffffffffea80c320 <ipc_port_accept+0x200>
ffffffffea80c358:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80c35c:	b5fffe20 	cbnz	x0, ffffffffea80c320 <ipc_port_accept+0x200>
	if (chan->path) {
ffffffffea80c360:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80c364:	b4000040 	cbz	x0, ffffffffea80c36c <ipc_port_accept+0x24c>
		free((void *)chan->path);
ffffffffea80c368:	94001b4c 	bl	ffffffffea813098 <free>
	if (chan->msg_queue) {
ffffffffea80c36c:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80c370:	b4000060 	cbz	x0, ffffffffea80c37c <ipc_port_accept+0x25c>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80c374:	9400014f 	bl	ffffffffea80c8b0 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80c378:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80c37c:	aa1303e0 	mov	x0, x19
ffffffffea80c380:	94001b46 	bl	ffffffffea813098 <free>
ffffffffea80c384:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80c388:	17ffff81 	b	ffffffffea80c18c <ipc_port_accept+0x6c>
ffffffffea80c38c:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80c390:	b5fffc80 	cbnz	x0, ffffffffea80c320 <ipc_port_accept+0x200>
	if (chan->path) {
ffffffffea80c394:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80c398:	b4000040 	cbz	x0, ffffffffea80c3a0 <ipc_port_accept+0x280>
		free((void *)chan->path);
ffffffffea80c39c:	94001b3f 	bl	ffffffffea813098 <free>
	if (chan->msg_queue) {
ffffffffea80c3a0:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80c3a4:	b4000060 	cbz	x0, ffffffffea80c3b0 <ipc_port_accept+0x290>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80c3a8:	94000142 	bl	ffffffffea80c8b0 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80c3ac:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80c3b0:	aa1303e0 	mov	x0, x19
ffffffffea80c3b4:	94001b39 	bl	ffffffffea813098 <free>
ffffffffea80c3b8:	17ffff9c 	b	ffffffffea80c228 <ipc_port_accept+0x108>
	ASSERT(chan->peer == NULL);
ffffffffea80c3bc:	d0000044 	adrp	x4, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80c3c0:	d0000042 	adrp	x2, ffffffffea816000 <__PRETTY_FUNCTION__.1974+0x108>
ffffffffea80c3c4:	b0000041 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea80c3c8:	913d8084 	add	x4, x4, #0xf60
ffffffffea80c3cc:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80c3d0:	913f6042 	add	x2, x2, #0xfd8
ffffffffea80c3d4:	91330021 	add	x1, x1, #0xcc0
ffffffffea80c3d8:	aa1703e0 	mov	x0, x23
ffffffffea80c3dc:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80c3e0:	9400158a 	bl	ffffffffea811a08 <_panic>
ffffffffea80c3e4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80c3e8 <sys_accept>:

long __SYSCALL sys_accept(uint32_t handle_id, user_addr_t user_uuid)
{
ffffffffea80c3e8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80c3ec:	910003fd 	mov	x29, sp
ffffffffea80c3f0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80c3f4:	2a0003f3 	mov	w19, w0
ffffffffea80c3f8:	f90013f5 	str	x21, [sp, #32]
ffffffffea80c3fc:	2a0103f5 	mov	w21, w1
	uctx_t *ctx = current_uctx();
ffffffffea80c400:	97fff896 	bl	ffffffffea80a658 <current_uctx>
	handle_t *phandle = NULL;
	handle_t *chandle = NULL;
ffffffffea80c404:	a903ffbf 	stp	xzr, xzr, [x29, #56]
	uctx_t *ctx = current_uctx();
ffffffffea80c408:	aa0003f4 	mov	x20, x0
	int ret;
	handle_id_t new_id;
	const uuid_t *peer_uuid_ptr;

	ret = uctx_handle_get(ctx, handle_id, &phandle);
ffffffffea80c40c:	9100e3a2 	add	x2, x29, #0x38
ffffffffea80c410:	2a1303e1 	mov	w1, w19
ffffffffea80c414:	97fff917 	bl	ffffffffea80a870 <uctx_handle_get>
	if (ret != NO_ERROR) {
ffffffffea80c418:	340000c0 	cbz	w0, ffffffffea80c430 <sys_accept+0x48>
		return (long) ret;
ffffffffea80c41c:	93407c00 	sxtw	x0, w0
err_install:
	handle_close(chandle);
err_accept:
	handle_decref(phandle);
	return (long) ret;
}
ffffffffea80c420:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c424:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80c428:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80c42c:	d65f03c0 	ret
	ret = ipc_port_accept(phandle, &chandle, &peer_uuid_ptr);
ffffffffea80c430:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c434:	910123a2 	add	x2, x29, #0x48
ffffffffea80c438:	910103a1 	add	x1, x29, #0x40
ffffffffea80c43c:	97ffff39 	bl	ffffffffea80c120 <ipc_port_accept>
ffffffffea80c440:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c444:	35000260 	cbnz	w0, ffffffffea80c490 <sys_accept+0xa8>
	ret = uctx_handle_install(ctx, chandle, &new_id);
ffffffffea80c448:	f94023a1 	ldr	x1, [x29, #64]
ffffffffea80c44c:	9100d3a2 	add	x2, x29, #0x34
ffffffffea80c450:	aa1403e0 	mov	x0, x20
ffffffffea80c454:	97fff8d5 	bl	ffffffffea80a7a8 <uctx_handle_install>
ffffffffea80c458:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c45c:	35000160 	cbnz	w0, ffffffffea80c488 <sys_accept+0xa0>
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea80c460:	f94027a1 	ldr	x1, [x29, #72]
ffffffffea80c464:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80c468:	2a1503e0 	mov	w0, w21
ffffffffea80c46c:	94001c7f 	bl	ffffffffea813668 <arch_copy_to_user>
ffffffffea80c470:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c474:	340001c0 	cbz	w0, ffffffffea80c4ac <sys_accept+0xc4>
	uctx_handle_remove(ctx, new_id, &chandle);
ffffffffea80c478:	b94037a1 	ldr	w1, [x29, #52]
ffffffffea80c47c:	910103a2 	add	x2, x29, #0x40
ffffffffea80c480:	aa1403e0 	mov	x0, x20
ffffffffea80c484:	97fff911 	bl	ffffffffea80a8c8 <uctx_handle_remove>
	handle_close(chandle);
ffffffffea80c488:	f94023a0 	ldr	x0, [x29, #64]
ffffffffea80c48c:	97fff6e7 	bl	ffffffffea80a028 <handle_close>
	handle_decref(phandle);
ffffffffea80c490:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c494:	97fff6bd 	bl	ffffffffea809f88 <handle_decref>
}
ffffffffea80c498:	f94013f5 	ldr	x21, [sp, #32]
	return (long) ret;
ffffffffea80c49c:	93407e60 	sxtw	x0, w19
}
ffffffffea80c4a0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c4a4:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80c4a8:	d65f03c0 	ret
	handle_decref(phandle);
ffffffffea80c4ac:	f9401fa0 	ldr	x0, [x29, #56]
ffffffffea80c4b0:	97fff6b6 	bl	ffffffffea809f88 <handle_decref>
	return (long) new_id;
ffffffffea80c4b4:	b94037a0 	ldr	w0, [x29, #52]
ffffffffea80c4b8:	17ffffda 	b	ffffffffea80c420 <sys_accept+0x38>
ffffffffea80c4bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80c4c0 <msg_get_filled_locked>:
	if (list->next != list) {
ffffffffea80c4c0:	f9400c01 	ldr	x1, [x0, #24]
 */
static void msg_get_filled_locked(ipc_msg_queue_t *mq)
{
	msg_item_t *item;

	item = list_peek_head_type(&mq->filled_list, msg_item_t, node);
ffffffffea80c4c4:	91004002 	add	x2, x0, #0x10
ffffffffea80c4c8:	f100003f 	cmp	x1, #0x0
ffffffffea80c4cc:	fa411044 	ccmp	x2, x1, #0x4, ne  // ne = any
ffffffffea80c4d0:	540001e0 	b.eq	ffffffffea80c50c <msg_get_filled_locked+0x4c>  // b.none
	item->next->prev = item->prev;
ffffffffea80c4d4:	a9401026 	ldp	x6, x4, [x1]
	item->prev = list->prev;
ffffffffea80c4d8:	aa0003e3 	mov	x3, x0
	DEBUG_ASSERT(item);

	list_delete(&item->node);
	list_add_tail(&mq->read_list, &item->node);
	item->state = MSG_ITEM_STATE_READ;
ffffffffea80c4dc:	52800045 	mov	w5, #0x2                   	// #2
	item->next->prev = item->prev;
ffffffffea80c4e0:	f9000086 	str	x6, [x4]
	item->prev->next = item->next;
ffffffffea80c4e4:	f9400026 	ldr	x6, [x1]
ffffffffea80c4e8:	f90004c4 	str	x4, [x6, #8]
	item->prev = item->next = 0;
ffffffffea80c4ec:	f900003f 	str	xzr, [x1]
	item->prev = list->prev;
ffffffffea80c4f0:	f8420c64 	ldr	x4, [x3, #32]!
	item->next = list;
ffffffffea80c4f4:	a9000c24 	stp	x4, x3, [x1]
	list->prev->next = item;
ffffffffea80c4f8:	f9401002 	ldr	x2, [x0, #32]
ffffffffea80c4fc:	f9000441 	str	x1, [x2, #8]
	list->prev = item;
ffffffffea80c500:	f9001001 	str	x1, [x0, #32]
ffffffffea80c504:	381d1025 	sturb	w5, [x1, #-47]
}
ffffffffea80c508:	d65f03c0 	ret
	item->next->prev = item->prev;
ffffffffea80c50c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80c510:	f9401c00 	ldr	x0, [x0, #56]
ffffffffea80c514:	d4207d00 	brk	#0x3e8

ffffffffea80c518 <check_channel_connected_locked>:
	if (unlikely(!chandle)) {
ffffffffea80c518:	b4000300 	cbz	x0, ffffffffea80c578 <check_channel_connected_locked+0x60>
{
ffffffffea80c51c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80c520:	910003fd 	mov	x29, sp
ffffffffea80c524:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80c528:	aa0003f3 	mov	x19, x0
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80c52c:	97fffca9 	bl	ffffffffea80b7d0 <ipc_is_channel>
ffffffffea80c530:	72001c1f 	tst	w0, #0xff
ffffffffea80c534:	54000100 	b.eq	ffffffffea80c554 <check_channel_connected_locked+0x3c>  // b.none
	if (likely(chan->state == IPC_CHAN_STATE_CONNECTED)) {
ffffffffea80c538:	b85e0261 	ldur	w1, [x19, #-32]
		return NO_ERROR;
ffffffffea80c53c:	52800000 	mov	w0, #0x0                   	// #0
	if (likely(chan->state == IPC_CHAN_STATE_CONNECTED)) {
ffffffffea80c540:	71000c3f 	cmp	w1, #0x3
ffffffffea80c544:	54000101 	b.ne	ffffffffea80c564 <check_channel_connected_locked+0x4c>  // b.any
}
ffffffffea80c548:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80c54c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80c550:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80c554:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80c558:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80c55c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80c560:	d65f03c0 	ret
		return ERR_NOT_READY;
ffffffffea80c564:	7100103f 	cmp	w1, #0x4
ffffffffea80c568:	128001c0 	mov	w0, #0xfffffff1            	// #-15
ffffffffea80c56c:	12800041 	mov	w1, #0xfffffffd            	// #-3
ffffffffea80c570:	1a810000 	csel	w0, w0, w1, eq  // eq = none
ffffffffea80c574:	17fffff5 	b	ffffffffea80c548 <check_channel_connected_locked+0x30>
		return ERR_INVALID_ARGS;
ffffffffea80c578:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80c57c:	d65f03c0 	ret

ffffffffea80c580 <msg_write_locked>:
{
ffffffffea80c580:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80c584:	910003fd 	mov	x29, sp
	ipc_msg_queue_t *mq = chan->peer->msg_queue;
ffffffffea80c588:	f9401002 	ldr	x2, [x0, #32]
{
ffffffffea80c58c:	a90153f3 	stp	x19, x20, [sp, #16]
	ipc_msg_queue_t *mq = chan->peer->msg_queue;
ffffffffea80c590:	f9405854 	ldr	x20, [x2, #176]
	if (list->next != list) {
ffffffffea80c594:	f9400693 	ldr	x19, [x20, #8]
	item = list_peek_head_type(&mq->free_list, msg_item_t, node);
ffffffffea80c598:	f100027f 	cmp	x19, #0x0
ffffffffea80c59c:	fa531284 	ccmp	x20, x19, #0x4, ne  // ne = any
ffffffffea80c5a0:	54000780 	b.eq	ffffffffea80c690 <msg_write_locked+0x110>  // b.none
ffffffffea80c5a4:	f90013b5 	str	x21, [x29, #32]
	if (item == NULL) {
ffffffffea80c5a8:	f100c27f 	cmp	x19, #0x30
	item = list_peek_head_type(&mq->free_list, msg_item_t, node);
ffffffffea80c5ac:	d100c275 	sub	x21, x19, #0x30
	if (item == NULL) {
ffffffffea80c5b0:	540006c0 	b.eq	ffffffffea80c688 <msg_write_locked+0x108>  // b.none
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80c5b4:	b9400023 	ldr	w3, [x1]
ffffffffea80c5b8:	aa0103e2 	mov	x2, x1
	return mq->buf + item->id * mq->item_sz;
ffffffffea80c5bc:	f9402284 	ldr	x4, [x20, #64]
	item->len = 0;
ffffffffea80c5c0:	f81f827f 	stur	xzr, [x19, #-8]
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80c5c4:	7100047f 	cmp	w3, #0x1
	return mq->buf + item->id * mq->item_sz;
ffffffffea80c5c8:	385d0260 	ldurb	w0, [x19, #-48]
	uint8_t *buf = msg_queue_get_buf(mq, item);
ffffffffea80c5cc:	f9401e81 	ldr	x1, [x20, #56]
	item->num_handles = 0;
ffffffffea80c5d0:	b81d427f 	stur	wzr, [x19, #-44]
	return mq->buf + item->id * mq->item_sz;
ffffffffea80c5d4:	d503201f 	nop
ffffffffea80c5d8:	9b011000 	madd	x0, x0, x1, x4
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80c5dc:	54000380 	b.eq	ffffffffea80c64c <msg_write_locked+0xcc>  // b.none
	} else if (msg->type == IPC_MSG_BUFFER_USER) {
ffffffffea80c5e0:	35000623 	cbnz	w3, ffffffffea80c6a4 <msg_write_locked+0x124>
		if (msg->user.num_handles) {
ffffffffea80c5e4:	b9401043 	ldr	w3, [x2, #16]
ffffffffea80c5e8:	350004a3 	cbnz	w3, ffffffffea80c67c <msg_write_locked+0xfc>
		ret = user_iovec_to_membuf(buf, mq->item_sz,
ffffffffea80c5ec:	29410843 	ldp	w3, w2, [x2, #8]
ffffffffea80c5f0:	94000326 	bl	ffffffffea80d288 <user_iovec_to_membuf>
ffffffffea80c5f4:	2a0003e2 	mov	w2, w0
	if (ret < 0) {
ffffffffea80c5f8:	b7f80380 	tbnz	x0, #63, ffffffffea80c668 <msg_write_locked+0xe8>
	item->next->prev = item->prev;
ffffffffea80c5fc:	a9430ea5 	ldp	x5, x3, [x21, #48]
	item->len = (size_t) ret;
ffffffffea80c600:	f81f8260 	stur	x0, [x19, #-8]
	item->prev = list->prev;
ffffffffea80c604:	aa1403e1 	mov	x1, x20
	list_delete(&item->node);
ffffffffea80c608:	9100c2a0 	add	x0, x21, #0x30
	item->state = MSG_ITEM_STATE_FILLED;
ffffffffea80c60c:	52800024 	mov	w4, #0x1                   	// #1
	item->next->prev = item->prev;
ffffffffea80c610:	f9000065 	str	x5, [x3]
	item->prev->next = item->next;
ffffffffea80c614:	f9401aa5 	ldr	x5, [x21, #48]
ffffffffea80c618:	f90004a3 	str	x3, [x5, #8]
	item->prev = item->next = 0;
ffffffffea80c61c:	f9001abf 	str	xzr, [x21, #48]
	item->prev = list->prev;
ffffffffea80c620:	f8410c23 	ldr	x3, [x1, #16]!
	item->next = list;
ffffffffea80c624:	a90306a3 	stp	x3, x1, [x21, #48]
	list->prev->next = item;
ffffffffea80c628:	f9400a81 	ldr	x1, [x20, #16]
ffffffffea80c62c:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea80c630:	f9000a80 	str	x0, [x20, #16]
ffffffffea80c634:	381d1264 	sturb	w4, [x19, #-47]
	return item->len;
ffffffffea80c638:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80c63c:	2a0203e0 	mov	w0, w2
ffffffffea80c640:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c644:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80c648:	d65f03c0 	ret
		if (msg->kern.num_handles) {
ffffffffea80c64c:	b9401843 	ldr	w3, [x2, #24]
ffffffffea80c650:	35000163 	cbnz	w3, ffffffffea80c67c <msg_write_locked+0xfc>
		ret = kern_iovec_to_membuf(buf, mq->item_sz,
ffffffffea80c654:	b9400843 	ldr	w3, [x2, #8]
ffffffffea80c658:	f9400842 	ldr	x2, [x2, #16]
ffffffffea80c65c:	94000285 	bl	ffffffffea80d070 <kern_iovec_to_membuf>
ffffffffea80c660:	2a0003e2 	mov	w2, w0
	if (ret < 0) {
ffffffffea80c664:	b6fffcc0 	tbz	x0, #63, ffffffffea80c5fc <msg_write_locked+0x7c>
ffffffffea80c668:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80c66c:	2a0203e0 	mov	w0, w2
ffffffffea80c670:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c674:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80c678:	d65f03c0 	ret
			return ERR_NOT_SUPPORTED;
ffffffffea80c67c:	128002e2 	mov	w2, #0xffffffe8            	// #-24
ffffffffea80c680:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c684:	17ffffee 	b	ffffffffea80c63c <msg_write_locked+0xbc>
ffffffffea80c688:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c68c:	d503201f 	nop
		chan->aux_state |= IPC_CHAN_AUX_STATE_SEND_BLOCKED;
ffffffffea80c690:	b9403801 	ldr	w1, [x0, #56]
		return ERR_NOT_ENOUGH_BUFFER;
ffffffffea80c694:	12800102 	mov	w2, #0xfffffff7            	// #-9
		chan->aux_state |= IPC_CHAN_AUX_STATE_SEND_BLOCKED;
ffffffffea80c698:	32000021 	orr	w1, w1, #0x1
ffffffffea80c69c:	b9003801 	str	w1, [x0, #56]
		return ERR_NOT_ENOUGH_BUFFER;
ffffffffea80c6a0:	17ffffe7 	b	ffffffffea80c63c <msg_write_locked+0xbc>
		return ERR_INVALID_ARGS;
ffffffffea80c6a4:	128000e2 	mov	w2, #0xfffffff8            	// #-8
ffffffffea80c6a8:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c6ac:	17ffffe4 	b	ffffffffea80c63c <msg_write_locked+0xbc>

ffffffffea80c6b0 <msg_read_locked>:
	if (id < mq->num_items) {
ffffffffea80c6b0:	b9403004 	ldr	w4, [x0, #48]
ffffffffea80c6b4:	6b04003f 	cmp	w1, w4
ffffffffea80c6b8:	54000702 	b.cs	ffffffffea80c798 <msg_read_locked+0xe8>  // b.hs, b.nlast
{
ffffffffea80c6bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80c6c0:	910003fd 	mov	x29, sp
ffffffffea80c6c4:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80c6c8:	2a0103f3 	mov	w19, w1
ffffffffea80c6cc:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80c6d0:	aa0003f4 	mov	x20, x0
ffffffffea80c6d4:	2a0203f6 	mov	w22, w2
ffffffffea80c6d8:	aa0303f5 	mov	x21, x3
		platform_arch_speculation_barrier();
ffffffffea80c6dc:	97ffd6b7 	bl	ffffffffea8021b8 <platform_arch_speculation_barrier>
		return &mq->items[id];
ffffffffea80c6e0:	2a1303e1 	mov	w1, w19
ffffffffea80c6e4:	8b011a80 	add	x0, x20, x1, lsl #6
ffffffffea80c6e8:	d37ae421 	lsl	x1, x1, #6
ffffffffea80c6ec:	91012021 	add	x1, x1, #0x48
	if (item->state != MSG_ITEM_STATE_READ) {
ffffffffea80c6f0:	39412402 	ldrb	w2, [x0, #73]
ffffffffea80c6f4:	7100085f 	cmp	w2, #0x2
ffffffffea80c6f8:	54000421 	b.ne	ffffffffea80c77c <msg_read_locked+0xcc>  // b.any
	if (item->num_handles) {
ffffffffea80c6fc:	b9404c02 	ldr	w2, [x0, #76]
ffffffffea80c700:	35000482 	cbnz	w2, ffffffffea80c790 <msg_read_locked+0xe0>
	if (offset > item->len) {
ffffffffea80c704:	f9403803 	ldr	x3, [x0, #112]
ffffffffea80c708:	2a1603e0 	mov	w0, w22
ffffffffea80c70c:	eb03001f 	cmp	x0, x3
ffffffffea80c710:	54000368 	b.hi	ffffffffea80c77c <msg_read_locked+0xcc>  // b.pmore
	const uint8_t *buf = msg_queue_get_buf(mq, item) + offset;
ffffffffea80c714:	a9438a85 	ldp	x5, x2, [x20, #56]
	size_t bytes_left = item->len - offset;
ffffffffea80c718:	cb000063 	sub	x3, x3, x0
	return mq->buf + item->id * mq->item_sz;
ffffffffea80c71c:	38616a81 	ldrb	w1, [x20, x1]
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80c720:	b94002a4 	ldr	w4, [x21]
ffffffffea80c724:	7100049f 	cmp	w4, #0x1
	const uint8_t *buf = msg_queue_get_buf(mq, item) + offset;
ffffffffea80c728:	9b050020 	madd	x0, x1, x5, x0
ffffffffea80c72c:	8b000042 	add	x2, x2, x0
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80c730:	54000140 	b.eq	ffffffffea80c758 <msg_read_locked+0xa8>  // b.none
	} else if (msg->type == IPC_MSG_BUFFER_USER) {
ffffffffea80c734:	35000244 	cbnz	w4, ffffffffea80c77c <msg_read_locked+0xcc>
		if (msg->user.num_handles) {
ffffffffea80c738:	b94012a0 	ldr	w0, [x21, #16]
ffffffffea80c73c:	350002a0 	cbnz	w0, ffffffffea80c790 <msg_read_locked+0xe0>
		return membuf_to_user_iovec(msg->user.iov, msg->user.num_iov,
ffffffffea80c740:	294102a1 	ldp	w1, w0, [x21, #8]
ffffffffea80c744:	94000291 	bl	ffffffffea80d188 <membuf_to_user_iovec>
}
ffffffffea80c748:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c74c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80c750:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80c754:	d65f03c0 	ret
		if (msg->kern.num_handles) {
ffffffffea80c758:	b9401aa0 	ldr	w0, [x21, #24]
ffffffffea80c75c:	350001a0 	cbnz	w0, ffffffffea80c790 <msg_read_locked+0xe0>
		return membuf_to_kern_iovec((const iovec_kern_t *)msg->kern.iov,
ffffffffea80c760:	b9400aa1 	ldr	w1, [x21, #8]
ffffffffea80c764:	f9400aa0 	ldr	x0, [x21, #16]
ffffffffea80c768:	940001fc 	bl	ffffffffea80cf58 <membuf_to_kern_iovec>
}
ffffffffea80c76c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c770:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80c774:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80c778:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80c77c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80c780:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c784:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80c788:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80c78c:	d65f03c0 	ret
		return ERR_NOT_SUPPORTED;
ffffffffea80c790:	128002e0 	mov	w0, #0xffffffe8            	// #-24
ffffffffea80c794:	17ffffed 	b	ffffffffea80c748 <msg_read_locked+0x98>
		return ERR_INVALID_ARGS;
ffffffffea80c798:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80c79c:	d65f03c0 	ret

ffffffffea80c7a0 <ipc_msg_queue_create>:
{
ffffffffea80c7a0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80c7a4:	910003fd 	mov	x29, sp
ffffffffea80c7a8:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea80c7ac:	2a0003f7 	mov	w23, w0
ffffffffea80c7b0:	aa0103f6 	mov	x22, x1
ffffffffea80c7b4:	f9000ff4 	str	x20, [sp, #24]
	tmp_mq = calloc(1, (sizeof(ipc_msg_queue_t) +
ffffffffea80c7b8:	d37a7ee1 	ubfiz	x1, x23, #6, #32
ffffffffea80c7bc:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80c7c0:	91012021 	add	x1, x1, #0x48
{
ffffffffea80c7c4:	aa0203f4 	mov	x20, x2
	tmp_mq = calloc(1, (sizeof(ipc_msg_queue_t) +
ffffffffea80c7c8:	94001a24 	bl	ffffffffea813058 <calloc>
	if (!tmp_mq) {
ffffffffea80c7cc:	b4000560 	cbz	x0, ffffffffea80c878 <ipc_msg_queue_create+0xd8>
ffffffffea80c7d0:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80c7d4:	aa0003f3 	mov	x19, x0
	tmp_mq->buf = malloc(num_items * item_sz);
ffffffffea80c7d8:	9b167ee0 	mul	x0, x23, x22
ffffffffea80c7dc:	94001a19 	bl	ffffffffea813040 <malloc>
ffffffffea80c7e0:	f9002260 	str	x0, [x19, #64]
	if (!tmp_mq->buf) {
ffffffffea80c7e4:	b4000540 	cbz	x0, ffffffffea80c88c <ipc_msg_queue_create+0xec>
ffffffffea80c7e8:	f90013b5 	str	x21, [x29, #32]
	list_initialize(&tmp_mq->filled_list);
ffffffffea80c7ec:	91004261 	add	x1, x19, #0x10
	list_initialize(&tmp_mq->read_list);
ffffffffea80c7f0:	91008260 	add	x0, x19, #0x20
	list->prev = list->next = list;
ffffffffea80c7f4:	a9004e73 	stp	x19, x19, [x19]
ffffffffea80c7f8:	a9010661 	stp	x1, x1, [x19, #16]
ffffffffea80c7fc:	aa1703f5 	mov	x21, x23
ffffffffea80c800:	a9020260 	stp	x0, x0, [x19, #32]
	tmp_mq->num_items = num_items;
ffffffffea80c804:	b9003277 	str	w23, [x19, #48]
	tmp_mq->item_sz = item_sz;
ffffffffea80c808:	f9001e76 	str	x22, [x19, #56]
	for (uint i = 0; i < num_items; i++) {
ffffffffea80c80c:	34000277 	cbz	w23, ffffffffea80c858 <ipc_msg_queue_create+0xb8>
ffffffffea80c810:	9101e260 	add	x0, x19, #0x78
ffffffffea80c814:	aa1303e2 	mov	x2, x19
ffffffffea80c818:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea80c81c:	14000002 	b	ffffffffea80c824 <ipc_msg_queue_create+0x84>
ffffffffea80c820:	2a0403e3 	mov	w3, w4
		tmp_mq->items[i].id = i;
ffffffffea80c824:	381d0003 	sturb	w3, [x0, #-48]
	for (uint i = 0; i < num_items; i++) {
ffffffffea80c828:	11000464 	add	w4, w3, #0x1
	item->next = list;
ffffffffea80c82c:	a9004c02 	stp	x2, x19, [x0]
ffffffffea80c830:	6b0402bf 	cmp	w21, w4
	list->prev->next = item;
ffffffffea80c834:	f9000440 	str	x0, [x2, #8]
ffffffffea80c838:	aa0003e2 	mov	x2, x0
ffffffffea80c83c:	91010000 	add	x0, x0, #0x40
ffffffffea80c840:	54ffff01 	b.ne	ffffffffea80c820 <ipc_msg_queue_create+0x80>  // b.any
ffffffffea80c844:	d37a7c60 	ubfiz	x0, x3, #6, #32
ffffffffea80c848:	9101e000 	add	x0, x0, #0x78
ffffffffea80c84c:	8b000260 	add	x0, x19, x0
ffffffffea80c850:	f9000260 	str	x0, [x19]
ffffffffea80c854:	d503201f 	nop
	return 0;
ffffffffea80c858:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c85c:	52800000 	mov	w0, #0x0                   	// #0
	*mq = tmp_mq;
ffffffffea80c860:	f9000293 	str	x19, [x20]
	return 0;
ffffffffea80c864:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea80c868:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80c86c:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80c870:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80c874:	d65f03c0 	ret
		dprintf(CRITICAL, "cannot allocate memory for message queue\n");
ffffffffea80c878:	f0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80c87c:	9101a000 	add	x0, x0, #0x68
ffffffffea80c880:	940013e4 	bl	ffffffffea811810 <_dprintf>
		return ERR_NO_MEMORY;
ffffffffea80c884:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea80c888:	17fffff8 	b	ffffffffea80c868 <ipc_msg_queue_create+0xc8>
		dprintf(CRITICAL,
ffffffffea80c88c:	f0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80c890:	91026000 	add	x0, x0, #0x98
ffffffffea80c894:	940013df 	bl	ffffffffea811810 <_dprintf>
	free(tmp_mq);
ffffffffea80c898:	aa1303e0 	mov	x0, x19
ffffffffea80c89c:	940019ff 	bl	ffffffffea813098 <free>
	return ret;
ffffffffea80c8a0:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea80c8a4:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80c8a8:	17fffff0 	b	ffffffffea80c868 <ipc_msg_queue_create+0xc8>
ffffffffea80c8ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80c8b0 <ipc_msg_queue_destroy>:
{
ffffffffea80c8b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80c8b4:	910003fd 	mov	x29, sp
ffffffffea80c8b8:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80c8bc:	aa0003f3 	mov	x19, x0
	free(mq->buf);
ffffffffea80c8c0:	f9402000 	ldr	x0, [x0, #64]
ffffffffea80c8c4:	940019f5 	bl	ffffffffea813098 <free>
	free(mq);
ffffffffea80c8c8:	aa1303e0 	mov	x0, x19
}
ffffffffea80c8cc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80c8d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(mq);
ffffffffea80c8d4:	140019f1 	b	ffffffffea813098 <free>

ffffffffea80c8d8 <ipc_msg_queue_is_empty>:
	return list_is_empty(&mq->filled_list);
ffffffffea80c8d8:	91004001 	add	x1, x0, #0x10
	return (list->next == list) ? true : false;
ffffffffea80c8dc:	f9400c00 	ldr	x0, [x0, #24]
ffffffffea80c8e0:	eb01001f 	cmp	x0, x1
}
ffffffffea80c8e4:	1a9f17e0 	cset	w0, eq  // eq = none
ffffffffea80c8e8:	d65f03c0 	ret
ffffffffea80c8ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80c8f0 <sys_send_msg>:
	return NO_ERROR;
}


long __SYSCALL sys_send_msg(uint32_t handle_id, user_addr_t user_msg)
{
ffffffffea80c8f0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	return arch_copy_from_user(kdest, usrc, len);
ffffffffea80c8f4:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80c8f8:	910003fd 	mov	x29, sp
ffffffffea80c8fc:	a90153f3 	stp	x19, x20, [sp, #16]
	handle_t  *chandle;
	msg_desc_t tmp_msg;
	int ret;

	/* copy message descriptor from user space */
	tmp_msg.type = IPC_MSG_BUFFER_USER;
ffffffffea80c900:	910183b4 	add	x20, x29, #0x60
{
ffffffffea80c904:	2a0003f3 	mov	w19, w0
	tmp_msg.type = IPC_MSG_BUFFER_USER;
ffffffffea80c908:	b81d8e9f 	str	wzr, [x20, #-40]!
ffffffffea80c90c:	91002280 	add	x0, x20, #0x8
ffffffffea80c910:	94001b5e 	bl	ffffffffea813688 <arch_copy_from_user>
	ret = copy_from_user(&tmp_msg.user, user_msg, sizeof(ipc_msg_user_t));
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80c914:	350004a0 	cbnz	w0, ffffffffea80c9a8 <sys_send_msg+0xb8>
		return (long) ret;
	}
	/* grab handle */
	ret = uctx_handle_get(current_uctx(), handle_id, &chandle);
ffffffffea80c918:	97fff750 	bl	ffffffffea80a658 <current_uctx>
ffffffffea80c91c:	9100c3a2 	add	x2, x29, #0x30
ffffffffea80c920:	2a1303e1 	mov	w1, w19
ffffffffea80c924:	97fff7d3 	bl	ffffffffea80a870 <uctx_handle_get>
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80c928:	35000400 	cbnz	w0, ffffffffea80c9a8 <sys_send_msg+0xb8>
ffffffffea80c92c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80c930:	f90013b5 	str	x21, [x29, #32]
ffffffffea80c934:	90000075 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea80c938:	913722a0 	add	x0, x21, #0xdc8
ffffffffea80c93c:	97ffe3eb 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
		return (long) ret;
	}
	mutex_acquire(&ipc_lock);
	/* check if it is  avalid channel to call send_msg */
	ret = check_channel_connected_locked(chandle);
ffffffffea80c940:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80c944:	97fffef5 	bl	ffffffffea80c518 <check_channel_connected_locked>
ffffffffea80c948:	2a0003f3 	mov	w19, w0
	if (likely(ret == NO_ERROR)) {
ffffffffea80c94c:	35000120 	cbnz	w0, ffffffffea80c970 <sys_send_msg+0x80>
ffffffffea80c950:	f90017b6 	str	x22, [x29, #40]
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		/* do write message to target channel  */
		ret = msg_write_locked(chan, &tmp_msg);
ffffffffea80c954:	aa1403e1 	mov	x1, x20
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
ffffffffea80c958:	f9401bb6 	ldr	x22, [x29, #48]
		ret = msg_write_locked(chan, &tmp_msg);
ffffffffea80c95c:	d10142c0 	sub	x0, x22, #0x50
ffffffffea80c960:	97ffff08 	bl	ffffffffea80c580 <msg_write_locked>
ffffffffea80c964:	2a0003f3 	mov	w19, w0
		if (ret >= 0) {
ffffffffea80c968:	36f80160 	tbz	w0, #31, ffffffffea80c994 <sys_send_msg+0xa4>
ffffffffea80c96c:	f94017b6 	ldr	x22, [x29, #40]
			/* and notify target */
			handle_notify(&chan->peer->handle);
		}
	}
	mutex_release(&ipc_lock);
ffffffffea80c970:	913722a0 	add	x0, x21, #0xdc8
ffffffffea80c974:	97ffe409 	bl	ffffffffea805998 <mutex_release>
	handle_decref(chandle);
ffffffffea80c978:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80c97c:	97fff583 	bl	ffffffffea809f88 <handle_decref>
	return (long) ret;
ffffffffea80c980:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c984:	93407e60 	sxtw	x0, w19
}
ffffffffea80c988:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c98c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80c990:	d65f03c0 	ret
			handle_notify(&chan->peer->handle);
ffffffffea80c994:	f85d02c0 	ldur	x0, [x22, #-48]
ffffffffea80c998:	91014000 	add	x0, x0, #0x50
ffffffffea80c99c:	97fff5e7 	bl	ffffffffea80a138 <handle_notify>
ffffffffea80c9a0:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c9a4:	17fffff3 	b	ffffffffea80c970 <sys_send_msg+0x80>
}
ffffffffea80c9a8:	a94153f3 	ldp	x19, x20, [sp, #16]
		return (long) ret;
ffffffffea80c9ac:	93407c00 	sxtw	x0, w0
}
ffffffffea80c9b0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80c9b4:	d65f03c0 	ret

ffffffffea80c9b8 <ipc_send_msg>:

int ipc_send_msg(handle_t *chandle, ipc_msg_kern_t *msg)
{
ffffffffea80c9b8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80c9bc:	910003fd 	mov	x29, sp
ffffffffea80c9c0:	f90013f5 	str	x21, [sp, #32]
	int ret;
	msg_desc_t tmp_msg;

	if (!msg) {
ffffffffea80c9c4:	b4000461 	cbz	x1, ffffffffea80ca50 <ipc_send_msg+0x98>
ffffffffea80c9c8:	a90153b3 	stp	x19, x20, [x29, #16]
		return ERR_INVALID_ARGS;
	}
	tmp_msg.type = IPC_MSG_BUFFER_KERNEL;
ffffffffea80c9cc:	910183b4 	add	x20, x29, #0x60
ffffffffea80c9d0:	f90017b6 	str	x22, [x29, #40]
ffffffffea80c9d4:	aa0003f3 	mov	x19, x0
ffffffffea80c9d8:	52800020 	mov	w0, #0x1                   	// #1
	memcpy(&tmp_msg.kern, msg, sizeof(ipc_msg_kern_t));
ffffffffea80c9dc:	d2800402 	mov	x2, #0x20                  	// #32
	tmp_msg.type = IPC_MSG_BUFFER_KERNEL;
ffffffffea80c9e0:	b81d8e80 	str	w0, [x20, #-40]!
ffffffffea80c9e4:	90000076 	adrp	x22, ffffffffea818000 <_mem_phys_base>
	memcpy(&tmp_msg.kern, msg, sizeof(ipc_msg_kern_t));
ffffffffea80c9e8:	91002280 	add	x0, x20, #0x8
ffffffffea80c9ec:	940019ad 	bl	ffffffffea8130a0 <memcpy>
ffffffffea80c9f0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80c9f4:	913722c0 	add	x0, x22, #0xdc8
ffffffffea80c9f8:	97ffe3bc 	bl	ffffffffea8058e8 <mutex_acquire_timeout>

	mutex_acquire(&ipc_lock);
	ret = check_channel_connected_locked(chandle);
ffffffffea80c9fc:	aa1303e0 	mov	x0, x19
ffffffffea80ca00:	97fffec6 	bl	ffffffffea80c518 <check_channel_connected_locked>
ffffffffea80ca04:	2a0003f5 	mov	w21, w0
	if (likely(ret == NO_ERROR)) {
ffffffffea80ca08:	350000c0 	cbnz	w0, ffffffffea80ca20 <ipc_send_msg+0x68>
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		ret = msg_write_locked(chan, &tmp_msg);
ffffffffea80ca0c:	aa1403e1 	mov	x1, x20
ffffffffea80ca10:	d1014260 	sub	x0, x19, #0x50
ffffffffea80ca14:	97fffedb 	bl	ffffffffea80c580 <msg_write_locked>
ffffffffea80ca18:	2a0003f5 	mov	w21, w0
		if (ret >= 0) {
ffffffffea80ca1c:	36f80120 	tbz	w0, #31, ffffffffea80ca40 <ipc_send_msg+0x88>
			handle_notify(&chan->peer->handle);
		}
	}
	mutex_release(&ipc_lock);
ffffffffea80ca20:	913722c0 	add	x0, x22, #0xdc8
ffffffffea80ca24:	97ffe3dd 	bl	ffffffffea805998 <mutex_release>
	return ret;
ffffffffea80ca28:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80ca2c:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea80ca30:	2a1503e0 	mov	w0, w21
ffffffffea80ca34:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ca38:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80ca3c:	d65f03c0 	ret
			handle_notify(&chan->peer->handle);
ffffffffea80ca40:	f85d0260 	ldur	x0, [x19, #-48]
ffffffffea80ca44:	91014000 	add	x0, x0, #0x50
ffffffffea80ca48:	97fff5bc 	bl	ffffffffea80a138 <handle_notify>
ffffffffea80ca4c:	17fffff5 	b	ffffffffea80ca20 <ipc_send_msg+0x68>
		return ERR_INVALID_ARGS;
ffffffffea80ca50:	128000f5 	mov	w21, #0xfffffff8            	// #-8
ffffffffea80ca54:	17fffff7 	b	ffffffffea80ca30 <ipc_send_msg+0x78>

ffffffffea80ca58 <sys_get_msg>:

long __SYSCALL sys_get_msg(uint32_t handle_id, user_addr_t user_msg_info)
{
ffffffffea80ca58:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80ca5c:	910003fd 	mov	x29, sp
ffffffffea80ca60:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80ca64:	2a0003f3 	mov	w19, w0
ffffffffea80ca68:	f90013f5 	str	x21, [sp, #32]
ffffffffea80ca6c:	2a0103f5 	mov	w21, w1
	handle_t *chandle;
	ipc_msg_info_t msg_info;
	int ret;

	/* grab handle */
	ret = uctx_handle_get(current_uctx(), handle_id, &chandle);
ffffffffea80ca70:	97fff6fa 	bl	ffffffffea80a658 <current_uctx>
ffffffffea80ca74:	2a1303e1 	mov	w1, w19
ffffffffea80ca78:	9100c3a2 	add	x2, x29, #0x30
ffffffffea80ca7c:	97fff77d 	bl	ffffffffea80a870 <uctx_handle_get>
	if (ret != NO_ERROR) {
		return (long) ret;
ffffffffea80ca80:	93407c13 	sxtw	x19, w0
	if (ret != NO_ERROR) {
ffffffffea80ca84:	340000c0 	cbz	w0, ffffffffea80ca9c <sys_get_msg+0x44>
		}
	}
	mutex_release(&ipc_lock);
	handle_decref(chandle);
	return (long) ret;
}
ffffffffea80ca88:	aa1303e0 	mov	x0, x19
ffffffffea80ca8c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80ca90:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ca94:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80ca98:	d65f03c0 	ret
ffffffffea80ca9c:	f90017b6 	str	x22, [x29, #40]
ffffffffea80caa0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80caa4:	90000076 	adrp	x22, ffffffffea818000 <_mem_phys_base>
ffffffffea80caa8:	913722c0 	add	x0, x22, #0xdc8
ffffffffea80caac:	97ffe38f 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	ret = check_channel_locked(chandle);
ffffffffea80cab0:	f9401ba0 	ldr	x0, [x29, #48]
	if (unlikely(!chandle)) {
ffffffffea80cab4:	b4000520 	cbz	x0, ffffffffea80cb58 <sys_get_msg+0x100>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80cab8:	97fffb46 	bl	ffffffffea80b7d0 <ipc_is_channel>
ffffffffea80cabc:	72001c1f 	tst	w0, #0xff
ffffffffea80cac0:	540004c0 	b.eq	ffffffffea80cb58 <sys_get_msg+0x100>  // b.none
ffffffffea80cac4:	f9000fb4 	str	x20, [x29, #24]
	item = list_peek_head_type(&mq->filled_list, msg_item_t, node);
ffffffffea80cac8:	92800073 	mov	x19, #0xfffffffffffffffc    	// #-4
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
ffffffffea80cacc:	f9401bb4 	ldr	x20, [x29, #48]
ffffffffea80cad0:	d1014294 	sub	x20, x20, #0x50
		ret = msg_peek_next_filled_locked(chan->msg_queue, &msg_info);
ffffffffea80cad4:	f9405a80 	ldr	x0, [x20, #176]
	item = list_peek_head_type(&mq->filled_list, msg_item_t, node);
ffffffffea80cad8:	91004001 	add	x1, x0, #0x10
	if (list->next != list) {
ffffffffea80cadc:	f9400c03 	ldr	x3, [x0, #24]
ffffffffea80cae0:	f100007f 	cmp	x3, #0x0
ffffffffea80cae4:	fa431024 	ccmp	x1, x3, #0x4, ne  // ne = any
ffffffffea80cae8:	54000181 	b.ne	ffffffffea80cb18 <sys_get_msg+0xc0>  // b.any
ffffffffea80caec:	f9400fb4 	ldr	x20, [x29, #24]
	mutex_release(&ipc_lock);
ffffffffea80caf0:	913722c0 	add	x0, x22, #0xdc8
ffffffffea80caf4:	97ffe3a9 	bl	ffffffffea805998 <mutex_release>
	handle_decref(chandle);
ffffffffea80caf8:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80cafc:	97fff523 	bl	ffffffffea809f88 <handle_decref>
ffffffffea80cb00:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea80cb04:	aa1303e0 	mov	x0, x19
ffffffffea80cb08:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cb0c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80cb10:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80cb14:	d65f03c0 	ret
	if (!item) {
ffffffffea80cb18:	f100c07f 	cmp	x3, #0x30
ffffffffea80cb1c:	54fffe80 	b.eq	ffffffffea80caec <sys_get_msg+0x94>  // b.none
	info->len = item->len;
ffffffffea80cb20:	f85f8060 	ldur	x0, [x3, #-8]
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea80cb24:	d2800102 	mov	x2, #0x8                   	// #8
ffffffffea80cb28:	b9003ba0 	str	w0, [x29, #56]
ffffffffea80cb2c:	9100e3a1 	add	x1, x29, #0x38
ffffffffea80cb30:	2a1503e0 	mov	w0, w21
	info->id  = item->id;
ffffffffea80cb34:	385d0063 	ldurb	w3, [x3, #-48]
ffffffffea80cb38:	b9003fa3 	str	w3, [x29, #60]
ffffffffea80cb3c:	94001acb 	bl	ffffffffea813668 <arch_copy_to_user>
			if (likely(ret == NO_ERROR)) {
ffffffffea80cb40:	35000100 	cbnz	w0, ffffffffea80cb60 <sys_get_msg+0x108>
				msg_get_filled_locked(chan->msg_queue);
ffffffffea80cb44:	f9405a80 	ldr	x0, [x20, #176]
ffffffffea80cb48:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea80cb4c:	97fffe5d 	bl	ffffffffea80c4c0 <msg_get_filled_locked>
ffffffffea80cb50:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80cb54:	17ffffe7 	b	ffffffffea80caf0 <sys_get_msg+0x98>
	if (!item) {
ffffffffea80cb58:	928000f3 	mov	x19, #0xfffffffffffffff8    	// #-8
ffffffffea80cb5c:	17ffffe5 	b	ffffffffea80caf0 <sys_get_msg+0x98>
ffffffffea80cb60:	93407c13 	sxtw	x19, w0
ffffffffea80cb64:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80cb68:	17ffffe2 	b	ffffffffea80caf0 <sys_get_msg+0x98>
ffffffffea80cb6c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80cb70 <ipc_get_msg>:

int ipc_get_msg(handle_t *chandle, ipc_msg_info_t *msg_info)
{
ffffffffea80cb70:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80cb74:	910003fd 	mov	x29, sp
ffffffffea80cb78:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80cb7c:	aa0003f3 	mov	x19, x0
ffffffffea80cb80:	f90013f5 	str	x21, [sp, #32]
ffffffffea80cb84:	90000074 	adrp	x20, ffffffffea818000 <_mem_phys_base>
ffffffffea80cb88:	aa0103f5 	mov	x21, x1
ffffffffea80cb8c:	91372280 	add	x0, x20, #0xdc8
ffffffffea80cb90:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80cb94:	97ffe355 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	if (unlikely(!chandle)) {
ffffffffea80cb98:	b4000453 	cbz	x19, ffffffffea80cc20 <ipc_get_msg+0xb0>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80cb9c:	aa1303e0 	mov	x0, x19
ffffffffea80cba0:	97fffb0c 	bl	ffffffffea80b7d0 <ipc_is_channel>
ffffffffea80cba4:	72001c1f 	tst	w0, #0xff
ffffffffea80cba8:	540003c0 	b.eq	ffffffffea80cc20 <ipc_get_msg+0xb0>  // b.none
	/* check if channel handle */
	ret = check_channel_locked(chandle);
	if (likely(ret == NO_ERROR)) {
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		/* peek next filled message */
		ret  = msg_peek_next_filled_locked(chan->msg_queue, msg_info);
ffffffffea80cbac:	f9403260 	ldr	x0, [x19, #96]
		return ERR_NO_MSG;
ffffffffea80cbb0:	12800073 	mov	w19, #0xfffffffc            	// #-4
	item = list_peek_head_type(&mq->filled_list, msg_item_t, node);
ffffffffea80cbb4:	91004002 	add	x2, x0, #0x10
ffffffffea80cbb8:	f9400c01 	ldr	x1, [x0, #24]
ffffffffea80cbbc:	f100003f 	cmp	x1, #0x0
ffffffffea80cbc0:	fa411044 	ccmp	x2, x1, #0x4, ne  // ne = any
ffffffffea80cbc4:	54000101 	b.ne	ffffffffea80cbe4 <ipc_get_msg+0x74>  // b.any
		if (likely(ret == NO_ERROR)) {
			/* and make it readable */
			msg_get_filled_locked(chan->msg_queue);
		}
	}
	mutex_release(&ipc_lock);
ffffffffea80cbc8:	91372280 	add	x0, x20, #0xdc8
ffffffffea80cbcc:	97ffe373 	bl	ffffffffea805998 <mutex_release>
	return ret;
}
ffffffffea80cbd0:	2a1303e0 	mov	w0, w19
ffffffffea80cbd4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80cbd8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80cbdc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cbe0:	d65f03c0 	ret
	if (!item) {
ffffffffea80cbe4:	f100c03f 	cmp	x1, #0x30
ffffffffea80cbe8:	54ffff00 	b.eq	ffffffffea80cbc8 <ipc_get_msg+0x58>  // b.none
	info->len = item->len;
ffffffffea80cbec:	f85f8022 	ldur	x2, [x1, #-8]
	return NO_ERROR;
ffffffffea80cbf0:	52800013 	mov	w19, #0x0                   	// #0
	info->len = item->len;
ffffffffea80cbf4:	b90002a2 	str	w2, [x21]
	info->id  = item->id;
ffffffffea80cbf8:	385d0021 	ldurb	w1, [x1, #-48]
ffffffffea80cbfc:	b90006a1 	str	w1, [x21, #4]
			msg_get_filled_locked(chan->msg_queue);
ffffffffea80cc00:	97fffe30 	bl	ffffffffea80c4c0 <msg_get_filled_locked>
	mutex_release(&ipc_lock);
ffffffffea80cc04:	91372280 	add	x0, x20, #0xdc8
ffffffffea80cc08:	97ffe364 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea80cc0c:	2a1303e0 	mov	w0, w19
ffffffffea80cc10:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80cc14:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80cc18:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cc1c:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80cc20:	128000f3 	mov	w19, #0xfffffff8            	// #-8
	mutex_release(&ipc_lock);
ffffffffea80cc24:	91372280 	add	x0, x20, #0xdc8
ffffffffea80cc28:	97ffe35c 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea80cc2c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80cc30:	2a1303e0 	mov	w0, w19
ffffffffea80cc34:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80cc38:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cc3c:	d65f03c0 	ret

ffffffffea80cc40 <ipc_put_msg>:

	return (long) ret;
}

int ipc_put_msg(handle_t *chandle, uint32_t msg_id)
{
ffffffffea80cc40:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80cc44:	910003fd 	mov	x29, sp
ffffffffea80cc48:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80cc4c:	2a0103f3 	mov	w19, w1
ffffffffea80cc50:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80cc54:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80cc58:	aa0003f6 	mov	x22, x0
ffffffffea80cc5c:	90000075 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea80cc60:	913722a0 	add	x0, x21, #0xdc8
ffffffffea80cc64:	97ffe321 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	if (unlikely(!chandle)) {
ffffffffea80cc68:	b4000776 	cbz	x22, ffffffffea80cd54 <ipc_put_msg+0x114>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80cc6c:	aa1603e0 	mov	x0, x22
ffffffffea80cc70:	97fffad8 	bl	ffffffffea80b7d0 <ipc_is_channel>
ffffffffea80cc74:	72001c1f 	tst	w0, #0xff
ffffffffea80cc78:	540006e0 	b.eq	ffffffffea80cd54 <ipc_put_msg+0x114>  // b.none
ffffffffea80cc7c:	f9000fb4 	str	x20, [x29, #24]
	ipc_msg_queue_t *mq = chan->msg_queue;
ffffffffea80cc80:	f94032d4 	ldr	x20, [x22, #96]
	if (id < mq->num_items) {
ffffffffea80cc84:	b9403280 	ldr	w0, [x20, #48]
ffffffffea80cc88:	6b00027f 	cmp	w19, w0
ffffffffea80cc8c:	54000622 	b.cs	ffffffffea80cd50 <ipc_put_msg+0x110>  // b.hs, b.nlast
		platform_arch_speculation_barrier();
ffffffffea80cc90:	97ffd54a 	bl	ffffffffea8021b8 <platform_arch_speculation_barrier>
ffffffffea80cc94:	91000660 	add	x0, x19, #0x1
ffffffffea80cc98:	8b131a93 	add	x19, x20, x19, lsl #6
ffffffffea80cc9c:	d37ae400 	lsl	x0, x0, #6
	if (!item || item->state != MSG_ITEM_STATE_READ) {
ffffffffea80cca0:	39412662 	ldrb	w2, [x19, #73]
		return &mq->items[id];
ffffffffea80cca4:	91002001 	add	x1, x0, #0x8
ffffffffea80cca8:	8b010281 	add	x1, x20, x1
	if (!item || item->state != MSG_ITEM_STATE_READ) {
ffffffffea80ccac:	7100085f 	cmp	w2, #0x2
ffffffffea80ccb0:	54000501 	b.ne	ffffffffea80cd50 <ipc_put_msg+0x110>  // b.any
	item->next->prev = item->prev;
ffffffffea80ccb4:	a9430c24 	ldp	x4, x3, [x1, #48]
	list_delete(&item->node);
ffffffffea80ccb8:	9100e000 	add	x0, x0, #0x38
	ipc_chan_t *peer = chan->peer;
ffffffffea80ccbc:	f85d02c2 	ldur	x2, [x22, #-48]
	list_delete(&item->node);
ffffffffea80ccc0:	8b000280 	add	x0, x20, x0
	return NO_ERROR;
ffffffffea80ccc4:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea80ccc8:	f9000064 	str	x4, [x3]
	item->prev->next = item->next;
ffffffffea80cccc:	f9401824 	ldr	x4, [x1, #48]
ffffffffea80ccd0:	f9000483 	str	x3, [x4, #8]
	item->prev = item->next = 0;
ffffffffea80ccd4:	f9001c3f 	str	xzr, [x1, #56]
	item->next = list->next;
ffffffffea80ccd8:	f9400683 	ldr	x3, [x20, #8]
ffffffffea80ccdc:	a9030c34 	stp	x20, x3, [x1, #48]
	list->next->prev = item;
ffffffffea80cce0:	f9400681 	ldr	x1, [x20, #8]
ffffffffea80cce4:	f9000020 	str	x0, [x1]
	list->next = item;
ffffffffea80cce8:	f9000680 	str	x0, [x20, #8]
	item->state = MSG_ITEM_STATE_FREE;
ffffffffea80ccec:	3901267f 	strb	wzr, [x19, #73]
	if (peer && (peer->aux_state & IPC_CHAN_AUX_STATE_SEND_BLOCKED)) {
ffffffffea80ccf0:	b4000062 	cbz	x2, ffffffffea80ccfc <ipc_put_msg+0xbc>
ffffffffea80ccf4:	b9403840 	ldr	w0, [x2, #56]
ffffffffea80ccf8:	37000120 	tbnz	w0, #0, ffffffffea80cd1c <ipc_put_msg+0xdc>
ffffffffea80ccfc:	f9400fb4 	ldr	x20, [x29, #24]
	if (likely(ret == NO_ERROR)) {
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		/* retire message */
		ret = msg_put_read_locked(chan, msg_id);
	}
	mutex_release(&ipc_lock);
ffffffffea80cd00:	913722a0 	add	x0, x21, #0xdc8
ffffffffea80cd04:	97ffe325 	bl	ffffffffea805998 <mutex_release>
	return ret;
}
ffffffffea80cd08:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cd0c:	2a1603e0 	mov	w0, w22
ffffffffea80cd10:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80cd14:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cd18:	d65f03c0 	ret
		peer->aux_state &= ~IPC_CHAN_AUX_STATE_SEND_BLOCKED;
ffffffffea80cd1c:	121f7801 	and	w1, w0, #0xfffffffe
		handle_notify(&peer->handle);
ffffffffea80cd20:	91014040 	add	x0, x2, #0x50
		peer->aux_state |=  IPC_CHAN_AUX_STATE_SEND_UNBLOCKED;
ffffffffea80cd24:	321f0021 	orr	w1, w1, #0x2
ffffffffea80cd28:	b9003841 	str	w1, [x2, #56]
		handle_notify(&peer->handle);
ffffffffea80cd2c:	97fff503 	bl	ffffffffea80a138 <handle_notify>
ffffffffea80cd30:	f9400fb4 	ldr	x20, [x29, #24]
	mutex_release(&ipc_lock);
ffffffffea80cd34:	913722a0 	add	x0, x21, #0xdc8
ffffffffea80cd38:	97ffe318 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea80cd3c:	2a1603e0 	mov	w0, w22
ffffffffea80cd40:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cd44:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80cd48:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cd4c:	d65f03c0 	ret
ffffffffea80cd50:	f9400fb4 	ldr	x20, [x29, #24]
		return ERR_INVALID_ARGS;
ffffffffea80cd54:	128000f6 	mov	w22, #0xfffffff8            	// #-8
	mutex_release(&ipc_lock);
ffffffffea80cd58:	913722a0 	add	x0, x21, #0xdc8
ffffffffea80cd5c:	97ffe30f 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea80cd60:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cd64:	2a1603e0 	mov	w0, w22
ffffffffea80cd68:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80cd6c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cd70:	d65f03c0 	ret
ffffffffea80cd74:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80cd78 <sys_put_msg>:
{
ffffffffea80cd78:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80cd7c:	910003fd 	mov	x29, sp
ffffffffea80cd80:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80cd84:	2a0003f3 	mov	w19, w0
ffffffffea80cd88:	2a0103f4 	mov	w20, w1
	int ret = uctx_handle_get(current_uctx(), handle_id, &chandle);
ffffffffea80cd8c:	97fff633 	bl	ffffffffea80a658 <current_uctx>
ffffffffea80cd90:	9100a3a2 	add	x2, x29, #0x28
ffffffffea80cd94:	2a1303e1 	mov	w1, w19
ffffffffea80cd98:	97fff6b6 	bl	ffffffffea80a870 <uctx_handle_get>
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80cd9c:	35000160 	cbnz	w0, ffffffffea80cdc8 <sys_put_msg+0x50>
	ret = ipc_put_msg(chandle, msg_id);
ffffffffea80cda0:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80cda4:	2a1403e1 	mov	w1, w20
ffffffffea80cda8:	97ffffa6 	bl	ffffffffea80cc40 <ipc_put_msg>
ffffffffea80cdac:	2a0003f3 	mov	w19, w0
	handle_decref(chandle);
ffffffffea80cdb0:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80cdb4:	97fff475 	bl	ffffffffea809f88 <handle_decref>
	return (long) ret;
ffffffffea80cdb8:	93407e60 	sxtw	x0, w19
}
ffffffffea80cdbc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80cdc0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cdc4:	d65f03c0 	ret
ffffffffea80cdc8:	a94153f3 	ldp	x19, x20, [sp, #16]
		return (long) ret;
ffffffffea80cdcc:	93407c00 	sxtw	x0, w0
}
ffffffffea80cdd0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cdd4:	d65f03c0 	ret

ffffffffea80cdd8 <sys_read_msg>:


long __SYSCALL sys_read_msg(uint32_t handle_id, uint32_t msg_id, uint32_t offset,
                            user_addr_t user_msg)
{
ffffffffea80cdd8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80cddc:	910003fd 	mov	x29, sp
ffffffffea80cde0:	a90153f3 	stp	x19, x20, [sp, #16]
	handle_t  *chandle;
	msg_desc_t tmp_msg;
	int ret;

	/* get msg descriptor form user space */
	tmp_msg.type = IPC_MSG_BUFFER_USER;
ffffffffea80cde4:	910183b3 	add	x19, x29, #0x60
{
ffffffffea80cde8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80cdec:	2a0003f4 	mov	w20, w0
ffffffffea80cdf0:	2a0103f5 	mov	w21, w1
ffffffffea80cdf4:	2a0203f6 	mov	w22, w2
	tmp_msg.type = IPC_MSG_BUFFER_USER;
ffffffffea80cdf8:	b81d8e7f 	str	wzr, [x19, #-40]!
	return arch_copy_from_user(kdest, usrc, len);
ffffffffea80cdfc:	2a0303e1 	mov	w1, w3
ffffffffea80ce00:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80ce04:	91002260 	add	x0, x19, #0x8
ffffffffea80ce08:	94001a20 	bl	ffffffffea813688 <arch_copy_from_user>
	ret = copy_from_user(&tmp_msg.user, user_msg, sizeof(ipc_msg_user_t));
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80ce0c:	350003e0 	cbnz	w0, ffffffffea80ce88 <sys_read_msg+0xb0>
		return (long) ret;
	}
	/* grab handle */
	ret = uctx_handle_get(current_uctx(), handle_id, &chandle);
ffffffffea80ce10:	97fff612 	bl	ffffffffea80a658 <current_uctx>
ffffffffea80ce14:	9100c3a2 	add	x2, x29, #0x30
ffffffffea80ce18:	2a1403e1 	mov	w1, w20
ffffffffea80ce1c:	97fff695 	bl	ffffffffea80a870 <uctx_handle_get>
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80ce20:	35000340 	cbnz	w0, ffffffffea80ce88 <sys_read_msg+0xb0>
ffffffffea80ce24:	90000074 	adrp	x20, ffffffffea818000 <_mem_phys_base>
ffffffffea80ce28:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80ce2c:	91372280 	add	x0, x20, #0xdc8
ffffffffea80ce30:	97ffe2ae 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
		return (long) ret;
	}
	mutex_acquire(&ipc_lock);
	/* check if channel handle is a valid one */
	ret = check_channel_locked (chandle);
ffffffffea80ce34:	f9401ba0 	ldr	x0, [x29, #48]
	if (unlikely(!chandle)) {
ffffffffea80ce38:	b4000340 	cbz	x0, ffffffffea80cea0 <sys_read_msg+0xc8>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80ce3c:	97fffa65 	bl	ffffffffea80b7d0 <ipc_is_channel>
ffffffffea80ce40:	72001c1f 	tst	w0, #0xff
ffffffffea80ce44:	540002e0 	b.eq	ffffffffea80cea0 <sys_read_msg+0xc8>  // b.none
	if (ret == NO_ERROR) {
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		/* read message content */
		ret = msg_read_locked(chan->msg_queue, msg_id,
ffffffffea80ce48:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80ce4c:	aa1303e3 	mov	x3, x19
ffffffffea80ce50:	2a1603e2 	mov	w2, w22
ffffffffea80ce54:	2a1503e1 	mov	w1, w21
ffffffffea80ce58:	f9403000 	ldr	x0, [x0, #96]
ffffffffea80ce5c:	97fffe15 	bl	ffffffffea80c6b0 <msg_read_locked>
ffffffffea80ce60:	93407c13 	sxtw	x19, w0
		                      offset, &tmp_msg);
	}
	mutex_release(&ipc_lock);
ffffffffea80ce64:	91372280 	add	x0, x20, #0xdc8
ffffffffea80ce68:	97ffe2cc 	bl	ffffffffea805998 <mutex_release>
	handle_decref(chandle);
ffffffffea80ce6c:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80ce70:	97fff446 	bl	ffffffffea809f88 <handle_decref>

	return (long) ret;
}
ffffffffea80ce74:	aa1303e0 	mov	x0, x19
ffffffffea80ce78:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ce7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ce80:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80ce84:	d65f03c0 	ret
		return (long) ret;
ffffffffea80ce88:	93407c13 	sxtw	x19, w0
}
ffffffffea80ce8c:	aa1303e0 	mov	x0, x19
ffffffffea80ce90:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ce94:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ce98:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80ce9c:	d65f03c0 	ret
{
ffffffffea80cea0:	928000f3 	mov	x19, #0xfffffffffffffff8    	// #-8
ffffffffea80cea4:	17fffff0 	b	ffffffffea80ce64 <sys_read_msg+0x8c>

ffffffffea80cea8 <ipc_read_msg>:

int ipc_read_msg(handle_t *chandle, uint32_t msg_id, uint32_t offset,
                 ipc_msg_kern_t *msg)
{
ffffffffea80cea8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80ceac:	910003fd 	mov	x29, sp
ffffffffea80ceb0:	f9000bf3 	str	x19, [sp, #16]
	int ret;
	msg_desc_t tmp_msg;

	if (!msg) {
ffffffffea80ceb4:	b40004c3 	cbz	x3, ffffffffea80cf4c <ipc_read_msg+0xa4>
ffffffffea80ceb8:	a901d7b4 	stp	x20, x21, [x29, #24]
		return ERR_INVALID_ARGS;
	}
	tmp_msg.type = IPC_MSG_BUFFER_KERNEL;
ffffffffea80cebc:	9101c3b4 	add	x20, x29, #0x70
ffffffffea80cec0:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea80cec4:	aa0003f3 	mov	x19, x0
ffffffffea80cec8:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80cecc:	2a0203f6 	mov	w22, w2
ffffffffea80ced0:	b81d8e80 	str	w0, [x20, #-40]!
	memcpy(&tmp_msg.kern, msg, sizeof(ipc_msg_kern_t));
ffffffffea80ced4:	d2800402 	mov	x2, #0x20                  	// #32
ffffffffea80ced8:	2a0103f5 	mov	w21, w1
ffffffffea80cedc:	aa0303e1 	mov	x1, x3
ffffffffea80cee0:	91002280 	add	x0, x20, #0x8
ffffffffea80cee4:	9400186f 	bl	ffffffffea8130a0 <memcpy>
ffffffffea80cee8:	90000077 	adrp	x23, ffffffffea818000 <_mem_phys_base>
ffffffffea80ceec:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80cef0:	913722e0 	add	x0, x23, #0xdc8
ffffffffea80cef4:	97ffe27d 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	if (unlikely(!chandle)) {
ffffffffea80cef8:	b4000273 	cbz	x19, ffffffffea80cf44 <ipc_read_msg+0x9c>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80cefc:	aa1303e0 	mov	x0, x19
ffffffffea80cf00:	97fffa34 	bl	ffffffffea80b7d0 <ipc_is_channel>
ffffffffea80cf04:	72001c1f 	tst	w0, #0xff
ffffffffea80cf08:	540001e0 	b.eq	ffffffffea80cf44 <ipc_read_msg+0x9c>  // b.none

	mutex_acquire(&ipc_lock);
	ret = check_channel_locked (chandle);
	if (ret == NO_ERROR) {
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		ret = msg_read_locked(chan->msg_queue, msg_id,
ffffffffea80cf0c:	f9403260 	ldr	x0, [x19, #96]
ffffffffea80cf10:	aa1403e3 	mov	x3, x20
ffffffffea80cf14:	2a1603e2 	mov	w2, w22
ffffffffea80cf18:	2a1503e1 	mov	w1, w21
ffffffffea80cf1c:	97fffde5 	bl	ffffffffea80c6b0 <msg_read_locked>
ffffffffea80cf20:	2a0003f3 	mov	w19, w0
		                      offset, &tmp_msg);
	}
	mutex_release(&ipc_lock);
ffffffffea80cf24:	913722e0 	add	x0, x23, #0xdc8
ffffffffea80cf28:	97ffe29c 	bl	ffffffffea805998 <mutex_release>
	return ret;
ffffffffea80cf2c:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea80cf30:	a942dfb6 	ldp	x22, x23, [x29, #40]
}
ffffffffea80cf34:	2a1303e0 	mov	w0, w19
ffffffffea80cf38:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cf3c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80cf40:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80cf44:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea80cf48:	17fffff7 	b	ffffffffea80cf24 <ipc_read_msg+0x7c>
		return ERR_INVALID_ARGS;
ffffffffea80cf4c:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea80cf50:	17fffff9 	b	ffffffffea80cf34 <ipc_read_msg+0x8c>
ffffffffea80cf54:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80cf58 <membuf_to_kern_iovec>:
ssize_t membuf_to_kern_iovec(const iovec_kern_t *iov, uint iov_cnt,
                             const uint8_t *buf, size_t len)
{
	size_t copied = 0;

	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80cf58:	7100003f 	cmp	w1, #0x0
ffffffffea80cf5c:	fa401864 	ccmp	x3, #0x0, #0x4, ne  // ne = any
ffffffffea80cf60:	54000820 	b.eq	ffffffffea80d064 <membuf_to_kern_iovec+0x10c>  // b.none
{
ffffffffea80cf64:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
		return 0;
	}

	if (unlikely(iov == NULL || buf == NULL)) {
ffffffffea80cf68:	f100001f 	cmp	x0, #0x0
ffffffffea80cf6c:	fa401844 	ccmp	x2, #0x0, #0x4, ne  // ne = any
{
ffffffffea80cf70:	910003fd 	mov	x29, sp
ffffffffea80cf74:	f9000ff4 	str	x20, [sp, #24]
ffffffffea80cf78:	aa0003f4 	mov	x20, x0
ffffffffea80cf7c:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80cf80:	aa0203f7 	mov	x23, x2
	if (unlikely(iov == NULL || buf == NULL)) {
ffffffffea80cf84:	54000400 	b.eq	ffffffffea80d004 <membuf_to_kern_iovec+0xac>  // b.none
ffffffffea80cf88:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80cf8c:	51000436 	sub	w22, w1, #0x1
ffffffffea80cf90:	910006d6 	add	x22, x22, #0x1
ffffffffea80cf94:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80cf98:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80cf9c:	aa0303f5 	mov	x21, x3
ffffffffea80cfa0:	8b161016 	add	x22, x0, x22, lsl #4
	size_t copied = 0;
ffffffffea80cfa4:	d2800018 	mov	x24, #0x0                   	// #0
ffffffffea80cfa8:	1400000d 	b	ffffffffea80cfdc <membuf_to_kern_iovec+0x84>

		size_t to_copy = len;
		if (to_copy > iov->len) {
			to_copy = iov->len;
		}
		if (unlikely(to_copy == 0)) {
ffffffffea80cfac:	b4000133 	cbz	x19, ffffffffea80cfd0 <membuf_to_kern_iovec+0x78>
			continue;
		}
		if (unlikely(iov->base == NULL)) {
ffffffffea80cfb0:	f9400283 	ldr	x3, [x20]
			return (ssize_t) ERR_INVALID_ARGS;
		}
		memcpy(iov->base, buf, to_copy);

		copied += to_copy;
ffffffffea80cfb4:	8b130318 	add	x24, x24, x19
		buf    += to_copy;
ffffffffea80cfb8:	8b1302f7 	add	x23, x23, x19
		memcpy(iov->base, buf, to_copy);
ffffffffea80cfbc:	aa0303e0 	mov	x0, x3
		if (unlikely(iov->base == NULL)) {
ffffffffea80cfc0:	b40001c3 	cbz	x3, ffffffffea80cff8 <membuf_to_kern_iovec+0xa0>
		memcpy(iov->base, buf, to_copy);
ffffffffea80cfc4:	94001837 	bl	ffffffffea8130a0 <memcpy>
		len    -= to_copy;

		if (len == 0) {
ffffffffea80cfc8:	eb1302b5 	subs	x21, x21, x19
ffffffffea80cfcc:	54000260 	b.eq	ffffffffea80d018 <membuf_to_kern_iovec+0xc0>  // b.none
	for (uint i = 0; i < iov_cnt; i++, iov++) {
ffffffffea80cfd0:	91004294 	add	x20, x20, #0x10
ffffffffea80cfd4:	eb16029f 	cmp	x20, x22
ffffffffea80cfd8:	54000200 	b.eq	ffffffffea80d018 <membuf_to_kern_iovec+0xc0>  // b.none
		if (to_copy > iov->len) {
ffffffffea80cfdc:	f9400693 	ldr	x19, [x20, #8]
		memcpy(iov->base, buf, to_copy);
ffffffffea80cfe0:	aa1703e1 	mov	x1, x23
ffffffffea80cfe4:	aa1303e2 	mov	x2, x19
		if (to_copy > iov->len) {
ffffffffea80cfe8:	eb15027f 	cmp	x19, x21
ffffffffea80cfec:	54fffe03 	b.cc	ffffffffea80cfac <membuf_to_kern_iovec+0x54>  // b.lo, b.ul, b.last
		if (unlikely(iov->base == NULL)) {
ffffffffea80cff0:	f9400280 	ldr	x0, [x20]
ffffffffea80cff4:	b5000220 	cbnz	x0, ffffffffea80d038 <membuf_to_kern_iovec+0xe0>
ffffffffea80cff8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80cffc:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d000:	f9401fb8 	ldr	x24, [x29, #56]
		return (ssize_t) ERR_INVALID_ARGS;
ffffffffea80d004:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
			break;
		}
	}

	return  (ssize_t) copied;
}
ffffffffea80d008:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d00c:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d010:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d014:	d65f03c0 	ret
ffffffffea80d018:	aa1803e0 	mov	x0, x24
	return  (ssize_t) copied;
ffffffffea80d01c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d020:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d024:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea80d028:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d02c:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d030:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d034:	d65f03c0 	ret
		memcpy(iov->base, buf, to_copy);
ffffffffea80d038:	aa1503e2 	mov	x2, x21
ffffffffea80d03c:	aa1703e1 	mov	x1, x23
ffffffffea80d040:	94001818 	bl	ffffffffea8130a0 <memcpy>
ffffffffea80d044:	f9400bb3 	ldr	x19, [x29, #16]
		copied += to_copy;
ffffffffea80d048:	8b1802a0 	add	x0, x21, x24
}
ffffffffea80d04c:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d050:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d054:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80d058:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d05c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d060:	d65f03c0 	ret
		return 0;
ffffffffea80d064:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80d068:	d65f03c0 	ret
ffffffffea80d06c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d070 <kern_iovec_to_membuf>:
ssize_t kern_iovec_to_membuf(uint8_t *buf, size_t len,
                             const iovec_kern_t *iov, uint iov_cnt)
{
	size_t copied = 0;

	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d070:	7100007f 	cmp	w3, #0x0
ffffffffea80d074:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
ffffffffea80d078:	54000820 	b.eq	ffffffffea80d17c <kern_iovec_to_membuf+0x10c>  // b.none
{
ffffffffea80d07c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
		return 0;
	}
	if (unlikely(buf == NULL || iov == NULL)) {
ffffffffea80d080:	f100001f 	cmp	x0, #0x0
ffffffffea80d084:	fa401844 	ccmp	x2, #0x0, #0x4, ne  // ne = any
{
ffffffffea80d088:	910003fd 	mov	x29, sp
ffffffffea80d08c:	f9000ff4 	str	x20, [sp, #24]
ffffffffea80d090:	aa0203f4 	mov	x20, x2
ffffffffea80d094:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80d098:	aa0003f7 	mov	x23, x0
	if (unlikely(buf == NULL || iov == NULL)) {
ffffffffea80d09c:	54000400 	b.eq	ffffffffea80d11c <kern_iovec_to_membuf+0xac>  // b.none
ffffffffea80d0a0:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80d0a4:	51000476 	sub	w22, w3, #0x1
ffffffffea80d0a8:	910006d6 	add	x22, x22, #0x1
ffffffffea80d0ac:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80d0b0:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80d0b4:	aa0103f5 	mov	x21, x1
ffffffffea80d0b8:	8b161056 	add	x22, x2, x22, lsl #4
	size_t copied = 0;
ffffffffea80d0bc:	d2800018 	mov	x24, #0x0                   	// #0
ffffffffea80d0c0:	1400000d 	b	ffffffffea80d0f4 <kern_iovec_to_membuf+0x84>

		size_t to_copy = len;
		if (to_copy > iov->len) {
			to_copy = iov->len;
		}
		if (unlikely(to_copy == 0)) {
ffffffffea80d0c4:	b4000133 	cbz	x19, ffffffffea80d0e8 <kern_iovec_to_membuf+0x78>
			continue;
		}
		if (unlikely(iov->base == NULL)) {
ffffffffea80d0c8:	f9400283 	ldr	x3, [x20]
			return (ssize_t) ERR_INVALID_ARGS;
		}
		memcpy (buf, iov->base, to_copy);

		copied += to_copy;
ffffffffea80d0cc:	8b130318 	add	x24, x24, x19
		buf    += to_copy;
ffffffffea80d0d0:	8b1302f7 	add	x23, x23, x19
		memcpy (buf, iov->base, to_copy);
ffffffffea80d0d4:	aa0303e1 	mov	x1, x3
		if (unlikely(iov->base == NULL)) {
ffffffffea80d0d8:	b40001c3 	cbz	x3, ffffffffea80d110 <kern_iovec_to_membuf+0xa0>
		memcpy (buf, iov->base, to_copy);
ffffffffea80d0dc:	940017f1 	bl	ffffffffea8130a0 <memcpy>
		len    -= to_copy;

		if (len == 0) {
ffffffffea80d0e0:	eb1302b5 	subs	x21, x21, x19
ffffffffea80d0e4:	54000260 	b.eq	ffffffffea80d130 <kern_iovec_to_membuf+0xc0>  // b.none
	for (uint i = 0; i < iov_cnt; i++, iov++) {
ffffffffea80d0e8:	91004294 	add	x20, x20, #0x10
ffffffffea80d0ec:	eb16029f 	cmp	x20, x22
ffffffffea80d0f0:	54000200 	b.eq	ffffffffea80d130 <kern_iovec_to_membuf+0xc0>  // b.none
		if (to_copy > iov->len) {
ffffffffea80d0f4:	f9400693 	ldr	x19, [x20, #8]
		memcpy (buf, iov->base, to_copy);
ffffffffea80d0f8:	aa1703e0 	mov	x0, x23
ffffffffea80d0fc:	aa1303e2 	mov	x2, x19
		if (to_copy > iov->len) {
ffffffffea80d100:	eb15027f 	cmp	x19, x21
ffffffffea80d104:	54fffe03 	b.cc	ffffffffea80d0c4 <kern_iovec_to_membuf+0x54>  // b.lo, b.ul, b.last
		if (unlikely(iov->base == NULL)) {
ffffffffea80d108:	f9400281 	ldr	x1, [x20]
ffffffffea80d10c:	b5000221 	cbnz	x1, ffffffffea80d150 <kern_iovec_to_membuf+0xe0>
ffffffffea80d110:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d114:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d118:	f9401fb8 	ldr	x24, [x29, #56]
		return (ssize_t) ERR_INVALID_ARGS;
ffffffffea80d11c:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
			break;
		}
	}

	return (ssize_t) copied;
}
ffffffffea80d120:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d124:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d128:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d12c:	d65f03c0 	ret
ffffffffea80d130:	aa1803e0 	mov	x0, x24
	return (ssize_t) copied;
ffffffffea80d134:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d138:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d13c:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea80d140:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d144:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d148:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d14c:	d65f03c0 	ret
		memcpy (buf, iov->base, to_copy);
ffffffffea80d150:	aa1503e2 	mov	x2, x21
ffffffffea80d154:	aa1703e0 	mov	x0, x23
ffffffffea80d158:	940017d2 	bl	ffffffffea8130a0 <memcpy>
ffffffffea80d15c:	f9400bb3 	ldr	x19, [x29, #16]
		copied += to_copy;
ffffffffea80d160:	8b1802a0 	add	x0, x21, x24
}
ffffffffea80d164:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d168:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d16c:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80d170:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d174:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d178:	d65f03c0 	ret
		return 0;
ffffffffea80d17c:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80d180:	d65f03c0 	ret
ffffffffea80d184:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d188 <membuf_to_user_iovec>:
{
	status_t ret;
	size_t copied = 0;
	iovec_user_t uiov;

	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d188:	7100003f 	cmp	w1, #0x0
ffffffffea80d18c:	fa401864 	ccmp	x3, #0x0, #0x4, ne  // ne = any
ffffffffea80d190:	54000680 	b.eq	ffffffffea80d260 <membuf_to_user_iovec+0xd8>  // b.none
{
ffffffffea80d194:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80d198:	910003fd 	mov	x29, sp
ffffffffea80d19c:	f90017f6 	str	x22, [sp, #40]
ffffffffea80d1a0:	aa0203f6 	mov	x22, x2
		return 0;
	}
	if (unlikely(buf == NULL)) {
ffffffffea80d1a4:	b40006e2 	cbz	x2, ffffffffea80d280 <membuf_to_user_iovec+0xf8>
ffffffffea80d1a8:	51000421 	sub	w1, w1, #0x1
ffffffffea80d1ac:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80d1b0:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80d1b4:	aa0303f4 	mov	x20, x3
ffffffffea80d1b8:	2a0003f8 	mov	w24, w0
ffffffffea80d1bc:	91000437 	add	x23, x1, #0x1
ffffffffea80d1c0:	f90013b5 	str	x21, [x29, #32]
ffffffffea80d1c4:	d2800015 	mov	x21, #0x0                   	// #0
ffffffffea80d1c8:	f90023b9 	str	x25, [x29, #64]
	size_t copied = 0;
ffffffffea80d1cc:	d2800019 	mov	x25, #0x0                   	// #0
ffffffffea80d1d0:	0b150f01 	add	w1, w24, w21, lsl #3
ffffffffea80d1d4:	d2800102 	mov	x2, #0x8                   	// #8
ffffffffea80d1d8:	910006b5 	add	x21, x21, #0x1
ffffffffea80d1dc:	910163a0 	add	x0, x29, #0x58
ffffffffea80d1e0:	9400192a 	bl	ffffffffea813688 <arch_copy_from_user>

		/* copy user iovec from user space into local buffer */
		ret = copy_from_user(&uiov,
		                     iov_uaddr + i * sizeof(iovec_user_t),
		                     sizeof(iovec_user_t));
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d1e4:	350002e0 	cbnz	w0, ffffffffea80d240 <membuf_to_user_iovec+0xb8>
			return (ssize_t) ret;
		}

		size_t to_copy = len;
		if (to_copy > uiov.len) {
ffffffffea80d1e8:	294b4fa0 	ldp	w0, w19, [x29, #88]
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea80d1ec:	aa1603e1 	mov	x1, x22
ffffffffea80d1f0:	eb13029f 	cmp	x20, x19
ffffffffea80d1f4:	54000209 	b.ls	ffffffffea80d234 <membuf_to_user_iovec+0xac>  // b.plast
ffffffffea80d1f8:	aa1303e2 	mov	x2, x19
		/* copy data to user space */
		ret = copy_to_user(uiov.base, buf, to_copy);
		if (unlikely(ret != NO_ERROR)) {
			return (ssize_t) ret;
		}
		copied += to_copy;
ffffffffea80d1fc:	8b130339 	add	x25, x25, x19
		buf    += to_copy;
ffffffffea80d200:	8b1302d6 	add	x22, x22, x19
ffffffffea80d204:	94001919 	bl	ffffffffea813668 <arch_copy_to_user>
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d208:	350001c0 	cbnz	w0, ffffffffea80d240 <membuf_to_user_iovec+0xb8>
		len    -= to_copy;

		if (len == 0) {
ffffffffea80d20c:	eb130294 	subs	x20, x20, x19
ffffffffea80d210:	54000060 	b.eq	ffffffffea80d21c <membuf_to_user_iovec+0x94>  // b.none
	for (uint i = 0; i < iov_cnt; i++) {
ffffffffea80d214:	eb1702bf 	cmp	x21, x23
ffffffffea80d218:	54fffdc1 	b.ne	ffffffffea80d1d0 <membuf_to_user_iovec+0x48>  // b.any
ffffffffea80d21c:	aa1903e0 	mov	x0, x25
			break;;
		}
	}

	return  (ssize_t) copied;
ffffffffea80d220:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d224:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d228:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d22c:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80d230:	14000009 	b	ffffffffea80d254 <membuf_to_user_iovec+0xcc>
ffffffffea80d234:	aa1403e2 	mov	x2, x20
ffffffffea80d238:	9400190c 	bl	ffffffffea813668 <arch_copy_to_user>
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d23c:	34000160 	cbz	w0, ffffffffea80d268 <membuf_to_user_iovec+0xe0>
			return (ssize_t) ret;
ffffffffea80d240:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d244:	93407c00 	sxtw	x0, w0
ffffffffea80d248:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d24c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d250:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea80d254:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80d258:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80d25c:	d65f03c0 	ret
		return 0;
ffffffffea80d260:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80d264:	d65f03c0 	ret
		copied += to_copy;
ffffffffea80d268:	8b190280 	add	x0, x20, x25
ffffffffea80d26c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d270:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d274:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d278:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80d27c:	17fffff6 	b	ffffffffea80d254 <membuf_to_user_iovec+0xcc>
		return (ssize_t) ERR_INVALID_ARGS;
ffffffffea80d280:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80d284:	17fffff4 	b	ffffffffea80d254 <membuf_to_user_iovec+0xcc>

ffffffffea80d288 <user_iovec_to_membuf>:
{
	status_t ret;
	size_t copied = 0;
	iovec_user_t uiov;

	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d288:	7100007f 	cmp	w3, #0x0
ffffffffea80d28c:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
ffffffffea80d290:	54000680 	b.eq	ffffffffea80d360 <user_iovec_to_membuf+0xd8>  // b.none
{
ffffffffea80d294:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80d298:	910003fd 	mov	x29, sp
ffffffffea80d29c:	f90017f6 	str	x22, [sp, #40]
ffffffffea80d2a0:	aa0003f6 	mov	x22, x0
		return 0;
	}
	if (unlikely(buf == NULL)) {
ffffffffea80d2a4:	b40006e0 	cbz	x0, ffffffffea80d380 <user_iovec_to_membuf+0xf8>
ffffffffea80d2a8:	51000463 	sub	w3, w3, #0x1
ffffffffea80d2ac:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80d2b0:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80d2b4:	aa0103f4 	mov	x20, x1
ffffffffea80d2b8:	2a0203f8 	mov	w24, w2
ffffffffea80d2bc:	91000477 	add	x23, x3, #0x1
ffffffffea80d2c0:	f90013b5 	str	x21, [x29, #32]
ffffffffea80d2c4:	d2800015 	mov	x21, #0x0                   	// #0
ffffffffea80d2c8:	f90023b9 	str	x25, [x29, #64]
	size_t copied = 0;
ffffffffea80d2cc:	d2800019 	mov	x25, #0x0                   	// #0
	return arch_copy_from_user(kdest, usrc, len);
ffffffffea80d2d0:	0b150f01 	add	w1, w24, w21, lsl #3
ffffffffea80d2d4:	d2800102 	mov	x2, #0x8                   	// #8
ffffffffea80d2d8:	910006b5 	add	x21, x21, #0x1
ffffffffea80d2dc:	910163a0 	add	x0, x29, #0x58
ffffffffea80d2e0:	940018ea 	bl	ffffffffea813688 <arch_copy_from_user>

		/* copy user iovec from user space into local buffer */
		ret = copy_from_user(&uiov,
		                     iov_uaddr + i * sizeof(iovec_user_t),
		                     sizeof(iovec_user_t));
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d2e4:	350002e0 	cbnz	w0, ffffffffea80d340 <user_iovec_to_membuf+0xb8>
			return (ssize_t) ret;
		}
		size_t to_copy = len;
		if (to_copy > uiov.len) {
ffffffffea80d2e8:	294b4fa1 	ldp	w1, w19, [x29, #88]
ffffffffea80d2ec:	aa1603e0 	mov	x0, x22
ffffffffea80d2f0:	eb13029f 	cmp	x20, x19
ffffffffea80d2f4:	54000209 	b.ls	ffffffffea80d334 <user_iovec_to_membuf+0xac>  // b.plast
ffffffffea80d2f8:	aa1303e2 	mov	x2, x19
		ret = copy_from_user(buf, uiov.base, to_copy);
		if (unlikely(ret != NO_ERROR)) {
			return (ssize_t) ret;
		}

		copied += to_copy;
ffffffffea80d2fc:	8b130339 	add	x25, x25, x19
		buf    += to_copy;
ffffffffea80d300:	8b1302d6 	add	x22, x22, x19
ffffffffea80d304:	940018e1 	bl	ffffffffea813688 <arch_copy_from_user>
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d308:	350001c0 	cbnz	w0, ffffffffea80d340 <user_iovec_to_membuf+0xb8>
		len    -= to_copy;
		if (len == 0) {
ffffffffea80d30c:	eb130294 	subs	x20, x20, x19
ffffffffea80d310:	54000060 	b.eq	ffffffffea80d31c <user_iovec_to_membuf+0x94>  // b.none
	for (uint i = 0; i < iov_cnt; i++) {
ffffffffea80d314:	eb1702bf 	cmp	x21, x23
ffffffffea80d318:	54fffdc1 	b.ne	ffffffffea80d2d0 <user_iovec_to_membuf+0x48>  // b.any
ffffffffea80d31c:	aa1903e0 	mov	x0, x25
			break;;
		}
	}

	return (ssize_t) copied;
ffffffffea80d320:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d324:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d328:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d32c:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80d330:	14000009 	b	ffffffffea80d354 <user_iovec_to_membuf+0xcc>
ffffffffea80d334:	aa1403e2 	mov	x2, x20
ffffffffea80d338:	940018d4 	bl	ffffffffea813688 <arch_copy_from_user>
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d33c:	34000160 	cbz	w0, ffffffffea80d368 <user_iovec_to_membuf+0xe0>
			return (ssize_t) ret;
ffffffffea80d340:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d344:	93407c00 	sxtw	x0, w0
ffffffffea80d348:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d34c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d350:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea80d354:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80d358:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80d35c:	d65f03c0 	ret
		return 0;
ffffffffea80d360:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80d364:	d65f03c0 	ret
		copied += to_copy;
ffffffffea80d368:	8b190280 	add	x0, x20, x25
ffffffffea80d36c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d370:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d374:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d378:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80d37c:	17fffff6 	b	ffffffffea80d354 <user_iovec_to_membuf+0xcc>
		return (ssize_t) ERR_INVALID_ARGS;
ffffffffea80d380:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80d384:	17fffff4 	b	ffffffffea80d354 <user_iovec_to_membuf+0xcc>

ffffffffea80d388 <vqueue_init>:

int vqueue_init(struct vqueue *vq, uint32_t id,
		paddr_t paddr, uint num, ulong align,
		void *priv, vqueue_cb_t notify_cb, vqueue_cb_t kick_cb,
		uint32_t guest)
{
ffffffffea80d388:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
}

static inline unsigned vring_size(unsigned int num, unsigned long align)
{
	return ((sizeof(struct vring_desc) * num + sizeof(__u16) * (3 + num)
		 + align - 1) & ~(align - 1))
ffffffffea80d38c:	51000488 	sub	w8, w4, #0x1
ffffffffea80d390:	910003fd 	mov	x29, sp
ffffffffea80d394:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d398:	2a0303f4 	mov	w20, w3
	return ((sizeof(struct vring_desc) * num + sizeof(__u16) * (3 + num)
ffffffffea80d39c:	11000c63 	add	w3, w3, #0x3
ffffffffea80d3a0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80d3a4:	8b344c63 	add	x3, x3, w20, uxtw #3
ffffffffea80d3a8:	aa0403f5 	mov	x21, x4
		 + align - 1) & ~(align - 1))
ffffffffea80d3ac:	4b0403e4 	neg	w4, w4
ffffffffea80d3b0:	a90573fb 	stp	x27, x28, [sp, #80]
ffffffffea80d3b4:	0b030503 	add	w3, w8, w3, lsl #1
ffffffffea80d3b8:	aa0203fc 	mov	x28, x2
ffffffffea80d3bc:	0a040063 	and	w3, w3, w4

	DEBUG_ASSERT(vq);

	vq->vring_sz = vring_size(num, align);
	roundedup_vring_sz = ROUNDUP(vq->vring_sz, PAGE_SIZE);
	ret = trusty_hyp_check_guest_pa_valid(paddr, roundedup_vring_sz, guest);
ffffffffea80d3c0:	b94083a2 	ldr	w2, [x29, #128]
		+ sizeof(__u16) * 3 + sizeof(struct vring_used_elem) * num;
ffffffffea80d3c4:	0b140c63 	add	w3, w3, w20, lsl #3
{
ffffffffea80d3c8:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80d3cc:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea80d3d0:	2a0103f7 	mov	w23, w1
	vq->vring_sz = vring_size(num, align);
ffffffffea80d3d4:	11001861 	add	w1, w3, #0x6
ffffffffea80d3d8:	f9001801 	str	x1, [x0, #48]
	roundedup_vring_sz = ROUNDUP(vq->vring_sz, PAGE_SIZE);
ffffffffea80d3dc:	913ffc21 	add	x1, x1, #0xfff
{
ffffffffea80d3e0:	aa0003f6 	mov	x22, x0
	roundedup_vring_sz = ROUNDUP(vq->vring_sz, PAGE_SIZE);
ffffffffea80d3e4:	9274cc33 	and	x19, x1, #0xfffffffffffff000
{
ffffffffea80d3e8:	aa0503f8 	mov	x24, x5
ffffffffea80d3ec:	aa0603f9 	mov	x25, x6
ffffffffea80d3f0:	aa0703fa 	mov	x26, x7
	ret = trusty_hyp_check_guest_pa_valid(paddr, roundedup_vring_sz, guest);
ffffffffea80d3f4:	aa1303e1 	mov	x1, x19
ffffffffea80d3f8:	aa1c03e0 	mov	x0, x28
	void   *vptr = NULL;
ffffffffea80d3fc:	f9003fbf 	str	xzr, [x29, #120]
	ret = trusty_hyp_check_guest_pa_valid(paddr, roundedup_vring_sz, guest);
ffffffffea80d400:	97ffd4c4 	bl	ffffffffea802710 <trusty_hyp_check_guest_pa_valid>
	if (ret != NO_ERROR) {
ffffffffea80d404:	35000320 	cbnz	w0, ffffffffea80d468 <vqueue_init+0xe0>
ffffffffea80d408:	2a1403e8 	mov	w8, w20
		TRACEF("%s: check_guest_pa_valid failed, error = %d",
			__func__, ret);
		return ret;
	}

	ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80d40c:	d0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80d410:	f90037a8 	str	x8, [x29, #104]
ffffffffea80d414:	90000280 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
ffffffffea80d418:	52800607 	mov	w7, #0x30                  	// #48
ffffffffea80d41c:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80d420:	aa1c03e5 	mov	x5, x28
ffffffffea80d424:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea80d428:	9101e3a3 	add	x3, x29, #0x78
ffffffffea80d42c:	aa1303e2 	mov	x2, x19
ffffffffea80d430:	9106c021 	add	x1, x1, #0x1b0
ffffffffea80d434:	91034000 	add	x0, x0, #0xd0
ffffffffea80d438:	94000f34 	bl	ffffffffea811108 <vmm_alloc_physical>
ffffffffea80d43c:	2a0003fb 	mov	w27, w0
	                         roundedup_vring_sz,
	                         &vptr,  PAGE_SIZE_SHIFT,
	                         paddr, 0,
	                         ARCH_MMU_FLAG_NS | ARCH_MMU_FLAG_PERM_NO_EXECUTE |
	                         ARCH_MMU_FLAG_CACHED);
	if (ret != NO_ERROR) {
ffffffffea80d440:	f94037a8 	ldr	x8, [x29, #104]
ffffffffea80d444:	34000360 	cbz	w0, ffffffffea80d4b0 <vqueue_init+0x128>
	vq->vring_addr = (vaddr_t)vptr;

	event_init(&vq->avail_event, false, 0);

	return NO_ERROR;
}
ffffffffea80d448:	2a1b03e0 	mov	w0, w27
ffffffffea80d44c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d450:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d454:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80d458:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80d45c:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea80d460:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80d464:	d65f03c0 	ret
		TRACEF("%s: check_guest_pa_valid failed, error = %d",
ffffffffea80d468:	d0000045 	adrp	x5, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80d46c:	2a0003fb 	mov	w27, w0
ffffffffea80d470:	2a0003e4 	mov	w4, w0
ffffffffea80d474:	528007c2 	mov	w2, #0x3e                  	// #62
ffffffffea80d478:	9105e0a0 	add	x0, x5, #0x178
ffffffffea80d47c:	d0000043 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80d480:	d0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80d484:	9103e063 	add	x3, x3, #0xf8
ffffffffea80d488:	91036021 	add	x1, x1, #0xd8
ffffffffea80d48c:	940016c5 	bl	ffffffffea812fa0 <_printf>
}
ffffffffea80d490:	2a1b03e0 	mov	w0, w27
ffffffffea80d494:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d498:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d49c:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80d4a0:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80d4a4:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea80d4a8:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80d4ac:	d65f03c0 	ret
	vring_init(&vq->vring, num, vptr, align);
ffffffffea80d4b0:	f9403fa1 	ldr	x1, [x29, #120]
	vr->used = (void *)(((unsigned long)&vr->avail->ring[num] + sizeof(__u16)
ffffffffea80d4b4:	91000900 	add	x0, x8, #0x2
		+ align-1) & ~(align - 1));
ffffffffea80d4b8:	910006a4 	add	x4, x21, #0x1
ffffffffea80d4bc:	cb1503f5 	neg	x21, x21
	vq->id = id;
ffffffffea80d4c0:	b90002d7 	str	w23, [x22]
	event_init(&vq->avail_event, false, 0);
ffffffffea80d4c4:	52800002 	mov	w2, #0x0                   	// #0
	vr->avail = p + num*sizeof(struct vring_desc);
ffffffffea80d4c8:	8b081028 	add	x8, x1, x8, lsl #4
	vr->num = num;
ffffffffea80d4cc:	b9000ad4 	str	w20, [x22, #8]
	vr->used = (void *)(((unsigned long)&vr->avail->ring[num] + sizeof(__u16)
ffffffffea80d4d0:	8b000500 	add	x0, x8, x0, lsl #1
	vr->avail = p + num*sizeof(struct vring_desc);
ffffffffea80d4d4:	a90122c1 	stp	x1, x8, [x22, #16]
		+ align-1) & ~(align - 1));
ffffffffea80d4d8:	8b040000 	add	x0, x0, x4
	vq->kick_cb = kick_cb;
ffffffffea80d4dc:	a907ead9 	stp	x25, x26, [x22, #120]
ffffffffea80d4e0:	8a150015 	and	x21, x0, x21
	vq->vring_addr = (vaddr_t)vptr;
ffffffffea80d4e4:	a90206d5 	stp	x21, x1, [x22, #32]
	vq->priv = priv;
ffffffffea80d4e8:	f90046d8 	str	x24, [x22, #136]
	event_init(&vq->avail_event, false, 0);
ffffffffea80d4ec:	910122c0 	add	x0, x22, #0x48
ffffffffea80d4f0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80d4f4:	97ffe04d 	bl	ffffffffea805628 <event_init>
}
ffffffffea80d4f8:	2a1b03e0 	mov	w0, w27
ffffffffea80d4fc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d500:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d504:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80d508:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80d50c:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea80d510:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80d514:	d65f03c0 	ret

ffffffffea80d518 <vqueue_destroy>:

void vqueue_destroy(struct vqueue *vq)
{
ffffffffea80d518:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80d51c:	910003fd 	mov	x29, sp
ffffffffea80d520:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d524:	aa0003f3 	mov	x19, x0
	vaddr_t vring_addr;
	spin_lock_saved_state_t state;

	DEBUG_ASSERT(vq);

	spin_lock_save(&vq->slock, &state, VQ_LOCK_FLAGS);
ffffffffea80d528:	9100e014 	add	x20, x0, #0x38
{
ffffffffea80d52c:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80d530:	d53b4220 	mrs	x0, daif
ffffffffea80d534:	37380220 	tbnz	w0, #7, ffffffffea80d578 <vqueue_destroy+0x60>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80d538:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80d53c:	aa1403e0 	mov	x0, x20
ffffffffea80d540:	97ffd507 	bl	ffffffffea80295c <arch_spin_lock>
	vring_addr = vq->vring_addr;
ffffffffea80d544:	f9401675 	ldr	x21, [x19, #40]
    arch_spin_unlock(lock);
ffffffffea80d548:	aa1403e0 	mov	x0, x20
	vq->vring_addr = (vaddr_t)NULL;
	vq->vring_sz = 0;
ffffffffea80d54c:	a902fe7f 	stp	xzr, xzr, [x19, #40]
	vq->last_avail_idx = 0;
ffffffffea80d550:	7900827f 	strh	wzr, [x19, #64]
ffffffffea80d554:	97ffd50a 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80d558:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&vq->slock, state, VQ_LOCK_FLAGS);

	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80d55c:	aa1503e1 	mov	x1, x21
}
ffffffffea80d560:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80d564:	a94153f3 	ldp	x19, x20, [sp, #16]
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80d568:	90000280 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
}
ffffffffea80d56c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80d570:	91034000 	add	x0, x0, #0xd0
ffffffffea80d574:	14000f47 	b	ffffffffea811290 <vmm_free_region>
    arch_spin_lock(lock);
ffffffffea80d578:	aa1403e0 	mov	x0, x20
ffffffffea80d57c:	97ffd4f8 	bl	ffffffffea80295c <arch_spin_lock>
	vring_addr = vq->vring_addr;
ffffffffea80d580:	f9401675 	ldr	x21, [x19, #40]
    arch_spin_unlock(lock);
ffffffffea80d584:	aa1403e0 	mov	x0, x20
	vq->vring_sz = 0;
ffffffffea80d588:	a902fe7f 	stp	xzr, xzr, [x19, #40]
	vq->last_avail_idx = 0;
ffffffffea80d58c:	7900827f 	strh	wzr, [x19, #64]
ffffffffea80d590:	97ffd4fb 	bl	ffffffffea80297c <arch_spin_unlock>
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80d594:	aa1503e1 	mov	x1, x21
}
ffffffffea80d598:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80d59c:	a94153f3 	ldp	x19, x20, [sp, #16]
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80d5a0:	90000280 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
}
ffffffffea80d5a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80d5a8:	91034000 	add	x0, x0, #0xd0
ffffffffea80d5ac:	14000f39 	b	ffffffffea811290 <vmm_free_region>

ffffffffea80d5b0 <vqueue_signal_avail>:

void vqueue_signal_avail(struct vqueue *vq)
{
ffffffffea80d5b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80d5b4:	910003fd 	mov	x29, sp
ffffffffea80d5b8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d5bc:	aa0003f3 	mov	x19, x0
	spin_lock_saved_state_t state;

	spin_lock_save(&vq->slock, &state, VQ_LOCK_FLAGS);
ffffffffea80d5c0:	9100e014 	add	x20, x0, #0x38
{
ffffffffea80d5c4:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80d5c8:	d53b4220 	mrs	x0, daif
ffffffffea80d5cc:	91012275 	add	x21, x19, #0x48
ffffffffea80d5d0:	37380280 	tbnz	w0, #7, ffffffffea80d620 <vqueue_signal_avail+0x70>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80d5d4:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80d5d8:	aa1403e0 	mov	x0, x20
ffffffffea80d5dc:	97ffd4e0 	bl	ffffffffea80295c <arch_spin_lock>
	if (vq->vring_addr) {
ffffffffea80d5e0:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80d5e4:	b4000440 	cbz	x0, ffffffffea80d66c <vqueue_signal_avail+0xbc>
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80d5e8:	f9401263 	ldr	x3, [x19, #32]
	}
	event_signal(&vq->avail_event, false);
ffffffffea80d5ec:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80d5f0:	aa1503e0 	mov	x0, x21
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80d5f4:	79400062 	ldrh	w2, [x3]
ffffffffea80d5f8:	32000042 	orr	w2, w2, #0x1
ffffffffea80d5fc:	79000062 	strh	w2, [x3]
	event_signal(&vq->avail_event, false);
ffffffffea80d600:	97ffe064 	bl	ffffffffea805790 <event_signal>
    arch_spin_unlock(lock);
ffffffffea80d604:	aa1403e0 	mov	x0, x20
ffffffffea80d608:	97ffd4dd 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80d60c:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&vq->slock, state, VQ_LOCK_FLAGS);
}
ffffffffea80d610:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d614:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80d618:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80d61c:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea80d620:	aa1403e0 	mov	x0, x20
ffffffffea80d624:	97ffd4ce 	bl	ffffffffea80295c <arch_spin_lock>
	if (vq->vring_addr) {
ffffffffea80d628:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80d62c:	b5000120 	cbnz	x0, ffffffffea80d650 <vqueue_signal_avail+0xa0>
	event_signal(&vq->avail_event, false);
ffffffffea80d630:	aa1503e0 	mov	x0, x21
ffffffffea80d634:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80d638:	97ffe056 	bl	ffffffffea805790 <event_signal>
}
ffffffffea80d63c:	f94013f5 	ldr	x21, [sp, #32]
    arch_spin_unlock(lock);
ffffffffea80d640:	aa1403e0 	mov	x0, x20
ffffffffea80d644:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d648:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80d64c:	17ffd4cc 	b	ffffffffea80297c <arch_spin_unlock>
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80d650:	f9401263 	ldr	x3, [x19, #32]
	event_signal(&vq->avail_event, false);
ffffffffea80d654:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80d658:	aa1503e0 	mov	x0, x21
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80d65c:	79400062 	ldrh	w2, [x3]
ffffffffea80d660:	32000042 	orr	w2, w2, #0x1
ffffffffea80d664:	79000062 	strh	w2, [x3]
ffffffffea80d668:	17fffff4 	b	ffffffffea80d638 <vqueue_signal_avail+0x88>
	event_signal(&vq->avail_event, false);
ffffffffea80d66c:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80d670:	aa1503e0 	mov	x0, x21
ffffffffea80d674:	97ffe047 	bl	ffffffffea805790 <event_signal>
ffffffffea80d678:	aa1403e0 	mov	x0, x20
ffffffffea80d67c:	97ffd4c0 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea80d680:	17ffffe3 	b	ffffffffea80d60c <vqueue_signal_avail+0x5c>
ffffffffea80d684:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d688 <vqueue_get_avail_buf>:

	return NO_ERROR;
}

int vqueue_get_avail_buf(struct vqueue *vq, struct vqueue_buf *iovbuf)
{
ffffffffea80d688:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80d68c:	910003fd 	mov	x29, sp
ffffffffea80d690:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d694:	aa0103f4 	mov	x20, x1
ffffffffea80d698:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80d69c:	aa0003f5 	mov	x21, x0
ffffffffea80d6a0:	f9001bf7 	str	x23, [sp, #48]
	spin_lock_saved_state_t state;

	spin_lock_save(&vq->slock, &state, VQ_LOCK_FLAGS);
ffffffffea80d6a4:	9100e016 	add	x22, x0, #0x38
ffffffffea80d6a8:	aa1e03f7 	mov	x23, x30
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80d6ac:	d53b4220 	mrs	x0, daif
ffffffffea80d6b0:	37380100 	tbnz	w0, #7, ffffffffea80d6d0 <vqueue_get_avail_buf+0x48>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80d6b4:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80d6b8:	aa1603e0 	mov	x0, x22
ffffffffea80d6bc:	97ffd4a8 	bl	ffffffffea80295c <arch_spin_lock>
	if (!vq->vring_addr) {
ffffffffea80d6c0:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80d6c4:	b4000de0 	cbz	x0, ffffffffea80d880 <vqueue_get_avail_buf+0x1f8>
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea80d6c8:	52800033 	mov	w19, #0x1                   	// #1
ffffffffea80d6cc:	14000006 	b	ffffffffea80d6e4 <vqueue_get_avail_buf+0x5c>
ffffffffea80d6d0:	aa1603e0 	mov	x0, x22
ffffffffea80d6d4:	97ffd4a2 	bl	ffffffffea80295c <arch_spin_lock>
ffffffffea80d6d8:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80d6dc:	b4000e00 	cbz	x0, ffffffffea80d89c <vqueue_get_avail_buf+0x214>
    spin_lock_saved_state_t state = 0;
ffffffffea80d6e0:	52800013 	mov	w19, #0x0                   	// #0
	uint16_t avail_cnt = vq->vring.avail->idx - vq->last_avail_idx;
ffffffffea80d6e4:	f9400ea1 	ldr	x1, [x21, #24]
ffffffffea80d6e8:	794082a3 	ldrh	w3, [x21, #64]
	if (unlikely(avail_cnt > (uint16_t) vq->vring.num)) {
ffffffffea80d6ec:	794012a0 	ldrh	w0, [x21, #8]
	uint16_t avail_cnt = vq->vring.avail->idx - vq->last_avail_idx;
ffffffffea80d6f0:	79400424 	ldrh	w4, [x1, #2]
ffffffffea80d6f4:	4b030081 	sub	w1, w4, w3
	if (unlikely(avail_cnt > (uint16_t) vq->vring.num)) {
ffffffffea80d6f8:	6b21201f 	cmp	w0, w1, uxth
ffffffffea80d6fc:	54000aa3 	b.cc	ffffffffea80d850 <vqueue_get_avail_buf+0x1c8>  // b.lo, b.ul, b.last
	if (vq->last_avail_idx == vq->vring.avail->idx) {
ffffffffea80d700:	6b03009f 	cmp	w4, w3
ffffffffea80d704:	54000780 	b.eq	ffffffffea80d7f4 <vqueue_get_avail_buf+0x16c>  // b.none
	smp_rmb();
ffffffffea80d708:	d50339bf 	dmb	ishld
	next_idx = vq->vring.avail->ring[vq->last_avail_idx % vq->vring.num];
ffffffffea80d70c:	794082a1 	ldrh	w1, [x21, #64]
ffffffffea80d710:	b9400aa4 	ldr	w4, [x21, #8]
ffffffffea80d714:	f9400ea3 	ldr	x3, [x21, #24]
	vq->last_avail_idx++;
ffffffffea80d718:	11000422 	add	w2, w1, #0x1
	next_idx = vq->vring.avail->ring[vq->last_avail_idx % vq->vring.num];
ffffffffea80d71c:	1ac40820 	udiv	w0, w1, w4
ffffffffea80d720:	1b048400 	msub	w0, w0, w4, w1
ffffffffea80d724:	8b000460 	add	x0, x3, x0, lsl #1
ffffffffea80d728:	79400803 	ldrh	w3, [x0, #4]
	vq->last_avail_idx++;
ffffffffea80d72c:	790082a2 	strh	w2, [x21, #64]
	if (unlikely(next_idx >= vq->vring.num)) {
ffffffffea80d730:	6b03009f 	cmp	w4, w3
ffffffffea80d734:	540009a9 	b.ls	ffffffffea80d868 <vqueue_get_avail_buf+0x1e0>  // b.plast
		desc = &vq->vring.desc[next_idx];
ffffffffea80d738:	f9400aa9 	ldr	x9, [x21, #16]
			iovlist = &iovbuf->out_iovs;
ffffffffea80d73c:	9100a28c 	add	x12, x20, #0x28
	iovbuf->head = next_idx;
ffffffffea80d740:	79000283 	strh	w3, [x20]
			iovlist = &iovbuf->out_iovs;
ffffffffea80d744:	91002294 	add	x20, x20, #0x8
	iovbuf->in_iovs.used = 0;
ffffffffea80d748:	b900069f 	str	wzr, [x20, #4]
	iovbuf->in_iovs.len  = 0;
ffffffffea80d74c:	f900069f 	str	xzr, [x20, #8]
	iovbuf->out_iovs.used = 0;
ffffffffea80d750:	b900269f 	str	wzr, [x20, #36]
	iovbuf->out_iovs.len  = 0;
ffffffffea80d754:	f900169f 	str	xzr, [x20, #40]
		desc = &vq->vring.desc[next_idx];
ffffffffea80d758:	d37c3c63 	ubfiz	x3, x3, #4, #16
ffffffffea80d75c:	8b030125 	add	x5, x9, x3
		if (desc->flags & VRING_DESC_F_WRITE) {
ffffffffea80d760:	794018a7 	ldrh	w7, [x5, #12]
			iovlist = &iovbuf->out_iovs;
ffffffffea80d764:	f27f00ff 	tst	x7, #0x2
ffffffffea80d768:	9a8c0280 	csel	x0, x20, x12, eq  // eq = none
		if (iovlist->used < iovlist->cnt) {
ffffffffea80d76c:	29400801 	ldp	w1, w2, [x0]
ffffffffea80d770:	6b01005f 	cmp	w2, w1
ffffffffea80d774:	54000382 	b.cs	ffffffffea80d7e4 <vqueue_get_avail_buf+0x15c>  // b.hs, b.nlast
			iovlist->iovs[iovlist->used].len = desc->len;
ffffffffea80d778:	a941180a 	ldp	x10, x6, [x0, #16]
ffffffffea80d77c:	2a0203e8 	mov	w8, w2
ffffffffea80d780:	b94008a1 	ldr	w1, [x5, #8]
			iovlist->used++;
ffffffffea80d784:	11000442 	add	w2, w2, #0x1
			iovlist->phys[iovlist->used] = (paddr_t) desc->addr;
ffffffffea80d788:	f863692b 	ldr	x11, [x9, x3]
			iovlist->iovs[iovlist->used].len = desc->len;
ffffffffea80d78c:	8b0810c6 	add	x6, x6, x8, lsl #4
		next_idx = desc->next;
ffffffffea80d790:	79401ca3 	ldrh	w3, [x5, #14]
			iovlist->iovs[iovlist->used].len = desc->len;
ffffffffea80d794:	f90004c1 	str	x1, [x6, #8]
			iovlist->phys[iovlist->used] = (paddr_t) desc->addr;
ffffffffea80d798:	f828794b 	str	x11, [x10, x8, lsl #3]
			iovlist->used++;
ffffffffea80d79c:	b9000402 	str	w2, [x0, #4]
			iovlist->len += desc->len;
ffffffffea80d7a0:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80d7a4:	8b010042 	add	x2, x2, x1
ffffffffea80d7a8:	f9000402 	str	x2, [x0, #8]
	} while (desc->flags & VRING_DESC_F_NEXT);
ffffffffea80d7ac:	36000207 	tbz	w7, #0, ffffffffea80d7ec <vqueue_get_avail_buf+0x164>
		if (unlikely(next_idx >= vq->vring.num)) {
ffffffffea80d7b0:	6b03009f 	cmp	w4, w3
ffffffffea80d7b4:	54fffd28 	b.hi	ffffffffea80d758 <vqueue_get_avail_buf+0xd0>  // b.pmore
			return ERR_NOT_VALID;
ffffffffea80d7b8:	128000d4 	mov	w20, #0xfffffff9            	// #-7
    arch_spin_unlock(lock);
ffffffffea80d7bc:	aa1603e0 	mov	x0, x22
ffffffffea80d7c0:	97ffd46f 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea80d7c4:	34000053 	cbz	w19, ffffffffea80d7cc <vqueue_get_avail_buf+0x144>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80d7c8:	d50342ff 	msr	daifclr, #0x2
	int ret = _vqueue_get_avail_buf_locked(vq, iovbuf);
	spin_unlock_restore(&vq->slock, state, VQ_LOCK_FLAGS);
	return ret;
}
ffffffffea80d7cc:	2a1403e0 	mov	w0, w20
ffffffffea80d7d0:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d7d4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d7d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d7dc:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d7e0:	d65f03c0 	ret
			return ERR_TOO_BIG;
ffffffffea80d7e4:	12800314 	mov	w20, #0xffffffe7            	// #-25
ffffffffea80d7e8:	17fffff5 	b	ffffffffea80d7bc <vqueue_get_avail_buf+0x134>
	return NO_ERROR;
ffffffffea80d7ec:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea80d7f0:	17fffff3 	b	ffffffffea80d7bc <vqueue_get_avail_buf+0x134>
ffffffffea80d7f4:	f9001fb8 	str	x24, [x29, #56]
		event_unsignal(&vq->avail_event);
ffffffffea80d7f8:	910122b8 	add	x24, x21, #0x48
ffffffffea80d7fc:	aa1803e0 	mov	x0, x24
ffffffffea80d800:	97ffe024 	bl	ffffffffea805890 <event_unsignal>
		vq->vring.used->flags &= ~VRING_USED_F_NO_NOTIFY;
ffffffffea80d804:	f94012a1 	ldr	x1, [x21, #32]
ffffffffea80d808:	79400020 	ldrh	w0, [x1]
ffffffffea80d80c:	121f7800 	and	w0, w0, #0xfffffffe
ffffffffea80d810:	79000020 	strh	w0, [x1]
		smp_mb();
ffffffffea80d814:	d5033bbf 	dmb	ish
		if (vq->last_avail_idx == vq->vring.avail->idx) {
ffffffffea80d818:	f9400ea0 	ldr	x0, [x21, #24]
ffffffffea80d81c:	794082a1 	ldrh	w1, [x21, #64]
ffffffffea80d820:	79400400 	ldrh	w0, [x0, #2]
ffffffffea80d824:	6b00003f 	cmp	w1, w0
ffffffffea80d828:	54000340 	b.eq	ffffffffea80d890 <vqueue_get_avail_buf+0x208>  // b.none
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80d82c:	f94012a3 	ldr	x3, [x21, #32]
		event_signal(&vq->avail_event, false);
ffffffffea80d830:	aa1803e0 	mov	x0, x24
ffffffffea80d834:	52800001 	mov	w1, #0x0                   	// #0
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80d838:	79400062 	ldrh	w2, [x3]
ffffffffea80d83c:	32000042 	orr	w2, w2, #0x1
ffffffffea80d840:	79000062 	strh	w2, [x3]
		event_signal(&vq->avail_event, false);
ffffffffea80d844:	97ffdfd3 	bl	ffffffffea805790 <event_signal>
ffffffffea80d848:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80d84c:	17ffffaf 	b	ffffffffea80d708 <vqueue_get_avail_buf+0x80>
		panic("vq %p: new avail idx out of range (old %u new %u)\n",
ffffffffea80d850:	d0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80d854:	aa1503e2 	mov	x2, x21
ffffffffea80d858:	91046021 	add	x1, x1, #0x118
ffffffffea80d85c:	aa1703e0 	mov	x0, x23
ffffffffea80d860:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80d864:	94001069 	bl	ffffffffea811a08 <_panic>
		panic("vq %p: head out of range %u (max %u)\n",
ffffffffea80d868:	d0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80d86c:	aa1503e2 	mov	x2, x21
ffffffffea80d870:	91054021 	add	x1, x1, #0x150
ffffffffea80d874:	aa1703e0 	mov	x0, x23
ffffffffea80d878:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80d87c:	94001063 	bl	ffffffffea811a08 <_panic>
ffffffffea80d880:	aa1603e0 	mov	x0, x22
		return ERR_CHANNEL_CLOSED;
ffffffffea80d884:	128001d4 	mov	w20, #0xfffffff1            	// #-15
ffffffffea80d888:	97ffd43d 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea80d88c:	17ffffcf 	b	ffffffffea80d7c8 <vqueue_get_avail_buf+0x140>
			return ERR_NOT_ENOUGH_BUFFER;
ffffffffea80d890:	12800114 	mov	w20, #0xfffffff7            	// #-9
ffffffffea80d894:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80d898:	17ffffc9 	b	ffffffffea80d7bc <vqueue_get_avail_buf+0x134>
ffffffffea80d89c:	aa1603e0 	mov	x0, x22
		return ERR_CHANNEL_CLOSED;
ffffffffea80d8a0:	128001d4 	mov	w20, #0xfffffff1            	// #-15
ffffffffea80d8a4:	97ffd436 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea80d8a8:	17ffffc9 	b	ffffffffea80d7cc <vqueue_get_avail_buf+0x144>
ffffffffea80d8ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d8b0 <vqueue_map_iovs>:

int vqueue_map_iovs(struct vqueue_iovs *vqiovs, u_int flags, uint32_t guest)
{
ffffffffea80d8b0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80d8b4:	910003fd 	mov	x29, sp
	DEBUG_ASSERT(vqiovs);
	DEBUG_ASSERT(vqiovs->phys);
	DEBUG_ASSERT(vqiovs->iovs);
	DEBUG_ASSERT(vqiovs->used <= vqiovs->cnt);

	for (i = 0; i < vqiovs->used; i++) {
ffffffffea80d8b8:	b9400403 	ldr	w3, [x0, #4]
{
ffffffffea80d8bc:	f9002ffc 	str	x28, [sp, #88]
	for (i = 0; i < vqiovs->used; i++) {
ffffffffea80d8c0:	34000883 	cbz	w3, ffffffffea80d9d0 <vqueue_map_iovs+0x120>
ffffffffea80d8c4:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80d8c8:	aa0003f4 	mov	x20, x0
ffffffffea80d8cc:	a9025bb5 	stp	x21, x22, [x29, #32]
			TRACEF("%s: check_guest_pa_valid failed, error = %d",
				__func__, ret);
			return ret;
		}
        vqiovs->iovs[i].base = NULL;
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80d8d0:	90000295 	adrp	x21, ffffffffea85d000 <rb_data+0x18>
ffffffffea80d8d4:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80d8d8:	2a0203f6 	mov	w22, w2
ffffffffea80d8dc:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea80d8e0:	d0000058 	adrp	x24, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80d8e4:	2a0103f7 	mov	w23, w1
ffffffffea80d8e8:	9106c318 	add	x24, x24, #0x1b0
ffffffffea80d8ec:	910342b5 	add	x21, x21, #0xd0
	for (i = 0; i < vqiovs->used; i++) {
ffffffffea80d8f0:	5280001a 	mov	w26, #0x0                   	// #0
ffffffffea80d8f4:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80d8f8:	14000011 	b	ffffffffea80d93c <vqueue_map_iovs+0x8c>
        vqiovs->iovs[i].base = NULL;
ffffffffea80d8fc:	a9410682 	ldp	x2, x1, [x20, #16]
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80d900:	2a1703e7 	mov	w7, w23
ffffffffea80d904:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80d908:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea80d90c:	8b1b0023 	add	x3, x1, x27
ffffffffea80d910:	f8797845 	ldr	x5, [x2, x25, lsl #3]
ffffffffea80d914:	aa1303e2 	mov	x2, x19
        vqiovs->iovs[i].base = NULL;
ffffffffea80d918:	f83b683f 	str	xzr, [x1, x27]
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80d91c:	aa1803e1 	mov	x1, x24
ffffffffea80d920:	94000dfa 	bl	ffffffffea811108 <vmm_alloc_physical>
ffffffffea80d924:	2a0003fc 	mov	w28, w0
		                         roundedup_iovs_sz,
		                         &vqiovs->iovs[i].base, PAGE_SIZE_SHIFT,
		                         vqiovs->phys[i], 0, flags);
		if (ret) {
ffffffffea80d928:	350005e0 	cbnz	w0, ffffffffea80d9e4 <vqueue_map_iovs+0x134>
	for (i = 0; i < vqiovs->used; i++) {
ffffffffea80d92c:	b9400680 	ldr	w0, [x20, #4]
ffffffffea80d930:	1100075a 	add	w26, w26, #0x1
ffffffffea80d934:	6b1a001f 	cmp	w0, w26
ffffffffea80d938:	54000429 	b.ls	ffffffffea80d9bc <vqueue_map_iovs+0x10c>  // b.plast
		roundedup_iovs_sz = ROUNDUP(vqiovs->iovs[i].len, PAGE_SIZE);
ffffffffea80d93c:	a9410e80 	ldp	x0, x3, [x20, #16]
ffffffffea80d940:	2a1a03f9 	mov	w25, w26
		ret = trusty_hyp_check_guest_pa_valid(vqiovs->phys[i],
ffffffffea80d944:	2a1603e2 	mov	w2, w22
		roundedup_iovs_sz = ROUNDUP(vqiovs->iovs[i].len, PAGE_SIZE);
ffffffffea80d948:	d37cef3b 	lsl	x27, x25, #4
ffffffffea80d94c:	8b1b0063 	add	x3, x3, x27
		ret = trusty_hyp_check_guest_pa_valid(vqiovs->phys[i],
ffffffffea80d950:	f8797800 	ldr	x0, [x0, x25, lsl #3]
		roundedup_iovs_sz = ROUNDUP(vqiovs->iovs[i].len, PAGE_SIZE);
ffffffffea80d954:	f9400473 	ldr	x19, [x3, #8]
ffffffffea80d958:	913ffe73 	add	x19, x19, #0xfff
ffffffffea80d95c:	9274ce73 	and	x19, x19, #0xfffffffffffff000
		ret = trusty_hyp_check_guest_pa_valid(vqiovs->phys[i],
ffffffffea80d960:	aa1303e1 	mov	x1, x19
ffffffffea80d964:	97ffd36b 	bl	ffffffffea802710 <trusty_hyp_check_guest_pa_valid>
ffffffffea80d968:	aa0003e4 	mov	x4, x0
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80d96c:	aa1503e0 	mov	x0, x21
		ret = trusty_hyp_check_guest_pa_valid(vqiovs->phys[i],
ffffffffea80d970:	2a0403fc 	mov	w28, w4
		if (ret != NO_ERROR) {
ffffffffea80d974:	34fffc44 	cbz	w4, ffffffffea80d8fc <vqueue_map_iovs+0x4c>
			TRACEF("%s: check_guest_pa_valid failed, error = %d",
ffffffffea80d978:	d0000043 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80d97c:	d0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80d980:	d0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80d984:	91042063 	add	x3, x3, #0x108
ffffffffea80d988:	52801e42 	mov	w2, #0xf2                  	// #242
ffffffffea80d98c:	9103a021 	add	x1, x1, #0xe8
ffffffffea80d990:	9105e000 	add	x0, x0, #0x178
ffffffffea80d994:	94001583 	bl	ffffffffea812fa0 <_printf>
		vmm_free_region(vmm_get_kernel_aspace(),
		                (vaddr_t)vqiovs->iovs[i].base);
		vqiovs->iovs[i].base = NULL;
	}
	return ret;
}
ffffffffea80d998:	2a1c03e0 	mov	w0, w28
ffffffffea80d99c:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea80d9a0:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d9a4:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d9a8:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d9ac:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80d9b0:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea80d9b4:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80d9b8:	d65f03c0 	ret
ffffffffea80d9bc:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80d9c0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d9c4:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d9c8:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80d9cc:	f9402bbb 	ldr	x27, [x29, #80]
	return NO_ERROR;
ffffffffea80d9d0:	5280001c 	mov	w28, #0x0                   	// #0
}
ffffffffea80d9d4:	2a1c03e0 	mov	w0, w28
ffffffffea80d9d8:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea80d9dc:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80d9e0:	d65f03c0 	ret
	while (i--) {
ffffffffea80d9e4:	51000753 	sub	w19, w26, #0x1
ffffffffea80d9e8:	34fffd9a 	cbz	w26, ffffffffea80d998 <vqueue_map_iovs+0xe8>
ffffffffea80d9ec:	f9400e80 	ldr	x0, [x20, #24]
ffffffffea80d9f0:	d37c7e73 	ubfiz	x19, x19, #4, #32
ffffffffea80d9f4:	d503201f 	nop
		vmm_free_region(vmm_get_kernel_aspace(),
ffffffffea80d9f8:	f8736801 	ldr	x1, [x0, x19]
ffffffffea80d9fc:	aa1503e0 	mov	x0, x21
ffffffffea80da00:	94000e24 	bl	ffffffffea811290 <vmm_free_region>
		vqiovs->iovs[i].base = NULL;
ffffffffea80da04:	f9400e80 	ldr	x0, [x20, #24]
ffffffffea80da08:	f833681f 	str	xzr, [x0, x19]
ffffffffea80da0c:	d1004273 	sub	x19, x19, #0x10
	while (i--) {
ffffffffea80da10:	b100427f 	cmn	x19, #0x10
ffffffffea80da14:	54ffff21 	b.ne	ffffffffea80d9f8 <vqueue_map_iovs+0x148>  // b.any
ffffffffea80da18:	17ffffe0 	b	ffffffffea80d998 <vqueue_map_iovs+0xe8>
ffffffffea80da1c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80da20 <vqueue_unmap_iovs>:
	DEBUG_ASSERT(vqiovs);
	DEBUG_ASSERT(vqiovs->phys);
	DEBUG_ASSERT(vqiovs->iovs);
	DEBUG_ASSERT(vqiovs->used <= vqiovs->cnt);

	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80da20:	b9400401 	ldr	w1, [x0, #4]
ffffffffea80da24:	34000321 	cbz	w1, ffffffffea80da88 <vqueue_unmap_iovs+0x68>
{
ffffffffea80da28:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80da2c:	910003fd 	mov	x29, sp
ffffffffea80da30:	f9400c01 	ldr	x1, [x0, #24]
ffffffffea80da34:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80da38:	90000296 	adrp	x22, ffffffffea85d000 <rb_data+0x18>
ffffffffea80da3c:	aa0003f5 	mov	x21, x0
		/* base is expected to be set */
		DEBUG_ASSERT(vqiovs->iovs[i].base);
		vmm_free_region(vmm_get_kernel_aspace(),
ffffffffea80da40:	910342d6 	add	x22, x22, #0xd0
{
ffffffffea80da44:	a90153f3 	stp	x19, x20, [sp, #16]
	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80da48:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea80da4c:	d503201f 	nop
		                (vaddr_t)vqiovs->iovs[i].base);
ffffffffea80da50:	d37c7e74 	ubfiz	x20, x19, #4, #32
		vmm_free_region(vmm_get_kernel_aspace(),
ffffffffea80da54:	aa1603e0 	mov	x0, x22
	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80da58:	11000673 	add	w19, w19, #0x1
		vmm_free_region(vmm_get_kernel_aspace(),
ffffffffea80da5c:	f8746821 	ldr	x1, [x1, x20]
ffffffffea80da60:	94000e0c 	bl	ffffffffea811290 <vmm_free_region>
		vqiovs->iovs[i].base = NULL;
ffffffffea80da64:	f9400ea1 	ldr	x1, [x21, #24]
	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80da68:	b94006a0 	ldr	w0, [x21, #4]
		vqiovs->iovs[i].base = NULL;
ffffffffea80da6c:	f834683f 	str	xzr, [x1, x20]
	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80da70:	6b13001f 	cmp	w0, w19
ffffffffea80da74:	54fffee8 	b.hi	ffffffffea80da50 <vqueue_unmap_iovs+0x30>  // b.pmore
	}
}
ffffffffea80da78:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80da7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80da80:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80da84:	d65f03c0 	ret
ffffffffea80da88:	d65f03c0 	ret
ffffffffea80da8c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80da90 <vqueue_add_buf>:
	vq->vring.used->idx++;
	return NO_ERROR;
}

int vqueue_add_buf(struct vqueue *vq, struct vqueue_buf *buf, uint32_t len)
{
ffffffffea80da90:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80da94:	910003fd 	mov	x29, sp
ffffffffea80da98:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80da9c:	aa0003f3 	mov	x19, x0
ffffffffea80daa0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80daa4:	aa0103f4 	mov	x20, x1
ffffffffea80daa8:	2a0203f6 	mov	w22, w2
	spin_lock_saved_state_t state;

	spin_lock_save(&vq->slock, &state, VQ_LOCK_FLAGS);
ffffffffea80daac:	9100e015 	add	x21, x0, #0x38
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80dab0:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80dab4:	37380180 	tbnz	w0, #7, ffffffffea80dae4 <vqueue_add_buf+0x54>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80dab8:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80dabc:	aa1503e0 	mov	x0, x21
ffffffffea80dac0:	97ffd3a7 	bl	ffffffffea80295c <arch_spin_lock>
	if (!vq->vring_addr) {
ffffffffea80dac4:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80dac8:	b4000580 	cbz	x0, ffffffffea80db78 <vqueue_add_buf+0xe8>
	if (buf->head >= vq->vring.num) {
ffffffffea80dacc:	79400285 	ldrh	w5, [x20]
ffffffffea80dad0:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea80dad4:	6b05003f 	cmp	w1, w5
ffffffffea80dad8:	54000589 	b.ls	ffffffffea80db88 <vqueue_add_buf+0xf8>  // b.plast
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea80dadc:	52800034 	mov	w20, #0x1                   	// #1
ffffffffea80dae0:	1400000a 	b	ffffffffea80db08 <vqueue_add_buf+0x78>
ffffffffea80dae4:	aa1503e0 	mov	x0, x21
ffffffffea80dae8:	97ffd39d 	bl	ffffffffea80295c <arch_spin_lock>
	if (!vq->vring_addr) {
ffffffffea80daec:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80daf0:	b4000340 	cbz	x0, ffffffffea80db58 <vqueue_add_buf+0xc8>
	if (buf->head >= vq->vring.num) {
ffffffffea80daf4:	79400285 	ldrh	w5, [x20]
ffffffffea80daf8:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea80dafc:	6b05003f 	cmp	w1, w5
ffffffffea80db00:	54000349 	b.ls	ffffffffea80db68 <vqueue_add_buf+0xd8>  // b.plast
    spin_lock_saved_state_t state = 0;
ffffffffea80db04:	52800014 	mov	w20, #0x0                   	// #0
	used = &vq->vring.used->ring[vq->vring.used->idx % vq->vring.num];
ffffffffea80db08:	f9401263 	ldr	x3, [x19, #32]
ffffffffea80db0c:	79400464 	ldrh	w4, [x3, #2]
ffffffffea80db10:	1ac10880 	udiv	w0, w4, w1
ffffffffea80db14:	1b019000 	msub	w0, w0, w1, w4
ffffffffea80db18:	8b000c60 	add	x0, x3, x0, lsl #3
	used->len = len;
ffffffffea80db1c:	2900d805 	stp	w5, w22, [x0, #4]
	smp_wmb();
ffffffffea80db20:	d5033abf 	dmb	ishst
	vq->vring.used->idx++;
ffffffffea80db24:	f9401262 	ldr	x2, [x19, #32]
    arch_spin_unlock(lock);
ffffffffea80db28:	aa1503e0 	mov	x0, x21
ffffffffea80db2c:	79400441 	ldrh	w1, [x2, #2]
ffffffffea80db30:	11000421 	add	w1, w1, #0x1
ffffffffea80db34:	79000441 	strh	w1, [x2, #2]
ffffffffea80db38:	97ffd391 	bl	ffffffffea80297c <arch_spin_unlock>
	return NO_ERROR;
ffffffffea80db3c:	52800000 	mov	w0, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea80db40:	34000054 	cbz	w20, ffffffffea80db48 <vqueue_add_buf+0xb8>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80db44:	d50342ff 	msr	daifclr, #0x2
	int ret = _vqueue_add_buf_locked(vq, buf, len);
	spin_unlock_restore(&vq->slock, state, VQ_LOCK_FLAGS);
	return ret;
}
ffffffffea80db48:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80db4c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80db50:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80db54:	d65f03c0 	ret
ffffffffea80db58:	aa1503e0 	mov	x0, x21
ffffffffea80db5c:	97ffd388 	bl	ffffffffea80297c <arch_spin_unlock>
		return ERR_CHANNEL_CLOSED;
ffffffffea80db60:	128001c0 	mov	w0, #0xfffffff1            	// #-15
ffffffffea80db64:	17fffff9 	b	ffffffffea80db48 <vqueue_add_buf+0xb8>
ffffffffea80db68:	aa1503e0 	mov	x0, x21
ffffffffea80db6c:	97ffd384 	bl	ffffffffea80297c <arch_spin_unlock>
		return ERR_NOT_VALID;
ffffffffea80db70:	128000c0 	mov	w0, #0xfffffff9            	// #-7
ffffffffea80db74:	17fffff5 	b	ffffffffea80db48 <vqueue_add_buf+0xb8>
ffffffffea80db78:	aa1503e0 	mov	x0, x21
ffffffffea80db7c:	97ffd380 	bl	ffffffffea80297c <arch_spin_unlock>
		return ERR_CHANNEL_CLOSED;
ffffffffea80db80:	128001c0 	mov	w0, #0xfffffff1            	// #-15
ffffffffea80db84:	17fffff0 	b	ffffffffea80db44 <vqueue_add_buf+0xb4>
ffffffffea80db88:	aa1503e0 	mov	x0, x21
ffffffffea80db8c:	97ffd37c 	bl	ffffffffea80297c <arch_spin_unlock>
		return ERR_NOT_VALID;
ffffffffea80db90:	128000c0 	mov	w0, #0xfffffff9            	// #-7
ffffffffea80db94:	17ffffec 	b	ffffffffea80db44 <vqueue_add_buf+0xb4>

ffffffffea80db98 <trusty_sm_init>:
	.stdcall_handler = trusty_sm_stdcall,
	.nopcall_handler = trusty_sm_nopcall
};

static void trusty_sm_init(uint level)
{
ffffffffea80db98:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	int err;

	dprintf(INFO, "Initializing Trusted OS SMC handler\n");

	err = sm_register_entity(SMC_ENTITY_TRUSTED_OS, &trusty_sm_entity);
ffffffffea80db9c:	f0000041 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea80dba0:	52800640 	mov	w0, #0x32                  	// #50
ffffffffea80dba4:	91390021 	add	x1, x1, #0xe40
{
ffffffffea80dba8:	910003fd 	mov	x29, sp
	err = sm_register_entity(SMC_ENTITY_TRUSTED_OS, &trusty_sm_entity);
ffffffffea80dbac:	97ffeb85 	bl	ffffffffea8089c0 <sm_register_entity>
	if (err) {
ffffffffea80dbb0:	35000060 	cbnz	w0, ffffffffea80dbbc <trusty_sm_init+0x24>
		TRACEF("WARNING: Cannot register SMC entity! (%d)\n", err);
	}
}
ffffffffea80dbb4:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80dbb8:	d65f03c0 	ret
ffffffffea80dbbc:	a8c17bfd 	ldp	x29, x30, [sp], #16
		TRACEF("WARNING: Cannot register SMC entity! (%d)\n", err);
ffffffffea80dbc0:	d0000044 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80dbc4:	2a0003e3 	mov	w3, w0
ffffffffea80dbc8:	d0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80dbcc:	52802442 	mov	w2, #0x122                 	// #290
ffffffffea80dbd0:	9109c021 	add	x1, x1, #0x270
ffffffffea80dbd4:	910ac080 	add	x0, x4, #0x2b0
ffffffffea80dbd8:	140014f2 	b	ffffffffea812fa0 <_printf>
ffffffffea80dbdc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80dbe0 <get_ns_mem_buf>:
{
ffffffffea80dbe0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80dbe4:	910003fd 	mov	x29, sp
ffffffffea80dbe8:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80dbec:	aa0303f3 	mov	x19, x3
	status_t rc = smc32_decode_mem_buf_info(args, ppa, psz, pflags);
ffffffffea80dbf0:	97ffebda 	bl	ffffffffea808b58 <smc32_decode_mem_buf_info>
	if (rc != NO_ERROR) {
ffffffffea80dbf4:	35000100 	cbnz	w0, ffffffffea80dc14 <get_ns_mem_buf+0x34>
	uint mem_type = *pflags & ARCH_MMU_FLAG_CACHE_MASK;
ffffffffea80dbf8:	b9400260 	ldr	w0, [x19]
ffffffffea80dbfc:	12000401 	and	w1, w0, #0x3
	if (mem_type != ARCH_MMU_FLAG_CACHED &&
ffffffffea80dc00:	7100043f 	cmp	w1, #0x1
ffffffffea80dc04:	540000e8 	b.hi	ffffffffea80dc20 <get_ns_mem_buf+0x40>  // b.pmore
		return ERR_INVALID_ARGS;
ffffffffea80dc08:	721e041f 	tst	w0, #0xc
ffffffffea80dc0c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80dc10:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
}
ffffffffea80dc14:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80dc18:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80dc1c:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80dc20:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80dc24:	17fffffc 	b	ffffffffea80dc14 <get_ns_mem_buf+0x34>

ffffffffea80dc28 <trusty_sm_nopcall>:
{
ffffffffea80dc28:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80dc2c:	aa0003e1 	mov	x1, x0
ffffffffea80dc30:	910003fd 	mov	x29, sp
	uint32_t guest = args->params[SMC_ARGS_GUESTID];
ffffffffea80dc34:	b9401c02 	ldr	w2, [x0, #28]
	if (((int32_t)guest != HV_GUEST_ID) &&
ffffffffea80dc38:	51004040 	sub	w0, w2, #0x10
ffffffffea80dc3c:	3100481f 	cmn	w0, #0x12
ffffffffea80dc40:	540003c9 	b.ls	ffffffffea80dcb8 <trusty_sm_nopcall+0x90>  // b.plast
	switch (args->params[0]) {
ffffffffea80dc44:	b9400420 	ldr	w0, [x1, #4]
ffffffffea80dc48:	52800323 	mov	w3, #0x19                  	// #25
ffffffffea80dc4c:	72a64003 	movk	w3, #0x3200, lsl #16
ffffffffea80dc50:	6b03001f 	cmp	w0, w3
ffffffffea80dc54:	540002a0 	b.eq	ffffffffea80dca8 <trusty_sm_nopcall+0x80>  // b.none
ffffffffea80dc58:	52800342 	mov	w2, #0x1a                  	// #26
ffffffffea80dc5c:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80dc60:	6b02001f 	cmp	w0, w2
ffffffffea80dc64:	540000e0 	b.eq	ffffffffea80dc80 <trusty_sm_nopcall+0x58>  // b.none
ffffffffea80dc68:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80dc6c:	d0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80dc70:	9106e000 	add	x0, x0, #0x1b8
ffffffffea80dc74:	f8617800 	ldr	x0, [x0, x1, lsl #3]
}
ffffffffea80dc78:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80dc7c:	d65f03c0 	ret
		res = arm_gic_sim_irq_handler(args->params[1]);
ffffffffea80dc80:	b9400820 	ldr	w0, [x1, #8]
ffffffffea80dc84:	97ffdc63 	bl	ffffffffea804e10 <arm_gic_sim_irq_handler>
ffffffffea80dc88:	93407c00 	sxtw	x0, w0
	if (err >= 0) {
ffffffffea80dc8c:	b6ffff60 	tbz	x0, #63, ffffffffea80dc78 <trusty_sm_nopcall+0x50>
ffffffffea80dc90:	91006001 	add	x1, x0, #0x18
ffffffffea80dc94:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea80dc98:	f100403f 	cmp	x1, #0x10
ffffffffea80dc9c:	54fffe89 	b.ls	ffffffffea80dc6c <trusty_sm_nopcall+0x44>  // b.plast
}
ffffffffea80dca0:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80dca4:	d65f03c0 	ret
		res = virtio_kick_vq(args->params[1], args->params[2], guest);
ffffffffea80dca8:	29410420 	ldp	w0, w1, [x1, #8]
ffffffffea80dcac:	9400029d 	bl	ffffffffea80e720 <virtio_kick_vq>
ffffffffea80dcb0:	93407c00 	sxtw	x0, w0
		break;
ffffffffea80dcb4:	17fffff6 	b	ffffffffea80dc8c <trusty_sm_nopcall+0x64>
		TRACEF("%s: Error. Unexpected guestID %u\n",
ffffffffea80dcb8:	2a0203e4 	mov	w4, w2
ffffffffea80dcbc:	d0000043 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80dcc0:	d0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80dcc4:	d0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80dcc8:	910a6063 	add	x3, x3, #0x298
ffffffffea80dccc:	52801fe2 	mov	w2, #0xff                  	// #255
ffffffffea80dcd0:	91096021 	add	x1, x1, #0x258
ffffffffea80dcd4:	910ba000 	add	x0, x0, #0x2e8
ffffffffea80dcd8:	940014b2 	bl	ffffffffea812fa0 <_printf>
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80dcdc:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80dce0:	17ffffe6 	b	ffffffffea80dc78 <trusty_sm_nopcall+0x50>
ffffffffea80dce4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80dce8 <lock_bl_data_interface>:
}
ffffffffea80dce8:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80dcec:	d65f03c0 	ret

ffffffffea80dcf0 <handle_bl_data_interface>:
}
ffffffffea80dcf0:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80dcf4:	d65f03c0 	ret

ffffffffea80dcf8 <set_root_of_trust_params>:
}
ffffffffea80dcf8:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80dcfc:	d65f03c0 	ret

ffffffffea80dd00 <trusty_sm_stdcall>:
{
ffffffffea80dd00:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80dd04:	910003fd 	mov	x29, sp
ffffffffea80dd08:	f9000bf3 	str	x19, [sp, #16]
	uint32_t guest = args->params[SMC_ARGS_GUESTID];
ffffffffea80dd0c:	b9401c13 	ldr	w19, [x0, #28]
	 if (((int32_t)guest != HV_GUEST_ID) &&
ffffffffea80dd10:	51004261 	sub	w1, w19, #0x10
ffffffffea80dd14:	3100483f 	cmn	w1, #0x12
ffffffffea80dd18:	54001229 	b.ls	ffffffffea80df5c <trusty_sm_stdcall+0x25c>  // b.plast
	switch (args->smc_nr) {
ffffffffea80dd1c:	b9400001 	ldr	w1, [x0]
ffffffffea80dd20:	528003c2 	mov	w2, #0x1e                  	// #30
ffffffffea80dd24:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80dd28:	aa0003e3 	mov	x3, x0
ffffffffea80dd2c:	6b02003f 	cmp	w1, w2
ffffffffea80dd30:	54000e20 	b.eq	ffffffffea80def4 <trusty_sm_stdcall+0x1f4>  // b.none
ffffffffea80dd34:	540002a8 	b.hi	ffffffffea80dd88 <trusty_sm_stdcall+0x88>  // b.pmore
ffffffffea80dd38:	528002c2 	mov	w2, #0x16                  	// #22
ffffffffea80dd3c:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80dd40:	6b02003f 	cmp	w1, w2
ffffffffea80dd44:	54000c00 	b.eq	ffffffffea80dec4 <trusty_sm_stdcall+0x1c4>  // b.none
ffffffffea80dd48:	54000549 	b.ls	ffffffffea80ddf0 <trusty_sm_stdcall+0xf0>  // b.plast
ffffffffea80dd4c:	528002e0 	mov	w0, #0x17                  	// #23
ffffffffea80dd50:	72a64000 	movk	w0, #0x3200, lsl #16
ffffffffea80dd54:	6b00003f 	cmp	w1, w0
ffffffffea80dd58:	54000e20 	b.eq	ffffffffea80df1c <trusty_sm_stdcall+0x21c>  // b.none
ffffffffea80dd5c:	11000400 	add	w0, w0, #0x1
ffffffffea80dd60:	6b00003f 	cmp	w1, w0
ffffffffea80dd64:	54000961 	b.ne	ffffffffea80de90 <trusty_sm_stdcall+0x190>  // b.any
		res = virtio_kick_vq(args->params[0], args->params[1], guest);
ffffffffea80dd68:	29408460 	ldp	w0, w1, [x3, #4]
ffffffffea80dd6c:	2a1303e2 	mov	w2, w19
ffffffffea80dd70:	9400026c 	bl	ffffffffea80e720 <virtio_kick_vq>
ffffffffea80dd74:	93407c00 	sxtw	x0, w0
	if (err >= 0) {
ffffffffea80dd78:	b7f80280 	tbnz	x0, #63, ffffffffea80ddc8 <trusty_sm_stdcall+0xc8>
}
ffffffffea80dd7c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80dd80:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80dd84:	d65f03c0 	ret
	switch (args->smc_nr) {
ffffffffea80dd88:	529fffa2 	mov	w2, #0xfffd                	// #65533
ffffffffea80dd8c:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80dd90:	6b02003f 	cmp	w1, w2
ffffffffea80dd94:	54000ce0 	b.eq	ffffffffea80df30 <trusty_sm_stdcall+0x230>  // b.none
ffffffffea80dd98:	54000529 	b.ls	ffffffffea80de3c <trusty_sm_stdcall+0x13c>  // b.plast
ffffffffea80dd9c:	529fffc0 	mov	w0, #0xfffe                	// #65534
ffffffffea80dda0:	72a64000 	movk	w0, #0x3200, lsl #16
ffffffffea80dda4:	6b00003f 	cmp	w1, w0
ffffffffea80dda8:	540006c0 	b.eq	ffffffffea80de80 <trusty_sm_stdcall+0x180>  // b.none
ffffffffea80ddac:	12b9bfe0 	mov	w0, #0x3200ffff            	// #838926335
ffffffffea80ddb0:	6b00003f 	cmp	w1, w0
ffffffffea80ddb4:	540006e1 	b.ne	ffffffffea80de90 <trusty_sm_stdcall+0x190>  // b.any
		res = set_root_of_trust_params((paddr_t)args->params[0],
ffffffffea80ddb8:	29408460 	ldp	w0, w1, [x3, #4]
ffffffffea80ddbc:	97ffffcf 	bl	ffffffffea80dcf8 <set_root_of_trust_params>
	if (err >= 0) {
ffffffffea80ddc0:	b6fffde0 	tbz	x0, #63, ffffffffea80dd7c <trusty_sm_stdcall+0x7c>
ffffffffea80ddc4:	d503201f 	nop
ffffffffea80ddc8:	91006001 	add	x1, x0, #0x18
ffffffffea80ddcc:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea80ddd0:	f100403f 	cmp	x1, #0x10
ffffffffea80ddd4:	54fffd48 	b.hi	ffffffffea80dd7c <trusty_sm_stdcall+0x7c>  // b.pmore
ffffffffea80ddd8:	d0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80dddc:	9106e000 	add	x0, x0, #0x1b8
}
ffffffffea80dde0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80dde4:	f8617800 	ldr	x0, [x0, x1, lsl #3]
ffffffffea80dde8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ddec:	d65f03c0 	ret
	switch (args->smc_nr) {
ffffffffea80ddf0:	52800282 	mov	w2, #0x14                  	// #20
ffffffffea80ddf4:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80ddf8:	6b02003f 	cmp	w1, w2
ffffffffea80ddfc:	540004e0 	b.eq	ffffffffea80de98 <trusty_sm_stdcall+0x198>  // b.none
ffffffffea80de00:	11000442 	add	w2, w2, #0x1
ffffffffea80de04:	6b02003f 	cmp	w1, w2
ffffffffea80de08:	54000441 	b.ne	ffffffffea80de90 <trusty_sm_stdcall+0x190>  // b.any
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80de0c:	910093a3 	add	x3, x29, #0x24
ffffffffea80de10:	910083a2 	add	x2, x29, #0x20
ffffffffea80de14:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80de18:	97ffff72 	bl	ffffffffea80dbe0 <get_ns_mem_buf>
ffffffffea80de1c:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR) {
ffffffffea80de20:	b5fffac0 	cbnz	x0, ffffffffea80dd78 <trusty_sm_stdcall+0x78>
			res = virtio_start(ns_pa, ns_sz, ns_mmu_flags, guest);
ffffffffea80de24:	29440ba1 	ldp	w1, w2, [x29, #32]
ffffffffea80de28:	2a1303e3 	mov	w3, w19
ffffffffea80de2c:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80de30:	9400017c 	bl	ffffffffea80e420 <virtio_start>
ffffffffea80de34:	93407c00 	sxtw	x0, w0
ffffffffea80de38:	17ffffd0 	b	ffffffffea80dd78 <trusty_sm_stdcall+0x78>
	switch (args->smc_nr) {
ffffffffea80de3c:	528003e2 	mov	w2, #0x1f                  	// #31
ffffffffea80de40:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80de44:	6b02003f 	cmp	w1, w2
ffffffffea80de48:	54000780 	b.eq	ffffffffea80df38 <trusty_sm_stdcall+0x238>  // b.none
ffffffffea80de4c:	11000442 	add	w2, w2, #0x1
ffffffffea80de50:	6b02003f 	cmp	w1, w2
ffffffffea80de54:	540001e1 	b.ne	ffffffffea80de90 <trusty_sm_stdcall+0x190>  // b.any
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80de58:	910093a3 	add	x3, x29, #0x24
ffffffffea80de5c:	910083a2 	add	x2, x29, #0x20
ffffffffea80de60:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80de64:	97ffff5f 	bl	ffffffffea80dbe0 <get_ns_mem_buf>
ffffffffea80de68:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR)
ffffffffea80de6c:	b5fff860 	cbnz	x0, ffffffffea80dd78 <trusty_sm_stdcall+0x78>
			res = ql_tipc_handle_cmd(ns_pa, ns_sz);
ffffffffea80de70:	b94023a1 	ldr	w1, [x29, #32]
ffffffffea80de74:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80de78:	94000788 	bl	ffffffffea80fc98 <ql_tipc_handle_cmd>
ffffffffea80de7c:	17ffffbf 	b	ffffffffea80dd78 <trusty_sm_stdcall+0x78>
		res = handle_bl_data_interface((long)args->params[0],
ffffffffea80de80:	29408460 	ldp	w0, w1, [x3, #4]
ffffffffea80de84:	b9400c62 	ldr	w2, [x3, #12]
ffffffffea80de88:	97ffff9a 	bl	ffffffffea80dcf0 <handle_bl_data_interface>
		break;
ffffffffea80de8c:	17ffffbb 	b	ffffffffea80dd78 <trusty_sm_stdcall+0x78>
	switch (args->smc_nr) {
ffffffffea80de90:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80de94:	17ffffd1 	b	ffffffffea80ddd8 <trusty_sm_stdcall+0xd8>
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80de98:	910093a3 	add	x3, x29, #0x24
ffffffffea80de9c:	910083a2 	add	x2, x29, #0x20
ffffffffea80dea0:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80dea4:	97ffff4f 	bl	ffffffffea80dbe0 <get_ns_mem_buf>
ffffffffea80dea8:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR) {
ffffffffea80deac:	b5fff660 	cbnz	x0, ffffffffea80dd78 <trusty_sm_stdcall+0x78>
			res = virtio_get_description(ns_pa, ns_sz,
ffffffffea80deb0:	29440ba1 	ldp	w1, w2, [x29, #32]
ffffffffea80deb4:	2a1303e3 	mov	w3, w19
ffffffffea80deb8:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80debc:	940000d5 	bl	ffffffffea80e210 <virtio_get_description>
ffffffffea80dec0:	17ffffae 	b	ffffffffea80dd78 <trusty_sm_stdcall+0x78>
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80dec4:	910093a3 	add	x3, x29, #0x24
ffffffffea80dec8:	910083a2 	add	x2, x29, #0x20
ffffffffea80decc:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80ded0:	97ffff44 	bl	ffffffffea80dbe0 <get_ns_mem_buf>
ffffffffea80ded4:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR) {
ffffffffea80ded8:	b5fff500 	cbnz	x0, ffffffffea80dd78 <trusty_sm_stdcall+0x78>
			res = virtio_stop(ns_pa, ns_sz, ns_mmu_flags, guest);
ffffffffea80dedc:	29440ba1 	ldp	w1, w2, [x29, #32]
ffffffffea80dee0:	2a1303e3 	mov	w3, w19
ffffffffea80dee4:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80dee8:	940001b2 	bl	ffffffffea80e5b0 <virtio_stop>
ffffffffea80deec:	93407c00 	sxtw	x0, w0
ffffffffea80def0:	17ffffa2 	b	ffffffffea80dd78 <trusty_sm_stdcall+0x78>
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80def4:	910093a3 	add	x3, x29, #0x24
ffffffffea80def8:	910083a2 	add	x2, x29, #0x20
ffffffffea80defc:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80df00:	97ffff38 	bl	ffffffffea80dbe0 <get_ns_mem_buf>
ffffffffea80df04:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR)
ffffffffea80df08:	b5fff380 	cbnz	x0, ffffffffea80dd78 <trusty_sm_stdcall+0x78>
			res = ql_tipc_create_device(ns_pa, ns_sz, ns_mmu_flags);
ffffffffea80df0c:	29440ba1 	ldp	w1, w2, [x29, #32]
ffffffffea80df10:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80df14:	940006bd 	bl	ffffffffea80fa08 <ql_tipc_create_device>
ffffffffea80df18:	17ffff98 	b	ffffffffea80dd78 <trusty_sm_stdcall+0x78>
		res = virtio_device_reset(args->params[0], guest);
ffffffffea80df1c:	b9400460 	ldr	w0, [x3, #4]
ffffffffea80df20:	2a1303e1 	mov	w1, w19
ffffffffea80df24:	940001d3 	bl	ffffffffea80e670 <virtio_device_reset>
ffffffffea80df28:	93407c00 	sxtw	x0, w0
		break;
ffffffffea80df2c:	17ffff93 	b	ffffffffea80dd78 <trusty_sm_stdcall+0x78>
		res = lock_bl_data_interface();
ffffffffea80df30:	97ffff6e 	bl	ffffffffea80dce8 <lock_bl_data_interface>
		break;
ffffffffea80df34:	17ffff91 	b	ffffffffea80dd78 <trusty_sm_stdcall+0x78>
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80df38:	910093a3 	add	x3, x29, #0x24
ffffffffea80df3c:	910083a2 	add	x2, x29, #0x20
ffffffffea80df40:	9100a3a1 	add	x1, x29, #0x28
ffffffffea80df44:	97ffff27 	bl	ffffffffea80dbe0 <get_ns_mem_buf>
ffffffffea80df48:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR)
ffffffffea80df4c:	b5fff160 	cbnz	x0, ffffffffea80dd78 <trusty_sm_stdcall+0x78>
			res = ql_tipc_shutdown_device(ns_pa);
ffffffffea80df50:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80df54:	9400070b 	bl	ffffffffea80fb80 <ql_tipc_shutdown_device>
ffffffffea80df58:	17ffff88 	b	ffffffffea80dd78 <trusty_sm_stdcall+0x78>
		TRACEF("%s: Error. Unexpected guestID %u\n",
ffffffffea80df5c:	d0000043 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80df60:	d0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80df64:	d0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80df68:	2a1303e4 	mov	w4, w19
ffffffffea80df6c:	910a0063 	add	x3, x3, #0x280
ffffffffea80df70:	52801322 	mov	w2, #0x99                  	// #153
ffffffffea80df74:	91090021 	add	x1, x1, #0x240
ffffffffea80df78:	910ba000 	add	x0, x0, #0x2e8
ffffffffea80df7c:	94001409 	bl	ffffffffea812fa0 <_printf>
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80df80:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80df84:	17ffff7e 	b	ffffffffea80dd7c <trusty_sm_stdcall+0x7c>

ffffffffea80df88 <smc_hv_init>:
}
ffffffffea80df88:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80df8c:	d65f03c0 	ret

ffffffffea80df90 <map_descr>:
	.addl_guests_virtio_bus = NULL,
};

static status_t map_descr(ns_paddr_t buf_pa, void **buf_va, ns_size_t sz,
                          uint buf_mmu_flags, uint32_t guest_id)
{
ffffffffea80df90:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80df94:	910003fd 	mov	x29, sp
ffffffffea80df98:	f9001bf7 	str	x23, [sp, #48]
	status_t ret;
	size_t roundedup_sz;

	if (!buf_pa) {
ffffffffea80df9c:	b4000640 	cbz	x0, ffffffffea80e064 <map_descr+0xd4>
ffffffffea80dfa0:	f9000fb4 	str	x20, [x29, #24]
		LTRACEF("invalid descr addr 0x%llx\n", buf_pa);
		return ERR_INVALID_ARGS;
	}

	if (buf_pa & (PAGE_SIZE-1)) {
ffffffffea80dfa4:	f2402c1f 	tst	x0, #0xfff
ffffffffea80dfa8:	aa0003f4 	mov	x20, x0
ffffffffea80dfac:	54000561 	b.ne	ffffffffea80e058 <map_descr+0xc8>  // b.any
ffffffffea80dfb0:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80dfb4:	2a0203f3 	mov	w19, w2
		LTRACEF("unsuported addr range 0x%llx\n", buf_pa);
		return ERR_INVALID_ARGS;
	}
#endif

	roundedup_sz = ROUNDUP(sz, PAGE_SIZE);
ffffffffea80dfb8:	913ffe73 	add	x19, x19, #0xfff
ffffffffea80dfbc:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80dfc0:	9274ce73 	and	x19, x19, #0xfffffffffffff000
ffffffffea80dfc4:	2a0303f5 	mov	w21, w3
ffffffffea80dfc8:	aa0103f6 	mov	x22, x1
ffffffffea80dfcc:	2a0403e2 	mov	w2, w4
	ret = trusty_hyp_check_guest_pa_valid(buf_pa, roundedup_sz, guest_id);
ffffffffea80dfd0:	aa1303e1 	mov	x1, x19
ffffffffea80dfd4:	97ffd1cf 	bl	ffffffffea802710 <trusty_hyp_check_guest_pa_valid>
ffffffffea80dfd8:	2a0003f7 	mov	w23, w0
	if (ret != NO_ERROR) {
ffffffffea80dfdc:	35000200 	cbnz	w0, ffffffffea80e01c <map_descr+0x8c>
			__func__, ret);
		return ret;
	}

	/* map resource table into our address space */
	return  vmm_alloc_physical(vmm_get_kernel_aspace(), "virtio",
ffffffffea80dfe0:	2a1503e7 	mov	w7, w21
ffffffffea80dfe4:	aa1403e5 	mov	x5, x20
ffffffffea80dfe8:	aa1603e3 	mov	x3, x22
ffffffffea80dfec:	aa1303e2 	mov	x2, x19
ffffffffea80dff0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80dff4:	d0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80dff8:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80dffc:	90000280 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
	                           roundedup_sz,
	                           buf_va, PAGE_SIZE_SHIFT,
	                           (paddr_t) buf_pa, 0, buf_mmu_flags);
}
ffffffffea80e000:	f9401bf7 	ldr	x23, [sp, #48]
	return  vmm_alloc_physical(vmm_get_kernel_aspace(), "virtio",
ffffffffea80e004:	52800006 	mov	w6, #0x0                   	// #0
}
ffffffffea80e008:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return  vmm_alloc_physical(vmm_get_kernel_aspace(), "virtio",
ffffffffea80e00c:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea80e010:	910f8021 	add	x1, x1, #0x3e0
ffffffffea80e014:	91034000 	add	x0, x0, #0xd0
ffffffffea80e018:	14000c3c 	b	ffffffffea811108 <vmm_alloc_physical>
		TRACEF("%s: check_guest_pa_valid failed, error = %d",
ffffffffea80e01c:	b0000045 	adrp	x5, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80e020:	2a0003e4 	mov	w4, w0
ffffffffea80e024:	b0000043 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80e028:	b0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80e02c:	910d6063 	add	x3, x3, #0x358
ffffffffea80e030:	52800e42 	mov	w2, #0x72                  	// #114
ffffffffea80e034:	910c6021 	add	x1, x1, #0x318
ffffffffea80e038:	9105e0a0 	add	x0, x5, #0x178
ffffffffea80e03c:	940013d9 	bl	ffffffffea812fa0 <_printf>
		return ret;
ffffffffea80e040:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80e044:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea80e048:	2a1703e0 	mov	w0, w23
ffffffffea80e04c:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80e050:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80e054:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80e058:	128000f7 	mov	w23, #0xfffffff8            	// #-8
ffffffffea80e05c:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80e060:	17fffffa 	b	ffffffffea80e048 <map_descr+0xb8>
ffffffffea80e064:	128000f7 	mov	w23, #0xfffffff8            	// #-8
ffffffffea80e068:	17fffff8 	b	ffffffffea80e048 <map_descr+0xb8>
ffffffffea80e06c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e070 <get_guest_virtio_bus.constprop.2>:
	if (vb == NULL) {
		TRACEF("%s: Bad pointer. vb is NULL\n", __func__);
		return ERR_INVALID_ARGS;
	}

	if (guest_id > 0) {
ffffffffea80e070:	34000321 	cbz	w1, ffffffffea80e0d4 <get_guest_virtio_bus.constprop.2+0x64>
static status_t get_guest_virtio_bus(struct trusty_virtio_bus **vb,
ffffffffea80e074:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80e078:	910003fd 	mov	x29, sp
ffffffffea80e07c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80e080:	aa0003f4 	mov	x20, x0
		if (guest_id >= guests_vbus_context.num_guests) {
ffffffffea80e084:	d0000040 	adrp	x0, ffffffffea818000 <_mem_phys_base>
static status_t get_guest_virtio_bus(struct trusty_virtio_bus **vb,
ffffffffea80e088:	f90013f5 	str	x21, [sp, #32]
ffffffffea80e08c:	2a0103f3 	mov	w19, w1
		if (guest_id >= guests_vbus_context.num_guests) {
ffffffffea80e090:	91396015 	add	x21, x0, #0xe58
ffffffffea80e094:	b94e5805 	ldr	w5, [x0, #3672]
ffffffffea80e098:	6b05003f 	cmp	w1, w5
ffffffffea80e09c:	540002a2 	b.cs	ffffffffea80e0f0 <get_guest_virtio_bus.constprop.2+0x80>  // b.hs, b.nlast
				__func__, guest_id, guests_vbus_context.num_guests);
			return ERR_INVALID_ARGS;
		}

		/* Barrier against speculating addl_guests_virtio_bus[guest_id - 1] */
		platform_arch_speculation_barrier();
ffffffffea80e0a0:	97ffd046 	bl	ffffffffea8021b8 <platform_arch_speculation_barrier>

		if (guests_vbus_context.addl_guests_virtio_bus == NULL) {
ffffffffea80e0a4:	f9401aa4 	ldr	x4, [x21, #48]
ffffffffea80e0a8:	b40003a4 	cbz	x4, ffffffffea80e11c <get_guest_virtio_bus.constprop.2+0xac>
			TRACEF("%s: addl_guests_virtio_bus init failed\n",
				 __func__);
			return ERR_NOT_READY;
		}

		*vb = guests_vbus_context.addl_guests_virtio_bus + (guest_id - 1);
ffffffffea80e0ac:	51000661 	sub	w1, w19, #0x1
ffffffffea80e0b0:	52800513 	mov	w19, #0x28                  	// #40
	} else {
		*vb = &guests_vbus_context.guest0_virtio_bus;
	}

	return NO_ERROR;
ffffffffea80e0b4:	52800002 	mov	w2, #0x0                   	// #0
		*vb = guests_vbus_context.addl_guests_virtio_bus + (guest_id - 1);
ffffffffea80e0b8:	9bb31021 	umaddl	x1, w1, w19, x4
ffffffffea80e0bc:	f9000281 	str	x1, [x20]
}
ffffffffea80e0c0:	2a0203e0 	mov	w0, w2
ffffffffea80e0c4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80e0c8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e0cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e0d0:	d65f03c0 	ret
		*vb = &guests_vbus_context.guest0_virtio_bus;
ffffffffea80e0d4:	d0000041 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea80e0d8:	91396021 	add	x1, x1, #0xe58
ffffffffea80e0dc:	91002021 	add	x1, x1, #0x8
	return NO_ERROR;
ffffffffea80e0e0:	52800002 	mov	w2, #0x0                   	// #0
		*vb = &guests_vbus_context.guest0_virtio_bus;
ffffffffea80e0e4:	f9000001 	str	x1, [x0]
}
ffffffffea80e0e8:	2a0203e0 	mov	w0, w2
ffffffffea80e0ec:	d65f03c0 	ret
			TRACEF("%s: Bad input, guest %d regd_guests %d\n",
ffffffffea80e0f0:	528014c2 	mov	w2, #0xa6                  	// #166
ffffffffea80e0f4:	b0000043 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80e0f8:	b0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80e0fc:	b0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80e100:	2a1303e4 	mov	w4, w19
ffffffffea80e104:	910da063 	add	x3, x3, #0x368
ffffffffea80e108:	910ca021 	add	x1, x1, #0x328
ffffffffea80e10c:	910e0000 	add	x0, x0, #0x380
ffffffffea80e110:	940013a4 	bl	ffffffffea812fa0 <_printf>
			return ERR_INVALID_ARGS;
ffffffffea80e114:	128000e2 	mov	w2, #0xfffffff8            	// #-8
ffffffffea80e118:	17ffffea 	b	ffffffffea80e0c0 <get_guest_virtio_bus.constprop.2+0x50>
			TRACEF("%s: addl_guests_virtio_bus init failed\n",
ffffffffea80e11c:	528015e2 	mov	w2, #0xaf                  	// #175
ffffffffea80e120:	b0000043 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80e124:	b0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80e128:	b0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80e12c:	910da063 	add	x3, x3, #0x368
ffffffffea80e130:	910ca021 	add	x1, x1, #0x328
ffffffffea80e134:	910ec000 	add	x0, x0, #0x3b0
ffffffffea80e138:	9400139a 	bl	ffffffffea812fa0 <_printf>
ffffffffea80e13c:	12800042 	mov	w2, #0xfffffffd            	// #-3
ffffffffea80e140:	17ffffe0 	b	ffffffffea80e0c0 <get_guest_virtio_bus.constprop.2+0x50>
ffffffffea80e144:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e148 <virtio_register_device>:

/*
 *     Register virtio device
 */
status_t virtio_register_device(struct vdev *vd, uint32_t guest_id)
{
ffffffffea80e148:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	status_t ret = ERR_BAD_STATE;
	struct trusty_virtio_bus *vb = NULL;

	guests_vbus_context.num_guests++;
ffffffffea80e14c:	d0000043 	adrp	x3, ffffffffea818000 <_mem_phys_base>
{
ffffffffea80e150:	910003fd 	mov	x29, sp
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e154:	9100c3a2 	add	x2, x29, #0x30
{
ffffffffea80e158:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80e15c:	aa0003f3 	mov	x19, x0
	guests_vbus_context.num_guests++;
ffffffffea80e160:	b94e5860 	ldr	w0, [x3, #3672]
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e164:	f81f8c5f 	str	xzr, [x2, #-8]!
	guests_vbus_context.num_guests++;
ffffffffea80e168:	11000400 	add	w0, w0, #0x1
ffffffffea80e16c:	b90e5860 	str	w0, [x3, #3672]

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e170:	aa0203e0 	mov	x0, x2
ffffffffea80e174:	97ffffbf 	bl	ffffffffea80e070 <get_guest_virtio_bus.constprop.2>
ffffffffea80e178:	35000420 	cbnz	w0, ffffffffea80e1fc <virtio_register_device+0xb4>
		return ERR_INVALID_ARGS;
	}

	if (vb->state == VIRTIO_BUS_STATE_UNINITIALIZED) {
ffffffffea80e17c:	f94017a1 	ldr	x1, [x29, #40]
ffffffffea80e180:	b9401022 	ldr	w2, [x1, #16]
ffffffffea80e184:	35000402 	cbnz	w2, ffffffffea80e204 <virtio_register_device+0xbc>
	if (!vd) {
ffffffffea80e188:	b40003b3 	cbz	x19, ffffffffea80e1fc <virtio_register_device+0xb4>
	if (!vd->ops) {
ffffffffea80e18c:	f9401262 	ldr	x2, [x19, #32]
ffffffffea80e190:	b4000362 	cbz	x2, ffffffffea80e1fc <virtio_register_device+0xb4>
	if (!ops->descr_sz || !ops->get_descr ||
ffffffffea80e194:	f9400043 	ldr	x3, [x2]
ffffffffea80e198:	b4000323 	cbz	x3, ffffffffea80e1fc <virtio_register_device+0xb4>
ffffffffea80e19c:	f9400443 	ldr	x3, [x2, #8]
ffffffffea80e1a0:	b40002e3 	cbz	x3, ffffffffea80e1fc <virtio_register_device+0xb4>
ffffffffea80e1a4:	f9400843 	ldr	x3, [x2, #16]
ffffffffea80e1a8:	b40002a3 	cbz	x3, ffffffffea80e1fc <virtio_register_device+0xb4>
	    !ops->probe || !ops->reset || !ops->kick_vqueue) {
ffffffffea80e1ac:	f9400c43 	ldr	x3, [x2, #24]
ffffffffea80e1b0:	b4000263 	cbz	x3, ffffffffea80e1fc <virtio_register_device+0xb4>
ffffffffea80e1b4:	f9401042 	ldr	x2, [x2, #32]
ffffffffea80e1b8:	b4000222 	cbz	x2, ffffffffea80e1fc <virtio_register_device+0xb4>
		ret = validate_vdev(vd);
		if (ret == NO_ERROR) {
			vb->vdev_cnt++;
			vd->devid = vb->next_dev_id++;
ffffffffea80e1bc:	29401423 	ldp	w3, w5, [x1]
	item->prev = list->prev;
ffffffffea80e1c0:	aa0103e2 	mov	x2, x1
			list_add_tail(&vb->vdev_list, &vd->node);
ffffffffea80e1c4:	91004264 	add	x4, x19, #0x10
			vb->vdev_cnt++;
ffffffffea80e1c8:	11000463 	add	w3, w3, #0x1
			vd->devid = vb->next_dev_id++;
ffffffffea80e1cc:	110004a6 	add	w6, w5, #0x1
			vb->vdev_cnt++;
ffffffffea80e1d0:	b9000023 	str	w3, [x1]
ffffffffea80e1d4:	f8418c43 	ldr	x3, [x2, #24]!
			vd->devid = vb->next_dev_id++;
ffffffffea80e1d8:	b9000426 	str	w6, [x1, #4]
	item->next = list;
ffffffffea80e1dc:	a9010a63 	stp	x3, x2, [x19, #16]
ffffffffea80e1e0:	b9000665 	str	w5, [x19, #4]
	list->prev->next = item;
ffffffffea80e1e4:	f9400c22 	ldr	x2, [x1, #24]
ffffffffea80e1e8:	f9000444 	str	x4, [x2, #8]
	list->prev = item;
ffffffffea80e1ec:	f9000c24 	str	x4, [x1, #24]
		}
	}
	return ret;
}
ffffffffea80e1f0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80e1f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e1f8:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80e1fc:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80e200:	17fffffc 	b	ffffffffea80e1f0 <virtio_register_device+0xa8>
	status_t ret = ERR_BAD_STATE;
ffffffffea80e204:	128003c0 	mov	w0, #0xffffffe1            	// #-31
ffffffffea80e208:	17fffffa 	b	ffffffffea80e1f0 <virtio_register_device+0xa8>
ffffffffea80e20c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e210 <virtio_get_description>:
/*
 * Retrieve device description to be shared with NS side
 */
ssize_t virtio_get_description(ns_paddr_t buf_pa, ns_size_t buf_sz,
                               uint buf_mmu_flags, uint32_t guest_id)
{
ffffffffea80e210:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80e214:	910003fd 	mov	x29, sp
	status_t ret;
	struct vdev *vd;
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e218:	910183a4 	add	x4, x29, #0x60
{
ffffffffea80e21c:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea80e220:	a903e7f8 	stp	x24, x25, [sp, #56]
ffffffffea80e224:	2a0103f7 	mov	w23, w1
ffffffffea80e228:	aa0003f8 	mov	x24, x0
ffffffffea80e22c:	2a0303f6 	mov	w22, w3
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e230:	f81f0c9f 	str	xzr, [x4, #-16]!
{
ffffffffea80e234:	2a0203f9 	mov	w25, w2

	LTRACEF("descr_buf: %u bytes @ 0x%llx\n", buf_sz, buf_pa);

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e238:	2a0303e1 	mov	w1, w3
ffffffffea80e23c:	aa0403e0 	mov	x0, x4
ffffffffea80e240:	97ffff8c 	bl	ffffffffea80e070 <get_guest_virtio_bus.constprop.2>
ffffffffea80e244:	35000e40 	cbnz	w0, ffffffffea80e40c <virtio_get_description+0x1fc>
ffffffffea80e248:	f90013b5 	str	x21, [x29, #32]
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e24c:	910183b5 	add	x21, x29, #0x60
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e250:	2a1603e1 	mov	w1, w22
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e254:	f81f8ebf 	str	xzr, [x21, #-8]!
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e258:	aa1503e0 	mov	x0, x21
ffffffffea80e25c:	97ffff85 	bl	ffffffffea80e070 <get_guest_virtio_bus.constprop.2>
ffffffffea80e260:	35000bc0 	cbnz	w0, ffffffffea80e3d8 <virtio_get_description+0x1c8>
	if (vb->state == VIRTIO_BUS_STATE_UNINITIALIZED) {
ffffffffea80e264:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea80e268:	b9401020 	ldr	w0, [x1, #16]
ffffffffea80e26c:	35000360 	cbnz	w0, ffffffffea80e2d8 <virtio_get_description+0xc8>
ffffffffea80e270:	a90153b3 	stp	x19, x20, [x29, #16]
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e274:	91006020 	add	x0, x1, #0x18
		uint32_t offset = sizeof(struct resource_table) +
ffffffffea80e278:	b9400034 	ldr	w20, [x1]
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e27c:	f9401022 	ldr	x2, [x1, #32]
		uint32_t offset = sizeof(struct resource_table) +
ffffffffea80e280:	11001294 	add	w20, w20, #0x4
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e284:	d1004053 	sub	x19, x2, #0x10
ffffffffea80e288:	eb02001f 	cmp	x0, x2
		uint32_t offset = sizeof(struct resource_table) +
ffffffffea80e28c:	531e7694 	lsl	w20, w20, #2
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e290:	540001c0 	b.eq	ffffffffea80e2c8 <virtio_get_description+0xb8>  // b.none
ffffffffea80e294:	d503201f 	nop
			offset += vd->ops->descr_sz(vd);
ffffffffea80e298:	f9401261 	ldr	x1, [x19, #32]
ffffffffea80e29c:	aa1303e0 	mov	x0, x19
ffffffffea80e2a0:	f9400021 	ldr	x1, [x1]
			vd->descr_offset = offset;
ffffffffea80e2a4:	b9000a74 	str	w20, [x19, #8]
			offset += vd->ops->descr_sz(vd);
ffffffffea80e2a8:	d63f0020 	blr	x1
ffffffffea80e2ac:	0b000294 	add	w20, w20, w0
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e2b0:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea80e2b4:	f9400e62 	ldr	x2, [x19, #24]
ffffffffea80e2b8:	91006020 	add	x0, x1, #0x18
ffffffffea80e2bc:	d1004053 	sub	x19, x2, #0x10
ffffffffea80e2c0:	eb00005f 	cmp	x2, x0
ffffffffea80e2c4:	54fffea1 	b.ne	ffffffffea80e298 <virtio_get_description+0x88>  // b.any
		vb->descr_size = offset;
ffffffffea80e2c8:	f9000434 	str	x20, [x1, #8]
		vb->state = VIRTIO_BUS_STATE_IDLE;
ffffffffea80e2cc:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80e2d0:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80e2d4:	b9001020 	str	w0, [x1, #16]
	if (ret != NO_ERROR) {
		TRACEF("failed (%d) finalize_vdev_registery\n", ret);
		return ret;
	}

	if ((size_t)buf_sz < vb->descr_size) {
ffffffffea80e2d8:	f9402ba0 	ldr	x0, [x29, #80]
ffffffffea80e2dc:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80e2e0:	eb37405f 	cmp	x2, w23, uxtw
ffffffffea80e2e4:	54000988 	b.hi	ffffffffea80e414 <virtio_get_description+0x204>  // b.pmore
		return ERR_NOT_ENOUGH_BUFFER;
	}

	/* map in NS memory */
	void *va = NULL;
	ret = map_descr(buf_pa, &va, vb->descr_size, buf_mmu_flags, guest_id);
ffffffffea80e2e8:	2a1603e4 	mov	w4, w22
ffffffffea80e2ec:	2a1903e3 	mov	w3, w25
ffffffffea80e2f0:	aa1503e1 	mov	x1, x21
ffffffffea80e2f4:	aa1803e0 	mov	x0, x24
	void *va = NULL;
ffffffffea80e2f8:	f9002fbf 	str	xzr, [x29, #88]
	ret = map_descr(buf_pa, &va, vb->descr_size, buf_mmu_flags, guest_id);
ffffffffea80e2fc:	97ffff25 	bl	ffffffffea80df90 <map_descr>
	if (ret != NO_ERROR) {
ffffffffea80e300:	340000e0 	cbz	w0, ffffffffea80e31c <virtio_get_description+0x10c>
		LTRACEF("failed (%d) to map in descriptor buffer\n",
			(int)ret);
		return ret;
ffffffffea80e304:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80e308:	93407c00 	sxtw	x0, w0
	}

	unmap_descr(buf_pa, va, vb->descr_size);

	return vb->descr_size;
}
ffffffffea80e30c:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80e310:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea80e314:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80e318:	d65f03c0 	ret
	memset(va, 0, vb->descr_size);
ffffffffea80e31c:	a94503a2 	ldp	x2, x0, [x29, #80]
ffffffffea80e320:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80e324:	f9400442 	ldr	x2, [x2, #8]
ffffffffea80e328:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80e32c:	94001419 	bl	ffffffffea813390 <memset>
	trusty_virtio_descr_t *descr = (trusty_virtio_descr_t *)va;
ffffffffea80e330:	a94557a0 	ldp	x0, x21, [x29, #80]
	descr->ver = VIRTIO_FW_RSC_VER;
ffffffffea80e334:	52800023 	mov	w3, #0x1                   	// #1
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e338:	91006001 	add	x1, x0, #0x18
	descr->num = vb->vdev_cnt;
ffffffffea80e33c:	b9400002 	ldr	w2, [x0]
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e340:	f9401000 	ldr	x0, [x0, #32]
	descr->num = vb->vdev_cnt;
ffffffffea80e344:	29000aa3 	stp	w3, w2, [x21]
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e348:	d1004013 	sub	x19, x0, #0x10
ffffffffea80e34c:	eb01001f 	cmp	x0, x1
ffffffffea80e350:	540002c0 	b.eq	ffffffffea80e3a8 <virtio_get_description+0x198>  // b.none
	uint32_t vdev_idx = 0;
ffffffffea80e354:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80e358:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80e35c:	d503201f 	nop
		vd->ops->get_descr(vd, (uint8_t *)descr + vd->descr_offset);
ffffffffea80e360:	f9401262 	ldr	x2, [x19, #32]
		descr->offset[vdev_idx++] = vd->descr_offset;
ffffffffea80e364:	8b204aa3 	add	x3, x21, w0, uxtw #2
ffffffffea80e368:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea80e36c:	11000414 	add	w20, w0, #0x1
		vd->ops->get_descr(vd, (uint8_t *)descr + vd->descr_offset);
ffffffffea80e370:	aa1303e0 	mov	x0, x19
ffffffffea80e374:	f9400442 	ldr	x2, [x2, #8]
		descr->offset[vdev_idx++] = vd->descr_offset;
ffffffffea80e378:	b9001061 	str	w1, [x3, #16]
		vd->ops->get_descr(vd, (uint8_t *)descr + vd->descr_offset);
ffffffffea80e37c:	8b2142a1 	add	x1, x21, w1, uxtw
ffffffffea80e380:	d63f0040 	blr	x2
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e384:	f9402ba1 	ldr	x1, [x29, #80]
		descr->offset[vdev_idx++] = vd->descr_offset;
ffffffffea80e388:	2a1403e0 	mov	w0, w20
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e38c:	f9400e62 	ldr	x2, [x19, #24]
ffffffffea80e390:	91006021 	add	x1, x1, #0x18
ffffffffea80e394:	d1004053 	sub	x19, x2, #0x10
ffffffffea80e398:	eb01005f 	cmp	x2, x1
ffffffffea80e39c:	54fffe21 	b.ne	ffffffffea80e360 <virtio_get_description+0x150>  // b.any
ffffffffea80e3a0:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80e3a4:	f9402fb5 	ldr	x21, [x29, #88]
	return vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)va);
ffffffffea80e3a8:	aa1503e1 	mov	x1, x21
ffffffffea80e3ac:	f0000260 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
ffffffffea80e3b0:	91034000 	add	x0, x0, #0xd0
ffffffffea80e3b4:	94000bb7 	bl	ffffffffea811290 <vmm_free_region>
	return vb->descr_size;
ffffffffea80e3b8:	f9402ba0 	ldr	x0, [x29, #80]
ffffffffea80e3bc:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80e3c0:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80e3c4:	f9400400 	ldr	x0, [x0, #8]
}
ffffffffea80e3c8:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80e3cc:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea80e3d0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80e3d4:	d65f03c0 	ret
		TRACEF("failed (%d) finalize_vdev_registery\n", ret);
ffffffffea80e3d8:	128000e3 	mov	w3, #0xfffffff8            	// #-8
ffffffffea80e3dc:	528020c2 	mov	w2, #0x106                 	// #262
ffffffffea80e3e0:	b0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80e3e4:	b0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80e3e8:	910d0021 	add	x1, x1, #0x340
ffffffffea80e3ec:	910fa000 	add	x0, x0, #0x3e8
ffffffffea80e3f0:	940012ec 	bl	ffffffffea812fa0 <_printf>
		return ret;
ffffffffea80e3f4:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80e3f8:	a942dff6 	ldp	x22, x23, [sp, #40]
		return ret;
ffffffffea80e3fc:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
}
ffffffffea80e400:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea80e404:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80e408:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80e40c:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80e410:	17ffffbf 	b	ffffffffea80e30c <virtio_get_description+0xfc>
		return ERR_NOT_ENOUGH_BUFFER;
ffffffffea80e414:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
ffffffffea80e418:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80e41c:	17ffffbc 	b	ffffffffea80e30c <virtio_get_description+0xfc>

ffffffffea80e420 <virtio_start>:
/*
 * Called by NS side to finalize device initialization
 */
status_t virtio_start(ns_paddr_t ns_descr_pa, ns_size_t descr_sz,
                      uint descr_mmu_flags, uint32_t guest_id)
{
ffffffffea80e420:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80e424:	910003fd 	mov	x29, sp
	status_t ret;
	int oldstate;
	void *descr_va;
	void *ns_descr_va = NULL;
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e428:	910143a4 	add	x4, x29, #0x50
{
ffffffffea80e42c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80e430:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80e434:	2a0103f3 	mov	w19, w1
ffffffffea80e438:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80e43c:	aa0003f6 	mov	x22, x0
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e440:	f81f8c9f 	str	xzr, [x4, #-8]!
{
ffffffffea80e444:	2a0303f5 	mov	w21, w3

	LTRACEF("%u bytes @ 0x%llx\n", descr_sz, ns_descr_pa);

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e448:	2a0303e1 	mov	w1, w3
	void *ns_descr_va = NULL;
ffffffffea80e44c:	f90023bf 	str	xzr, [x29, #64]
{
ffffffffea80e450:	2a0203f7 	mov	w23, w2
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e454:	aa0403e0 	mov	x0, x4
ffffffffea80e458:	97ffff06 	bl	ffffffffea80e070 <get_guest_virtio_bus.constprop.2>
ffffffffea80e45c:	35000a60 	cbnz	w0, ffffffffea80e5a8 <virtio_start+0x188>
    __atomic_compare_exchange_n(ptr, &oldval, newval, false,
ffffffffea80e460:	f94027a1 	ldr	x1, [x29, #72]
ffffffffea80e464:	52800042 	mov	w2, #0x2                   	// #2
ffffffffea80e468:	91004021 	add	x1, x1, #0x10
ffffffffea80e46c:	885f7c20 	ldxr	w0, [x1]
ffffffffea80e470:	7100041f 	cmp	w0, #0x1
ffffffffea80e474:	54000061 	b.ne	ffffffffea80e480 <virtio_start+0x60>  // b.any
ffffffffea80e478:	88037c22 	stxr	w3, w2, [x1]
ffffffffea80e47c:	35ffff83 	cbnz	w3, ffffffffea80e46c <virtio_start+0x4c>

	oldstate = atomic_cmpxchg(&vb->state,
				  VIRTIO_BUS_STATE_IDLE,
				  VIRTIO_BUS_STATE_ACTIVATING);

	if (oldstate != VIRTIO_BUS_STATE_IDLE) {
ffffffffea80e480:	7100041f 	cmp	w0, #0x1
ffffffffea80e484:	540008e1 	b.ne	ffffffffea80e5a0 <virtio_start+0x180>  // b.any
		/* bus should be in initializing state */
		LTRACEF("unexpected state state (%d)\n", oldstate);
		return ERR_BAD_STATE;
	}

	if ((size_t)descr_sz != vb->descr_size) {
ffffffffea80e488:	f94027a0 	ldr	x0, [x29, #72]
		LTRACEF("unexpected descriptor size (%zd vs. %zd)\n",
			(size_t)descr_sz, vb->descr_size);
		ret = ERR_INVALID_ARGS;
ffffffffea80e48c:	128000f4 	mov	w20, #0xfffffff8            	// #-8
	if ((size_t)descr_sz != vb->descr_size) {
ffffffffea80e490:	f9400401 	ldr	x1, [x0, #8]
ffffffffea80e494:	eb01027f 	cmp	x19, x1
ffffffffea80e498:	54000120 	b.eq	ffffffffea80e4bc <virtio_start+0x9c>  // b.none

err_map_in:
	free(descr_va);
err_alloc_descr:
err_bad_params:
	vb->state = oldstate;
ffffffffea80e49c:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea80e4a0:	b9001001 	str	w1, [x0, #16]
	return ret;
}
ffffffffea80e4a4:	2a1403e0 	mov	w0, w20
ffffffffea80e4a8:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80e4ac:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e4b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80e4b4:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80e4b8:	d65f03c0 	ret
ffffffffea80e4bc:	f9001fb8 	str	x24, [x29, #56]
	descr_va = malloc(descr_sz);
ffffffffea80e4c0:	aa1303e0 	mov	x0, x19
ffffffffea80e4c4:	940012df 	bl	ffffffffea813040 <malloc>
ffffffffea80e4c8:	aa0003f8 	mov	x24, x0
	if (!descr_va) {
ffffffffea80e4cc:	b4000580 	cbz	x0, ffffffffea80e57c <virtio_start+0x15c>
	ret = map_descr(ns_descr_pa, &ns_descr_va, vb->descr_size, descr_mmu_flags, guest_id);
ffffffffea80e4d0:	f94027a2 	ldr	x2, [x29, #72]
ffffffffea80e4d4:	2a1503e4 	mov	w4, w21
ffffffffea80e4d8:	2a1703e3 	mov	w3, w23
ffffffffea80e4dc:	910103a1 	add	x1, x29, #0x40
ffffffffea80e4e0:	aa1603e0 	mov	x0, x22
ffffffffea80e4e4:	b9400842 	ldr	w2, [x2, #8]
ffffffffea80e4e8:	97fffeaa 	bl	ffffffffea80df90 <map_descr>
ffffffffea80e4ec:	2a0003f4 	mov	w20, w0
	if (ret != NO_ERROR) {
ffffffffea80e4f0:	350004e0 	cbnz	w0, ffffffffea80e58c <virtio_start+0x16c>
	memcpy(descr_va, ns_descr_va, descr_sz);
ffffffffea80e4f4:	f94023a1 	ldr	x1, [x29, #64]
ffffffffea80e4f8:	aa1303e2 	mov	x2, x19
ffffffffea80e4fc:	aa1803e0 	mov	x0, x24
ffffffffea80e500:	940012e8 	bl	ffffffffea8130a0 <memcpy>
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e504:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80e508:	91006001 	add	x1, x0, #0x18
ffffffffea80e50c:	f9401000 	ldr	x0, [x0, #32]
ffffffffea80e510:	d1004013 	sub	x19, x0, #0x10
ffffffffea80e514:	eb00003f 	cmp	x1, x0
ffffffffea80e518:	540001c0 	b.eq	ffffffffea80e550 <virtio_start+0x130>  // b.none
ffffffffea80e51c:	d503201f 	nop
		vd->ops->probe(vd, (void*)((uint8_t*)descr_va + vd->descr_offset));
ffffffffea80e520:	f9401262 	ldr	x2, [x19, #32]
ffffffffea80e524:	aa1303e0 	mov	x0, x19
ffffffffea80e528:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea80e52c:	f9400842 	ldr	x2, [x2, #16]
ffffffffea80e530:	8b010301 	add	x1, x24, x1
ffffffffea80e534:	d63f0040 	blr	x2
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e538:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80e53c:	f9400e61 	ldr	x1, [x19, #24]
ffffffffea80e540:	91006000 	add	x0, x0, #0x18
ffffffffea80e544:	d1004033 	sub	x19, x1, #0x10
ffffffffea80e548:	eb00003f 	cmp	x1, x0
ffffffffea80e54c:	54fffea1 	b.ne	ffffffffea80e520 <virtio_start+0x100>  // b.any
	return vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)va);
ffffffffea80e550:	f94023a1 	ldr	x1, [x29, #64]
ffffffffea80e554:	f0000260 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
ffffffffea80e558:	91034000 	add	x0, x0, #0xd0
ffffffffea80e55c:	94000b4d 	bl	ffffffffea811290 <vmm_free_region>
	free(descr_va);
ffffffffea80e560:	aa1803e0 	mov	x0, x24
ffffffffea80e564:	940012cd 	bl	ffffffffea813098 <free>
	vb->state = VIRTIO_BUS_STATE_ACTIVE;
ffffffffea80e568:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80e56c:	52800061 	mov	w1, #0x3                   	// #3
	return NO_ERROR;
ffffffffea80e570:	f9401fb8 	ldr	x24, [x29, #56]
	vb->state = VIRTIO_BUS_STATE_ACTIVE;
ffffffffea80e574:	b9001001 	str	w1, [x0, #16]
	return NO_ERROR;
ffffffffea80e578:	17ffffcb 	b	ffffffffea80e4a4 <virtio_start+0x84>
		ret = ERR_NO_MEMORY;
ffffffffea80e57c:	12800094 	mov	w20, #0xfffffffb            	// #-5
ffffffffea80e580:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80e584:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80e588:	17ffffc5 	b	ffffffffea80e49c <virtio_start+0x7c>
	free(descr_va);
ffffffffea80e58c:	aa1803e0 	mov	x0, x24
ffffffffea80e590:	940012c2 	bl	ffffffffea813098 <free>
ffffffffea80e594:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80e598:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80e59c:	17ffffc0 	b	ffffffffea80e49c <virtio_start+0x7c>
		return ERR_BAD_STATE;
ffffffffea80e5a0:	128003d4 	mov	w20, #0xffffffe1            	// #-31
ffffffffea80e5a4:	17ffffc0 	b	ffffffffea80e4a4 <virtio_start+0x84>
		return ERR_INVALID_ARGS;
ffffffffea80e5a8:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80e5ac:	17ffffbe 	b	ffffffffea80e4a4 <virtio_start+0x84>

ffffffffea80e5b0 <virtio_stop>:

status_t virtio_stop(ns_paddr_t descr_pa, ns_size_t descr_sz,
		     uint descr_mmu_flags, uint32_t guest_id)
{
ffffffffea80e5b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	struct vdev *vd;
	struct trusty_virtio_bus *vb = NULL;

	LTRACEF("%u bytes @ 0x%llx\n", descr_sz, descr_pa);

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e5b4:	2a0303e1 	mov	w1, w3
{
ffffffffea80e5b8:	910003fd 	mov	x29, sp
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e5bc:	9100c3a0 	add	x0, x29, #0x30
{
ffffffffea80e5c0:	f9000ff4 	str	x20, [sp, #24]
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e5c4:	f81f8c1f 	str	xzr, [x0, #-8]!
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e5c8:	97fffeaa 	bl	ffffffffea80e070 <get_guest_virtio_bus.constprop.2>
ffffffffea80e5cc:	350004c0 	cbnz	w0, ffffffffea80e664 <virtio_stop+0xb4>
ffffffffea80e5d0:	2a0003f4 	mov	w20, w0
ffffffffea80e5d4:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea80e5d8:	52800082 	mov	w2, #0x4                   	// #4
ffffffffea80e5dc:	91004000 	add	x0, x0, #0x10
ffffffffea80e5e0:	885f7c01 	ldxr	w1, [x0]
ffffffffea80e5e4:	71000c3f 	cmp	w1, #0x3
ffffffffea80e5e8:	54000061 	b.ne	ffffffffea80e5f4 <virtio_stop+0x44>  // b.any
ffffffffea80e5ec:	88037c02 	stxr	w3, w2, [x0]
ffffffffea80e5f0:	35ffff83 	cbnz	w3, ffffffffea80e5e0 <virtio_stop+0x30>

	oldstate = atomic_cmpxchg(&vb->state,
				  VIRTIO_BUS_STATE_ACTIVE,
				  VIRTIO_BUS_STATE_DEACTIVATING);

	if (oldstate != VIRTIO_BUS_STATE_ACTIVE) {
ffffffffea80e5f4:	71000c3f 	cmp	w1, #0x3
ffffffffea80e5f8:	54000321 	b.ne	ffffffffea80e65c <virtio_stop+0xac>  // b.any
		return ERR_BAD_STATE;
	}
	/* reset all devices */
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e5fc:	f94017a1 	ldr	x1, [x29, #40]
ffffffffea80e600:	91006022 	add	x2, x1, #0x18
ffffffffea80e604:	f9401020 	ldr	x0, [x1, #32]
ffffffffea80e608:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80e60c:	eb02001f 	cmp	x0, x2
ffffffffea80e610:	d1004013 	sub	x19, x0, #0x10
ffffffffea80e614:	54000160 	b.eq	ffffffffea80e640 <virtio_stop+0x90>  // b.none
		vd->ops->reset(vd);
ffffffffea80e618:	f9401261 	ldr	x1, [x19, #32]
ffffffffea80e61c:	aa1303e0 	mov	x0, x19
ffffffffea80e620:	f9400c21 	ldr	x1, [x1, #24]
ffffffffea80e624:	d63f0020 	blr	x1
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e628:	f94017a1 	ldr	x1, [x29, #40]
ffffffffea80e62c:	f9400e60 	ldr	x0, [x19, #24]
ffffffffea80e630:	91006022 	add	x2, x1, #0x18
ffffffffea80e634:	d1004013 	sub	x19, x0, #0x10
ffffffffea80e638:	eb02001f 	cmp	x0, x2
ffffffffea80e63c:	54fffee1 	b.ne	ffffffffea80e618 <virtio_stop+0x68>  // b.any
	}

	vb->state = VIRTIO_BUS_STATE_IDLE;
ffffffffea80e640:	52800020 	mov	w0, #0x1                   	// #1

	return NO_ERROR;
ffffffffea80e644:	f9400bb3 	ldr	x19, [x29, #16]
	vb->state = VIRTIO_BUS_STATE_IDLE;
ffffffffea80e648:	b9001020 	str	w0, [x1, #16]
}
ffffffffea80e64c:	2a1403e0 	mov	w0, w20
ffffffffea80e650:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80e654:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e658:	d65f03c0 	ret
		return ERR_BAD_STATE;
ffffffffea80e65c:	128003d4 	mov	w20, #0xffffffe1            	// #-31
ffffffffea80e660:	17fffffb 	b	ffffffffea80e64c <virtio_stop+0x9c>
		return ERR_INVALID_ARGS;
ffffffffea80e664:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80e668:	17fffff9 	b	ffffffffea80e64c <virtio_stop+0x9c>
ffffffffea80e66c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e670 <virtio_device_reset>:

/*
 *  Reset virtio device with specified device id
 */
status_t virtio_device_reset(uint devid, uint32_t guest_id)
{
ffffffffea80e670:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80e674:	910003fd 	mov	x29, sp
	struct vdev *vd;
	status_t ret = ERR_NOT_FOUND;
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e678:	9100c3a2 	add	x2, x29, #0x30
{
ffffffffea80e67c:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80e680:	2a0003f3 	mov	w19, w0
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e684:	f81f8c5f 	str	xzr, [x2, #-8]!

	LTRACEF("dev=%d\n", devid);

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e688:	aa0203e0 	mov	x0, x2
ffffffffea80e68c:	97fffe79 	bl	ffffffffea80e070 <get_guest_virtio_bus.constprop.2>
ffffffffea80e690:	35000420 	cbnz	w0, ffffffffea80e714 <virtio_device_reset+0xa4>
		return ERR_INVALID_ARGS;
	}

	if (vb->state != VIRTIO_BUS_STATE_ACTIVE) {
ffffffffea80e694:	f94017a2 	ldr	x2, [x29, #40]
ffffffffea80e698:	b9401040 	ldr	w0, [x2, #16]
ffffffffea80e69c:	71000c1f 	cmp	w0, #0x3
ffffffffea80e6a0:	54000361 	b.ne	ffffffffea80e70c <virtio_device_reset+0x9c>  // b.any
		return ERR_BAD_STATE;
	}

	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e6a4:	f9401041 	ldr	x1, [x2, #32]
ffffffffea80e6a8:	91006042 	add	x2, x2, #0x18
ffffffffea80e6ac:	d1004020 	sub	x0, x1, #0x10
ffffffffea80e6b0:	eb01005f 	cmp	x2, x1
ffffffffea80e6b4:	54000180 	b.eq	ffffffffea80e6e4 <virtio_device_reset+0x74>  // b.none
		if (vd->devid == devid) {
ffffffffea80e6b8:	b85f4021 	ldur	w1, [x1, #-12]
ffffffffea80e6bc:	6b01027f 	cmp	w19, w1
ffffffffea80e6c0:	540000a1 	b.ne	ffffffffea80e6d4 <virtio_device_reset+0x64>  // b.any
ffffffffea80e6c4:	1400000c 	b	ffffffffea80e6f4 <virtio_device_reset+0x84>
ffffffffea80e6c8:	b85f4021 	ldur	w1, [x1, #-12]
ffffffffea80e6cc:	6b13003f 	cmp	w1, w19
ffffffffea80e6d0:	54000120 	b.eq	ffffffffea80e6f4 <virtio_device_reset+0x84>  // b.none
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e6d4:	f9400c01 	ldr	x1, [x0, #24]
ffffffffea80e6d8:	eb01005f 	cmp	x2, x1
ffffffffea80e6dc:	d1004020 	sub	x0, x1, #0x10
ffffffffea80e6e0:	54ffff41 	b.ne	ffffffffea80e6c8 <virtio_device_reset+0x58>  // b.any
	status_t ret = ERR_NOT_FOUND;
ffffffffea80e6e4:	12800020 	mov	w0, #0xfffffffe            	// #-2
			ret = vd->ops->reset(vd);
			break;
		}
	}
	return ret;
}
ffffffffea80e6e8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80e6ec:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e6f0:	d65f03c0 	ret
			ret = vd->ops->reset(vd);
ffffffffea80e6f4:	f9401001 	ldr	x1, [x0, #32]
ffffffffea80e6f8:	f9400c21 	ldr	x1, [x1, #24]
ffffffffea80e6fc:	d63f0020 	blr	x1
}
ffffffffea80e700:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80e704:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e708:	d65f03c0 	ret
		return ERR_BAD_STATE;
ffffffffea80e70c:	128003c0 	mov	w0, #0xffffffe1            	// #-31
ffffffffea80e710:	17fffff6 	b	ffffffffea80e6e8 <virtio_device_reset+0x78>
		return ERR_INVALID_ARGS;
ffffffffea80e714:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80e718:	17fffff4 	b	ffffffffea80e6e8 <virtio_device_reset+0x78>
ffffffffea80e71c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e720 <virtio_kick_vq>:

/*
 *  Kick vq for virtio device with specified device id
 */
status_t virtio_kick_vq(uint devid, uint vqid, uint32_t guest_id)
{
ffffffffea80e720:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80e724:	910003fd 	mov	x29, sp
	struct vdev *vd;
	status_t ret = ERR_NOT_FOUND;
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e728:	9100c3a3 	add	x3, x29, #0x30
{
ffffffffea80e72c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80e730:	2a0003f3 	mov	w19, w0
ffffffffea80e734:	2a0103f4 	mov	w20, w1

#if WITH_CHATTY_LTRACE
	LTRACEF("dev=%d\n", devid);
#endif

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e738:	2a0203e1 	mov	w1, w2
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e73c:	f81f8c7f 	str	xzr, [x3, #-8]!
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e740:	aa0303e0 	mov	x0, x3
ffffffffea80e744:	97fffe4b 	bl	ffffffffea80e070 <get_guest_virtio_bus.constprop.2>
ffffffffea80e748:	35000440 	cbnz	w0, ffffffffea80e7d0 <virtio_kick_vq+0xb0>
		return ERR_INVALID_ARGS;
	}

	if (vb->state != VIRTIO_BUS_STATE_ACTIVE) {
ffffffffea80e74c:	f94017a2 	ldr	x2, [x29, #40]
ffffffffea80e750:	b9401040 	ldr	w0, [x2, #16]
ffffffffea80e754:	71000c1f 	cmp	w0, #0x3
ffffffffea80e758:	54000381 	b.ne	ffffffffea80e7c8 <virtio_kick_vq+0xa8>  // b.any
		return ERR_BAD_STATE;
	}
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e75c:	f9401041 	ldr	x1, [x2, #32]
ffffffffea80e760:	91006042 	add	x2, x2, #0x18
ffffffffea80e764:	d1004020 	sub	x0, x1, #0x10
ffffffffea80e768:	eb01005f 	cmp	x2, x1
ffffffffea80e76c:	54000180 	b.eq	ffffffffea80e79c <virtio_kick_vq+0x7c>  // b.none
		if (vd->devid == devid) {
ffffffffea80e770:	b85f4021 	ldur	w1, [x1, #-12]
ffffffffea80e774:	6b01027f 	cmp	w19, w1
ffffffffea80e778:	540000a1 	b.ne	ffffffffea80e78c <virtio_kick_vq+0x6c>  // b.any
ffffffffea80e77c:	1400000c 	b	ffffffffea80e7ac <virtio_kick_vq+0x8c>
ffffffffea80e780:	b85f4021 	ldur	w1, [x1, #-12]
ffffffffea80e784:	6b13003f 	cmp	w1, w19
ffffffffea80e788:	54000120 	b.eq	ffffffffea80e7ac <virtio_kick_vq+0x8c>  // b.none
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80e78c:	f9400c01 	ldr	x1, [x0, #24]
ffffffffea80e790:	eb01005f 	cmp	x2, x1
ffffffffea80e794:	d1004020 	sub	x0, x1, #0x10
ffffffffea80e798:	54ffff41 	b.ne	ffffffffea80e780 <virtio_kick_vq+0x60>  // b.any
	status_t ret = ERR_NOT_FOUND;
ffffffffea80e79c:	12800020 	mov	w0, #0xfffffffe            	// #-2
			ret = vd->ops->kick_vqueue(vd, vqid);
			break;
		}
	}
	return ret;
}
ffffffffea80e7a0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e7a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e7a8:	d65f03c0 	ret
			ret = vd->ops->kick_vqueue(vd, vqid);
ffffffffea80e7ac:	f9401002 	ldr	x2, [x0, #32]
ffffffffea80e7b0:	2a1403e1 	mov	w1, w20
ffffffffea80e7b4:	f9401042 	ldr	x2, [x2, #32]
ffffffffea80e7b8:	d63f0040 	blr	x2
}
ffffffffea80e7bc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e7c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e7c4:	d65f03c0 	ret
		return ERR_BAD_STATE;
ffffffffea80e7c8:	128003c0 	mov	w0, #0xffffffe1            	// #-31
ffffffffea80e7cc:	17fffff5 	b	ffffffffea80e7a0 <virtio_kick_vq+0x80>
		return ERR_INVALID_ARGS;
ffffffffea80e7d0:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80e7d4:	17fffff3 	b	ffffffffea80e7a0 <virtio_kick_vq+0x80>

ffffffffea80e7d8 <tipc_descr_size>:

static size_t tipc_descr_size(struct vdev *vd)
{
	struct tipc_dev *dev = vdev_to_dev(vd);
	return dev->descr_size;
}
ffffffffea80e7d8:	f9402000 	ldr	x0, [x0, #64]
ffffffffea80e7dc:	d65f03c0 	ret

ffffffffea80e7e0 <tipc_tx_vq_notify_cb>:
{
ffffffffea80e7e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80e7e4:	910003fd 	mov	x29, sp
	vqueue_signal_avail(vq);
ffffffffea80e7e8:	97fffb72 	bl	ffffffffea80d5b0 <vqueue_signal_avail>
}
ffffffffea80e7ec:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80e7f0:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80e7f4:	d65f03c0 	ret

ffffffffea80e7f8 <_send_buf>:
	uint8_t  *data;
	size_t    len;
};

static int _send_buf(uint8_t *dst, size_t sz, void *ctx)
{
ffffffffea80e7f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80e7fc:	910003fd 	mov	x29, sp
	DEBUG_ASSERT(dst);
	DEBUG_ASSERT(buf);
	DEBUG_ASSERT(buf->data);
	DEBUG_ASSERT(sz <= buf->len);

	memcpy (dst, buf->data,  sz);
ffffffffea80e800:	f9400043 	ldr	x3, [x2]
ffffffffea80e804:	aa0103e2 	mov	x2, x1
{
ffffffffea80e808:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80e80c:	aa0103f3 	mov	x19, x1
	memcpy (dst, buf->data,  sz);
ffffffffea80e810:	aa0303e1 	mov	x1, x3
ffffffffea80e814:	94001223 	bl	ffffffffea8130a0 <memcpy>

	return (int) sz;
}
ffffffffea80e818:	2a1303e0 	mov	w0, w19
ffffffffea80e81c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80e820:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80e824:	d65f03c0 	ret

ffffffffea80e828 <tipc_get_vdev_descr>:
{
ffffffffea80e828:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80e82c:	910003fd 	mov	x29, sp
ffffffffea80e830:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80e834:	aa0003f3 	mov	x19, x0
ffffffffea80e838:	aa0103f4 	mov	x20, x1
	memcpy(vdev_descr, dev->descr_ptr, dev->descr_size);
ffffffffea80e83c:	aa0103e0 	mov	x0, x1
ffffffffea80e840:	a9438a61 	ldp	x1, x2, [x19, #56]
ffffffffea80e844:	94001217 	bl	ffffffffea8130a0 <memcpy>
	vdev_descr->vdev.notifyid = vd->devid;
ffffffffea80e848:	b9400660 	ldr	w0, [x19, #4]
ffffffffea80e84c:	b9000a80 	str	w0, [x20, #8]
}
ffffffffea80e850:	f9402260 	ldr	x0, [x19, #64]
ffffffffea80e854:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e858:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80e85c:	d65f03c0 	ret

ffffffffea80e860 <tx_data_cb>:
{
ffffffffea80e860:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	ipc_msg_kern_t dst_kern_msg = {
ffffffffea80e864:	52800024 	mov	w4, #0x1                   	// #1
{
ffffffffea80e868:	910003fd 	mov	x29, sp
ffffffffea80e86c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80e870:	aa0203f3 	mov	x19, x2
	rc = ipc_read_msg(cb_ctx->chan, cb_ctx->msg_inf.id, 0,
ffffffffea80e874:	9100c3a3 	add	x3, x29, #0x30
ffffffffea80e878:	52800002 	mov	w2, #0x0                   	// #0
	iovec_kern_t dst_iov = { buf, buf_len };
ffffffffea80e87c:	a90207a0 	stp	x0, x1, [x29, #32]
	rc = ipc_read_msg(cb_ctx->chan, cb_ctx->msg_inf.id, 0,
ffffffffea80e880:	b9400e61 	ldr	w1, [x19, #12]
ffffffffea80e884:	f9400260 	ldr	x0, [x19]
	ipc_msg_kern_t dst_kern_msg = {
ffffffffea80e888:	b90033a4 	str	w4, [x29, #48]
ffffffffea80e88c:	910083a4 	add	x4, x29, #0x20
ffffffffea80e890:	f9001fa4 	str	x4, [x29, #56]
ffffffffea80e894:	b90043bf 	str	wzr, [x29, #64]
ffffffffea80e898:	f90027bf 	str	xzr, [x29, #72]
	rc = ipc_read_msg(cb_ctx->chan, cb_ctx->msg_inf.id, 0,
ffffffffea80e89c:	97fff983 	bl	ffffffffea80cea8 <ipc_read_msg>
	ipc_put_msg(cb_ctx->chan, cb_ctx->msg_inf.id);
ffffffffea80e8a0:	b9400e61 	ldr	w1, [x19, #12]
	rc = ipc_read_msg(cb_ctx->chan, cb_ctx->msg_inf.id, 0,
ffffffffea80e8a4:	2a0003f4 	mov	w20, w0
	ipc_put_msg(cb_ctx->chan, cb_ctx->msg_inf.id);
ffffffffea80e8a8:	f9400260 	ldr	x0, [x19]
ffffffffea80e8ac:	97fff8e5 	bl	ffffffffea80cc40 <ipc_put_msg>
}
ffffffffea80e8b0:	2a1403e0 	mov	w0, w20
ffffffffea80e8b4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e8b8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80e8bc:	d65f03c0 	ret

ffffffffea80e8c0 <tipc_vdev_kick_vq>:
	if (vqid == vqueue_id(&dev->vqs[TIPC_VQ_TX])) {
ffffffffea80e8c0:	b9404802 	ldr	w2, [x0, #72]
ffffffffea80e8c4:	6b02003f 	cmp	w1, w2
ffffffffea80e8c8:	54000120 	b.eq	ffffffffea80e8ec <tipc_vdev_kick_vq+0x2c>  // b.none
	if (vqid == vqueue_id(&dev->vqs[TIPC_VQ_RX])) {
ffffffffea80e8cc:	b940d802 	ldr	w2, [x0, #216]
ffffffffea80e8d0:	6b02003f 	cmp	w1, w2
ffffffffea80e8d4:	54000161 	b.ne	ffffffffea80e900 <tipc_vdev_kick_vq+0x40>  // b.any
		return vqueue_notify(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80e8d8:	91036000 	add	x0, x0, #0xd8
	return vq->id;
}

static inline int vqueue_notify(struct vqueue *vq)
{
	if (vq->notify_cb){
ffffffffea80e8dc:	f9403c02 	ldr	x2, [x0, #120]
ffffffffea80e8e0:	b40000c2 	cbz	x2, ffffffffea80e8f8 <tipc_vdev_kick_vq+0x38>
		return vq->notify_cb(vq, vq->priv);
ffffffffea80e8e4:	f9404401 	ldr	x1, [x0, #136]
ffffffffea80e8e8:	d61f0040 	br	x2
		return vqueue_notify(&dev->vqs[TIPC_VQ_TX]);
ffffffffea80e8ec:	91012000 	add	x0, x0, #0x48
	if (vq->notify_cb){
ffffffffea80e8f0:	f9403c02 	ldr	x2, [x0, #120]
ffffffffea80e8f4:	b5ffff82 	cbnz	x2, ffffffffea80e8e4 <tipc_vdev_kick_vq+0x24>
	}
	return 0;
ffffffffea80e8f8:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea80e8fc:	d65f03c0 	ret
	return ERR_NOT_FOUND;
ffffffffea80e900:	12800020 	mov	w0, #0xfffffffe            	// #-2
}
ffffffffea80e904:	d65f03c0 	ret

ffffffffea80e908 <tipc_send_data.constprop.3>:
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80e908:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
ffffffffea80e90c:	910003fd 	mov	x29, sp
ffffffffea80e910:	a90153f3 	stp	x19, x20, [sp, #16]
	struct vqueue *vq = &dev->vqs[TIPC_VQ_TX];
ffffffffea80e914:	91012013 	add	x19, x0, #0x48
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80e918:	a9025bf5 	stp	x21, x22, [sp, #32]
		event_wait(&vq->avail_event);
ffffffffea80e91c:	91024014 	add	x20, x0, #0x90
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80e920:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80e924:	aa0003f6 	mov	x22, x0
ffffffffea80e928:	a9046bf9 	stp	x25, x26, [sp, #64]
		if (dev->tx_stop) {
ffffffffea80e92c:	91400415 	add	x21, x0, #0x1, lsl #12
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80e930:	f9002bfb 	str	x27, [sp, #80]
ffffffffea80e934:	2a0103fa 	mov	w26, w1
ffffffffea80e938:	2a0203f9 	mov	w25, w2
	memset(&buf, 0, sizeof(buf));
ffffffffea80e93c:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80e940:	d2800902 	mov	x2, #0x48                  	// #72
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80e944:	aa0303f8 	mov	x24, x3
ffffffffea80e948:	12003cb7 	and	w23, w5, #0xffff
	memset(&buf, 0, sizeof(buf));
ffffffffea80e94c:	9101e3a0 	add	x0, x29, #0x78
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80e950:	aa0403fb 	mov	x27, x4
	memset(&buf, 0, sizeof(buf));
ffffffffea80e954:	9400128f 	bl	ffffffffea813390 <memset>
	buf.out_iovs.cnt  = MAX_TX_IOVS;
ffffffffea80e958:	52800022 	mov	w2, #0x1                   	// #1
	buf.out_iovs.phys = out_phys;
ffffffffea80e95c:	910183a1 	add	x1, x29, #0x60
	buf.out_iovs.iovs = out_iovs;
ffffffffea80e960:	9101a3a0 	add	x0, x29, #0x68
	buf.out_iovs.cnt  = MAX_TX_IOVS;
ffffffffea80e964:	b900a3a2 	str	w2, [x29, #160]
	buf.out_iovs.iovs = out_iovs;
ffffffffea80e968:	a90b03a1 	stp	x1, x0, [x29, #176]
ffffffffea80e96c:	14000006 	b	ffffffffea80e984 <tipc_send_data.constprop.3+0x7c>
		if (ret != ERR_NOT_ENOUGH_BUFFER || !wait) {
ffffffffea80e970:	3100245f 	cmn	w2, #0x9
ffffffffea80e974:	540003a1 	b.ne	ffffffffea80e9e8 <tipc_send_data.constprop.3+0xe0>  // b.any
ffffffffea80e978:	97ffdb62 	bl	ffffffffea805700 <event_wait_timeout>
		if (dev->tx_stop) {
ffffffffea80e97c:	394942a0 	ldrb	w0, [x21, #592]
ffffffffea80e980:	35000440 	cbnz	w0, ffffffffea80ea08 <tipc_send_data.constprop.3+0x100>
		ret = vqueue_get_avail_buf(vq, &buf);
ffffffffea80e984:	9101e3a1 	add	x1, x29, #0x78
ffffffffea80e988:	aa1303e0 	mov	x0, x19
ffffffffea80e98c:	97fffb3f 	bl	ffffffffea80d688 <vqueue_get_avail_buf>
ffffffffea80e990:	2a0003e2 	mov	w2, w0
ffffffffea80e994:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80e998:	aa1403e0 	mov	x0, x20
		if (ret == NO_ERROR) {
ffffffffea80e99c:	35fffea2 	cbnz	w2, ffffffffea80e970 <tipc_send_data.constprop.3+0x68>
	if (buf.out_iovs.used == 0) {
ffffffffea80e9a0:	b940a7a0 	ldr	w0, [x29, #164]
ffffffffea80e9a4:	12800102 	mov	w2, #0xfffffff7            	// #-9
ffffffffea80e9a8:	34000180 	cbz	w0, ffffffffea80e9d8 <tipc_send_data.constprop.3+0xd0>
	if (sizeof(struct tipc_hdr) > buf.out_iovs.iovs[0].len) {
ffffffffea80e9ac:	f9405fa0 	ldr	x0, [x29, #184]
ffffffffea80e9b0:	f9400400 	ldr	x0, [x0, #8]
ffffffffea80e9b4:	f1003c1f 	cmp	x0, #0xf
ffffffffea80e9b8:	54000109 	b.ls	ffffffffea80e9d8 <tipc_send_data.constprop.3+0xd0>  // b.plast
	ret = vqueue_map_iovs(&buf.out_iovs, map_flags, dev->guest);
ffffffffea80e9bc:	b9402ac2 	ldr	w2, [x22, #40]
ffffffffea80e9c0:	910283b5 	add	x21, x29, #0xa0
ffffffffea80e9c4:	52800601 	mov	w1, #0x30                  	// #48
ffffffffea80e9c8:	aa1503e0 	mov	x0, x21
ffffffffea80e9cc:	97fffbb9 	bl	ffffffffea80d8b0 <vqueue_map_iovs>
ffffffffea80e9d0:	2a0003e2 	mov	w2, w0
	if (ret == NO_ERROR) {
ffffffffea80e9d4:	340002c0 	cbz	w0, ffffffffea80ea2c <tipc_send_data.constprop.3+0x124>
	ret = vqueue_add_buf(vq, &buf, ret);
ffffffffea80e9d8:	9101e3a1 	add	x1, x29, #0x78
ffffffffea80e9dc:	aa1303e0 	mov	x0, x19
ffffffffea80e9e0:	97fffc2c 	bl	ffffffffea80da90 <vqueue_add_buf>
ffffffffea80e9e4:	2a0003e2 	mov	w2, w0
}
ffffffffea80e9e8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e9ec:	2a0203e0 	mov	w0, w2
ffffffffea80e9f0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80e9f4:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80e9f8:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80e9fc:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea80ea00:	a8cc7bfd 	ldp	x29, x30, [sp], #192
ffffffffea80ea04:	d65f03c0 	ret
ffffffffea80ea08:	a94153f3 	ldp	x19, x20, [sp, #16]
			return ERR_CHANNEL_CLOSED;
ffffffffea80ea0c:	128001c2 	mov	w2, #0xfffffff1            	// #-15
}
ffffffffea80ea10:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ea14:	2a0203e0 	mov	w0, w2
ffffffffea80ea18:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80ea1c:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80ea20:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea80ea24:	a8cc7bfd 	ldp	x29, x30, [sp], #192
ffffffffea80ea28:	d65f03c0 	ret
		struct tipc_hdr *hdr = buf.out_iovs.iovs[0].base;
ffffffffea80ea2c:	f9405fa1 	ldr	x1, [x29, #184]
	sizeof(struct tipc_hdr) + data_len;
ffffffffea80ea30:	92403ee4 	and	x4, x23, #0xffff
	size_t ttl_len =
ffffffffea80ea34:	91004085 	add	x5, x4, #0x10
		ret = cb(hdr->data, data_len, cb_ctx);
ffffffffea80ea38:	aa1b03e2 	mov	x2, x27
		if (ttl_len > buf.out_iovs.iovs[0].len) {
ffffffffea80ea3c:	a9400c20 	ldp	x0, x3, [x1]
		hdr->dst = remote;
ffffffffea80ea40:	2900641a 	stp	w26, w25, [x0]
		hdr->reserved = 0;
ffffffffea80ea44:	b900081f 	str	wzr, [x0, #8]
ffffffffea80ea48:	eb0300bf 	cmp	x5, x3
ffffffffea80ea4c:	51004063 	sub	w3, w3, #0x10
		hdr->len = data_len;
ffffffffea80ea50:	79001817 	strh	w23, [x0, #12]
ffffffffea80ea54:	92403c61 	and	x1, x3, #0xffff
		hdr->flags = 0;
ffffffffea80ea58:	79001c1f 	strh	wzr, [x0, #14]
		ret = cb(hdr->data, data_len, cb_ctx);
ffffffffea80ea5c:	9a848021 	csel	x1, x1, x4, hi  // hi = pmore
ffffffffea80ea60:	91004000 	add	x0, x0, #0x10
ffffffffea80ea64:	d63f0300 	blr	x24
			ret += sizeof(struct tipc_hdr);
ffffffffea80ea68:	7100001f 	cmp	w0, #0x0
		ret = cb(hdr->data, data_len, cb_ctx);
ffffffffea80ea6c:	2a0003f4 	mov	w20, w0
			ret += sizeof(struct tipc_hdr);
ffffffffea80ea70:	11004000 	add	w0, w0, #0x10
ffffffffea80ea74:	1a94a014 	csel	w20, w0, w20, ge  // ge = tcont
		vqueue_unmap_iovs(&buf.out_iovs);
ffffffffea80ea78:	aa1503e0 	mov	x0, x21
ffffffffea80ea7c:	97fffbe9 	bl	ffffffffea80da20 <vqueue_unmap_iovs>
ffffffffea80ea80:	2a1403e2 	mov	w2, w20
ffffffffea80ea84:	17ffffd5 	b	ffffffffea80e9d8 <tipc_send_data.constprop.3+0xd0>

ffffffffea80ea88 <tipc_vdev_probe>:
{
ffffffffea80ea88:	d102c3ff 	sub	sp, sp, #0xb0
ffffffffea80ea8c:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea80ea90:	910043fd 	add	x29, sp, #0x10
	if (dev->vd.state != VDEV_STATE_RESET) {
ffffffffea80ea94:	b9400002 	ldr	w2, [x0]
{
ffffffffea80ea98:	f90027f8 	str	x24, [sp, #72]
	if (dev->vd.state != VDEV_STATE_RESET) {
ffffffffea80ea9c:	35000f22 	cbnz	w2, ffffffffea80ec80 <tipc_vdev_probe+0x1f8>
	if (vdev_descr->hdr.type != RSC_VDEV) {
ffffffffea80eaa0:	b9400022 	ldr	w2, [x1]
ffffffffea80eaa4:	71000c5f 	cmp	w2, #0x3
ffffffffea80eaa8:	54000e01 	b.ne	ffffffffea80ec68 <tipc_vdev_probe+0x1e0>  // b.any
	if (vdev_descr->vdev.id != VIRTIO_ID_TIPC) {
ffffffffea80eaac:	b9400422 	ldr	w2, [x1, #4]
ffffffffea80eab0:	7100345f 	cmp	w2, #0xd
ffffffffea80eab4:	54000da1 	b.ne	ffffffffea80ec68 <tipc_vdev_probe+0x1e0>  // b.any
	if (vdev_descr->vdev.num_of_vrings != TIPC_VQ_NUM) {
ffffffffea80eab8:	39406422 	ldrb	w2, [x1, #25]
ffffffffea80eabc:	7100085f 	cmp	w2, #0x2
ffffffffea80eac0:	54000d41 	b.ne	ffffffffea80ec68 <tipc_vdev_probe+0x1e0>  // b.any
	if (vdev_descr->vdev.status != (VIRTIO_CONFIG_S_ACKNOWLEDGE |
ffffffffea80eac4:	39406022 	ldrb	w2, [x1, #24]
ffffffffea80eac8:	71001c5f 	cmp	w2, #0x7
ffffffffea80eacc:	54000ce1 	b.ne	ffffffffea80ec68 <tipc_vdev_probe+0x1e0>  // b.any
ffffffffea80ead0:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea80ead4:	9101201a 	add	x26, x0, #0x48
ffffffffea80ead8:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80eadc:	90000006 	adrp	x6, ffffffffea80e000 <map_descr+0x70>
ffffffffea80eae0:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80eae4:	aa0103f9 	mov	x25, x1
ffffffffea80eae8:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80eaec:	aa0003f4 	mov	x20, x0
ffffffffea80eaf0:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80eaf4:	91007033 	add	x19, x1, #0x1c
ffffffffea80eaf8:	b000005b 	adrp	x27, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80eafc:	aa1a03f6 	mov	x22, x26
ffffffffea80eb00:	911f80c6 	add	x6, x6, #0x7e0
	for (vring_cnt = 0; vring_cnt < dscr->vdev.num_of_vrings; vring_cnt++) {
ffffffffea80eb04:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea80eb08:	9112437b 	add	x27, x27, #0x490
	if (vdev_descr->vdev.status != (VIRTIO_CONFIG_S_ACKNOWLEDGE |
ffffffffea80eb0c:	d2800017 	mov	x23, #0x0                   	// #0
ffffffffea80eb10:	14000009 	b	ffffffffea80eb34 <tipc_vdev_probe+0xac>
	for (vring_cnt = 0; vring_cnt < dscr->vdev.num_of_vrings; vring_cnt++) {
ffffffffea80eb14:	39406720 	ldrb	w0, [x25, #25]
ffffffffea80eb18:	110006b5 	add	w21, w21, #0x1
ffffffffea80eb1c:	910022f7 	add	x23, x23, #0x8
ffffffffea80eb20:	91005273 	add	x19, x19, #0x14
ffffffffea80eb24:	910242d6 	add	x22, x22, #0x90
ffffffffea80eb28:	6b0002bf 	cmp	w21, w0
ffffffffea80eb2c:	540003e2 	b.cs	ffffffffea80eba8 <tipc_vdev_probe+0x120>  // b.hs, b.nlast
ffffffffea80eb30:	f87b6ae6 	ldr	x6, [x23, x27]
		ret = vqueue_init(&dev->vqs[vring_cnt],
ffffffffea80eb34:	29401260 	ldp	w0, w4, [x19]
ffffffffea80eb38:	d2800007 	mov	x7, #0x0                   	// #0
ffffffffea80eb3c:	29410663 	ldp	w3, w1, [x19, #8]
		uint64_t pa64 = ((uint64_t)vring->reserved << 32) | vring->da;
ffffffffea80eb40:	b9401262 	ldr	w2, [x19, #16]
		ret = vqueue_init(&dev->vqs[vring_cnt],
ffffffffea80eb44:	b9402a85 	ldr	w5, [x20, #40]
ffffffffea80eb48:	b90003e5 	str	w5, [sp]
ffffffffea80eb4c:	aa1403e5 	mov	x5, x20
ffffffffea80eb50:	aa028002 	orr	x2, x0, x2, lsl #32
ffffffffea80eb54:	aa1603e0 	mov	x0, x22
ffffffffea80eb58:	97fffa0c 	bl	ffffffffea80d388 <vqueue_init>
ffffffffea80eb5c:	2a0003f8 	mov	w24, w0
		if (ret) {
ffffffffea80eb60:	34fffda0 	cbz	w0, ffffffffea80eb14 <tipc_vdev_probe+0x8c>
ffffffffea80eb64:	d1012294 	sub	x20, x20, #0x48
	while (vring_cnt--) {
ffffffffea80eb68:	340000d5 	cbz	w21, ffffffffea80eb80 <tipc_vdev_probe+0xf8>
		vqueue_destroy(&dev->vqs[vring_cnt]);
ffffffffea80eb6c:	aa1a03e0 	mov	x0, x26
ffffffffea80eb70:	d102435a 	sub	x26, x26, #0x90
ffffffffea80eb74:	97fffa69 	bl	ffffffffea80d518 <vqueue_destroy>
	while (vring_cnt--) {
ffffffffea80eb78:	eb1a029f 	cmp	x20, x26
ffffffffea80eb7c:	54ffff81 	b.ne	ffffffffea80eb6c <tipc_vdev_probe+0xe4>  // b.any
ffffffffea80eb80:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80eb84:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80eb88:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80eb8c:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80eb90:	f9402bbb 	ldr	x27, [x29, #80]
}
ffffffffea80eb94:	2a1803e0 	mov	w0, w24
ffffffffea80eb98:	f94027f8 	ldr	x24, [sp, #72]
ffffffffea80eb9c:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea80eba0:	9102c3ff 	add	sp, sp, #0xb0
ffffffffea80eba4:	d65f03c0 	ret
	snprintf(tname, sizeof(tname), "tipc-dev%d-rx", dev->vd.devid);
ffffffffea80eba8:	b9400683 	ldr	w3, [x20, #4]
ffffffffea80ebac:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea80ebb0:	b0000042 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80ebb4:	910203a0 	add	x0, x29, #0x80
ffffffffea80ebb8:	91162042 	add	x2, x2, #0x588
ffffffffea80ebbc:	940010db 	bl	ffffffffea812f28 <snprintf>
		thread_create(tname, tipc_rx_thread_func, dev,
ffffffffea80ebc0:	90000001 	adrp	x1, ffffffffea80e000 <map_descr+0x70>
ffffffffea80ebc4:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea80ebc8:	52800203 	mov	w3, #0x10                  	// #16
ffffffffea80ebcc:	aa1403e2 	mov	x2, x20
ffffffffea80ebd0:	91322021 	add	x1, x1, #0xc88
ffffffffea80ebd4:	910203a0 	add	x0, x29, #0x80
ffffffffea80ebd8:	97ffdd5c 	bl	ffffffffea806148 <thread_create>
	dev->rx_thread =
ffffffffea80ebdc:	f9092280 	str	x0, [x20, #4672]
	if (dev->rx_thread) {
ffffffffea80ebe0:	b4000040 	cbz	x0, ffffffffea80ebe8 <tipc_vdev_probe+0x160>
		thread_resume(dev->rx_thread);
ffffffffea80ebe4:	97ffddb9 	bl	ffffffffea8062c8 <thread_resume>
	snprintf(tname, sizeof(tname), "tipc-dev%d-tx", dev->vd.devid);
ffffffffea80ebe8:	b9400683 	ldr	w3, [x20, #4]
ffffffffea80ebec:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea80ebf0:	b0000042 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80ebf4:	910203a0 	add	x0, x29, #0x80
ffffffffea80ebf8:	91166042 	add	x2, x2, #0x598
ffffffffea80ebfc:	940010cb 	bl	ffffffffea812f28 <snprintf>
		thread_create(tname, tipc_tx_thread_func, dev,
ffffffffea80ec00:	b0000001 	adrp	x1, ffffffffea80f000 <tipc_rx_thread_func+0x378>
ffffffffea80ec04:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea80ec08:	52800203 	mov	w3, #0x10                  	// #16
ffffffffea80ec0c:	aa1403e2 	mov	x2, x20
ffffffffea80ec10:	9110c021 	add	x1, x1, #0x430
ffffffffea80ec14:	910203a0 	add	x0, x29, #0x80
ffffffffea80ec18:	97ffdd4c 	bl	ffffffffea806148 <thread_create>
	dev->tx_thread =
ffffffffea80ec1c:	f9092680 	str	x0, [x20, #4680]
	if (dev->tx_thread) {
ffffffffea80ec20:	b4000040 	cbz	x0, ffffffffea80ec28 <tipc_vdev_probe+0x1a0>
		thread_resume(dev->tx_thread);
ffffffffea80ec24:	97ffdda9 	bl	ffffffffea8062c8 <thread_resume>
	msg.hdr.type = TIPC_CTRL_MSGTYPE_GO_ONLINE;
ffffffffea80ec28:	910283a0 	add	x0, x29, #0xa0
ffffffffea80ec2c:	d2800033 	mov	x19, #0x1                   	// #1

static int
tipc_send_buf(struct tipc_dev *dev, uint32_t local, uint32_t remote,
              void *data, uint16_t data_len, bool wait)
{
	struct buf_ctx ctx = {data, data_len};
ffffffffea80ec30:	d2800105 	mov	x5, #0x8                   	// #8

	return tipc_send_data(dev, local, remote,
ffffffffea80ec34:	528006a2 	mov	w2, #0x35                  	// #53
ffffffffea80ec38:	90000003 	adrp	x3, ffffffffea80e000 <map_descr+0x70>
ffffffffea80ec3c:	9101c3a4 	add	x4, x29, #0x70
	msg.hdr.type = TIPC_CTRL_MSGTYPE_GO_ONLINE;
ffffffffea80ec40:	f81c8c13 	str	x19, [x0, #-56]!
	return tipc_send_data(dev, local, remote,
ffffffffea80ec44:	911fe063 	add	x3, x3, #0x7f8
ffffffffea80ec48:	2a0203e1 	mov	w1, w2
	struct buf_ctx ctx = {data, data_len};
ffffffffea80ec4c:	a90717a0 	stp	x0, x5, [x29, #112]
	return tipc_send_data(dev, local, remote,
ffffffffea80ec50:	aa1403e0 	mov	x0, x20
ffffffffea80ec54:	97ffff2d 	bl	ffffffffea80e908 <tipc_send_data.constprop.3>
ffffffffea80ec58:	2a0003f8 	mov	w24, w0
	if (ret == NO_ERROR) {
ffffffffea80ec5c:	35fff920 	cbnz	w0, ffffffffea80eb80 <tipc_vdev_probe+0xf8>
		dev->vd.state = VDEV_STATE_ACTIVE;
ffffffffea80ec60:	b9000293 	str	w19, [x20]
ffffffffea80ec64:	17ffffc7 	b	ffffffffea80eb80 <tipc_vdev_probe+0xf8>
	if (vdev_descr->vdev.status != (VIRTIO_CONFIG_S_ACKNOWLEDGE |
ffffffffea80ec68:	128000f8 	mov	w24, #0xfffffff8            	// #-8
}
ffffffffea80ec6c:	2a1803e0 	mov	w0, w24
ffffffffea80ec70:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea80ec74:	f94027f8 	ldr	x24, [sp, #72]
ffffffffea80ec78:	9102c3ff 	add	sp, sp, #0xb0
ffffffffea80ec7c:	d65f03c0 	ret
		return ERR_BAD_STATE;
ffffffffea80ec80:	128003d8 	mov	w24, #0xffffffe1            	// #-31
ffffffffea80ec84:	17ffffc4 	b	ffffffffea80eb94 <tipc_vdev_probe+0x10c>

ffffffffea80ec88 <tipc_rx_thread_func>:
{
ffffffffea80ec88:	d10883ff 	sub	sp, sp, #0x220
	mutex_acquire(&dev->ept_lock);
ffffffffea80ec8c:	d2824106 	mov	x6, #0x1208                	// #4616
	memset(&buf, 0, sizeof(buf));
ffffffffea80ec90:	d2800902 	mov	x2, #0x48                  	// #72
ffffffffea80ec94:	52800001 	mov	w1, #0x0                   	// #0
{
ffffffffea80ec98:	a9007bfd 	stp	x29, x30, [sp]
ffffffffea80ec9c:	910003fd 	mov	x29, sp
ffffffffea80eca0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80eca4:	aa0003f5 	mov	x21, x0
ffffffffea80eca8:	a90153f3 	stp	x19, x20, [sp, #16]
	memset(&buf, 0, sizeof(buf));
ffffffffea80ecac:	910363a0 	add	x0, x29, #0xd8
{
ffffffffea80ecb0:	a90363f7 	stp	x23, x24, [sp, #48]
	struct vqueue *vq = &dev->vqs[TIPC_VQ_RX];
ffffffffea80ecb4:	910362b4 	add	x20, x21, #0xd8
{
ffffffffea80ecb8:	a9046bf9 	stp	x25, x26, [sp, #64]
	mutex_acquire(&dev->ept_lock);
ffffffffea80ecbc:	8b0602b8 	add	x24, x21, x6
ffffffffea80ecc0:	aa1e03f9 	mov	x25, x30
{
ffffffffea80ecc4:	f9002bfb 	str	x27, [sp, #80]
ffffffffea80ecc8:	914006b6 	add	x22, x21, #0x1, lsl #12
	memset(&buf, 0, sizeof(buf));
ffffffffea80eccc:	940011b1 	bl	ffffffffea813390 <memset>
		event_wait(&vq->avail_event);
ffffffffea80ecd0:	910482b7 	add	x23, x21, #0x120
	buf.in_iovs.cnt  = MAX_RX_IOVS;
ffffffffea80ecd4:	52800022 	mov	w2, #0x1                   	// #1
	buf.in_iovs.phys = in_phys;
ffffffffea80ecd8:	9101e3a1 	add	x1, x29, #0x78
	buf.in_iovs.iovs = in_iovs;
ffffffffea80ecdc:	910223a0 	add	x0, x29, #0x88
	buf.in_iovs.cnt  = MAX_RX_IOVS;
ffffffffea80ece0:	b900e3a2 	str	w2, [x29, #224]
	buf.in_iovs.iovs = in_iovs;
ffffffffea80ece4:	a90f03a1 	stp	x1, x0, [x29, #240]
	while(!dev->rx_stop) {
ffffffffea80ece8:	394946c0 	ldrb	w0, [x22, #593]
ffffffffea80ecec:	350007c0 	cbnz	w0, ffffffffea80ede4 <tipc_rx_thread_func+0x15c>
ffffffffea80ecf0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80ecf4:	aa1703e0 	mov	x0, x23
ffffffffea80ecf8:	97ffda82 	bl	ffffffffea805700 <event_wait_timeout>
		ret = vqueue_get_avail_buf(vq, &buf);
ffffffffea80ecfc:	910363a1 	add	x1, x29, #0xd8
ffffffffea80ed00:	aa1403e0 	mov	x0, x20
ffffffffea80ed04:	97fffa61 	bl	ffffffffea80d688 <vqueue_get_avail_buf>
		if (ret == ERR_CHANNEL_CLOSED) {
ffffffffea80ed08:	31003c1f 	cmn	w0, #0xf
ffffffffea80ed0c:	540006c0 	b.eq	ffffffffea80ede4 <tipc_rx_thread_func+0x15c>  // b.none
		if (ret == ERR_NOT_ENOUGH_BUFFER) {
ffffffffea80ed10:	3100241f 	cmn	w0, #0x9
ffffffffea80ed14:	54fffea0 	b.eq	ffffffffea80ece8 <tipc_rx_thread_func+0x60>  // b.none
ffffffffea80ed18:	2a0003f3 	mov	w19, w0
		if (likely(ret == NO_ERROR)) {
ffffffffea80ed1c:	350002e0 	cbnz	w0, ffffffffea80ed78 <tipc_rx_thread_func+0xf0>
	if (buf->in_iovs.used == 0) {
ffffffffea80ed20:	b940e7a0 	ldr	w0, [x29, #228]
ffffffffea80ed24:	340012c0 	cbz	w0, ffffffffea80ef7c <tipc_rx_thread_func+0x2f4>
	int ret = vqueue_map_iovs(&buf->in_iovs, map_flags, dev->guest);
ffffffffea80ed28:	b9402aa2 	ldr	w2, [x21, #40]
ffffffffea80ed2c:	52800701 	mov	w1, #0x38                  	// #56
ffffffffea80ed30:	910383a0 	add	x0, x29, #0xe0
ffffffffea80ed34:	97fffadf 	bl	ffffffffea80d8b0 <vqueue_map_iovs>
	if (ret) {
ffffffffea80ed38:	350003a0 	cbnz	w0, ffffffffea80edac <tipc_rx_thread_func+0x124>
	if (buf->in_iovs.iovs[0].len < sizeof(struct tipc_hdr)) {
ffffffffea80ed3c:	f9407fa1 	ldr	x1, [x29, #248]
ffffffffea80ed40:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea80ed44:	f9400420 	ldr	x0, [x1, #8]
ffffffffea80ed48:	f1003c1f 	cmp	x0, #0xf
ffffffffea80ed4c:	54000129 	b.ls	ffffffffea80ed70 <tipc_rx_thread_func+0xe8>  // b.plast
	ns_hdr  = buf->in_iovs.iovs[0].base;
ffffffffea80ed50:	f9400021 	ldr	x1, [x1]
	ns_data_len = ns_hdr->len;
ffffffffea80ed54:	79401822 	ldrh	w2, [x1, #12]
	src_addr = ns_hdr->src;
ffffffffea80ed58:	b940003b 	ldr	w27, [x1]
	dst_addr = ns_hdr->dst;
ffffffffea80ed5c:	b940043a 	ldr	w26, [x1, #4]
	ns_data_len = ns_hdr->len;
ffffffffea80ed60:	92403c42 	and	x2, x2, #0xffff
	if (ns_data_len + sizeof(struct tipc_hdr) != buf->in_iovs.iovs[0].len) {
ffffffffea80ed64:	91004043 	add	x3, x2, #0x10
ffffffffea80ed68:	eb03001f 	cmp	x0, x3
ffffffffea80ed6c:	540004e0 	b.eq	ffffffffea80ee08 <tipc_rx_thread_func+0x180>  // b.none
	vqueue_unmap_iovs(&buf->in_iovs);
ffffffffea80ed70:	910383a0 	add	x0, x29, #0xe0
ffffffffea80ed74:	97fffb2b 	bl	ffffffffea80da20 <vqueue_unmap_iovs>
		ret = vqueue_add_buf(vq, &buf, ret);
ffffffffea80ed78:	2a1303e2 	mov	w2, w19
ffffffffea80ed7c:	910363a1 	add	x1, x29, #0xd8
ffffffffea80ed80:	aa1403e0 	mov	x0, x20
ffffffffea80ed84:	97fffb43 	bl	ffffffffea80da90 <vqueue_add_buf>
		if (ret == ERR_CHANNEL_CLOSED) {
ffffffffea80ed88:	31003c1f 	cmn	w0, #0xf
ffffffffea80ed8c:	540002c0 	b.eq	ffffffffea80ede4 <tipc_rx_thread_func+0x15c>  // b.none
		if (ret != NO_ERROR) {
ffffffffea80ed90:	34fffac0 	cbz	w0, ffffffffea80ece8 <tipc_rx_thread_func+0x60>
			panic("Unable (%d) to return buffer to vqueue\n", ret);
ffffffffea80ed94:	b0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80ed98:	2a0003e2 	mov	w2, w0
ffffffffea80ed9c:	9113a021 	add	x1, x1, #0x4e8
ffffffffea80eda0:	aa1903e0 	mov	x0, x25
ffffffffea80eda4:	f9002fbc 	str	x28, [x29, #88]
ffffffffea80eda8:	94000b18 	bl	ffffffffea811a08 <_panic>
		TRACEF("failed to map iovs %d\n", ret);
ffffffffea80edac:	2a0003e3 	mov	w3, w0
ffffffffea80edb0:	b0000044 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80edb4:	2a0303f3 	mov	w19, w3
ffffffffea80edb8:	52803e62 	mov	w2, #0x1f3                 	// #499
ffffffffea80edbc:	91128080 	add	x0, x4, #0x4a0
ffffffffea80edc0:	b0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80edc4:	9110a021 	add	x1, x1, #0x428
ffffffffea80edc8:	94001076 	bl	ffffffffea812fa0 <_printf>
		ret = vqueue_add_buf(vq, &buf, ret);
ffffffffea80edcc:	2a1303e2 	mov	w2, w19
ffffffffea80edd0:	910363a1 	add	x1, x29, #0xd8
ffffffffea80edd4:	aa1403e0 	mov	x0, x20
ffffffffea80edd8:	97fffb2e 	bl	ffffffffea80da90 <vqueue_add_buf>
		if (ret == ERR_CHANNEL_CLOSED) {
ffffffffea80eddc:	31003c1f 	cmn	w0, #0xf
ffffffffea80ede0:	54fffd81 	b.ne	ffffffffea80ed90 <tipc_rx_thread_func+0x108>  // b.any
}
ffffffffea80ede4:	a9407bfd 	ldp	x29, x30, [sp]
ffffffffea80ede8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80edec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80edf0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80edf4:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80edf8:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80edfc:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea80ee00:	910883ff 	add	sp, sp, #0x220
ffffffffea80ee04:	d65f03c0 	ret
	if (dst_addr == TIPC_CTRL_ADDR) {
ffffffffea80ee08:	7100d75f 	cmp	w26, #0x35
ffffffffea80ee0c:	54000480 	b.eq	ffffffffea80ee9c <tipc_rx_thread_func+0x214>  // b.none
	ipc_msg_kern_t msg = {
ffffffffea80ee10:	910493a0 	add	x0, x29, #0x124
	ns_data = buf->in_iovs.iovs[0].base + sizeof(struct tipc_hdr);
ffffffffea80ee14:	91004021 	add	x1, x1, #0x10
	return (uint)(addr - TIPC_ADDR_BASE);
ffffffffea80ee18:	510fa35a 	sub	w26, w26, #0x3e8
		.iov		= (iovec_kern_t []) {
ffffffffea80ee1c:	a90a8ba1 	stp	x1, x2, [x29, #168]
ffffffffea80ee20:	12800001 	mov	w1, #0xffffffff            	// #-1
	ipc_msg_kern_t msg = {
ffffffffea80ee24:	a9007c1f 	stp	xzr, xzr, [x0]
ffffffffea80ee28:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80ee2c:	b90123a0 	str	w0, [x29, #288]
ffffffffea80ee30:	9102a3a0 	add	x0, x29, #0xa8
ffffffffea80ee34:	f90097a0 	str	x0, [x29, #296]
ffffffffea80ee38:	910843a0 	add	x0, x29, #0x210
ffffffffea80ee3c:	f812401f 	stur	xzr, [x0, #-220]
ffffffffea80ee40:	aa1803e0 	mov	x0, x24
ffffffffea80ee44:	b9013fbf 	str	wzr, [x29, #316]
ffffffffea80ee48:	97ffdaa8 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80ee4c:	7103ff5f 	cmp	w26, #0xff
ffffffffea80ee50:	54001448 	b.hi	ffffffffea80f0d8 <tipc_rx_thread_func+0x450>  // b.pmore
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80ee54:	2a1a03e0 	mov	w0, w26
ffffffffea80ee58:	d346fc01 	lsr	x1, x0, #6
ffffffffea80ee5c:	8b010ea1 	add	x1, x21, x1, lsl #3
ffffffffea80ee60:	f948b421 	ldr	x1, [x1, #4456]
ffffffffea80ee64:	9ada243a 	lsr	x26, x1, x26
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80ee68:	3600139a 	tbz	w26, #0, ffffffffea80f0d8 <tipc_rx_thread_func+0x450>
ffffffffea80ee6c:	8b0012a0 	add	x0, x21, x0, lsl #4
	if (ept && ept->remote == remote) {
ffffffffea80ee70:	b9416801 	ldr	w1, [x0, #360]
ffffffffea80ee74:	6b01037f 	cmp	w27, w1
ffffffffea80ee78:	54001301 	b.ne	ffffffffea80f0d8 <tipc_rx_thread_func+0x450>  // b.any
		if (ept->chan){
ffffffffea80ee7c:	f940b800 	ldr	x0, [x0, #368]
ffffffffea80ee80:	b40012c0 	cbz	x0, ffffffffea80f0d8 <tipc_rx_thread_func+0x450>
			ret = ipc_send_msg(ept->chan, &msg);
ffffffffea80ee84:	910483a1 	add	x1, x29, #0x120
ffffffffea80ee88:	97fff6cc 	bl	ffffffffea80c9b8 <ipc_send_msg>
ffffffffea80ee8c:	2a0003f3 	mov	w19, w0
	mutex_release(&dev->ept_lock);
ffffffffea80ee90:	aa1803e0 	mov	x0, x24
ffffffffea80ee94:	97ffdac1 	bl	ffffffffea805998 <mutex_release>
ffffffffea80ee98:	17ffffb6 	b	ffffffffea80ed70 <tipc_rx_thread_func+0xe8>
	if (msg_len < sizeof(struct tipc_ctrl_msg_hdr)) {
ffffffffea80ee9c:	f1001c5f 	cmp	x2, #0x7
ffffffffea80eea0:	54000b09 	b.ls	ffffffffea80f000 <tipc_rx_thread_func+0x378>  // b.plast
	msg_type = ns_msg_hdr->type;
ffffffffea80eea4:	b940103a 	ldr	w26, [x1, #16]
	msg_body_len = ns_msg_hdr->body_len;
ffffffffea80eea8:	b9401433 	ldr	w19, [x1, #20]
ffffffffea80eeac:	2a1303f3 	mov	w19, w19
	if (sizeof(struct tipc_ctrl_msg_hdr) + msg_body_len != msg_len) {
ffffffffea80eeb0:	91002260 	add	x0, x19, #0x8
ffffffffea80eeb4:	eb00005f 	cmp	x2, x0
ffffffffea80eeb8:	54000a41 	b.ne	ffffffffea80f000 <tipc_rx_thread_func+0x378>  // b.any
	switch (msg_type) {
ffffffffea80eebc:	71000f5f 	cmp	w26, #0x3
ffffffffea80eec0:	54000620 	b.eq	ffffffffea80ef84 <tipc_rx_thread_func+0x2fc>  // b.none
ffffffffea80eec4:	7100175f 	cmp	w26, #0x5
ffffffffea80eec8:	540009c1 	b.ne	ffffffffea80f000 <tipc_rx_thread_func+0x378>  // b.any
		if (msg_body_len != sizeof(struct tipc_disc_req_body)) {
ffffffffea80eecc:	f100127f 	cmp	x19, #0x4
ffffffffea80eed0:	54000981 	b.ne	ffffffffea80f000 <tipc_rx_thread_func+0x378>  // b.any
ffffffffea80eed4:	d2822d02 	mov	x2, #0x1168                	// #4456
	uint32_t target = ns_req->target;
ffffffffea80eed8:	b9401833 	ldr	w19, [x1, #24]
ffffffffea80eedc:	aa1803e0 	mov	x0, x24
ffffffffea80eee0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80eee4:	8b0202ba 	add	x26, x21, x2
ffffffffea80eee8:	97ffda80 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	return (uint)(addr - TIPC_ADDR_BASE);
ffffffffea80eeec:	510fa261 	sub	w1, w19, #0x3e8
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80eef0:	7103fc3f 	cmp	w1, #0xff
ffffffffea80eef4:	540008a9 	b.ls	ffffffffea80f008 <tipc_rx_thread_func+0x380>  // b.plast
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80eef8:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80eefc:	14000004 	b	ffffffffea80ef0c <tipc_rx_thread_func+0x284>
ffffffffea80ef00:	91000400 	add	x0, x0, #0x1
		for (uint slot  = 0; slot < countof(dev->epts); slot++) {
ffffffffea80ef04:	f104001f 	cmp	x0, #0x100
ffffffffea80ef08:	54000320 	b.eq	ffffffffea80ef6c <tipc_rx_thread_func+0x2e4>  // b.none
ffffffffea80ef0c:	d346fc01 	lsr	x1, x0, #6
ffffffffea80ef10:	f8617b41 	ldr	x1, [x26, x1, lsl #3]
ffffffffea80ef14:	9ac02421 	lsr	x1, x1, x0
			if (bitmap_test(dev->inuse, slot)) {
ffffffffea80ef18:	3607ff41 	tbz	w1, #0, ffffffffea80ef00 <tipc_rx_thread_func+0x278>
				if (dev->epts[slot].remote == remote) {
ffffffffea80ef1c:	8b0012a1 	add	x1, x21, x0, lsl #4
ffffffffea80ef20:	b9416821 	ldr	w1, [x1, #360]
ffffffffea80ef24:	6b01037f 	cmp	w27, w1
ffffffffea80ef28:	54fffec1 	b.ne	ffffffffea80ef00 <tipc_rx_thread_func+0x278>  // b.any
					ept = &dev->epts[slot];
ffffffffea80ef2c:	8b0012a0 	add	x0, x21, x0, lsl #4
ffffffffea80ef30:	9105a013 	add	x19, x0, #0x168
		handle_t *chan = ept->chan;
ffffffffea80ef34:	f940067b 	ldr	x27, [x19, #8]
		if (chan) {
ffffffffea80ef38:	b400011b 	cbz	x27, ffffffffea80ef58 <tipc_rx_thread_func+0x2d0>
			handle_list_del(&dev->handle_list, chan);
ffffffffea80ef3c:	aa1b03e1 	mov	x1, x27
ffffffffea80ef40:	d2823700 	mov	x0, #0x11b8                	// #4536
ffffffffea80ef44:	8b0002a0 	add	x0, x21, x0
ffffffffea80ef48:	97ffecd4 	bl	ffffffffea80a298 <handle_list_del>
	handle->cookie = cookie;
ffffffffea80ef4c:	f9001b7f 	str	xzr, [x27, #48]
			handle_close(chan);
ffffffffea80ef50:	aa1b03e0 	mov	x0, x27
ffffffffea80ef54:	97ffec35 	bl	ffffffffea80a028 <handle_close>
	return slot_to_addr(ept - dev->epts);
ffffffffea80ef58:	9105a2a0 	add	x0, x21, #0x168
ffffffffea80ef5c:	cb000260 	sub	x0, x19, x0
ffffffffea80ef60:	9344fc00 	asr	x0, x0, #4
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80ef64:	7103fc1f 	cmp	w0, #0xff
ffffffffea80ef68:	540009a9 	b.ls	ffffffffea80f09c <tipc_rx_thread_func+0x414>  // b.plast
	mutex_release(&dev->ept_lock);
ffffffffea80ef6c:	aa1803e0 	mov	x0, x24
ffffffffea80ef70:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea80ef74:	97ffda89 	bl	ffffffffea805998 <mutex_release>
ffffffffea80ef78:	17ffff7e 	b	ffffffffea80ed70 <tipc_rx_thread_func+0xe8>
	if (buf->in_iovs.used == 0) {
ffffffffea80ef7c:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea80ef80:	17ffff7e 	b	ffffffffea80ed78 <tipc_rx_thread_func+0xf0>
		if (msg_body_len != sizeof(struct tipc_conn_req_body)) {
ffffffffea80ef84:	f104027f 	cmp	x19, #0x100
ffffffffea80ef88:	540003c1 	b.ne	ffffffffea80f000 <tipc_rx_thread_func+0x378>  // b.any
	strncpy(req.name, (const char *)ns_req->name, sizeof(req.name));
ffffffffea80ef8c:	aa1303e2 	mov	x2, x19
ffffffffea80ef90:	91006021 	add	x1, x1, #0x18
ffffffffea80ef94:	f9002fbc 	str	x28, [x29, #88]
ffffffffea80ef98:	910483a0 	add	x0, x29, #0x120
	handle_t *chan = NULL;
ffffffffea80ef9c:	f90043bf 	str	xzr, [x29, #128]
	strncpy(req.name, (const char *)ns_req->name, sizeof(req.name));
ffffffffea80efa0:	94001168 	bl	ffffffffea813540 <strncpy>
	err = ipc_port_connect_async(dev->guest, dev->uuid, req.name, sizeof(req.name),
ffffffffea80efa4:	b9402aa0 	ldr	w0, [x21, #40]
ffffffffea80efa8:	910203a5 	add	x5, x29, #0x80
ffffffffea80efac:	f9401aa1 	ldr	x1, [x21, #48]
ffffffffea80efb0:	52800004 	mov	w4, #0x0                   	// #0
ffffffffea80efb4:	aa1303e3 	mov	x3, x19
ffffffffea80efb8:	910483a2 	add	x2, x29, #0x120
ffffffffea80efbc:	97fff357 	bl	ffffffffea80bd18 <ipc_port_connect_async>
ffffffffea80efc0:	2a0003fc 	mov	w28, w0
	if (err == NO_ERROR) {
ffffffffea80efc4:	340008e0 	cbz	w0, ffffffffea80f0e0 <tipc_rx_thread_func+0x458>
	if (chan) {
ffffffffea80efc8:	f94043a1 	ldr	x1, [x29, #128]
	return NULL;
ffffffffea80efcc:	d2800000 	mov	x0, #0x0                   	// #0
	if (chan) {
ffffffffea80efd0:	b4000381 	cbz	x1, ffffffffea80f040 <tipc_rx_thread_func+0x3b8>
ffffffffea80efd4:	f9001820 	str	x0, [x1, #48]
		handle_list_add(&dev->handle_list, chan);
ffffffffea80efd8:	d2823703 	mov	x3, #0x11b8                	// #4536
ffffffffea80efdc:	8b0302a0 	add	x0, x21, x3
		event_signal(&dev->have_handles, false);
ffffffffea80efe0:	52800013 	mov	w19, #0x0                   	// #0
		handle_list_add(&dev->handle_list, chan);
ffffffffea80efe4:	97ffec83 	bl	ffffffffea80a1f0 <handle_list_add>
		event_signal(&dev->have_handles, false);
ffffffffea80efe8:	d2823104 	mov	x4, #0x1188                	// #4488
ffffffffea80efec:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80eff0:	8b0402a0 	add	x0, x21, x4
ffffffffea80eff4:	97ffd9e7 	bl	ffffffffea805790 <event_signal>
ffffffffea80eff8:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea80effc:	17ffff5d 	b	ffffffffea80ed70 <tipc_rx_thread_func+0xe8>
		if (msg_body_len != sizeof(struct tipc_disc_req_body)) {
ffffffffea80f000:	128000d3 	mov	w19, #0xfffffff9            	// #-7
ffffffffea80f004:	17ffff5b 	b	ffffffffea80ed70 <tipc_rx_thread_func+0xe8>
ffffffffea80f008:	2a0103e0 	mov	w0, w1
ffffffffea80f00c:	d346fc02 	lsr	x2, x0, #6
ffffffffea80f010:	f8627b42 	ldr	x2, [x26, x2, lsl #3]
ffffffffea80f014:	9ac12441 	lsr	x1, x2, x1
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80f018:	3607f701 	tbz	w1, #0, ffffffffea80eef8 <tipc_rx_thread_func+0x270>
	if (!ept || ept->remote != remote) {
ffffffffea80f01c:	91005800 	add	x0, x0, #0x16
ffffffffea80f020:	d37cec00 	lsl	x0, x0, #4
ffffffffea80f024:	8b0002a1 	add	x1, x21, x0
ffffffffea80f028:	b9400821 	ldr	w1, [x1, #8]
ffffffffea80f02c:	6b01037f 	cmp	w27, w1
ffffffffea80f030:	54fff641 	b.ne	ffffffffea80eef8 <tipc_rx_thread_func+0x270>  // b.any
			return &dev->epts[slot];
ffffffffea80f034:	91002000 	add	x0, x0, #0x8
ffffffffea80f038:	8b0002b3 	add	x19, x21, x0
ffffffffea80f03c:	17ffffbe 	b	ffffffffea80ef34 <tipc_rx_thread_func+0x2ac>
	return NULL;
ffffffffea80f040:	5280001a 	mov	w26, #0x0                   	// #0
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f044:	d2800080 	mov	x0, #0x4                   	// #4
	return tipc_send_data(dev, local, remote,
ffffffffea80f048:	f0ffffe3 	adrp	x3, ffffffffea80e000 <map_descr+0x70>
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f04c:	f2c00280 	movk	x0, #0x14, lsl #32
	return tipc_send_data(dev, local, remote,
ffffffffea80f050:	911fe063 	add	x3, x3, #0x7f8
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f054:	f9005fa0 	str	x0, [x29, #184]
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f058:	9102e3a0 	add	x0, x29, #0xb8
ffffffffea80f05c:	d2800385 	mov	x5, #0x1c                  	// #28
	return tipc_send_data(dev, local, remote,
ffffffffea80f060:	528006a2 	mov	w2, #0x35                  	// #53
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f064:	f9004fa0 	str	x0, [x29, #152]
	return tipc_send_data(dev, local, remote,
ffffffffea80f068:	910263a4 	add	x4, x29, #0x98
ffffffffea80f06c:	2a0203e1 	mov	w1, w2
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f070:	f90053a5 	str	x5, [x29, #160]
	msg.body.status = status;
ffffffffea80f074:	291873bb 	stp	w27, w28, [x29, #192]
	return tipc_send_data(dev, local, remote,
ffffffffea80f078:	aa1503e0 	mov	x0, x21
	msg.body.remote = local;
ffffffffea80f07c:	b900cbba 	str	w26, [x29, #200]
	if (err) {
ffffffffea80f080:	52800013 	mov	w19, #0x0                   	// #0
	msg.body.max_msg_size = msg_sz;
ffffffffea80f084:	f80cc3bf 	stur	xzr, [x29, #204]
	return tipc_send_data(dev, local, remote,
ffffffffea80f088:	97fffe20 	bl	ffffffffea80e908 <tipc_send_data.constprop.3>
ffffffffea80f08c:	2a0003e3 	mov	w3, w0
	if (err) {
ffffffffea80f090:	350007c0 	cbnz	w0, ffffffffea80f188 <tipc_rx_thread_func+0x500>
ffffffffea80f094:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea80f098:	17ffff36 	b	ffffffffea80ed70 <tipc_rx_thread_func+0xe8>
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80f09c:	93437c01 	sbfx	x1, x0, #3, #29
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f0a0:	52800022 	mov	w2, #0x1                   	// #1
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea80f0a4:	927ee821 	and	x1, x1, #0x1ffffffffffffffc
ffffffffea80f0a8:	1ac02042 	lsl	w2, w2, w0
ffffffffea80f0ac:	8b01035a 	add	x26, x26, x1
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80f0b0:	2a2203e1 	mvn	w1, w2
ffffffffea80f0b4:	885f7f42 	ldxr	w2, [x26]
ffffffffea80f0b8:	0a010042 	and	w2, w2, w1
ffffffffea80f0bc:	88037f42 	stxr	w3, w2, [x26]
ffffffffea80f0c0:	35ffffa3 	cbnz	w3, ffffffffea80f0b4 <tipc_rx_thread_func+0x42c>
ffffffffea80f0c4:	d37c7c00 	ubfiz	x0, x0, #4, #32
ffffffffea80f0c8:	8b0002a0 	add	x0, x21, x0
		dev->epts[slot].remote = 0;
ffffffffea80f0cc:	b901681f 	str	wzr, [x0, #360]
		dev->epts[slot].chan = NULL;
ffffffffea80f0d0:	f900b81f 	str	xzr, [x0, #368]
ffffffffea80f0d4:	17ffffa6 	b	ffffffffea80ef6c <tipc_rx_thread_func+0x2e4>
		if (ept->chan){
ffffffffea80f0d8:	12800033 	mov	w19, #0xfffffffe            	// #-2
ffffffffea80f0dc:	17ffff6d 	b	ffffffffea80ee90 <tipc_rx_thread_func+0x208>
ffffffffea80f0e0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f0e4:	aa1803e0 	mov	x0, x24
ffffffffea80f0e8:	97ffda00 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
		if (bitmap[i] == ~0UL)
ffffffffea80f0ec:	f948b6a0 	ldr	x0, [x21, #4456]
	int slot = bitmap_ffz(dev->inuse, TIPC_ADDR_MAX_NUM);
ffffffffea80f0f0:	d2822d05 	mov	x5, #0x1168                	// #4456
ffffffffea80f0f4:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea80f0f8:	8b0502a4 	add	x4, x21, x5
ffffffffea80f0fc:	b100041f 	cmn	x0, #0x1
		local = alloc_local_addr(dev, remote, chan);
ffffffffea80f100:	f94043a5 	ldr	x5, [x29, #128]
ffffffffea80f104:	54000540 	b.eq	ffffffffea80f1ac <tipc_rx_thread_func+0x524>  // b.none
	return __builtin_ffsl(~x) - 1;
ffffffffea80f108:	aa2003e1 	mvn	x1, x0
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f10c:	52800023 	mov	w3, #0x1                   	// #1
	return __builtin_ffsl(~x) - 1;
ffffffffea80f110:	dac00020 	rbit	x0, x1
ffffffffea80f114:	f100003f 	cmp	x1, #0x0
ffffffffea80f118:	dac01000 	clz	x0, x0
    return __atomic_fetch_or(ptr, val, __ATOMIC_RELAXED);
ffffffffea80f11c:	f90037a4 	str	x4, [x29, #104]
ffffffffea80f120:	5a9f1000 	csinv	w0, w0, wzr, ne  // ne = any
		bit = i * BITMAP_BITS_PER_WORD + _ffz(bitmap[i]);
ffffffffea80f124:	0b020013 	add	w19, w0, w2
ffffffffea80f128:	aa1303fa 	mov	x26, x19
	return atomic_or(&((int*)bitmap)[BITMAP_INT(bit)], mask) & mask ? 1 : 0;
ffffffffea80f12c:	d345fe60 	lsr	x0, x19, #5
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f130:	1ad32061 	lsl	w1, w3, w19
ffffffffea80f134:	8b000880 	add	x0, x4, x0, lsl #2
ffffffffea80f138:	885f7c02 	ldxr	w2, [x0]
ffffffffea80f13c:	2a010042 	orr	w2, w2, w1
ffffffffea80f140:	88037c02 	stxr	w3, w2, [x0]
ffffffffea80f144:	35ffffa3 	cbnz	w3, ffffffffea80f138 <tipc_rx_thread_func+0x4b0>
ffffffffea80f148:	8b1312a1 	add	x1, x21, x19, lsl #4
		mutex_release(&dev->ept_lock);
ffffffffea80f14c:	aa1803e0 	mov	x0, x24
		dev->epts[slot].remote = remote;
ffffffffea80f150:	b901683b 	str	w27, [x1, #360]
		dev->epts[slot].chan = chan;
ffffffffea80f154:	f900b825 	str	x5, [x1, #368]
		mutex_release(&dev->ept_lock);
ffffffffea80f158:	97ffda10 	bl	ffffffffea805998 <mutex_release>
	if (chan) {
ffffffffea80f15c:	f94043a1 	ldr	x1, [x29, #128]
ffffffffea80f160:	f94037a4 	ldr	x4, [x29, #104]
ffffffffea80f164:	b40003c1 	cbz	x1, ffffffffea80f1dc <tipc_rx_thread_func+0x554>
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80f168:	d346fe62 	lsr	x2, x19, #6
			return &dev->epts[slot];
ffffffffea80f16c:	8b1312a0 	add	x0, x21, x19, lsl #4
ffffffffea80f170:	9105a000 	add	x0, x0, #0x168
ffffffffea80f174:	f8627882 	ldr	x2, [x4, x2, lsl #3]
ffffffffea80f178:	9ada245a 	lsr	x26, x2, x26
ffffffffea80f17c:	f240035f 	tst	x26, #0x1
ffffffffea80f180:	9a9f1000 	csel	x0, x0, xzr, ne  // ne = any
ffffffffea80f184:	17ffff94 	b	ffffffffea80efd4 <tipc_rx_thread_func+0x34c>
		TRACEF("failed (%d) to send response\n", err);
ffffffffea80f188:	90000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80f18c:	90000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80f190:	52802982 	mov	w2, #0x14c                 	// #332
ffffffffea80f194:	91106021 	add	x1, x1, #0x418
ffffffffea80f198:	91130000 	add	x0, x0, #0x4c0
ffffffffea80f19c:	2a0303f3 	mov	w19, w3
ffffffffea80f1a0:	94000f80 	bl	ffffffffea812fa0 <_printf>
ffffffffea80f1a4:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea80f1a8:	17fffef2 	b	ffffffffea80ed70 <tipc_rx_thread_func+0xe8>
		if (bitmap[i] == ~0UL)
ffffffffea80f1ac:	f948baa0 	ldr	x0, [x21, #4464]
	for (i = 0; i < BITMAP_NUM_WORDS(numbits); i++) {
ffffffffea80f1b0:	52800022 	mov	w2, #0x1                   	// #1
		if (bitmap[i] == ~0UL)
ffffffffea80f1b4:	b100041f 	cmn	x0, #0x1
ffffffffea80f1b8:	54000060 	b.eq	ffffffffea80f1c4 <tipc_rx_thread_func+0x53c>  // b.none
ffffffffea80f1bc:	531a6442 	lsl	w2, w2, #6
ffffffffea80f1c0:	17ffffd2 	b	ffffffffea80f108 <tipc_rx_thread_func+0x480>
ffffffffea80f1c4:	f948bea0 	ldr	x0, [x21, #4472]
ffffffffea80f1c8:	b100041f 	cmn	x0, #0x1
ffffffffea80f1cc:	540000c0 	b.eq	ffffffffea80f1e4 <tipc_rx_thread_func+0x55c>  // b.none
	for (i = 0; i < BITMAP_NUM_WORDS(numbits); i++) {
ffffffffea80f1d0:	52800042 	mov	w2, #0x2                   	// #2
ffffffffea80f1d4:	531a6442 	lsl	w2, w2, #6
ffffffffea80f1d8:	17ffffcc 	b	ffffffffea80f108 <tipc_rx_thread_func+0x480>
	return (uint32_t) (slot + TIPC_ADDR_BASE);
ffffffffea80f1dc:	110fa35a 	add	w26, w26, #0x3e8
ffffffffea80f1e0:	17ffff99 	b	ffffffffea80f044 <tipc_rx_thread_func+0x3bc>
		if (bitmap[i] == ~0UL)
ffffffffea80f1e4:	f948c2a0 	ldr	x0, [x21, #4480]
ffffffffea80f1e8:	b100041f 	cmn	x0, #0x1
ffffffffea80f1ec:	54000080 	b.eq	ffffffffea80f1fc <tipc_rx_thread_func+0x574>  // b.none
	for (i = 0; i < BITMAP_NUM_WORDS(numbits); i++) {
ffffffffea80f1f0:	2a1a03e2 	mov	w2, w26
ffffffffea80f1f4:	531a6442 	lsl	w2, w2, #6
ffffffffea80f1f8:	17ffffc4 	b	ffffffffea80f108 <tipc_rx_thread_func+0x480>
			handle_close(chan);
ffffffffea80f1fc:	aa0503e0 	mov	x0, x5
ffffffffea80f200:	97ffeb8a 	bl	ffffffffea80a028 <handle_close>
		mutex_release(&dev->ept_lock);
ffffffffea80f204:	aa1803e0 	mov	x0, x24
			chan = NULL;
ffffffffea80f208:	f90043bf 	str	xzr, [x29, #128]
		mutex_release(&dev->ept_lock);
ffffffffea80f20c:	97ffd9e3 	bl	ffffffffea805998 <mutex_release>
	if (chan) {
ffffffffea80f210:	f94043a1 	ldr	x1, [x29, #128]
ffffffffea80f214:	b4fff161 	cbz	x1, ffffffffea80f040 <tipc_rx_thread_func+0x3b8>
	return NULL;
ffffffffea80f218:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80f21c:	17ffff6e 	b	ffffffffea80efd4 <tipc_rx_thread_func+0x34c>

ffffffffea80f220 <tipc_rx_vq_notify_cb>:
ffffffffea80f220:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80f224:	910003fd 	mov	x29, sp
ffffffffea80f228:	97fff8e2 	bl	ffffffffea80d5b0 <vqueue_signal_avail>
ffffffffea80f22c:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80f230:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80f234:	d65f03c0 	ret

ffffffffea80f238 <tipc_vdev_reset>:
	if (dev->vd.state == VDEV_STATE_RESET) {
ffffffffea80f238:	b9400001 	ldr	w1, [x0]
ffffffffea80f23c:	35000061 	cbnz	w1, ffffffffea80f248 <tipc_vdev_reset+0x10>
}
ffffffffea80f240:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80f244:	d65f03c0 	ret
{
ffffffffea80f248:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80f24c:	910003fd 	mov	x29, sp
ffffffffea80f250:	f90023f9 	str	x25, [sp, #64]
	dev->rx_stop = true;
ffffffffea80f254:	91400419 	add	x25, x0, #0x1, lsl #12
{
ffffffffea80f258:	f9000ff4 	str	x20, [sp, #24]
	dev->rx_stop = true;
ffffffffea80f25c:	52800034 	mov	w20, #0x1                   	// #1
{
ffffffffea80f260:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80f264:	aa0003f7 	mov	x23, x0
ffffffffea80f268:	f9002bfb 	str	x27, [sp, #80]
	vqueue_signal_avail(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80f26c:	9103601b 	add	x27, x0, #0xd8
	dev->rx_stop = true;
ffffffffea80f270:	39094734 	strb	w20, [x25, #593]
	vqueue_signal_avail(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80f274:	aa1b03e0 	mov	x0, x27
ffffffffea80f278:	f90037be 	str	x30, [x29, #104]
ffffffffea80f27c:	97fff8cd 	bl	ffffffffea80d5b0 <vqueue_signal_avail>
	rc = thread_join(dev->rx_thread, NULL, 1000);
ffffffffea80f280:	f94922e0 	ldr	x0, [x23, #4672]
ffffffffea80f284:	52807d02 	mov	w2, #0x3e8                 	// #1000
ffffffffea80f288:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80f28c:	97ffddab 	bl	ffffffffea806938 <thread_join>
ffffffffea80f290:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80f294:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80f298:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80f29c:	f90027ba 	str	x26, [x29, #72]
ffffffffea80f2a0:	f9002fbc 	str	x28, [x29, #88]
	if (rc != NO_ERROR) {
ffffffffea80f2a4:	35000b00 	cbnz	w0, ffffffffea80f404 <tipc_vdev_reset+0x1cc>
	dev->rx_thread = NULL;
ffffffffea80f2a8:	f90922ff 	str	xzr, [x23, #4672]
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80f2ac:	d2823702 	mov	x2, #0x11b8                	// #4536
	mutex_acquire(&dev->ept_lock);
ffffffffea80f2b0:	d2824103 	mov	x3, #0x1208                	// #4616
	dev->tx_stop = true;
ffffffffea80f2b4:	39094334 	strb	w20, [x25, #592]
	dev->rx_stop = false;
ffffffffea80f2b8:	3909473f 	strb	wzr, [x25, #593]
	ept = dev->epts;
ffffffffea80f2bc:	9105a2f5 	add	x21, x23, #0x168
ffffffffea80f2c0:	d2822d01 	mov	x1, #0x1168                	// #4456
	mutex_acquire(&dev->ept_lock);
ffffffffea80f2c4:	8b0302fc 	add	x28, x23, x3
ffffffffea80f2c8:	8b0102fa 	add	x26, x23, x1
	ept = dev->epts;
ffffffffea80f2cc:	aa1503f3 	mov	x19, x21
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80f2d0:	8b0202f6 	add	x22, x23, x2
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f2d4:	52800038 	mov	w24, #0x1                   	// #1
ffffffffea80f2d8:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f2dc:	aa1c03e0 	mov	x0, x28
	ept = dev->epts;
ffffffffea80f2e0:	d2800014 	mov	x20, #0x0                   	// #0
ffffffffea80f2e4:	97ffd981 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
ffffffffea80f2e8:	14000005 	b	ffffffffea80f2fc <tipc_vdev_reset+0xc4>
	for (uint slot  = 0; slot < countof(dev->epts); slot++, ept++) {
ffffffffea80f2ec:	91004273 	add	x19, x19, #0x10
ffffffffea80f2f0:	91000694 	add	x20, x20, #0x1
ffffffffea80f2f4:	eb1a027f 	cmp	x19, x26
ffffffffea80f2f8:	54000440 	b.eq	ffffffffea80f380 <tipc_vdev_reset+0x148>  // b.none
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80f2fc:	d346fe80 	lsr	x0, x20, #6
ffffffffea80f300:	f8607b40 	ldr	x0, [x26, x0, lsl #3]
ffffffffea80f304:	9ad42400 	lsr	x0, x0, x20
		if (!bitmap_test(dev->inuse, slot)) {
ffffffffea80f308:	3607ff20 	tbz	w0, #0, ffffffffea80f2ec <tipc_vdev_reset+0xb4>
		if (!ept->chan) {
ffffffffea80f30c:	f9400661 	ldr	x1, [x19, #8]
ffffffffea80f310:	b4fffee1 	cbz	x1, ffffffffea80f2ec <tipc_vdev_reset+0xb4>
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80f314:	aa1603e0 	mov	x0, x22
ffffffffea80f318:	97ffebe0 	bl	ffffffffea80a298 <handle_list_del>
		handle_set_cookie(ept->chan, NULL);
ffffffffea80f31c:	f9400661 	ldr	x1, [x19, #8]
		handle_close(ept->chan);
ffffffffea80f320:	aa0103e0 	mov	x0, x1
ffffffffea80f324:	f900183f 	str	xzr, [x1, #48]
ffffffffea80f328:	97ffeb40 	bl	ffffffffea80a028 <handle_close>
	return slot_to_addr(ept - dev->epts);
ffffffffea80f32c:	cb150260 	sub	x0, x19, x21
ffffffffea80f330:	9344fc00 	asr	x0, x0, #4
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80f334:	7103fc1f 	cmp	w0, #0xff
ffffffffea80f338:	54fffda8 	b.hi	ffffffffea80f2ec <tipc_vdev_reset+0xb4>  // b.pmore
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80f33c:	93437c01 	sbfx	x1, x0, #3, #29
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f340:	1ac02303 	lsl	w3, w24, w0
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea80f344:	927ee821 	and	x1, x1, #0x1ffffffffffffffc
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80f348:	2a2303e3 	mvn	w3, w3
ffffffffea80f34c:	8b010341 	add	x1, x26, x1
ffffffffea80f350:	885f7c22 	ldxr	w2, [x1]
ffffffffea80f354:	0a030042 	and	w2, w2, w3
ffffffffea80f358:	88047c22 	stxr	w4, w2, [x1]
ffffffffea80f35c:	35ffffa4 	cbnz	w4, ffffffffea80f350 <tipc_vdev_reset+0x118>
ffffffffea80f360:	d37c7c00 	ubfiz	x0, x0, #4, #32
	for (uint slot  = 0; slot < countof(dev->epts); slot++, ept++) {
ffffffffea80f364:	91004273 	add	x19, x19, #0x10
ffffffffea80f368:	8b0002e0 	add	x0, x23, x0
ffffffffea80f36c:	91000694 	add	x20, x20, #0x1
ffffffffea80f370:	eb1a027f 	cmp	x19, x26
		dev->epts[slot].remote = 0;
ffffffffea80f374:	b901681f 	str	wzr, [x0, #360]
		dev->epts[slot].chan = NULL;
ffffffffea80f378:	f900b81f 	str	xzr, [x0, #368]
	for (uint slot  = 0; slot < countof(dev->epts); slot++, ept++) {
ffffffffea80f37c:	54fffc01 	b.ne	ffffffffea80f2fc <tipc_vdev_reset+0xc4>  // b.any
	mutex_release(&dev->ept_lock);
ffffffffea80f380:	aa1c03e0 	mov	x0, x28
ffffffffea80f384:	97ffd985 	bl	ffffffffea805998 <mutex_release>
	event_signal(&dev->have_handles, false);
ffffffffea80f388:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80f38c:	d2823100 	mov	x0, #0x1188                	// #4488
	vqueue_signal_avail(&dev->vqs[TIPC_VQ_TX]);
ffffffffea80f390:	910122f3 	add	x19, x23, #0x48
	event_signal(&dev->have_handles, false);
ffffffffea80f394:	8b0002e0 	add	x0, x23, x0
ffffffffea80f398:	97ffd8fe 	bl	ffffffffea805790 <event_signal>
	vqueue_signal_avail(&dev->vqs[TIPC_VQ_TX]);
ffffffffea80f39c:	aa1303e0 	mov	x0, x19
ffffffffea80f3a0:	97fff884 	bl	ffffffffea80d5b0 <vqueue_signal_avail>
	rc = thread_join(dev->tx_thread, NULL, 1000);
ffffffffea80f3a4:	f94926e0 	ldr	x0, [x23, #4680]
ffffffffea80f3a8:	52807d02 	mov	w2, #0x3e8                 	// #1000
ffffffffea80f3ac:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80f3b0:	97ffdd62 	bl	ffffffffea806938 <thread_join>
	if (rc != NO_ERROR) {
ffffffffea80f3b4:	35000320 	cbnz	w0, ffffffffea80f418 <tipc_vdev_reset+0x1e0>
	dev->tx_thread = NULL;
ffffffffea80f3b8:	f90926ff 	str	xzr, [x23, #4680]
	vqueue_destroy(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80f3bc:	aa1b03e0 	mov	x0, x27
	dev->tx_stop = false;
ffffffffea80f3c0:	3909433f 	strb	wzr, [x25, #592]
	vqueue_destroy(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80f3c4:	97fff855 	bl	ffffffffea80d518 <vqueue_destroy>
	vqueue_destroy(&dev->vqs[TIPC_VQ_TX]);
ffffffffea80f3c8:	aa1303e0 	mov	x0, x19
ffffffffea80f3cc:	97fff853 	bl	ffffffffea80d518 <vqueue_destroy>
}
ffffffffea80f3d0:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80f3d4:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80f3d8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80f3dc:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80f3e0:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea80f3e4:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea80f3e8:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80f3ec:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80f3f0:	f9402bfb 	ldr	x27, [sp, #80]
	dev->vd.state = VDEV_STATE_RESET;
ffffffffea80f3f4:	b90002ff 	str	wzr, [x23]
}
ffffffffea80f3f8:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80f3fc:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80f400:	d65f03c0 	ret
		panic("unable to shutdown rx thread: %d\n", rc);
ffffffffea80f404:	2a0003e2 	mov	w2, w0
ffffffffea80f408:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea80f40c:	90000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80f410:	9116a021 	add	x1, x1, #0x5a8
ffffffffea80f414:	9400097d 	bl	ffffffffea811a08 <_panic>
		panic("unable to shutdown tx thread: %d\n", rc);
ffffffffea80f418:	2a0003e2 	mov	w2, w0
ffffffffea80f41c:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea80f420:	90000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80f424:	91174021 	add	x1, x1, #0x5d0
ffffffffea80f428:	94000978 	bl	ffffffffea811a08 <_panic>
ffffffffea80f42c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80f430 <tipc_tx_thread_func>:
{
ffffffffea80f430:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
ffffffffea80f434:	910003fd 	mov	x29, sp
ffffffffea80f438:	f9002ffc 	str	x28, [sp, #88]
	while (!dev->tx_stop) {
ffffffffea80f43c:	9140041c 	add	x28, x0, #0x1, lsl #12
ffffffffea80f440:	39494381 	ldrb	w1, [x28, #592]
ffffffffea80f444:	35001361 	cbnz	w1, ffffffffea80f6b0 <tipc_tx_thread_func+0x280>
ffffffffea80f448:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80f44c:	aa0003f4 	mov	x20, x0
ffffffffea80f450:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80f454:	d2823707 	mov	x7, #0x11b8                	// #4536
ffffffffea80f458:	a9046bb9 	stp	x25, x26, [x29, #64]
		ret = tipc_send_data(dev, local, remote,
ffffffffea80f45c:	f0fffff8 	adrp	x24, ffffffffea80e000 <map_descr+0x70>
ffffffffea80f460:	8b070299 	add	x25, x20, x7
ffffffffea80f464:	91218318 	add	x24, x24, #0x860
ffffffffea80f468:	d2823106 	mov	x6, #0x1188                	// #4488
ffffffffea80f46c:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80f470:	8b060000 	add	x0, x0, x6
ffffffffea80f474:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80f478:	a90603be 	stp	x30, x0, [x29, #96]
ffffffffea80f47c:	d503201f 	nop
ffffffffea80f480:	f94037a0 	ldr	x0, [x29, #104]
	msg.hdr.type = TIPC_CTRL_MSGTYPE_DISC_REQ;
ffffffffea80f484:	d28000bb 	mov	x27, #0x5                   	// #5
ffffffffea80f488:	f2c0009b 	movk	x27, #0x4, lsl #32
ffffffffea80f48c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f490:	97ffd89c 	bl	ffffffffea805700 <event_wait_timeout>
ffffffffea80f494:	14000005 	b	ffffffffea80f4a8 <tipc_tx_thread_func+0x78>
		} else if (chan_event & IPC_HANDLE_POLL_MSG) {
ffffffffea80f498:	37180620 	tbnz	w0, #3, ffffffffea80f55c <tipc_tx_thread_func+0x12c>
		} else if (chan_event & IPC_HANDLE_POLL_HUP) {
ffffffffea80f49c:	37100b60 	tbnz	w0, #2, ffffffffea80f608 <tipc_tx_thread_func+0x1d8>
		handle_decref(chan);
ffffffffea80f4a0:	aa1303e0 	mov	x0, x19
ffffffffea80f4a4:	97ffeab9 	bl	ffffffffea809f88 <handle_decref>
		ret = handle_list_wait(&dev->handle_list, &chan,
ffffffffea80f4a8:	12800003 	mov	w3, #0xffffffff            	// #-1
ffffffffea80f4ac:	9101d3a2 	add	x2, x29, #0x74
ffffffffea80f4b0:	9101e3a1 	add	x1, x29, #0x78
ffffffffea80f4b4:	aa1903e0 	mov	x0, x25
ffffffffea80f4b8:	97ffeb8a 	bl	ffffffffea80a2e0 <handle_list_wait>
		if (ret == ERR_NOT_FOUND) {
ffffffffea80f4bc:	3100081f 	cmn	w0, #0x2
ffffffffea80f4c0:	54000ea0 	b.eq	ffffffffea80f694 <tipc_tx_thread_func+0x264>  // b.none
		if (ret < 0) {
ffffffffea80f4c4:	37f813a0 	tbnz	w0, #31, ffffffffea80f738 <tipc_tx_thread_func+0x308>
		if (chan_event & IPC_HANDLE_POLL_READY) {
ffffffffea80f4c8:	b94077a0 	ldr	w0, [x29, #116]
ffffffffea80f4cc:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea80f4d0:	3607fe40 	tbz	w0, #0, ffffffffea80f498 <tipc_tx_thread_func+0x68>
	mutex_acquire(&dev->ept_lock);
ffffffffea80f4d4:	d2824105 	mov	x5, #0x1208                	// #4616
ffffffffea80f4d8:	8b050295 	add	x21, x20, x5
ffffffffea80f4dc:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f4e0:	aa1503e0 	mov	x0, x21
ffffffffea80f4e4:	97ffd901 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	return handle->cookie;
ffffffffea80f4e8:	f9401a73 	ldr	x19, [x19, #48]
	if (ept) {
ffffffffea80f4ec:	b4000793 	cbz	x19, ffffffffea80f5dc <tipc_tx_thread_func+0x1ac>
		remote = ept->remote;
ffffffffea80f4f0:	b9400276 	ldr	w22, [x19]
	mutex_release(&dev->ept_lock);
ffffffffea80f4f4:	aa1503e0 	mov	x0, x21
ffffffffea80f4f8:	97ffd928 	bl	ffffffffea805998 <mutex_release>
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f4fc:	910243b5 	add	x21, x29, #0x90
	return slot_to_addr(ept - dev->epts);
ffffffffea80f500:	9105a280 	add	x0, x20, #0x168
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f504:	d2800081 	mov	x1, #0x4                   	// #4
	return slot_to_addr(ept - dev->epts);
ffffffffea80f508:	cb000260 	sub	x0, x19, x0
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f50c:	f2c00281 	movk	x1, #0x14, lsl #32
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f510:	d2800385 	mov	x5, #0x1c                  	// #28
	return tipc_send_data(dev, local, remote,
ffffffffea80f514:	528006a2 	mov	w2, #0x35                  	// #53
	return slot_to_addr(ept - dev->epts);
ffffffffea80f518:	9344fc00 	asr	x0, x0, #4
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f51c:	a90817b5 	stp	x21, x5, [x29, #128]
	return (uint32_t) (slot + TIPC_ADDR_BASE);
ffffffffea80f520:	110fa000 	add	w0, w0, #0x3e8
	msg.body.remote = local;
ffffffffea80f524:	b900a3a0 	str	w0, [x29, #160]
	msg.body.max_msg_size = msg_sz;
ffffffffea80f528:	d2820000 	mov	x0, #0x1000                	// #4096
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f52c:	f9004ba1 	str	x1, [x29, #144]
	msg.body.max_msg_size = msg_sz;
ffffffffea80f530:	f2c00020 	movk	x0, #0x1, lsl #32
	return tipc_send_data(dev, local, remote,
ffffffffea80f534:	f0ffffe3 	adrp	x3, ffffffffea80e000 <map_descr+0x70>
ffffffffea80f538:	910203a4 	add	x4, x29, #0x80
	msg.body.status = status;
ffffffffea80f53c:	29137fb6 	stp	w22, wzr, [x29, #152]
	msg.body.max_msg_size = msg_sz;
ffffffffea80f540:	f80a43a0 	stur	x0, [x29, #164]
	return tipc_send_data(dev, local, remote,
ffffffffea80f544:	911fe063 	add	x3, x3, #0x7f8
ffffffffea80f548:	2a0203e1 	mov	w1, w2
ffffffffea80f54c:	aa1403e0 	mov	x0, x20
ffffffffea80f550:	97fffcee 	bl	ffffffffea80e908 <tipc_send_data.constprop.3>
ffffffffea80f554:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea80f558:	17ffffd2 	b	ffffffffea80f4a0 <tipc_tx_thread_func+0x70>
	mutex_acquire(&dev->ept_lock);
ffffffffea80f55c:	d2824104 	mov	x4, #0x1208                	// #4616
ffffffffea80f560:	8b040295 	add	x21, x20, x4
ffffffffea80f564:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f568:	aa1503e0 	mov	x0, x21
	data_cb_ctx_t cb_ctx = { .chan = chan };
ffffffffea80f56c:	a9097fb3 	stp	x19, xzr, [x29, #144]
ffffffffea80f570:	97ffd8de 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
ffffffffea80f574:	f9401a60 	ldr	x0, [x19, #48]
	if (!ept) {
ffffffffea80f578:	b4000320 	cbz	x0, ffffffffea80f5dc <tipc_tx_thread_func+0x1ac>
			TRACEF("tipc_send_data failed (%d)\n", ret);
ffffffffea80f57c:	9000005a 	adrp	x26, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
	remote = ept->remote;
ffffffffea80f580:	b9400017 	ldr	w23, [x0]
			TRACEF("tipc_send_data failed (%d)\n", ret);
ffffffffea80f584:	9110e35a 	add	x26, x26, #0x438
	mutex_release(&dev->ept_lock);
ffffffffea80f588:	aa1503e0 	mov	x0, x21
ffffffffea80f58c:	910243b5 	add	x21, x29, #0x90
ffffffffea80f590:	97ffd902 	bl	ffffffffea805998 <mutex_release>
		ret = ipc_get_msg(chan, &cb_ctx.msg_inf);
ffffffffea80f594:	910022b6 	add	x22, x21, #0x8
ffffffffea80f598:	1400000a 	b	ffffffffea80f5c0 <tipc_tx_thread_func+0x190>
		if (ret != NO_ERROR) {
ffffffffea80f59c:	35000c00 	cbnz	w0, ffffffffea80f71c <tipc_tx_thread_func+0x2ec>
		ret = tipc_send_data(dev, local, remote,
ffffffffea80f5a0:	794133a5 	ldrh	w5, [x29, #152]
ffffffffea80f5a4:	aa1503e4 	mov	x4, x21
ffffffffea80f5a8:	aa1803e3 	mov	x3, x24
ffffffffea80f5ac:	2a1703e2 	mov	w2, w23
ffffffffea80f5b0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80f5b4:	aa1403e0 	mov	x0, x20
ffffffffea80f5b8:	97fffcd4 	bl	ffffffffea80e908 <tipc_send_data.constprop.3>
		if (ret != NO_ERROR) {
ffffffffea80f5bc:	35000180 	cbnz	w0, ffffffffea80f5ec <tipc_tx_thread_func+0x1bc>
		ret = ipc_get_msg(chan, &cb_ctx.msg_inf);
ffffffffea80f5c0:	aa1603e1 	mov	x1, x22
ffffffffea80f5c4:	aa1303e0 	mov	x0, x19
ffffffffea80f5c8:	97fff56a 	bl	ffffffffea80cb70 <ipc_get_msg>
		if (ret == ERR_NO_MSG) {
ffffffffea80f5cc:	3100101f 	cmn	w0, #0x4
ffffffffea80f5d0:	54fffe61 	b.ne	ffffffffea80f59c <tipc_tx_thread_func+0x16c>  // b.any
ffffffffea80f5d4:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea80f5d8:	17ffffb2 	b	ffffffffea80f4a0 <tipc_tx_thread_func+0x70>
		mutex_release(&dev->ept_lock);
ffffffffea80f5dc:	aa1503e0 	mov	x0, x21
ffffffffea80f5e0:	97ffd8ee 	bl	ffffffffea805998 <mutex_release>
ffffffffea80f5e4:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea80f5e8:	17ffffae 	b	ffffffffea80f4a0 <tipc_tx_thread_func+0x70>
			TRACEF("tipc_send_data failed (%d)\n", ret);
ffffffffea80f5ec:	90000044 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80f5f0:	2a0003e3 	mov	w3, w0
ffffffffea80f5f4:	528051c2 	mov	w2, #0x28e                 	// #654
ffffffffea80f5f8:	aa1a03e1 	mov	x1, x26
ffffffffea80f5fc:	91158080 	add	x0, x4, #0x560
ffffffffea80f600:	94000e68 	bl	ffffffffea812fa0 <_printf>
ffffffffea80f604:	17ffffe4 	b	ffffffffea80f594 <tipc_tx_thread_func+0x164>
	mutex_acquire(&dev->ept_lock);
ffffffffea80f608:	d2824103 	mov	x3, #0x1208                	// #4616
ffffffffea80f60c:	8b030296 	add	x22, x20, x3
ffffffffea80f610:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f614:	aa1603e0 	mov	x0, x22
ffffffffea80f618:	97ffd8b4 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
ffffffffea80f61c:	f9401a62 	ldr	x2, [x19, #48]
	if (ept) {
ffffffffea80f620:	b4000502 	cbz	x2, ffffffffea80f6c0 <tipc_tx_thread_func+0x290>
		handle_list_del(&dev->handle_list, chan);
ffffffffea80f624:	aa1303e1 	mov	x1, x19
	return slot_to_addr(ept - dev->epts);
ffffffffea80f628:	9105a295 	add	x21, x20, #0x168
ffffffffea80f62c:	cb150055 	sub	x21, x2, x21
		handle_list_del(&dev->handle_list, chan);
ffffffffea80f630:	aa1903e0 	mov	x0, x25
		remote = ept->remote;
ffffffffea80f634:	b9400057 	ldr	w23, [x2]
		handle_list_del(&dev->handle_list, chan);
ffffffffea80f638:	97ffeb18 	bl	ffffffffea80a298 <handle_list_del>
	handle->cookie = cookie;
ffffffffea80f63c:	f9001a7f 	str	xzr, [x19, #48]
	return slot_to_addr(ept - dev->epts);
ffffffffea80f640:	9344feb5 	asr	x21, x21, #4
		handle_close(chan);
ffffffffea80f644:	aa1303e0 	mov	x0, x19
ffffffffea80f648:	97ffea78 	bl	ffffffffea80a028 <handle_close>
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80f64c:	7103febf 	cmp	w21, #0xff
ffffffffea80f650:	54000409 	b.ls	ffffffffea80f6d0 <tipc_tx_thread_func+0x2a0>  // b.plast
	mutex_release(&dev->ept_lock);
ffffffffea80f654:	aa1603e0 	mov	x0, x22
ffffffffea80f658:	97ffd8d0 	bl	ffffffffea805998 <mutex_release>
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f65c:	910203a0 	add	x0, x29, #0x80
ffffffffea80f660:	d2800185 	mov	x5, #0xc                   	// #12
	return tipc_send_data(dev, local, remote,
ffffffffea80f664:	f0ffffe3 	adrp	x3, ffffffffea80e000 <map_descr+0x70>
ffffffffea80f668:	910243a4 	add	x4, x29, #0x90
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f66c:	a90917a0 	stp	x0, x5, [x29, #144]
	return tipc_send_data(dev, local, remote,
ffffffffea80f670:	911fe063 	add	x3, x3, #0x7f8
ffffffffea80f674:	528006a2 	mov	w2, #0x35                  	// #53
ffffffffea80f678:	110fa2a1 	add	w1, w21, #0x3e8
	msg.hdr.type = TIPC_CTRL_MSGTYPE_DISC_REQ;
ffffffffea80f67c:	f90043bb 	str	x27, [x29, #128]
	return tipc_send_data(dev, local, remote,
ffffffffea80f680:	aa1403e0 	mov	x0, x20
	msg.body.target = remote;
ffffffffea80f684:	b9008bb7 	str	w23, [x29, #136]
	return tipc_send_data(dev, local, remote,
ffffffffea80f688:	97fffca0 	bl	ffffffffea80e908 <tipc_send_data.constprop.3>
ffffffffea80f68c:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea80f690:	17ffff84 	b	ffffffffea80f4a0 <tipc_tx_thread_func+0x70>
	while (!dev->tx_stop) {
ffffffffea80f694:	39494380 	ldrb	w0, [x28, #592]
ffffffffea80f698:	34ffef40 	cbz	w0, ffffffffea80f480 <tipc_tx_thread_func+0x50>
ffffffffea80f69c:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80f6a0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80f6a4:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80f6a8:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80f6ac:	f9402bbb 	ldr	x27, [x29, #80]
}
ffffffffea80f6b0:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea80f6b4:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80f6b8:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea80f6bc:	d65f03c0 	ret
	mutex_release(&dev->ept_lock);
ffffffffea80f6c0:	aa1603e0 	mov	x0, x22
ffffffffea80f6c4:	97ffd8b5 	bl	ffffffffea805998 <mutex_release>
ffffffffea80f6c8:	f9403fb3 	ldr	x19, [x29, #120]
ffffffffea80f6cc:	17ffff75 	b	ffffffffea80f4a0 <tipc_tx_thread_func+0x70>
ffffffffea80f6d0:	93437ea0 	sbfx	x0, x21, #3, #29
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f6d4:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea80f6d8:	927ee800 	and	x0, x0, #0x1ffffffffffffffc
ffffffffea80f6dc:	1ad52021 	lsl	w1, w1, w21
ffffffffea80f6e0:	8b000280 	add	x0, x20, x0
ffffffffea80f6e4:	d2822d02 	mov	x2, #0x1168                	// #4456
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80f6e8:	2a2103e1 	mvn	w1, w1
ffffffffea80f6ec:	8b020000 	add	x0, x0, x2
ffffffffea80f6f0:	885f7c02 	ldxr	w2, [x0]
ffffffffea80f6f4:	0a010042 	and	w2, w2, w1
ffffffffea80f6f8:	88037c02 	stxr	w3, w2, [x0]
ffffffffea80f6fc:	35ffffa3 	cbnz	w3, ffffffffea80f6f0 <tipc_tx_thread_func+0x2c0>
ffffffffea80f700:	d37c7ea1 	ubfiz	x1, x21, #4, #32
ffffffffea80f704:	aa1603e0 	mov	x0, x22
ffffffffea80f708:	8b010281 	add	x1, x20, x1
		dev->epts[slot].remote = 0;
ffffffffea80f70c:	b901683f 	str	wzr, [x1, #360]
		dev->epts[slot].chan = NULL;
ffffffffea80f710:	f900b83f 	str	xzr, [x1, #368]
	mutex_release(&dev->ept_lock);
ffffffffea80f714:	97ffd8a1 	bl	ffffffffea805998 <mutex_release>
ffffffffea80f718:	17ffffd1 	b	ffffffffea80f65c <tipc_tx_thread_func+0x22c>
			panic ("%s: failed (%d) to get message\n",
ffffffffea80f71c:	2a0003e3 	mov	w3, w0
ffffffffea80f720:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80f724:	90000042 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80f728:	90000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80f72c:	91112042 	add	x2, x2, #0x448
ffffffffea80f730:	91150021 	add	x1, x1, #0x540
ffffffffea80f734:	940008b5 	bl	ffffffffea811a08 <_panic>
			panic("%s: couldn't wait for handle events (%d)\n",
ffffffffea80f738:	2a0003e3 	mov	w3, w0
ffffffffea80f73c:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80f740:	90000042 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80f744:	90000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80f748:	91116042 	add	x2, x2, #0x458
ffffffffea80f74c:	91144021 	add	x1, x1, #0x510
ffffffffea80f750:	940008ae 	bl	ffffffffea811a08 <_panic>
ffffffffea80f754:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80f758 <create_tipc_device>:
};

status_t create_tipc_device(const struct tipc_vdev_descr *descr, size_t size,
                            const uuid_t *uuid, uint32_t guest,
                            struct tipc_dev **dev_ptr)
{
ffffffffea80f758:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80f75c:	910003fd 	mov	x29, sp
ffffffffea80f760:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea80f764:	2a0303f4 	mov	w20, w3
ffffffffea80f768:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea80f76c:	aa0403f5 	mov	x21, x4
ffffffffea80f770:	f9001ff8 	str	x24, [sp, #56]
ffffffffea80f774:	aa0003f7 	mov	x23, x0
ffffffffea80f778:	aa0103f6 	mov	x22, x1

	DEBUG_ASSERT(uuid);
	DEBUG_ASSERT(descr);
	DEBUG_ASSERT(size);

	dev = calloc(1, sizeof(*dev));
ffffffffea80f77c:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80f780:	d2824b01 	mov	x1, #0x1258                	// #4696
{
ffffffffea80f784:	aa0203f8 	mov	x24, x2
	dev = calloc(1, sizeof(*dev));
ffffffffea80f788:	94000e34 	bl	ffffffffea813058 <calloc>
	if (!dev) {
ffffffffea80f78c:	b4000640 	cbz	x0, ffffffffea80f854 <create_tipc_device+0xfc>
ffffffffea80f790:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80f794:	aa0003f3 	mov	x19, x0
		return ERR_NO_MEMORY;
	}
	mutex_init(&dev->ept_lock);
ffffffffea80f798:	d2824100 	mov	x0, #0x1208                	// #4616
ffffffffea80f79c:	8b000260 	add	x0, x19, x0
ffffffffea80f7a0:	97ffd846 	bl	ffffffffea8058b8 <mutex_init>
	dev->vd.ops = &_tipc_dev_ops;
	dev->uuid = uuid;
	dev->guest = guest;
	dev->descr_ptr = descr;
	dev->descr_size = size;
	handle_list_init(&dev->handle_list);
ffffffffea80f7a4:	d2823701 	mov	x1, #0x11b8                	// #4536
ffffffffea80f7a8:	8b010260 	add	x0, x19, x1
	dev->vd.ops = &_tipc_dev_ops;
ffffffffea80f7ac:	90000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80f7b0:	9111a021 	add	x1, x1, #0x468
ffffffffea80f7b4:	f9001261 	str	x1, [x19, #32]
	dev->guest = guest;
ffffffffea80f7b8:	b9002a74 	str	w20, [x19, #40]
	dev->descr_ptr = descr;
ffffffffea80f7bc:	a9035e78 	stp	x24, x23, [x19, #48]
	dev->descr_size = size;
ffffffffea80f7c0:	f9002276 	str	x22, [x19, #64]
	handle_list_init(&dev->handle_list);
ffffffffea80f7c4:	97ffea7d 	bl	ffffffffea80a1b8 <handle_list_init>
	event_init(&dev->have_handles, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea80f7c8:	d2823103 	mov	x3, #0x1188                	// #4488
ffffffffea80f7cc:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80f7d0:	8b030260 	add	x0, x19, x3
ffffffffea80f7d4:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80f7d8:	97ffd794 	bl	ffffffffea805628 <event_init>

	ret = virtio_register_device(&dev->vd, guest);
ffffffffea80f7dc:	2a1403e1 	mov	w1, w20
ffffffffea80f7e0:	aa1303e0 	mov	x0, x19
ffffffffea80f7e4:	97fffa59 	bl	ffffffffea80e148 <virtio_register_device>
ffffffffea80f7e8:	2a0003f4 	mov	w20, w0
	if (ret != NO_ERROR) {
ffffffffea80f7ec:	35000140 	cbnz	w0, ffffffffea80f814 <create_tipc_device+0xbc>
		goto err_register;
	}
	if (dev_ptr) {
ffffffffea80f7f0:	b4000255 	cbz	x21, ffffffffea80f838 <create_tipc_device+0xe0>
		*dev_ptr = dev;
ffffffffea80f7f4:	f90002b3 	str	x19, [x21]
ffffffffea80f7f8:	f9400bb3 	ldr	x19, [x29, #16]
	return NO_ERROR;

err_register:
	free(dev);
	return ret;
}
ffffffffea80f7fc:	2a1403e0 	mov	w0, w20
ffffffffea80f800:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea80f804:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80f808:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80f80c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80f810:	d65f03c0 	ret
	free(dev);
ffffffffea80f814:	aa1303e0 	mov	x0, x19
ffffffffea80f818:	94000e20 	bl	ffffffffea813098 <free>
}
ffffffffea80f81c:	2a1403e0 	mov	w0, w20
	return ret;
ffffffffea80f820:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea80f824:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80f828:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80f82c:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea80f830:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80f834:	d65f03c0 	ret
ffffffffea80f838:	2a1403e0 	mov	w0, w20
ffffffffea80f83c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80f840:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80f844:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80f848:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea80f84c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80f850:	d65f03c0 	ret
		return ERR_NO_MEMORY;
ffffffffea80f854:	12800094 	mov	w20, #0xfffffffb            	// #-5
ffffffffea80f858:	17ffffe9 	b	ffffffffea80f7fc <create_tipc_device+0xa4>
ffffffffea80f85c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80f860 <dev_connect>:
	return err;
}

static int dev_connect(struct ql_tipc_dev *dev, void *ns_payload,
                       size_t ns_payload_len)
{
ffffffffea80f860:	a9ab7bfd 	stp	x29, x30, [sp, #-336]!
	struct {
		struct tipc_connect_req hdr;
		uint8_t body[TIPC_MAX_SRV_NAME_LEN + 1];
	} req;

	if (ns_payload_len <= sizeof(req.hdr))
ffffffffea80f864:	f100405f 	cmp	x2, #0x10
{
ffffffffea80f868:	910003fd 	mov	x29, sp
ffffffffea80f86c:	a901d7f4 	stp	x20, x21, [sp, #24]
	struct tipc_cmd_hdr *ns_hdr = dev->ns_va;
ffffffffea80f870:	f9403815 	ldr	x21, [x0, #112]
	handle_t *chan = NULL;
ffffffffea80f874:	f9001bbf 	str	xzr, [x29, #48]
	if (ns_payload_len <= sizeof(req.hdr))
ffffffffea80f878:	54000b89 	b.ls	ffffffffea80f9e8 <dev_connect+0x188>  // b.plast
		return set_status(dev, opcode, ERR_INVALID_ARGS, 0);

	if (ns_payload_len >= sizeof(req))
ffffffffea80f87c:	f1045c5f 	cmp	x2, #0x117
ffffffffea80f880:	54000b48 	b.hi	ffffffffea80f9e8 <dev_connect+0x188>  // b.pmore
ffffffffea80f884:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80f888:	aa0003f3 	mov	x19, x0
		return set_status(dev, opcode, ERR_INVALID_ARGS, 0);

	/* copy out and zero terminate */
	memcpy(&req, ns_payload, ns_payload_len);
	req.body[ns_payload_len - sizeof(req.hdr)] = 0;
ffffffffea80f88c:	d1004054 	sub	x20, x2, #0x10
	memcpy(&req, ns_payload, ns_payload_len);
ffffffffea80f890:	9100e3a0 	add	x0, x29, #0x38
ffffffffea80f894:	94000e03 	bl	ffffffffea8130a0 <memcpy>

	/* open ipc channel */
	rc = ipc_port_connect_async(dev->guest, dev->uuid, (const char *)req.body,
ffffffffea80f898:	b9407a60 	ldr	w0, [x19, #120]
	req.body[ns_payload_len - sizeof(req.hdr)] = 0;
ffffffffea80f89c:	910123a7 	add	x7, x29, #0x48
	rc = ipc_port_connect_async(dev->guest, dev->uuid, (const char *)req.body,
ffffffffea80f8a0:	f9404261 	ldr	x1, [x19, #128]
ffffffffea80f8a4:	aa1403e3 	mov	x3, x20
ffffffffea80f8a8:	9100c3a5 	add	x5, x29, #0x30
ffffffffea80f8ac:	52800004 	mov	w4, #0x0                   	// #0
	req.body[ns_payload_len - sizeof(req.hdr)] = 0;
ffffffffea80f8b0:	383468ff 	strb	wzr, [x7, x20]
	rc = ipc_port_connect_async(dev->guest, dev->uuid, (const char *)req.body,
ffffffffea80f8b4:	aa0703e2 	mov	x2, x7
ffffffffea80f8b8:	97fff118 	bl	ffffffffea80bd18 <ipc_port_connect_async>
ffffffffea80f8bc:	2a0003f4 	mov	w20, w0
				    ns_payload_len - sizeof(req.hdr), 0, &chan);
	if (rc != NO_ERROR) {
ffffffffea80f8c0:	340001a0 	cbz	w0, ffffffffea80f8f4 <dev_connect+0x94>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80f8c4:	531f7c01 	lsr	w1, w0, #31
		LTRACEF("failed to open ipc channel: %d\n", rc);
		return set_status(dev, opcode, rc, 0);
ffffffffea80f8c8:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80f8cc:	128fffc2 	mov	w2, #0xffff8001            	// #-32767
ffffffffea80f8d0:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80f8d4:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea80f8d8:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea80f8dc:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, rc, 0);
ffffffffea80f8e0:	f9400bb3 	ldr	x19, [x29, #16]
	handle_set_cookie(chan, ept_lookup(dev, local));
	handle_list_add(&dev->handle_list, chan);
	ns_hdr->handle = local;

	return set_status(dev, opcode, 0, 0);
}
ffffffffea80f8e4:	2a1403e0 	mov	w0, w20
ffffffffea80f8e8:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80f8ec:	a8d57bfd 	ldp	x29, x30, [sp], #336
ffffffffea80f8f0:	d65f03c0 	ret
		if (bitmap[i] == ~0UL)
ffffffffea80f8f4:	f9404661 	ldr	x1, [x19, #136]
	int slot = bitmap_ffz(dev->inuse, QL_TIPC_ADDR_MAX_NUM);
ffffffffea80f8f8:	91022263 	add	x3, x19, #0x88
	local = alloc_local_addr(dev, chan, req.hdr.cookie);
ffffffffea80f8fc:	a9431ba0 	ldp	x0, x6, [x29, #48]
ffffffffea80f900:	b100043f 	cmn	x1, #0x1
ffffffffea80f904:	540005a0 	b.eq	ffffffffea80f9b8 <dev_connect+0x158>  // b.none
	return __builtin_ffsl(~x) - 1;
ffffffffea80f908:	aa2103e2 	mvn	x2, x1
ffffffffea80f90c:	f90017b6 	str	x22, [x29, #40]
ffffffffea80f910:	dac00041 	rbit	x1, x2
ffffffffea80f914:	f100005f 	cmp	x2, #0x0
ffffffffea80f918:	dac01021 	clz	x1, x1
ffffffffea80f91c:	9a8107e1 	csinc	x1, xzr, x1, eq  // eq = none
ffffffffea80f920:	51000424 	sub	w4, w1, #0x1
		if (bit < numbits)
ffffffffea80f924:	71007c9f 	cmp	w4, #0x1f
ffffffffea80f928:	5400046c 	b.gt	ffffffffea80f9b4 <dev_connect+0x154>
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f92c:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80f930:	1ac42042 	lsl	w2, w2, w4
    return __atomic_fetch_or(ptr, val, __ATOMIC_RELAXED);
ffffffffea80f934:	885f7c65 	ldxr	w5, [x3]
ffffffffea80f938:	2a0200a5 	orr	w5, w5, w2
ffffffffea80f93c:	88077c65 	stxr	w7, w5, [x3]
ffffffffea80f940:	35ffffa7 	cbnz	w7, ffffffffea80f934 <dev_connect+0xd4>
ffffffffea80f944:	8b21d263 	add	x3, x19, w1, sxtw #4
	return NULL;
ffffffffea80f948:	d37c7c82 	ubfiz	x2, x4, #4, #32
	handle_set_cookie(chan, ept_lookup(dev, local));
ffffffffea80f94c:	f9401ba5 	ldr	x5, [x29, #48]
	return NULL;
ffffffffea80f950:	91024042 	add	x2, x2, #0x90
ffffffffea80f954:	8b020262 	add	x2, x19, x2
	return (uint32_t) (slot + QL_TIPC_ADDR_BASE);
ffffffffea80f958:	11007c36 	add	w22, w1, #0x1f
		dev->epts[slot].cookie = cookie;
ffffffffea80f95c:	a9081860 	stp	x0, x6, [x3, #128]
	handle_list_add(&dev->handle_list, chan);
ffffffffea80f960:	aa0503e1 	mov	x1, x5
ffffffffea80f964:	91004260 	add	x0, x19, #0x10
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80f968:	f9404663 	ldr	x3, [x19, #136]
ffffffffea80f96c:	9ac42463 	lsr	x3, x3, x4
	return NULL;
ffffffffea80f970:	f240007f 	tst	x3, #0x1
ffffffffea80f974:	9a9f1042 	csel	x2, x2, xzr, ne  // ne = any
ffffffffea80f978:	f90018a2 	str	x2, [x5, #48]
	handle_list_add(&dev->handle_list, chan);
ffffffffea80f97c:	97ffea1d 	bl	ffffffffea80a1f0 <handle_list_add>
	return set_status(dev, opcode, 0, 0);
ffffffffea80f980:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80f984:	128fffc1 	mov	w1, #0xffff8001            	// #-32767
	ns_hdr->handle = local;
ffffffffea80f988:	b9000ab6 	str	w22, [x21, #8]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80f98c:	79000001 	strh	w1, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80f990:	b900041f 	str	wzr, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea80f994:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea80f998:	d5033abf 	dmb	ishst
ffffffffea80f99c:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea80f9a0:	2a1403e0 	mov	w0, w20
	smp_wmb();
ffffffffea80f9a4:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea80f9a8:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80f9ac:	a8d57bfd 	ldp	x29, x30, [sp], #336
ffffffffea80f9b0:	d65f03c0 	ret
ffffffffea80f9b4:	f94017b6 	ldr	x22, [x29, #40]
		handle_close(chan);
ffffffffea80f9b8:	97ffe99c 	bl	ffffffffea80a028 <handle_close>
		chan = NULL;
ffffffffea80f9bc:	f9001bbf 	str	xzr, [x29, #48]
		return set_status(dev, opcode, ERR_NO_RESOURCES, 0);
ffffffffea80f9c0:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80f9c4:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80f9c8:	128fffc2 	mov	w2, #0xffff8001            	// #-32767
ffffffffea80f9cc:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80f9d0:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea80f9d4:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea80f9d8:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, ERR_NO_RESOURCES, 0);
ffffffffea80f9dc:	12800514 	mov	w20, #0xffffffd7            	// #-41
ffffffffea80f9e0:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80f9e4:	17ffffc0 	b	ffffffffea80f8e4 <dev_connect+0x84>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80f9e8:	52800020 	mov	w0, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80f9ec:	128fffc1 	mov	w1, #0xffff8001            	// #-32767
ffffffffea80f9f0:	790002a1 	strh	w1, [x21]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80f9f4:	b90006a0 	str	w0, [x21, #4]
	ns_hdr->payload_len = len;
ffffffffea80f9f8:	b9000ebf 	str	wzr, [x21, #12]
	smp_wmb();
ffffffffea80f9fc:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, ERR_INVALID_ARGS, 0);
ffffffffea80fa00:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80fa04:	17ffffb8 	b	ffffffffea80f8e4 <dev_connect+0x84>

ffffffffea80fa08 <ql_tipc_create_device>:
	}
}

long ql_tipc_create_device(ns_addr_t buf_pa, ns_size_t buf_sz,
                           uint buf_mmu_flags)
{
ffffffffea80fa08:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80fa0c:	910003fd 	mov	x29, sp
ffffffffea80fa10:	f90017f6 	str	x22, [sp, #40]
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80fa14:	b0000056 	adrp	x22, ffffffffea818000 <_mem_phys_base>
ffffffffea80fa18:	913a42c5 	add	x5, x22, #0xe90
ffffffffea80fa1c:	f94004a3 	ldr	x3, [x5, #8]
ffffffffea80fa20:	eb05007f 	cmp	x3, x5
ffffffffea80fa24:	540000a1 	b.ne	ffffffffea80fa38 <ql_tipc_create_device+0x30>  // b.any
ffffffffea80fa28:	1400000b 	b	ffffffffea80fa54 <ql_tipc_create_device+0x4c>
ffffffffea80fa2c:	f9400463 	ldr	x3, [x3, #8]
ffffffffea80fa30:	eb05007f 	cmp	x3, x5
ffffffffea80fa34:	54000100 	b.eq	ffffffffea80fa54 <ql_tipc_create_device+0x4c>  // b.none
		if(dev->ns_pa == buf_pa) {
ffffffffea80fa38:	f9403464 	ldr	x4, [x3, #104]
ffffffffea80fa3c:	eb04001f 	cmp	x0, x4
ffffffffea80fa40:	54ffff61 	b.ne	ffffffffea80fa2c <ql_tipc_create_device+0x24>  // b.any
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80fa44:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
	return dev_create(buf_pa, buf_sz, buf_mmu_flags);
}
ffffffffea80fa48:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80fa4c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80fa50:	d65f03c0 	ret
	if (!buf_sz) {
ffffffffea80fa54:	f2402c1f 	tst	x0, #0xfff
ffffffffea80fa58:	7a400824 	ccmp	w1, #0x0, #0x4, eq  // eq = none
ffffffffea80fa5c:	54ffff40 	b.eq	ffffffffea80fa44 <ql_tipc_create_device+0x3c>  // b.none
ffffffffea80fa60:	f90023b9 	str	x25, [x29, #64]
	if (buf_sz & (PAGE_SIZE-1)) {
ffffffffea80fa64:	f2402c3f 	tst	x1, #0xfff
ffffffffea80fa68:	2a0103f9 	mov	w25, w1
ffffffffea80fa6c:	54000841 	b.ne	ffffffffea80fb74 <ql_tipc_create_device+0x16c>  // b.any
ffffffffea80fa70:	f9001fb8 	str	x24, [x29, #56]
	if (_dev_cnt >= QL_TIPC_DEV_MAX_NUM) {
ffffffffea80fa74:	b0000278 	adrp	x24, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea80fa78:	b94f3f03 	ldr	w3, [x24, #3900]
ffffffffea80fa7c:	7100047f 	cmp	w3, #0x1
ffffffffea80fa80:	54000648 	b.hi	ffffffffea80fb48 <ql_tipc_create_device+0x140>  // b.pmore
ffffffffea80fa84:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80fa88:	aa0003f3 	mov	x19, x0
ffffffffea80fa8c:	f90013b5 	str	x21, [x29, #32]
	dev = calloc(1, sizeof(*dev));
ffffffffea80fa90:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80fa94:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80fa98:	2a0103f5 	mov	w21, w1
ffffffffea80fa9c:	2a0203f7 	mov	w23, w2
ffffffffea80faa0:	d2805201 	mov	x1, #0x290                 	// #656
ffffffffea80faa4:	94000d6d 	bl	ffffffffea813058 <calloc>
ffffffffea80faa8:	aa0003f4 	mov	x20, x0
	if (!dev) {
ffffffffea80faac:	b4000580 	cbz	x0, ffffffffea80fb5c <ql_tipc_create_device+0x154>
	item->prev = item->next = 0;
ffffffffea80fab0:	f900041f 	str	xzr, [x0, #8]
	dev->uuid = &zero_uuid;
ffffffffea80fab4:	90000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
	dev->guest = 0;
ffffffffea80fab8:	b900781f 	str	wzr, [x0, #120]
	dev->uuid = &zero_uuid;
ffffffffea80fabc:	91032021 	add	x1, x1, #0xc8
ffffffffea80fac0:	f9004001 	str	x1, [x0, #128]
ffffffffea80fac4:	f801041f 	str	xzr, [x0], #16
	handle_list_init(&dev->handle_list);
ffffffffea80fac8:	97ffe9bc 	bl	ffffffffea80a1b8 <handle_list_init>
	dev->ns_sz = buf_sz;
ffffffffea80facc:	290c5697 	stp	w23, w21, [x20, #96]
	                         ROUNDUP(buf_sz, PAGE_SIZE),
ffffffffea80fad0:	913fff22 	add	x2, x25, #0xfff
	res = vmm_alloc_physical(vmm_get_kernel_aspace(), "tipc",
ffffffffea80fad4:	90000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea80fad8:	d0000260 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
ffffffffea80fadc:	2a1703e7 	mov	w7, w23
ffffffffea80fae0:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80fae4:	aa1303e5 	mov	x5, x19
ffffffffea80fae8:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea80faec:	9101c283 	add	x3, x20, #0x70
ffffffffea80faf0:	92745042 	and	x2, x2, #0x1fffff000
ffffffffea80faf4:	91182021 	add	x1, x1, #0x608
ffffffffea80faf8:	91034000 	add	x0, x0, #0xd0
	dev->ns_pa = buf_pa;
ffffffffea80fafc:	f9003693 	str	x19, [x20, #104]
	res = vmm_alloc_physical(vmm_get_kernel_aspace(), "tipc",
ffffffffea80fb00:	94000582 	bl	ffffffffea811108 <vmm_alloc_physical>
	if (res != NO_ERROR) {
ffffffffea80fb04:	35000280 	cbnz	w0, ffffffffea80fb54 <ql_tipc_create_device+0x14c>
	item->next = list->next;
ffffffffea80fb08:	913a42d6 	add	x22, x22, #0xe90
	_dev_cnt++;
ffffffffea80fb0c:	b94f3f01 	ldr	w1, [x24, #3900]
ffffffffea80fb10:	f94013b5 	ldr	x21, [x29, #32]
	return 0;
ffffffffea80fb14:	d2800000 	mov	x0, #0x0                   	// #0
	_dev_cnt++;
ffffffffea80fb18:	11000421 	add	w1, w1, #0x1
ffffffffea80fb1c:	b90f3f01 	str	w1, [x24, #3900]
ffffffffea80fb20:	f94006c1 	ldr	x1, [x22, #8]
ffffffffea80fb24:	a9000696 	stp	x22, x1, [x20]
ffffffffea80fb28:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80fb2c:	f94023b9 	ldr	x25, [x29, #64]
	list->next->prev = item;
ffffffffea80fb30:	f9000034 	str	x20, [x1]
	list->next = item;
ffffffffea80fb34:	f90006d4 	str	x20, [x22, #8]
ffffffffea80fb38:	a94153b3 	ldp	x19, x20, [x29, #16]
}
ffffffffea80fb3c:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80fb40:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80fb44:	d65f03c0 	ret
		return SM_ERR_NOT_ALLOWED;
ffffffffea80fb48:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
ffffffffea80fb4c:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80fb50:	17ffffbe 	b	ffffffffea80fa48 <ql_tipc_create_device+0x40>
		free(dev);
ffffffffea80fb54:	aa1403e0 	mov	x0, x20
ffffffffea80fb58:	94000d50 	bl	ffffffffea813098 <free>
		return SM_ERR_INTERNAL_FAILURE;
ffffffffea80fb5c:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea80fb60:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80fb64:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80fb68:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80fb6c:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80fb70:	17ffffb6 	b	ffffffffea80fa48 <ql_tipc_create_device+0x40>
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80fb74:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80fb78:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80fb7c:	17ffffb3 	b	ffffffffea80fa48 <ql_tipc_create_device+0x40>

ffffffffea80fb80 <ql_tipc_shutdown_device>:

long ql_tipc_shutdown_device(ns_addr_t buf_pa)
{
ffffffffea80fb80:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80fb84:	b0000041 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea80fb88:	913a4021 	add	x1, x1, #0xe90
{
ffffffffea80fb8c:	910003fd 	mov	x29, sp
ffffffffea80fb90:	f90013f5 	str	x21, [sp, #32]
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80fb94:	f9400435 	ldr	x21, [x1, #8]
ffffffffea80fb98:	eb0102bf 	cmp	x21, x1
ffffffffea80fb9c:	540007a0 	b.eq	ffffffffea80fc90 <ql_tipc_shutdown_device+0x110>  // b.none
		if(dev->ns_pa == buf_pa) {
ffffffffea80fba0:	f94036a2 	ldr	x2, [x21, #104]
ffffffffea80fba4:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80fba8:	f90017b6 	str	x22, [x29, #40]
ffffffffea80fbac:	eb02001f 	cmp	x0, x2
ffffffffea80fbb0:	540000a1 	b.ne	ffffffffea80fbc4 <ql_tipc_shutdown_device+0x44>  // b.any
ffffffffea80fbb4:	1400000d 	b	ffffffffea80fbe8 <ql_tipc_shutdown_device+0x68>
ffffffffea80fbb8:	f94036a2 	ldr	x2, [x21, #104]
ffffffffea80fbbc:	eb02001f 	cmp	x0, x2
ffffffffea80fbc0:	54000140 	b.eq	ffffffffea80fbe8 <ql_tipc_shutdown_device+0x68>  // b.none
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80fbc4:	f94006b5 	ldr	x21, [x21, #8]
ffffffffea80fbc8:	eb0102bf 	cmp	x21, x1
ffffffffea80fbcc:	54ffff61 	b.ne	ffffffffea80fbb8 <ql_tipc_shutdown_device+0x38>  // b.any
	struct ql_tipc_dev *dev = dev_lookup(buf_pa);
	if (!dev) {
		LTRACEF("0x%llx: device not found\n", buf_pa);
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80fbd0:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80fbd4:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80fbd8:	a94153b3 	ldp	x19, x20, [x29, #16]
	}
	dev_shutdown(dev);
	return 0;
}
ffffffffea80fbdc:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80fbe0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80fbe4:	d65f03c0 	ret
	item->next->prev = item->prev;
ffffffffea80fbe8:	a9400ea2 	ldp	x2, x3, [x21]
	_dev_cnt--;
ffffffffea80fbec:	b0000264 	adrp	x4, ffffffffea85c000 <idle_threads+0xeb0>
	vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)dev->ns_va);
ffffffffea80fbf0:	f9403aa1 	ldr	x1, [x21, #112]
ffffffffea80fbf4:	910242b4 	add	x20, x21, #0x90
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80fbf8:	910042b6 	add	x22, x21, #0x10
	vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)dev->ns_va);
ffffffffea80fbfc:	d0000260 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
ffffffffea80fc00:	f9000062 	str	x2, [x3]
ffffffffea80fc04:	91034000 	add	x0, x0, #0xd0
	_dev_cnt--;
ffffffffea80fc08:	b94f3c82 	ldr	w2, [x4, #3900]
	for (uint slot = 0; slot < countof(dev->epts); slot++) {
ffffffffea80fc0c:	52800013 	mov	w19, #0x0                   	// #0
	item->prev->next = item->next;
ffffffffea80fc10:	f94002a5 	ldr	x5, [x21]
	_dev_cnt--;
ffffffffea80fc14:	51000442 	sub	w2, w2, #0x1
ffffffffea80fc18:	b90f3c82 	str	w2, [x4, #3900]
ffffffffea80fc1c:	f90004a3 	str	x3, [x5, #8]
	item->prev = item->next = 0;
ffffffffea80fc20:	a9007ebf 	stp	xzr, xzr, [x21]
	vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)dev->ns_va);
ffffffffea80fc24:	9400059b 	bl	ffffffffea811290 <vmm_free_region>
	dev->ns_va = NULL;
ffffffffea80fc28:	f9003abf 	str	xzr, [x21, #112]
ffffffffea80fc2c:	d503201f 	nop
ffffffffea80fc30:	f94046a1 	ldr	x1, [x21, #136]
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80fc34:	aa1603e0 	mov	x0, x22
ffffffffea80fc38:	9ad32421 	lsr	x1, x1, x19
	for (uint slot = 0; slot < countof(dev->epts); slot++) {
ffffffffea80fc3c:	11000673 	add	w19, w19, #0x1
		if (!bitmap_test(dev->inuse, slot))
ffffffffea80fc40:	36000121 	tbz	w1, #0, ffffffffea80fc64 <ql_tipc_shutdown_device+0xe4>
		if (!ept->chan)
ffffffffea80fc44:	f9400282 	ldr	x2, [x20]
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80fc48:	aa0203e1 	mov	x1, x2
		if (!ept->chan)
ffffffffea80fc4c:	b40000c2 	cbz	x2, ffffffffea80fc64 <ql_tipc_shutdown_device+0xe4>
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80fc50:	97ffe992 	bl	ffffffffea80a298 <handle_list_del>
		handle_set_cookie(ept->chan, NULL);
ffffffffea80fc54:	f9400281 	ldr	x1, [x20]
		handle_close(ept->chan);
ffffffffea80fc58:	aa0103e0 	mov	x0, x1
ffffffffea80fc5c:	f900183f 	str	xzr, [x1, #48]
ffffffffea80fc60:	97ffe8f2 	bl	ffffffffea80a028 <handle_close>
ffffffffea80fc64:	91004294 	add	x20, x20, #0x10
	for (uint slot = 0; slot < countof(dev->epts); slot++) {
ffffffffea80fc68:	7100827f 	cmp	w19, #0x20
ffffffffea80fc6c:	54fffe21 	b.ne	ffffffffea80fc30 <ql_tipc_shutdown_device+0xb0>  // b.any
	free(dev);
ffffffffea80fc70:	aa1503e0 	mov	x0, x21
ffffffffea80fc74:	94000d09 	bl	ffffffffea813098 <free>
ffffffffea80fc78:	a94153b3 	ldp	x19, x20, [x29, #16]
	return 0;
ffffffffea80fc7c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80fc80:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea80fc84:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80fc88:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80fc8c:	d65f03c0 	ret
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80fc90:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80fc94:	17fffffc 	b	ffffffffea80fc84 <ql_tipc_shutdown_device+0x104>

ffffffffea80fc98 <ql_tipc_handle_cmd>:

long ql_tipc_handle_cmd(ns_addr_t buf_pa, ns_size_t cmd_sz)
{
ffffffffea80fc98:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80fc9c:	b0000042 	adrp	x2, ffffffffea818000 <_mem_phys_base>
ffffffffea80fca0:	913a4042 	add	x2, x2, #0xe90
{
ffffffffea80fca4:	910003fd 	mov	x29, sp
ffffffffea80fca8:	f9000bf3 	str	x19, [sp, #16]
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80fcac:	f9400453 	ldr	x19, [x2, #8]
ffffffffea80fcb0:	eb02027f 	cmp	x19, x2
ffffffffea80fcb4:	540001a0 	b.eq	ffffffffea80fce8 <ql_tipc_handle_cmd+0x50>  // b.none
		if(dev->ns_pa == buf_pa) {
ffffffffea80fcb8:	f9403663 	ldr	x3, [x19, #104]
ffffffffea80fcbc:	a901d7b4 	stp	x20, x21, [x29, #24]
ffffffffea80fcc0:	eb03001f 	cmp	x0, x3
ffffffffea80fcc4:	540000a1 	b.ne	ffffffffea80fcd8 <ql_tipc_handle_cmd+0x40>  // b.any
ffffffffea80fcc8:	1400000c 	b	ffffffffea80fcf8 <ql_tipc_handle_cmd+0x60>
ffffffffea80fccc:	f9403663 	ldr	x3, [x19, #104]
ffffffffea80fcd0:	eb03001f 	cmp	x0, x3
ffffffffea80fcd4:	54000120 	b.eq	ffffffffea80fcf8 <ql_tipc_handle_cmd+0x60>  // b.none
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea80fcd8:	f9400673 	ldr	x19, [x19, #8]
ffffffffea80fcdc:	eb02027f 	cmp	x19, x2
ffffffffea80fce0:	54ffff61 	b.ne	ffffffffea80fccc <ql_tipc_handle_cmd+0x34>  // b.any
ffffffffea80fce4:	a941d7b4 	ldp	x20, x21, [x29, #24]

	/* lookup device */
	struct ql_tipc_dev *dev = dev_lookup(buf_pa);
	if (!dev) {
		LTRACEF("0x%llx: device not found\n", buf_pa);
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80fce8:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
		LTRACEF("malformed command\n");
		return SM_ERR_INVALID_PARAMETERS;
	}

	return dev_handle_cmd(dev, &cmd_hdr, dev->ns_va + sizeof(cmd_hdr));
}
ffffffffea80fcec:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80fcf0:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80fcf4:	d65f03c0 	ret
	if (cmd_sz < sizeof(cmd_hdr)) {
ffffffffea80fcf8:	71003c3f 	cmp	w1, #0xf
ffffffffea80fcfc:	54ffff49 	b.ls	ffffffffea80fce4 <ql_tipc_handle_cmd+0x4c>  // b.plast
ffffffffea80fd00:	2a0103f4 	mov	w20, w1
	memcpy(&cmd_hdr, dev->ns_va, sizeof(cmd_hdr));
ffffffffea80fd04:	f9403a61 	ldr	x1, [x19, #112]
ffffffffea80fd08:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80fd0c:	aa1e03f5 	mov	x21, x30
ffffffffea80fd10:	910103a0 	add	x0, x29, #0x40
ffffffffea80fd14:	94000ce3 	bl	ffffffffea8130a0 <memcpy>
	if (cmd_hdr.payload_len != (cmd_sz - sizeof(cmd_hdr))) {
ffffffffea80fd18:	b9404fa3 	ldr	w3, [x29, #76]
ffffffffea80fd1c:	2a1403e1 	mov	w1, w20
ffffffffea80fd20:	d1004021 	sub	x1, x1, #0x10
ffffffffea80fd24:	2a0303e2 	mov	w2, w3
ffffffffea80fd28:	eb01005f 	cmp	x2, x1
ffffffffea80fd2c:	54fffdc1 	b.ne	ffffffffea80fce4 <ql_tipc_handle_cmd+0x4c>  // b.any
	switch (cmd->opcode) {
ffffffffea80fd30:	794083a0 	ldrh	w0, [x29, #64]
	return dev_handle_cmd(dev, &cmd_hdr, dev->ns_va + sizeof(cmd_hdr));
ffffffffea80fd34:	f9403a74 	ldr	x20, [x19, #112]
	switch (cmd->opcode) {
ffffffffea80fd38:	71000c1f 	cmp	w0, #0x3
	return dev_handle_cmd(dev, &cmd_hdr, dev->ns_va + sizeof(cmd_hdr));
ffffffffea80fd3c:	91004281 	add	x1, x20, #0x10
	switch (cmd->opcode) {
ffffffffea80fd40:	540010c0 	b.eq	ffffffffea80ff58 <ql_tipc_handle_cmd+0x2c0>  // b.none
ffffffffea80fd44:	54000608 	b.hi	ffffffffea80fe04 <ql_tipc_handle_cmd+0x16c>  // b.pmore
ffffffffea80fd48:	7100041f 	cmp	w0, #0x1
ffffffffea80fd4c:	54000f80 	b.eq	ffffffffea80ff3c <ql_tipc_handle_cmd+0x2a4>  // b.none
ffffffffea80fd50:	7100081f 	cmp	w0, #0x2
ffffffffea80fd54:	54000aa1 	b.ne	ffffffffea80fea8 <ql_tipc_handle_cmd+0x210>  // b.any
ffffffffea80fd58:	f9001bb7 	str	x23, [x29, #48]
	if (ns_sz < sizeof(req))
ffffffffea80fd5c:	71001c7f 	cmp	w3, #0x7
	uint32_t  chan_event = 0;
ffffffffea80fd60:	b90063bf 	str	wzr, [x29, #96]
			return dev_get_event(dev, ns_payload, cmd->payload_len, cmd->handle);
ffffffffea80fd64:	b9404bb7 	ldr	w23, [x29, #72]
	if (ns_sz < sizeof(req))
ffffffffea80fd68:	54001c09 	b.ls	ffffffffea8100e8 <ql_tipc_handle_cmd+0x450>  // b.plast
	if (target) {
ffffffffea80fd6c:	34001877 	cbz	w23, ffffffffea810078 <ql_tipc_handle_cmd+0x3e0>
	return (uint)(addr - QL_TIPC_ADDR_BASE);
ffffffffea80fd70:	510082e0 	sub	w0, w23, #0x20
	if (slot < QL_TIPC_ADDR_MAX_NUM) {
ffffffffea80fd74:	71007c1f 	cmp	w0, #0x1f
ffffffffea80fd78:	54001b88 	b.hi	ffffffffea8100e8 <ql_tipc_handle_cmd+0x450>  // b.pmore
ffffffffea80fd7c:	f9404661 	ldr	x1, [x19, #136]
ffffffffea80fd80:	9ac02421 	lsr	x1, x1, x0
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80fd84:	36001b21 	tbz	w1, #0, ffffffffea8100e8 <ql_tipc_handle_cmd+0x450>
ffffffffea80fd88:	d37c7c00 	ubfiz	x0, x0, #4, #32
ffffffffea80fd8c:	f90017b6 	str	x22, [x29, #40]
ffffffffea80fd90:	8b000276 	add	x22, x19, x0
		if (!ept || !ept->chan)
ffffffffea80fd94:	f9404ac0 	ldr	x0, [x22, #144]
ffffffffea80fd98:	b4001a60 	cbz	x0, ffffffffea8100e4 <ql_tipc_handle_cmd+0x44c>
		rc = handle_wait(chan, &chan_event, 0);
ffffffffea80fd9c:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea80fda0:	910183a1 	add	x1, x29, #0x60
		chan = ept->chan;
ffffffffea80fda4:	f9003ba0 	str	x0, [x29, #112]
		rc = handle_wait(chan, &chan_event, 0);
ffffffffea80fda8:	97ffe8ac 	bl	ffffffffea80a058 <handle_wait>
		if (rc == ERR_TIMED_OUT) {
ffffffffea80fdac:	3100341f 	cmn	w0, #0xd
ffffffffea80fdb0:	54001940 	b.eq	ffffffffea8100d8 <ql_tipc_handle_cmd+0x440>  // b.none
		else if (rc < 0) {
ffffffffea80fdb4:	37f81f00 	tbnz	w0, #31, ffffffffea810194 <ql_tipc_handle_cmd+0x4fc>
			evt->cookie = ept->cookie;
ffffffffea80fdb8:	f9404ec1 	ldr	x1, [x22, #152]
ffffffffea80fdbc:	f94017b6 	ldr	x22, [x29, #40]
			evt->handle = target;
ffffffffea80fdc0:	b9001697 	str	w23, [x20, #20]
			evt->event  = chan_event;
ffffffffea80fdc4:	b94063a0 	ldr	w0, [x29, #96]
ffffffffea80fdc8:	b9001280 	str	w0, [x20, #16]
			evt->cookie = ept->cookie;
ffffffffea80fdcc:	f9000e81 	str	x1, [x20, #24]
	return set_status(dev, opcode, 0, sizeof(*evt));
ffffffffea80fdd0:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->payload_len = len;
ffffffffea80fdd4:	52800201 	mov	w1, #0x10                  	// #16
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80fdd8:	128fffa2 	mov	w2, #0xffff8002            	// #-32766
ffffffffea80fddc:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80fde0:	b900041f 	str	wzr, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea80fde4:	b9000c01 	str	w1, [x0, #12]
	smp_wmb();
ffffffffea80fde8:	d5033abf 	dmb	ishst
	return set_status(dev, opcode, 0, sizeof(*evt));
ffffffffea80fdec:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80fdf0:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80fdf4:	a941d7b4 	ldp	x20, x21, [x29, #24]
}
ffffffffea80fdf8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80fdfc:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80fe00:	d65f03c0 	ret
	switch (cmd->opcode) {
ffffffffea80fe04:	7100101f 	cmp	w0, #0x4
ffffffffea80fe08:	54000660 	b.eq	ffffffffea80fed4 <ql_tipc_handle_cmd+0x23c>  // b.none
ffffffffea80fe0c:	7100141f 	cmp	w0, #0x5
ffffffffea80fe10:	540004c1 	b.ne	ffffffffea80fea8 <ql_tipc_handle_cmd+0x210>  // b.any
	return (uint)(addr - QL_TIPC_ADDR_BASE);
ffffffffea80fe14:	b9404bb4 	ldr	w20, [x29, #72]
ffffffffea80fe18:	51008294 	sub	w20, w20, #0x20
	if (slot < QL_TIPC_ADDR_MAX_NUM) {
ffffffffea80fe1c:	71007e9f 	cmp	w20, #0x1f
ffffffffea80fe20:	54fff628 	b.hi	ffffffffea80fce4 <ql_tipc_handle_cmd+0x4c>  // b.pmore
ffffffffea80fe24:	f9404660 	ldr	x0, [x19, #136]
ffffffffea80fe28:	9ad42400 	lsr	x0, x0, x20
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80fe2c:	3607f5c0 	tbz	w0, #0, ffffffffea80fce4 <ql_tipc_handle_cmd+0x4c>
ffffffffea80fe30:	d37c7e95 	ubfiz	x21, x20, #4, #32
ffffffffea80fe34:	8b150275 	add	x21, x19, x21
	if (!ept || !ept->chan)
ffffffffea80fe38:	f9404aa1 	ldr	x1, [x21, #144]
ffffffffea80fe3c:	b4fff541 	cbz	x1, ffffffffea80fce4 <ql_tipc_handle_cmd+0x4c>
	handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80fe40:	91004260 	add	x0, x19, #0x10
ffffffffea80fe44:	97ffe915 	bl	ffffffffea80a298 <handle_list_del>
	handle_set_cookie(ept->chan, NULL);
ffffffffea80fe48:	f9404aa1 	ldr	x1, [x21, #144]
	handle_close(ept->chan);
ffffffffea80fe4c:	aa0103e0 	mov	x0, x1
ffffffffea80fe50:	f900183f 	str	xzr, [x1, #48]
ffffffffea80fe54:	97ffe875 	bl	ffffffffea80a028 <handle_close>
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80fe58:	52800020 	mov	w0, #0x1                   	// #1
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea80fe5c:	91022261 	add	x1, x19, #0x88
ffffffffea80fe60:	1ad42000 	lsl	w0, w0, w20
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80fe64:	2a2003e0 	mvn	w0, w0
ffffffffea80fe68:	885f7c22 	ldxr	w2, [x1]
ffffffffea80fe6c:	0a000042 	and	w2, w2, w0
ffffffffea80fe70:	88037c22 	stxr	w3, w2, [x1]
ffffffffea80fe74:	35ffffa3 	cbnz	w3, ffffffffea80fe68 <ql_tipc_handle_cmd+0x1d0>
		dev->epts[slot].cookie = 0;
ffffffffea80fe78:	a9097ebf 	stp	xzr, xzr, [x21, #144]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80fe7c:	128fff41 	mov	w1, #0xffff8005            	// #-32763
	return set_status(dev, opcode, 0, 0);
ffffffffea80fe80:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80fe84:	79000001 	strh	w1, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80fe88:	b900041f 	str	wzr, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea80fe8c:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea80fe90:	d5033abf 	dmb	ishst
	return set_status(dev, opcode, 0, 0);
ffffffffea80fe94:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80fe98:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80fe9c:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea80fea0:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80fea4:	d65f03c0 	ret
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80fea8:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80feac:	32114000 	orr	w0, w0, #0xffff8000
ffffffffea80feb0:	79000280 	strh	w0, [x20]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80feb4:	b9000681 	str	w1, [x20, #4]
	ns_hdr->payload_len = len;
ffffffffea80feb8:	b9000e9f 	str	wzr, [x20, #12]
	smp_wmb();
ffffffffea80febc:	d5033abf 	dmb	ishst
			return set_status(dev, cmd->opcode, ERR_NOT_SUPPORTED, 0);
ffffffffea80fec0:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
}
ffffffffea80fec4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80fec8:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea80fecc:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80fed0:	d65f03c0 	ret
	return (uint)(addr - QL_TIPC_ADDR_BASE);
ffffffffea80fed4:	b9404ba0 	ldr	w0, [x29, #72]
ffffffffea80fed8:	51008000 	sub	w0, w0, #0x20
	if (slot < QL_TIPC_ADDR_MAX_NUM) {
ffffffffea80fedc:	71007c1f 	cmp	w0, #0x1f
ffffffffea80fee0:	54001188 	b.hi	ffffffffea810110 <ql_tipc_handle_cmd+0x478>  // b.pmore
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80fee4:	f9404661 	ldr	x1, [x19, #136]
ffffffffea80fee8:	9ac02421 	lsr	x1, x1, x0
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80feec:	36001121 	tbz	w1, #0, ffffffffea810110 <ql_tipc_handle_cmd+0x478>
ffffffffea80fef0:	d37c7c00 	ubfiz	x0, x0, #4, #32
ffffffffea80fef4:	8b000275 	add	x21, x19, x0
	if (!ept || !ept->chan)
ffffffffea80fef8:	f9404aa0 	ldr	x0, [x21, #144]
ffffffffea80fefc:	b40010a0 	cbz	x0, ffffffffea810110 <ql_tipc_handle_cmd+0x478>
	rc = ipc_get_msg(ept->chan, &mi);
ffffffffea80ff00:	910143a1 	add	x1, x29, #0x50
ffffffffea80ff04:	97fff31b 	bl	ffffffffea80cb70 <ipc_get_msg>
	if (rc < 0)
ffffffffea80ff08:	36f805c0 	tbz	w0, #31, ffffffffea80ffc0 <ql_tipc_handle_cmd+0x328>
		return set_status(dev, opcode, rc, 0);
ffffffffea80ff0c:	f9403a61 	ldr	x1, [x19, #112]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80ff10:	52800022 	mov	w2, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80ff14:	128fff63 	mov	w3, #0xffff8004            	// #-32764
ffffffffea80ff18:	79000023 	strh	w3, [x1]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80ff1c:	b9000422 	str	w2, [x1, #4]
	ns_hdr->payload_len = len;
ffffffffea80ff20:	b9000c3f 	str	wzr, [x1, #12]
	smp_wmb();
ffffffffea80ff24:	d5033abf 	dmb	ishst
ffffffffea80ff28:	a941d7b4 	ldp	x20, x21, [x29, #24]
	return err;
ffffffffea80ff2c:	93407c00 	sxtw	x0, w0
}
ffffffffea80ff30:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80ff34:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80ff38:	d65f03c0 	ret
			return dev_connect(dev, ns_payload, cmd->payload_len);
ffffffffea80ff3c:	aa1303e0 	mov	x0, x19
ffffffffea80ff40:	97fffe48 	bl	ffffffffea80f860 <dev_connect>
ffffffffea80ff44:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea80ff48:	93407c00 	sxtw	x0, w0
}
ffffffffea80ff4c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80ff50:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80ff54:	d65f03c0 	ret
	return (uint)(addr - QL_TIPC_ADDR_BASE);
ffffffffea80ff58:	b9404ba0 	ldr	w0, [x29, #72]
ffffffffea80ff5c:	51008000 	sub	w0, w0, #0x20
	if (slot < QL_TIPC_ADDR_MAX_NUM) {
ffffffffea80ff60:	71007c1f 	cmp	w0, #0x1f
ffffffffea80ff64:	54000e88 	b.hi	ffffffffea810134 <ql_tipc_handle_cmd+0x49c>  // b.pmore
ffffffffea80ff68:	f9404663 	ldr	x3, [x19, #136]
ffffffffea80ff6c:	9ac02463 	lsr	x3, x3, x0
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80ff70:	36000e23 	tbz	w3, #0, ffffffffea810134 <ql_tipc_handle_cmd+0x49c>
	if (!ept || !ept->chan)
ffffffffea80ff74:	d37c7c00 	ubfiz	x0, x0, #4, #32
ffffffffea80ff78:	91024000 	add	x0, x0, #0x90
ffffffffea80ff7c:	f8606a60 	ldr	x0, [x19, x0]
ffffffffea80ff80:	b4000da0 	cbz	x0, ffffffffea810134 <ql_tipc_handle_cmd+0x49c>
	ipc_msg_kern_t msg = {
ffffffffea80ff84:	9101d3a3 	add	x3, x29, #0x74
		.iov = (iovec_kern_t[]) {
ffffffffea80ff88:	a9050ba1 	stp	x1, x2, [x29, #80]
	ipc_msg_kern_t msg = {
ffffffffea80ff8c:	910143a2 	add	x2, x29, #0x50
	return set_status(dev, opcode, ipc_send_msg(ept->chan, &msg), 0);
ffffffffea80ff90:	9101c3a1 	add	x1, x29, #0x70
	ipc_msg_kern_t msg = {
ffffffffea80ff94:	a9007c7f 	stp	xzr, xzr, [x3]
ffffffffea80ff98:	52800023 	mov	w3, #0x1                   	// #1
ffffffffea80ff9c:	b90073a3 	str	w3, [x29, #112]
ffffffffea80ffa0:	f9003fa2 	str	x2, [x29, #120]
ffffffffea80ffa4:	f80843bf 	stur	xzr, [x29, #132]
ffffffffea80ffa8:	b9008fbf 	str	wzr, [x29, #140]
	return set_status(dev, opcode, ipc_send_msg(ept->chan, &msg), 0);
ffffffffea80ffac:	97fff283 	bl	ffffffffea80c9b8 <ipc_send_msg>
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea80ffb0:	128fff83 	mov	w3, #0xffff8003            	// #-32765
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea80ffb4:	531f7c02 	lsr	w2, w0, #31
	return set_status(dev, opcode, ipc_send_msg(ept->chan, &msg), 0);
ffffffffea80ffb8:	f9403a61 	ldr	x1, [x19, #112]
ffffffffea80ffbc:	17ffffd7 	b	ffffffffea80ff18 <ql_tipc_handle_cmd+0x280>
	ipc_msg_kern_t msg = {
ffffffffea80ffc0:	9101d3a4 	add	x4, x29, #0x74
				.len  = dev->ns_sz - sizeof(struct tipc_cmd_hdr),
ffffffffea80ffc4:	b9406662 	ldr	w2, [x19, #100]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea80ffc8:	f9404aa0 	ldr	x0, [x21, #144]
ffffffffea80ffcc:	b94057a1 	ldr	w1, [x29, #84]
				.len  = dev->ns_sz - sizeof(struct tipc_cmd_hdr),
ffffffffea80ffd0:	d1004042 	sub	x2, x2, #0x10
				.base = dev->ns_va + sizeof(struct tipc_cmd_hdr),
ffffffffea80ffd4:	f9403a63 	ldr	x3, [x19, #112]
	ipc_msg_kern_t msg = {
ffffffffea80ffd8:	a9007c9f 	stp	xzr, xzr, [x4]
ffffffffea80ffdc:	52800024 	mov	w4, #0x1                   	// #1
				.base = dev->ns_va + sizeof(struct tipc_cmd_hdr),
ffffffffea80ffe0:	91004063 	add	x3, x3, #0x10
		.iov = (iovec_kern_t[]) {
ffffffffea80ffe4:	a9060ba3 	stp	x3, x2, [x29, #96]
	ipc_msg_kern_t msg = {
ffffffffea80ffe8:	910183a2 	add	x2, x29, #0x60
ffffffffea80ffec:	b90073a4 	str	w4, [x29, #112]
ffffffffea80fff0:	f9003fa2 	str	x2, [x29, #120]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea80fff4:	9101c3a3 	add	x3, x29, #0x70
	ipc_msg_kern_t msg = {
ffffffffea80fff8:	f80843bf 	stur	xzr, [x29, #132]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea80fffc:	52800002 	mov	w2, #0x0                   	// #0
	ipc_msg_kern_t msg = {
ffffffffea810000:	b9008fbf 	str	wzr, [x29, #140]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea810004:	97fff3a9 	bl	ffffffffea80cea8 <ipc_read_msg>
	ipc_put_msg(ept->chan, mi.id);
ffffffffea810008:	b94057a1 	ldr	w1, [x29, #84]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea81000c:	2a0003f4 	mov	w20, w0
	ipc_put_msg(ept->chan, mi.id);
ffffffffea810010:	f9404aa0 	ldr	x0, [x21, #144]
ffffffffea810014:	97fff30b 	bl	ffffffffea80cc40 <ipc_put_msg>
	if (rc < 0)
ffffffffea810018:	37f801d4 	tbnz	w20, #31, ffffffffea810050 <ql_tipc_handle_cmd+0x3b8>
	if (rc < (int)mi.len)
ffffffffea81001c:	b94053a1 	ldr	w1, [x29, #80]
ffffffffea810020:	f9403a60 	ldr	x0, [x19, #112]
ffffffffea810024:	6b01029f 	cmp	w20, w1
ffffffffea810028:	540008cb 	b.lt	ffffffffea810140 <ql_tipc_handle_cmd+0x4a8>  // b.tstop
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea81002c:	531f7e82 	lsr	w2, w20, #31
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810030:	128fff63 	mov	w3, #0xffff8004            	// #-32764
ffffffffea810034:	79000003 	strh	w3, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810038:	b9000402 	str	w2, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea81003c:	b9000c01 	str	w1, [x0, #12]
	smp_wmb();
ffffffffea810040:	d5033abf 	dmb	ishst
	return err;
ffffffffea810044:	93407e80 	sxtw	x0, w20
ffffffffea810048:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea81004c:	17ffff28 	b	ffffffffea80fcec <ql_tipc_handle_cmd+0x54>
		return set_status(dev, opcode, rc, 0);
ffffffffea810050:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810054:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810058:	128fff62 	mov	w2, #0xffff8004            	// #-32764
ffffffffea81005c:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810060:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea810064:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea810068:	d5033abf 	dmb	ishst
	return err;
ffffffffea81006c:	93407e80 	sxtw	x0, w20
ffffffffea810070:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea810074:	17ffff1e 	b	ffffffffea80fcec <ql_tipc_handle_cmd+0x54>
		rc = handle_list_wait(&dev->handle_list, &chan,
ffffffffea810078:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea81007c:	910183a2 	add	x2, x29, #0x60
ffffffffea810080:	9101c3a1 	add	x1, x29, #0x70
ffffffffea810084:	91004260 	add	x0, x19, #0x10
ffffffffea810088:	97ffe896 	bl	ffffffffea80a2e0 <handle_list_wait>
		if (rc == ERR_NOT_FOUND) {
ffffffffea81008c:	3100081f 	cmn	w0, #0x2
ffffffffea810090:	540006a0 	b.eq	ffffffffea810164 <ql_tipc_handle_cmd+0x4cc>  // b.none
		if (rc == ERR_TIMED_OUT) {
ffffffffea810094:	3100341f 	cmn	w0, #0xd
ffffffffea810098:	54000040 	b.eq	ffffffffea8100a0 <ql_tipc_handle_cmd+0x408>  // b.none
		if (rc < 0 && rc != ERR_TIMED_OUT) {
ffffffffea81009c:	37f807a0 	tbnz	w0, #31, ffffffffea810190 <ql_tipc_handle_cmd+0x4f8>
			ept = handle_get_cookie(chan);
ffffffffea8100a0:	f9403ba2 	ldr	x2, [x29, #112]
	return slot_to_addr(ept - dev->epts);
ffffffffea8100a4:	91024261 	add	x1, x19, #0x90
			handle_decref(chan);
ffffffffea8100a8:	aa0203e0 	mov	x0, x2
	return handle->cookie;
ffffffffea8100ac:	f9401842 	ldr	x2, [x2, #48]
	return slot_to_addr(ept - dev->epts);
ffffffffea8100b0:	cb010041 	sub	x1, x2, x1
			evt->cookie = ept->cookie;
ffffffffea8100b4:	f9400442 	ldr	x2, [x2, #8]
	return slot_to_addr(ept - dev->epts);
ffffffffea8100b8:	9344fc21 	asr	x1, x1, #4
	return (uint32_t) (slot + QL_TIPC_ADDR_BASE);
ffffffffea8100bc:	11008021 	add	w1, w1, #0x20
			evt->handle = ept_to_addr(dev, ept);
ffffffffea8100c0:	b9001681 	str	w1, [x20, #20]
			evt->event  = chan_event;
ffffffffea8100c4:	b94063a1 	ldr	w1, [x29, #96]
ffffffffea8100c8:	b9001281 	str	w1, [x20, #16]
			evt->cookie = ept->cookie;
ffffffffea8100cc:	f9000e82 	str	x2, [x20, #24]
			handle_decref(chan);
ffffffffea8100d0:	97ffe7ae 	bl	ffffffffea809f88 <handle_decref>
ffffffffea8100d4:	17ffff3f 	b	ffffffffea80fdd0 <ql_tipc_handle_cmd+0x138>
			evt->handle = 0;
ffffffffea8100d8:	a9017e9f 	stp	xzr, xzr, [x20, #16]
ffffffffea8100dc:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea8100e0:	17ffff3c 	b	ffffffffea80fdd0 <ql_tipc_handle_cmd+0x138>
ffffffffea8100e4:	f94017b6 	ldr	x22, [x29, #40]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8100e8:	52800020 	mov	w0, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea8100ec:	128fffa1 	mov	w1, #0xffff8002            	// #-32766
ffffffffea8100f0:	79000281 	strh	w1, [x20]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8100f4:	b9000680 	str	w0, [x20, #4]
	ns_hdr->payload_len = len;
ffffffffea8100f8:	b9000e9f 	str	wzr, [x20, #12]
	smp_wmb();
ffffffffea8100fc:	d5033abf 	dmb	ishst
			return set_status(dev, opcode, ERR_INVALID_ARGS, 0);
ffffffffea810100:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea810104:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea810108:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea81010c:	17fffef8 	b	ffffffffea80fcec <ql_tipc_handle_cmd+0x54>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810110:	52800020 	mov	w0, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810114:	128fff61 	mov	w1, #0xffff8004            	// #-32764
ffffffffea810118:	79000281 	strh	w1, [x20]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea81011c:	b9000680 	str	w0, [x20, #4]
	ns_hdr->payload_len = len;
ffffffffea810120:	b9000e9f 	str	wzr, [x20, #12]
	smp_wmb();
ffffffffea810124:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, ERR_INVALID_ARGS, 0);
ffffffffea810128:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea81012c:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea810130:	17fffeef 	b	ffffffffea80fcec <ql_tipc_handle_cmd+0x54>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810134:	52800020 	mov	w0, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810138:	128fff81 	mov	w1, #0xffff8003            	// #-32765
ffffffffea81013c:	17fffff7 	b	ffffffffea810118 <ql_tipc_handle_cmd+0x480>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810140:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810144:	128fff62 	mov	w2, #0xffff8004            	// #-32764
ffffffffea810148:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea81014c:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea810150:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea810154:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, ERR_BAD_LEN, 0);
ffffffffea810158:	928003e0 	mov	x0, #0xffffffffffffffe0    	// #-32
ffffffffea81015c:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea810160:	17fffee3 	b	ffffffffea80fcec <ql_tipc_handle_cmd+0x54>
			return set_status(dev, opcode, rc, 0);
ffffffffea810164:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810168:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea81016c:	128fffa2 	mov	w2, #0xffff8002            	// #-32766
ffffffffea810170:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810174:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea810178:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea81017c:	d5033abf 	dmb	ishst
			return set_status(dev, opcode, rc, 0);
ffffffffea810180:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea810184:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea810188:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea81018c:	17fffed8 	b	ffffffffea80fcec <ql_tipc_handle_cmd+0x54>
ffffffffea810190:	f90017b6 	str	x22, [x29, #40]
			panic("%s: couldn't wait for handle events (%d)\n",
ffffffffea810194:	f0000022 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea810198:	f0000021 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea81019c:	2a0003e3 	mov	w3, w0
ffffffffea8101a0:	9117e042 	add	x2, x2, #0x5f8
ffffffffea8101a4:	91144021 	add	x1, x1, #0x510
ffffffffea8101a8:	aa1503e0 	mov	x0, x21
ffffffffea8101ac:	94000617 	bl	ffffffffea811a08 <_panic>

ffffffffea8101b0 <tipc_init>:
	}
	return false;
}

static void tipc_init(uint level)
{
ffffffffea8101b0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	status_t res;

	res = create_tipc_device(&_descr0, sizeof(_descr0), &zero_uuid, 0, NULL);
ffffffffea8101b4:	f0000022 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea8101b8:	f0000020 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea8101bc:	d2800004 	mov	x4, #0x0                   	// #0
{
ffffffffea8101c0:	910003fd 	mov	x29, sp
	res = create_tipc_device(&_descr0, sizeof(_descr0), &zero_uuid, 0, NULL);
ffffffffea8101c4:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea8101c8:	91032042 	add	x2, x2, #0xc8
ffffffffea8101cc:	d2800d81 	mov	x1, #0x6c                  	// #108
ffffffffea8101d0:	91188000 	add	x0, x0, #0x620
ffffffffea8101d4:	97fffd61 	bl	ffffffffea80f758 <create_tipc_device>
	if (res != NO_ERROR) {
ffffffffea8101d8:	35000060 	cbnz	w0, ffffffffea8101e4 <tipc_init+0x34>
		TRACEF("WARNING: failed (%d) to register tipc device\n", res);
	}
}
ffffffffea8101dc:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8101e0:	d65f03c0 	ret
ffffffffea8101e4:	a8c17bfd 	ldp	x29, x30, [sp], #16
		TRACEF("WARNING: failed (%d) to register tipc device\n", res);
ffffffffea8101e8:	f0000024 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea8101ec:	2a0003e3 	mov	w3, w0
ffffffffea8101f0:	f0000021 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea8101f4:	52800c42 	mov	w2, #0x62                  	// #98
ffffffffea8101f8:	91184021 	add	x1, x1, #0x610
ffffffffea8101fc:	911a4080 	add	x0, x4, #0x690
ffffffffea810200:	14000b68 	b	ffffffffea812fa0 <_printf>
ffffffffea810204:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810208 <is_ns_client>:
	if (uuid == &zero_uuid) {
ffffffffea810208:	f0000021 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea81020c:	91032021 	add	x1, x1, #0xc8
ffffffffea810210:	eb00003f 	cmp	x1, x0
}
ffffffffea810214:	1a9f17e0 	cset	w0, eq  // eq = none
ffffffffea810218:	d65f03c0 	ret
ffffffffea81021c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810220 <target_early_init>:
 * chooses not to implement.
 */

__WEAK void target_early_init(void)
{
}
ffffffffea810220:	d65f03c0 	ret
ffffffffea810224:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810228 <target_init>:
ffffffffea810228:	d65f03c0 	ret
ffffffffea81022c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810230 <boot_alloc_mem>:

void *boot_alloc_mem(size_t len)
{
    uintptr_t ptr;

    ptr = ALIGN(boot_alloc_end, 8);
ffffffffea810230:	90000042 	adrp	x2, ffffffffea818000 <_mem_phys_base>
    boot_alloc_end = (ptr + ALIGN(len, 8));
ffffffffea810234:	91001c01 	add	x1, x0, #0x7
ffffffffea810238:	927df021 	and	x1, x1, #0xfffffffffffffff8
    ptr = ALIGN(boot_alloc_end, 8);
ffffffffea81023c:	f9475040 	ldr	x0, [x2, #3744]
ffffffffea810240:	91001c00 	add	x0, x0, #0x7
ffffffffea810244:	927df000 	and	x0, x0, #0xfffffffffffffff8
    boot_alloc_end = (ptr + ALIGN(len, 8));
ffffffffea810248:	8b000021 	add	x1, x1, x0
ffffffffea81024c:	f9075041 	str	x1, [x2, #3744]

    LTRACEF("len %zu, ptr %p\n", len, (void *)ptr);

    return (void *)ptr;
}
ffffffffea810250:	d65f03c0 	ret
ffffffffea810254:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810258 <pmm_alloc_contiguous.part.0>:
        return NULL;

    return paddr_to_kvaddr(pa);
}

uint pmm_alloc_contiguous(uint count, uint8_t alignment_log2, paddr_t *pa, struct list_node *list)
ffffffffea810258:	12001c21 	and	w1, w1, #0xff
ffffffffea81025c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea810260:	7100303f 	cmp	w1, #0xc
ffffffffea810264:	910003fd 	mov	x29, sp
ffffffffea810268:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81026c:	2a0003f4 	mov	w20, w0
ffffffffea810270:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea810274:	aa0303f3 	mov	x19, x3
ffffffffea810278:	aa0203f6 	mov	x22, x2
ffffffffea81027c:	f9001bf7 	str	x23, [sp, #48]
ffffffffea810280:	52800195 	mov	w21, #0xc                   	// #12
ffffffffea810284:	90000057 	adrp	x23, ffffffffea818000 <_mem_phys_base>
ffffffffea810288:	1a952035 	csel	w21, w1, w21, cs  // cs = hs, nlast
ffffffffea81028c:	913b02e0 	add	x0, x23, #0xec0
ffffffffea810290:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea810294:	97ffd595 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
        alignment_log2 = PAGE_SIZE_SHIFT;

    mutex_acquire(&lock);

    pmm_arena_t *a;
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810298:	90000042 	adrp	x2, ffffffffea818000 <_mem_phys_base>
ffffffffea81029c:	913ac042 	add	x2, x2, #0xeb0
ffffffffea8102a0:	f9400446 	ldr	x6, [x2, #8]
ffffffffea8102a4:	eb0200df 	cmp	x6, x2
ffffffffea8102a8:	54000d20 	b.eq	ffffffffea81044c <pmm_alloc_contiguous.part.0+0x1f4>  // b.none
ffffffffea8102ac:	12001ea3 	and	w3, w21, #0xff
                for (uint i = 0; i < count; i++) {
                    if (p->flags & VM_PAGE_FLAG_NONFREE) {
                        /* this run is broken, break out of the inner loop.
                         * start over at the next alignment boundary
                         */
                        start = ROUNDUP(start - aligned_offset + i + 1, 1UL << (alignment_log2 - PAGE_SIZE_SHIFT)) + aligned_offset;
ffffffffea8102b0:	51003060 	sub	w0, w3, #0xc
            paddr_t rounded_base = ROUNDUP(a->base, 1UL << alignment_log2);
ffffffffea8102b4:	d2800023 	mov	x3, #0x1                   	// #1
ffffffffea8102b8:	9ad52061 	lsl	x1, x3, x21
ffffffffea8102bc:	d100042c 	sub	x12, x1, #0x1
                        start = ROUNDUP(start - aligned_offset + i + 1, 1UL << (alignment_log2 - PAGE_SIZE_SHIFT)) + aligned_offset;
ffffffffea8102c0:	9ac02063 	lsl	x3, x3, x0
            paddr_t rounded_base = ROUNDUP(a->base, 1UL << alignment_log2);
ffffffffea8102c4:	cb0103e0 	neg	x0, x1
                        start = ROUNDUP(start - aligned_offset + i + 1, 1UL << (alignment_log2 - PAGE_SIZE_SHIFT)) + aligned_offset;
ffffffffea8102c8:	2a0303ed 	mov	w13, w3
ffffffffea8102cc:	4b0303ea 	neg	w10, w3
        if (a->flags & PMM_ARENA_FLAG_KMAP) {
ffffffffea8102d0:	b94018c1 	ldr	w1, [x6, #24]
ffffffffea8102d4:	36000b61 	tbz	w1, #0, ffffffffea810440 <pmm_alloc_contiguous.part.0+0x1e8>
            paddr_t rounded_base = ROUNDUP(a->base, 1UL << alignment_log2);
ffffffffea8102d8:	f94010c7 	ldr	x7, [x6, #32]
ffffffffea8102dc:	8b0c00e1 	add	x1, x7, x12
ffffffffea8102e0:	8a000021 	and	x1, x1, x0
            if (rounded_base < a->base || rounded_base > a->base + a->size - 1)
ffffffffea8102e4:	eb0100ff 	cmp	x7, x1
ffffffffea8102e8:	54000ac8 	b.hi	ffffffffea810440 <pmm_alloc_contiguous.part.0+0x1e8>  // b.pmore
ffffffffea8102ec:	f94014c3 	ldr	x3, [x6, #40]
ffffffffea8102f0:	8b0300e4 	add	x4, x7, x3
ffffffffea8102f4:	d1000484 	sub	x4, x4, #0x1
ffffffffea8102f8:	eb04003f 	cmp	x1, x4
ffffffffea8102fc:	54000a28 	b.hi	ffffffffea810440 <pmm_alloc_contiguous.part.0+0x1e8>  // b.pmore
            uint aligned_offset = (rounded_base - a->base) / PAGE_SIZE;
ffffffffea810300:	cb070021 	sub	x1, x1, x7
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea810304:	d34cfc68 	lsr	x8, x3, #12
            uint aligned_offset = (rounded_base - a->base) / PAGE_SIZE;
ffffffffea810308:	d34cfc21 	lsr	x1, x1, #12
ffffffffea81030c:	92407c2b 	and	x11, x1, #0xffffffff
ffffffffea810310:	2a0103ef 	mov	w15, w1
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea810314:	eb0b011f 	cmp	x8, x11
ffffffffea810318:	54000949 	b.ls	ffffffffea810440 <pmm_alloc_contiguous.part.0+0x1e8>  // b.plast
                   ((start + count) <= a->size / PAGE_SIZE)) {
ffffffffea81031c:	0b010289 	add	w9, w20, w1
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea810320:	eb29411f 	cmp	x8, w9, uxtw
ffffffffea810324:	540008e3 	b.cc	ffffffffea810440 <pmm_alloc_contiguous.part.0+0x1e8>  // b.lo, b.ul, b.last
                vm_page_t *p = &a->page_array[start];
ffffffffea810328:	f9401cce 	ldr	x14, [x6, #56]
ffffffffea81032c:	4b0101b0 	sub	w16, w13, w1
ffffffffea810330:	8b0b0564 	add	x4, x11, x11, lsl #1
ffffffffea810334:	8b040dc4 	add	x4, x14, x4, lsl #3
                for (uint i = 0; i < count; i++) {
ffffffffea810338:	34000174 	cbz	w20, ffffffffea810364 <pmm_alloc_contiguous.part.0+0x10c>
                    if (p->flags & VM_PAGE_FLAG_NONFREE) {
ffffffffea81033c:	39404083 	ldrb	w3, [x4, #16]
ffffffffea810340:	370006c3 	tbnz	w3, #0, ffffffffea810418 <pmm_alloc_contiguous.part.0+0x1c0>
                for (uint i = 0; i < count; i++) {
ffffffffea810344:	52800005 	mov	w5, #0x0                   	// #0
ffffffffea810348:	14000003 	b	ffffffffea810354 <pmm_alloc_contiguous.part.0+0xfc>
                    if (p->flags & VM_PAGE_FLAG_NONFREE) {
ffffffffea81034c:	39404083 	ldrb	w3, [x4, #16]
ffffffffea810350:	37000623 	tbnz	w3, #0, ffffffffea810414 <pmm_alloc_contiguous.part.0+0x1bc>
                for (uint i = 0; i < count; i++) {
ffffffffea810354:	110004a5 	add	w5, w5, #0x1
                        goto retry;
                    }
                    p++;
ffffffffea810358:	91006084 	add	x4, x4, #0x18
                for (uint i = 0; i < count; i++) {
ffffffffea81035c:	6b1400bf 	cmp	w5, w20
ffffffffea810360:	54ffff61 	b.ne	ffffffffea81034c <pmm_alloc_contiguous.part.0+0xf4>  // b.any

                /* we found a run */
                LTRACEF("found run from pn %u to %u\n", start, start + count);

                /* remove the pages from the run out of the free list */
                for (uint i = start; i < start + count; i++) {
ffffffffea810364:	6b01013f 	cmp	w9, w1
ffffffffea810368:	54000409 	b.ls	ffffffffea8103e8 <pmm_alloc_contiguous.part.0+0x190>  // b.plast
ffffffffea81036c:	51000529 	sub	w9, w9, #0x1
ffffffffea810370:	52800302 	mov	w2, #0x18                  	// #24
ffffffffea810374:	4b010129 	sub	w9, w9, w1
ffffffffea810378:	910061c0 	add	x0, x14, #0x18
ffffffffea81037c:	8b214124 	add	x4, x9, w1, uxtw
ffffffffea810380:	f94018c5 	ldr	x5, [x6, #48]
ffffffffea810384:	d503201f 	nop
ffffffffea810388:	9ba23821 	umaddl	x1, w1, w2, x14
ffffffffea81038c:	8b040484 	add	x4, x4, x4, lsl #1
ffffffffea810390:	8b040c04 	add	x4, x0, x4, lsl #3
ffffffffea810394:	d503201f 	nop
	item->next->prev = item->prev;
ffffffffea810398:	a9400022 	ldp	x2, x0, [x1]
ffffffffea81039c:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea8103a0:	f9400022 	ldr	x2, [x1]
ffffffffea8103a4:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea8103a8:	a9007c3f 	stp	xzr, xzr, [x1]
                    p = &a->page_array[i];
                    DEBUG_ASSERT(!(p->flags & VM_PAGE_FLAG_NONFREE));
                    DEBUG_ASSERT(list_in_list(&p->node));

                    list_delete(&p->node);
                    p->flags |= VM_PAGE_FLAG_NONFREE;
ffffffffea8103ac:	39404023 	ldrb	w3, [x1, #16]
ffffffffea8103b0:	32000063 	orr	w3, w3, #0x1
ffffffffea8103b4:	39004023 	strb	w3, [x1, #16]
                    a->free_count--;

                    if (list)
ffffffffea8103b8:	b40000d3 	cbz	x19, ffffffffea8103d0 <pmm_alloc_contiguous.part.0+0x178>
	item->prev = list->prev;
ffffffffea8103bc:	f9400260 	ldr	x0, [x19]
	item->next = list;
ffffffffea8103c0:	a9004c20 	stp	x0, x19, [x1]
	list->prev->next = item;
ffffffffea8103c4:	f9400260 	ldr	x0, [x19]
ffffffffea8103c8:	f9000401 	str	x1, [x0, #8]
	list->prev = item;
ffffffffea8103cc:	f9000261 	str	x1, [x19]
ffffffffea8103d0:	91006021 	add	x1, x1, #0x18
                for (uint i = start; i < start + count; i++) {
ffffffffea8103d4:	eb04003f 	cmp	x1, x4
ffffffffea8103d8:	54fffe01 	b.ne	ffffffffea810398 <pmm_alloc_contiguous.part.0+0x140>  // b.any
ffffffffea8103dc:	d10004a5 	sub	x5, x5, #0x1
ffffffffea8103e0:	cb0900a9 	sub	x9, x5, x9
ffffffffea8103e4:	f90018c9 	str	x9, [x6, #48]
                        list_add_tail(list, &p->node);
                }

                if (pa)
ffffffffea8103e8:	b4000076 	cbz	x22, ffffffffea8103f4 <pmm_alloc_contiguous.part.0+0x19c>
                    *pa = a->base + start * PAGE_SIZE;
ffffffffea8103ec:	8b0b30e7 	add	x7, x7, x11, lsl #12
ffffffffea8103f0:	f90002c7 	str	x7, [x22]

                mutex_release(&lock);
ffffffffea8103f4:	913b02e0 	add	x0, x23, #0xec0
ffffffffea8103f8:	97ffd568 	bl	ffffffffea805998 <mutex_release>
ffffffffea8103fc:	2a1403e0 	mov	w0, w20

    mutex_release(&lock);

    LTRACEF("couldn't find run\n");
    return 0;
}
ffffffffea810400:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea810404:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea810408:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea81040c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea810410:	d65f03c0 	ret
ffffffffea810414:	0b050021 	add	w1, w1, w5
                        start = ROUNDUP(start - aligned_offset + i + 1, 1UL << (alignment_log2 - PAGE_SIZE_SHIFT)) + aligned_offset;
ffffffffea810418:	0b010201 	add	w1, w16, w1
ffffffffea81041c:	0a0a0021 	and	w1, w1, w10
ffffffffea810420:	0b0f002b 	add	w11, w1, w15
ffffffffea810424:	aa0b03e1 	mov	x1, x11
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea810428:	eb08017f 	cmp	x11, x8
ffffffffea81042c:	540000a2 	b.cs	ffffffffea810440 <pmm_alloc_contiguous.part.0+0x1e8>  // b.hs, b.nlast
                   ((start + count) <= a->size / PAGE_SIZE)) {
ffffffffea810430:	0b140169 	add	w9, w11, w20
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea810434:	eb29411f 	cmp	x8, w9, uxtw
ffffffffea810438:	54fff7c2 	b.cs	ffffffffea810330 <pmm_alloc_contiguous.part.0+0xd8>  // b.hs, b.nlast
ffffffffea81043c:	d503201f 	nop
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810440:	f94004c6 	ldr	x6, [x6, #8]
ffffffffea810444:	eb0200df 	cmp	x6, x2
ffffffffea810448:	54fff441 	b.ne	ffffffffea8102d0 <pmm_alloc_contiguous.part.0+0x78>  // b.any
    mutex_release(&lock);
ffffffffea81044c:	913b02e0 	add	x0, x23, #0xec0
ffffffffea810450:	97ffd552 	bl	ffffffffea805998 <mutex_release>
    return 0;
ffffffffea810454:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea810458:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea81045c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea810460:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea810464:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea810468:	d65f03c0 	ret
ffffffffea81046c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810470 <page_to_address>:
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810470:	90000044 	adrp	x4, ffffffffea818000 <_mem_phys_base>
ffffffffea810474:	913ac084 	add	x4, x4, #0xeb0
ffffffffea810478:	f9400481 	ldr	x1, [x4, #8]
ffffffffea81047c:	eb04003f 	cmp	x1, x4
ffffffffea810480:	540001c0 	b.eq	ffffffffea8104b8 <page_to_address+0x48>  // b.none
ffffffffea810484:	d503201f 	nop
        if (PAGE_BELONGS_TO_ARENA(page, a)) {
ffffffffea810488:	f9401c23 	ldr	x3, [x1, #56]
ffffffffea81048c:	eb00007f 	cmp	x3, x0
ffffffffea810490:	540000e8 	b.hi	ffffffffea8104ac <page_to_address+0x3c>  // b.pmore
ffffffffea810494:	f9401422 	ldr	x2, [x1, #40]
ffffffffea810498:	d34cfc42 	lsr	x2, x2, #12
ffffffffea81049c:	8b020442 	add	x2, x2, x2, lsl #1
ffffffffea8104a0:	8b020c62 	add	x2, x3, x2, lsl #3
ffffffffea8104a4:	eb00005f 	cmp	x2, x0
ffffffffea8104a8:	540000c8 	b.hi	ffffffffea8104c0 <page_to_address+0x50>  // b.pmore
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8104ac:	f9400421 	ldr	x1, [x1, #8]
ffffffffea8104b0:	eb04003f 	cmp	x1, x4
ffffffffea8104b4:	54fffea1 	b.ne	ffffffffea810488 <page_to_address+0x18>  // b.any
    return -1;
ffffffffea8104b8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
}
ffffffffea8104bc:	d65f03c0 	ret
            return PAGE_ADDRESS_FROM_ARENA(page, a);
ffffffffea8104c0:	cb030000 	sub	x0, x0, x3
ffffffffea8104c4:	b201f3e3 	mov	x3, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
ffffffffea8104c8:	f2955563 	movk	x3, #0xaaab
ffffffffea8104cc:	f9401021 	ldr	x1, [x1, #32]
ffffffffea8104d0:	9bc37c00 	umulh	x0, x0, x3
ffffffffea8104d4:	d344fc00 	lsr	x0, x0, #4
ffffffffea8104d8:	8b003020 	add	x0, x1, x0, lsl #12
}
ffffffffea8104dc:	d65f03c0 	ret

ffffffffea8104e0 <address_to_page>:
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8104e0:	90000044 	adrp	x4, ffffffffea818000 <_mem_phys_base>
ffffffffea8104e4:	913ac084 	add	x4, x4, #0xeb0
ffffffffea8104e8:	f9400481 	ldr	x1, [x4, #8]
ffffffffea8104ec:	eb04003f 	cmp	x1, x4
ffffffffea8104f0:	540001a0 	b.eq	ffffffffea810524 <address_to_page+0x44>  // b.none
ffffffffea8104f4:	d503201f 	nop
        if (addr >= a->base && addr <= a->base + a->size - 1) {
ffffffffea8104f8:	f9401023 	ldr	x3, [x1, #32]
ffffffffea8104fc:	eb00007f 	cmp	x3, x0
ffffffffea810500:	540000c8 	b.hi	ffffffffea810518 <address_to_page+0x38>  // b.pmore
ffffffffea810504:	f9401422 	ldr	x2, [x1, #40]
ffffffffea810508:	8b020062 	add	x2, x3, x2
ffffffffea81050c:	d1000442 	sub	x2, x2, #0x1
ffffffffea810510:	eb00005f 	cmp	x2, x0
ffffffffea810514:	540000c2 	b.cs	ffffffffea81052c <address_to_page+0x4c>  // b.hs, b.nlast
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810518:	f9400421 	ldr	x1, [x1, #8]
ffffffffea81051c:	eb04003f 	cmp	x1, x4
ffffffffea810520:	54fffec1 	b.ne	ffffffffea8104f8 <address_to_page+0x18>  // b.any
    return NULL;
ffffffffea810524:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea810528:	d65f03c0 	ret
            size_t index = (addr - a->base) / PAGE_SIZE;
ffffffffea81052c:	cb030000 	sub	x0, x0, x3
            return &a->page_array[index];
ffffffffea810530:	f9401c21 	ldr	x1, [x1, #56]
            size_t index = (addr - a->base) / PAGE_SIZE;
ffffffffea810534:	d34cfc00 	lsr	x0, x0, #12
            return &a->page_array[index];
ffffffffea810538:	8b000400 	add	x0, x0, x0, lsl #1
ffffffffea81053c:	8b000c20 	add	x0, x1, x0, lsl #3
}
ffffffffea810540:	d65f03c0 	ret
ffffffffea810544:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810548 <pmm_add_arena>:
{
ffffffffea810548:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea81054c:	90000044 	adrp	x4, ffffffffea818000 <_mem_phys_base>
ffffffffea810550:	913ac082 	add	x2, x4, #0xeb0
{
ffffffffea810554:	910003fd 	mov	x29, sp
ffffffffea810558:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81055c:	aa0003f3 	mov	x19, x0
ffffffffea810560:	a9025bf5 	stp	x21, x22, [sp, #32]
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810564:	f9400440 	ldr	x0, [x2, #8]
ffffffffea810568:	eb02001f 	cmp	x0, x2
ffffffffea81056c:	54000180 	b.eq	ffffffffea81059c <pmm_add_arena+0x54>  // b.none
        if (a->priority > arena->priority) {
ffffffffea810570:	b9401c01 	ldr	w1, [x0, #28]
ffffffffea810574:	b9401e63 	ldr	w3, [x19, #28]
ffffffffea810578:	6b01007f 	cmp	w3, w1
ffffffffea81057c:	540000a2 	b.cs	ffffffffea810590 <pmm_add_arena+0x48>  // b.hs, b.nlast
ffffffffea810580:	1400002d 	b	ffffffffea810634 <pmm_add_arena+0xec>
ffffffffea810584:	b9401c01 	ldr	w1, [x0, #28]
ffffffffea810588:	6b03003f 	cmp	w1, w3
ffffffffea81058c:	54000548 	b.hi	ffffffffea810634 <pmm_add_arena+0xec>  // b.pmore
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810590:	f9400400 	ldr	x0, [x0, #8]
ffffffffea810594:	eb02001f 	cmp	x0, x2
ffffffffea810598:	54ffff61 	b.ne	ffffffffea810584 <pmm_add_arena+0x3c>  // b.any
	item->prev = list->prev;
ffffffffea81059c:	f9475881 	ldr	x1, [x4, #3760]
ffffffffea8105a0:	913ac080 	add	x0, x4, #0xeb0
	item->next = list;
ffffffffea8105a4:	a9000261 	stp	x1, x0, [x19]
	list->prev->next = item;
ffffffffea8105a8:	f9475880 	ldr	x0, [x4, #3760]
	list->prev = item;
ffffffffea8105ac:	f9075893 	str	x19, [x4, #3760]
	list->prev->next = item;
ffffffffea8105b0:	f9000413 	str	x19, [x0, #8]
    size_t page_count = arena->size / PAGE_SIZE;
ffffffffea8105b4:	f9401676 	ldr	x22, [x19, #40]
    list_initialize(&arena->free_list);
ffffffffea8105b8:	91010275 	add	x21, x19, #0x40
    arena->free_count = 0;
ffffffffea8105bc:	f9001a7f 	str	xzr, [x19, #48]
	list->prev = list->next = list;
ffffffffea8105c0:	a9045675 	stp	x21, x21, [x19, #64]
    size_t page_count = arena->size / PAGE_SIZE;
ffffffffea8105c4:	d34cfed6 	lsr	x22, x22, #12
    arena->page_array = boot_alloc_mem(page_count * sizeof(vm_page_t));
ffffffffea8105c8:	8b1606c2 	add	x2, x22, x22, lsl #1
ffffffffea8105cc:	d37df054 	lsl	x20, x2, #3
ffffffffea8105d0:	aa1403e0 	mov	x0, x20
ffffffffea8105d4:	97ffff17 	bl	ffffffffea810230 <boot_alloc_mem>
ffffffffea8105d8:	f9001e60 	str	x0, [x19, #56]
    memset(arena->page_array, 0, page_count * sizeof(vm_page_t));
ffffffffea8105dc:	aa1403e2 	mov	x2, x20
ffffffffea8105e0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8105e4:	94000b6b 	bl	ffffffffea813390 <memset>
    for (size_t i = 0; i < page_count; i++) {
ffffffffea8105e8:	b40001d6 	cbz	x22, ffffffffea810620 <pmm_add_arena+0xd8>
ffffffffea8105ec:	a9430264 	ldp	x4, x0, [x19, #48]
ffffffffea8105f0:	f9402261 	ldr	x1, [x19, #64]
ffffffffea8105f4:	8b000282 	add	x2, x20, x0
	item->next = list;
ffffffffea8105f8:	a9005401 	stp	x1, x21, [x0]
        list_add_tail(&arena->free_list, &p->node);
ffffffffea8105fc:	aa0003e1 	mov	x1, x0
	list->prev->next = item;
ffffffffea810600:	f9402263 	ldr	x3, [x19, #64]
ffffffffea810604:	f9000460 	str	x0, [x3, #8]
	list->prev = item;
ffffffffea810608:	f9002260 	str	x0, [x19, #64]
ffffffffea81060c:	91006000 	add	x0, x0, #0x18
    for (size_t i = 0; i < page_count; i++) {
ffffffffea810610:	eb02001f 	cmp	x0, x2
ffffffffea810614:	54ffff21 	b.ne	ffffffffea8105f8 <pmm_add_arena+0xb0>  // b.any
ffffffffea810618:	8b160084 	add	x4, x4, x22
ffffffffea81061c:	f9001a64 	str	x4, [x19, #48]
}
ffffffffea810620:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea810624:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea810628:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea81062c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea810630:	d65f03c0 	ret
	item->prev = list->prev;
ffffffffea810634:	f9400001 	ldr	x1, [x0]
	item->next = list;
ffffffffea810638:	a9000261 	stp	x1, x0, [x19]
	list->prev->next = item;
ffffffffea81063c:	f9400001 	ldr	x1, [x0]
ffffffffea810640:	f9000433 	str	x19, [x1, #8]
	list->prev = item;
ffffffffea810644:	f9000013 	str	x19, [x0]
ffffffffea810648:	17ffffdb 	b	ffffffffea8105b4 <pmm_add_arena+0x6c>
ffffffffea81064c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810650 <pmm_alloc_pages>:
{
ffffffffea810650:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea810654:	910003fd 	mov	x29, sp
ffffffffea810658:	f9000ff4 	str	x20, [sp, #24]
ffffffffea81065c:	2a0003f4 	mov	w20, w0
    if (count == 0)
ffffffffea810660:	350000a0 	cbnz	w0, ffffffffea810674 <pmm_alloc_pages+0x24>
}
ffffffffea810664:	2a1403e0 	mov	w0, w20
ffffffffea810668:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea81066c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea810670:	d65f03c0 	ret
ffffffffea810674:	f9000bb3 	str	x19, [x29, #16]
ffffffffea810678:	aa0103f3 	mov	x19, x1
ffffffffea81067c:	f90013b5 	str	x21, [x29, #32]
ffffffffea810680:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea810684:	90000055 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea810688:	913b02a0 	add	x0, x21, #0xec0
ffffffffea81068c:	97ffd497 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810690:	90000048 	adrp	x8, ffffffffea818000 <_mem_phys_base>
ffffffffea810694:	913ac108 	add	x8, x8, #0xeb0
    uint allocated = 0;
ffffffffea810698:	52800002 	mov	w2, #0x0                   	// #0
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea81069c:	f9400505 	ldr	x5, [x8, #8]
ffffffffea8106a0:	eb0800bf 	cmp	x5, x8
ffffffffea8106a4:	540005e0 	b.eq	ffffffffea810760 <pmm_alloc_pages+0x110>  // b.none
        while (allocated < count) {
ffffffffea8106a8:	6b02029f 	cmp	w20, w2
ffffffffea8106ac:	540003c9 	b.ls	ffffffffea810724 <pmm_alloc_pages+0xd4>  // b.plast
	if (list->next != list) {
ffffffffea8106b0:	f94024a0 	ldr	x0, [x5, #72]
            vm_page_t *page = list_remove_head_type(&a->free_list, vm_page_t, node);
ffffffffea8106b4:	910100a7 	add	x7, x5, #0x40
ffffffffea8106b8:	eb07001f 	cmp	x0, x7
ffffffffea8106bc:	540003a0 	b.eq	ffffffffea810730 <pmm_alloc_pages+0xe0>  // b.none
ffffffffea8106c0:	f94018a3 	ldr	x3, [x5, #48]
ffffffffea8106c4:	d1000463 	sub	x3, x3, #0x1
ffffffffea8106c8:	14000005 	b	ffffffffea8106dc <pmm_alloc_pages+0x8c>
ffffffffea8106cc:	f94024a0 	ldr	x0, [x5, #72]
ffffffffea8106d0:	eb07001f 	cmp	x0, x7
ffffffffea8106d4:	54000320 	b.eq	ffffffffea810738 <pmm_alloc_pages+0xe8>  // b.none
ffffffffea8106d8:	aa0603e3 	mov	x3, x6
	item->next->prev = item->prev;
ffffffffea8106dc:	a9400404 	ldp	x4, x1, [x0]
            allocated++;
ffffffffea8106e0:	11000442 	add	w2, w2, #0x1
ffffffffea8106e4:	d1000466 	sub	x6, x3, #0x1
        while (allocated < count) {
ffffffffea8106e8:	6b02029f 	cmp	w20, w2
ffffffffea8106ec:	f9000024 	str	x4, [x1]
	item->prev->next = item->next;
ffffffffea8106f0:	f9400004 	ldr	x4, [x0]
ffffffffea8106f4:	f9000481 	str	x1, [x4, #8]
	item->prev = item->next = 0;
ffffffffea8106f8:	f900001f 	str	xzr, [x0]
            page->flags |= VM_PAGE_FLAG_NONFREE;
ffffffffea8106fc:	39404001 	ldrb	w1, [x0, #16]
ffffffffea810700:	32000021 	orr	w1, w1, #0x1
ffffffffea810704:	39004001 	strb	w1, [x0, #16]
	item->prev = list->prev;
ffffffffea810708:	f9400261 	ldr	x1, [x19]
	item->next = list;
ffffffffea81070c:	a9004c01 	stp	x1, x19, [x0]
	list->prev->next = item;
ffffffffea810710:	f9400261 	ldr	x1, [x19]
ffffffffea810714:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea810718:	f9000260 	str	x0, [x19]
        while (allocated < count) {
ffffffffea81071c:	54fffd81 	b.ne	ffffffffea8106cc <pmm_alloc_pages+0x7c>  // b.any
ffffffffea810720:	f90018a3 	str	x3, [x5, #48]
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810724:	f94004a5 	ldr	x5, [x5, #8]
ffffffffea810728:	eb0800bf 	cmp	x5, x8
ffffffffea81072c:	54fffbe1 	b.ne	ffffffffea8106a8 <pmm_alloc_pages+0x58>  // b.any
	if (list->next != list) {
ffffffffea810730:	2a0203f4 	mov	w20, w2
ffffffffea810734:	14000003 	b	ffffffffea810740 <pmm_alloc_pages+0xf0>
            allocated++;
ffffffffea810738:	2a0203f4 	mov	w20, w2
ffffffffea81073c:	f90018a3 	str	x3, [x5, #48]
    mutex_release(&lock);
ffffffffea810740:	913b02a0 	add	x0, x21, #0xec0
ffffffffea810744:	97ffd495 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea810748:	2a1403e0 	mov	w0, w20
    mutex_release(&lock);
ffffffffea81074c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea810750:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea810754:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea810758:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea81075c:	d65f03c0 	ret
    uint allocated = 0;
ffffffffea810760:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea810764:	17fffff7 	b	ffffffffea810740 <pmm_alloc_pages+0xf0>

ffffffffea810768 <pmm_alloc_range>:
{
ffffffffea810768:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea81076c:	910003fd 	mov	x29, sp
ffffffffea810770:	f90013f5 	str	x21, [sp, #32]
ffffffffea810774:	2a0103f5 	mov	w21, w1
    if (count == 0)
ffffffffea810778:	350000a1 	cbnz	w1, ffffffffea81078c <pmm_alloc_range+0x24>
}
ffffffffea81077c:	2a1503e0 	mov	w0, w21
ffffffffea810780:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea810784:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea810788:	d65f03c0 	ret
ffffffffea81078c:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea810790:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea810794:	f90017b6 	str	x22, [x29, #40]
ffffffffea810798:	aa0203f4 	mov	x20, x2
    address = ROUNDDOWN(address, PAGE_SIZE);
ffffffffea81079c:	9274cc13 	and	x19, x0, #0xfffffffffffff000
ffffffffea8107a0:	90000056 	adrp	x22, ffffffffea818000 <_mem_phys_base>
ffffffffea8107a4:	913b02c0 	add	x0, x22, #0xec0
ffffffffea8107a8:	97ffd450 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8107ac:	9000004a 	adrp	x10, ffffffffea818000 <_mem_phys_base>
ffffffffea8107b0:	913ac14a 	add	x10, x10, #0xeb0
    uint allocated = 0;
ffffffffea8107b4:	52800003 	mov	w3, #0x0                   	// #0
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8107b8:	f9400549 	ldr	x9, [x10, #8]
ffffffffea8107bc:	eb0a013f 	cmp	x9, x10
ffffffffea8107c0:	54000640 	b.eq	ffffffffea810888 <pmm_alloc_range+0x120>  // b.none
ffffffffea8107c4:	d503201f 	nop
        while (allocated < count && ADDRESS_IN_ARENA(address, a)) {
ffffffffea8107c8:	6b0302bf 	cmp	w21, w3
ffffffffea8107cc:	54000709 	b.ls	ffffffffea8108ac <pmm_alloc_range+0x144>  // b.plast
ffffffffea8107d0:	f9401124 	ldr	x4, [x9, #32]
ffffffffea8107d4:	eb13009f 	cmp	x4, x19
ffffffffea8107d8:	540006c8 	b.hi	ffffffffea8108b0 <pmm_alloc_range+0x148>  // b.pmore
ffffffffea8107dc:	f9401527 	ldr	x7, [x9, #40]
ffffffffea8107e0:	8b070087 	add	x7, x4, x7
ffffffffea8107e4:	d10004e7 	sub	x7, x7, #0x1
ffffffffea8107e8:	eb1300ff 	cmp	x7, x19
ffffffffea8107ec:	54000623 	b.cc	ffffffffea8108b0 <pmm_alloc_range+0x148>  // b.lo, b.ul, b.last
            size_t index = (address - a->base) / PAGE_SIZE;
ffffffffea8107f0:	cb040260 	sub	x0, x19, x4
            vm_page_t *page = &a->page_array[index];
ffffffffea8107f4:	f9401d28 	ldr	x8, [x9, #56]
            size_t index = (address - a->base) / PAGE_SIZE;
ffffffffea8107f8:	d34cfc00 	lsr	x0, x0, #12
            vm_page_t *page = &a->page_array[index];
ffffffffea8107fc:	8b000400 	add	x0, x0, x0, lsl #1
ffffffffea810800:	8b000d00 	add	x0, x8, x0, lsl #3
            if (page->flags & VM_PAGE_FLAG_NONFREE) {
ffffffffea810804:	39404001 	ldrb	w1, [x0, #16]
ffffffffea810808:	37000541 	tbnz	w1, #0, ffffffffea8108b0 <pmm_alloc_range+0x148>
ffffffffea81080c:	f9401925 	ldr	x5, [x9, #48]
ffffffffea810810:	14000007 	b	ffffffffea81082c <pmm_alloc_range+0xc4>
        while (allocated < count && ADDRESS_IN_ARENA(address, a)) {
ffffffffea810814:	eb04027f 	cmp	x19, x4
ffffffffea810818:	54000543 	b.cc	ffffffffea8108c0 <pmm_alloc_range+0x158>  // b.lo, b.ul, b.last
ffffffffea81081c:	eb07027f 	cmp	x19, x7
ffffffffea810820:	54000508 	b.hi	ffffffffea8108c0 <pmm_alloc_range+0x158>  // b.pmore
            if (page->flags & VM_PAGE_FLAG_NONFREE) {
ffffffffea810824:	39404001 	ldrb	w1, [x0, #16]
ffffffffea810828:	370004c1 	tbnz	w1, #0, ffffffffea8108c0 <pmm_alloc_range+0x158>
	item->next->prev = item->prev;
ffffffffea81082c:	a9400806 	ldp	x6, x2, [x0]
            address += PAGE_SIZE;
ffffffffea810830:	91400673 	add	x19, x19, #0x1, lsl #12
            size_t index = (address - a->base) / PAGE_SIZE;
ffffffffea810834:	cb040261 	sub	x1, x19, x4
            allocated++;
ffffffffea810838:	11000463 	add	w3, w3, #0x1
        while (allocated < count && ADDRESS_IN_ARENA(address, a)) {
ffffffffea81083c:	6b0302bf 	cmp	w21, w3
            a->free_count--;
ffffffffea810840:	d10004a5 	sub	x5, x5, #0x1
ffffffffea810844:	f9000046 	str	x6, [x2]
            size_t index = (address - a->base) / PAGE_SIZE;
ffffffffea810848:	d34cfc21 	lsr	x1, x1, #12
	item->prev->next = item->next;
ffffffffea81084c:	f9400006 	ldr	x6, [x0]
            vm_page_t *page = &a->page_array[index];
ffffffffea810850:	8b010421 	add	x1, x1, x1, lsl #1
ffffffffea810854:	f90004c2 	str	x2, [x6, #8]
	item->prev = item->next = 0;
ffffffffea810858:	f900001f 	str	xzr, [x0]
            page->flags |= VM_PAGE_FLAG_NONFREE;
ffffffffea81085c:	39404002 	ldrb	w2, [x0, #16]
ffffffffea810860:	32000042 	orr	w2, w2, #0x1
ffffffffea810864:	39004002 	strb	w2, [x0, #16]
	item->prev = list->prev;
ffffffffea810868:	f9400282 	ldr	x2, [x20]
	item->next = list;
ffffffffea81086c:	a9005002 	stp	x2, x20, [x0]
	list->prev->next = item;
ffffffffea810870:	f9400282 	ldr	x2, [x20]
ffffffffea810874:	f9000440 	str	x0, [x2, #8]
	list->prev = item;
ffffffffea810878:	f9000280 	str	x0, [x20]
            vm_page_t *page = &a->page_array[index];
ffffffffea81087c:	8b010d00 	add	x0, x8, x1, lsl #3
        while (allocated < count && ADDRESS_IN_ARENA(address, a)) {
ffffffffea810880:	54fffca1 	b.ne	ffffffffea810814 <pmm_alloc_range+0xac>  // b.any
ffffffffea810884:	f9001925 	str	x5, [x9, #48]
    return allocated;
ffffffffea810888:	2a0303f5 	mov	w21, w3
    mutex_release(&lock);
ffffffffea81088c:	913b02c0 	add	x0, x22, #0xec0
ffffffffea810890:	97ffd442 	bl	ffffffffea805998 <mutex_release>
    return allocated;
ffffffffea810894:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea810898:	2a1503e0 	mov	w0, w21
ffffffffea81089c:	f94013f5 	ldr	x21, [sp, #32]
    return allocated;
ffffffffea8108a0:	a94153b3 	ldp	x19, x20, [x29, #16]
}
ffffffffea8108a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8108a8:	d65f03c0 	ret
        if (allocated == count)
ffffffffea8108ac:	54fffee0 	b.eq	ffffffffea810888 <pmm_alloc_range+0x120>  // b.none
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8108b0:	f9400529 	ldr	x9, [x9, #8]
ffffffffea8108b4:	eb0a013f 	cmp	x9, x10
ffffffffea8108b8:	54fff881 	b.ne	ffffffffea8107c8 <pmm_alloc_range+0x60>  // b.any
ffffffffea8108bc:	17fffff3 	b	ffffffffea810888 <pmm_alloc_range+0x120>
ffffffffea8108c0:	f9001925 	str	x5, [x9, #48]
ffffffffea8108c4:	f9400529 	ldr	x9, [x9, #8]
ffffffffea8108c8:	eb0a013f 	cmp	x9, x10
ffffffffea8108cc:	54fff7e1 	b.ne	ffffffffea8107c8 <pmm_alloc_range+0x60>  // b.any
ffffffffea8108d0:	17ffffee 	b	ffffffffea810888 <pmm_alloc_range+0x120>
ffffffffea8108d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8108d8 <pmm_free>:
{
ffffffffea8108d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8108dc:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8108e0:	910003fd 	mov	x29, sp
ffffffffea8108e4:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8108e8:	aa0003f3 	mov	x19, x0
ffffffffea8108ec:	f90013f5 	str	x21, [sp, #32]
ffffffffea8108f0:	90000055 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea8108f4:	913b02a0 	add	x0, x21, #0xec0
ffffffffea8108f8:	97ffd3fc 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
        list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8108fc:	90000044 	adrp	x4, ffffffffea818000 <_mem_phys_base>
ffffffffea810900:	913ac084 	add	x4, x4, #0xeb0
    uint count = 0;
ffffffffea810904:	52800014 	mov	w20, #0x0                   	// #0
	return (list->next == list) ? true : false;
ffffffffea810908:	f9400662 	ldr	x2, [x19, #8]
    while (!list_is_empty(list)) {
ffffffffea81090c:	eb02027f 	cmp	x19, x2
ffffffffea810910:	540004c0 	b.eq	ffffffffea8109a8 <pmm_free+0xd0>  // b.none
	item->next->prev = item->prev;
ffffffffea810914:	a9400041 	ldp	x1, x0, [x2]
ffffffffea810918:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea81091c:	f9400041 	ldr	x1, [x2]
ffffffffea810920:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea810924:	a9007c5f 	stp	xzr, xzr, [x2]
        list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810928:	f9400480 	ldr	x0, [x4, #8]
ffffffffea81092c:	eb04001f 	cmp	x0, x4
ffffffffea810930:	540000a1 	b.ne	ffffffffea810944 <pmm_free+0x6c>  // b.any
ffffffffea810934:	17fffff5 	b	ffffffffea810908 <pmm_free+0x30>
ffffffffea810938:	f9400400 	ldr	x0, [x0, #8]
ffffffffea81093c:	eb04001f 	cmp	x0, x4
ffffffffea810940:	54fffe40 	b.eq	ffffffffea810908 <pmm_free+0x30>  // b.none
            if (PAGE_BELONGS_TO_ARENA(page, a)) {
ffffffffea810944:	f9401c03 	ldr	x3, [x0, #56]
ffffffffea810948:	eb02007f 	cmp	x3, x2
ffffffffea81094c:	54ffff68 	b.hi	ffffffffea810938 <pmm_free+0x60>  // b.pmore
ffffffffea810950:	f9401401 	ldr	x1, [x0, #40]
ffffffffea810954:	d34cfc21 	lsr	x1, x1, #12
ffffffffea810958:	8b010421 	add	x1, x1, x1, lsl #1
ffffffffea81095c:	8b010c61 	add	x1, x3, x1, lsl #3
ffffffffea810960:	eb02003f 	cmp	x1, x2
ffffffffea810964:	54fffea9 	b.ls	ffffffffea810938 <pmm_free+0x60>  // b.plast
                page->flags &= ~VM_PAGE_FLAG_NONFREE;
ffffffffea810968:	39404043 	ldrb	w3, [x2, #16]
                list_add_head(&a->free_list, &page->node);
ffffffffea81096c:	91010005 	add	x5, x0, #0x40
                a->free_count++;
ffffffffea810970:	f9401801 	ldr	x1, [x0, #48]
                count++;
ffffffffea810974:	11000694 	add	w20, w20, #0x1
                page->flags &= ~VM_PAGE_FLAG_NONFREE;
ffffffffea810978:	121f7863 	and	w3, w3, #0xfffffffe
ffffffffea81097c:	39004043 	strb	w3, [x2, #16]
                a->free_count++;
ffffffffea810980:	91000421 	add	x1, x1, #0x1
	item->next = list->next;
ffffffffea810984:	f9402403 	ldr	x3, [x0, #72]
ffffffffea810988:	a9000c45 	stp	x5, x3, [x2]
	list->next->prev = item;
ffffffffea81098c:	f9402403 	ldr	x3, [x0, #72]
ffffffffea810990:	f9000062 	str	x2, [x3]
	list->next = item;
ffffffffea810994:	f9002402 	str	x2, [x0, #72]
ffffffffea810998:	f9001801 	str	x1, [x0, #48]
	return (list->next == list) ? true : false;
ffffffffea81099c:	f9400662 	ldr	x2, [x19, #8]
    while (!list_is_empty(list)) {
ffffffffea8109a0:	eb02027f 	cmp	x19, x2
ffffffffea8109a4:	54fffb81 	b.ne	ffffffffea810914 <pmm_free+0x3c>  // b.any
    mutex_release(&lock);
ffffffffea8109a8:	913b02a0 	add	x0, x21, #0xec0
ffffffffea8109ac:	97ffd3fb 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea8109b0:	2a1403e0 	mov	w0, w20
ffffffffea8109b4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8109b8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8109bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8109c0:	d65f03c0 	ret
ffffffffea8109c4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8109c8 <pmm_free_page>:
{
ffffffffea8109c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea8109cc:	aa0003e1 	mov	x1, x0
ffffffffea8109d0:	910003fd 	mov	x29, sp
	item->next = list->next;
ffffffffea8109d4:	910043a2 	add	x2, x29, #0x10
ffffffffea8109d8:	a9000822 	stp	x2, x2, [x1]
    return pmm_free(&list);
ffffffffea8109dc:	aa0203e0 	mov	x0, x2
	list->next = item;
ffffffffea8109e0:	a90107a1 	stp	x1, x1, [x29, #16]
ffffffffea8109e4:	97ffffbd 	bl	ffffffffea8108d8 <pmm_free>
}
ffffffffea8109e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8109ec:	d65f03c0 	ret

ffffffffea8109f0 <pmm_alloc_kpages>:
    if (count == 0)
ffffffffea8109f0:	340001e0 	cbz	w0, ffffffffea810a2c <pmm_alloc_kpages+0x3c>
{
ffffffffea8109f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea8109f8:	aa0103e3 	mov	x3, x1
ffffffffea8109fc:	52800181 	mov	w1, #0xc                   	// #12
ffffffffea810a00:	910003fd 	mov	x29, sp
ffffffffea810a04:	910063a2 	add	x2, x29, #0x18
ffffffffea810a08:	97fffe14 	bl	ffffffffea810258 <pmm_alloc_contiguous.part.0>
    if (alloc_count == 0)
ffffffffea810a0c:	340000a0 	cbz	w0, ffffffffea810a20 <pmm_alloc_kpages+0x30>
    return paddr_to_kvaddr(pa);
ffffffffea810a10:	f9400fa0 	ldr	x0, [x29, #24]
ffffffffea810a14:	94000067 	bl	ffffffffea810bb0 <paddr_to_kvaddr>
}
ffffffffea810a18:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea810a1c:	d65f03c0 	ret
        return NULL;
ffffffffea810a20:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea810a24:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea810a28:	d65f03c0 	ret
        return NULL;
ffffffffea810a2c:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea810a30:	d65f03c0 	ret
ffffffffea810a34:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810a38 <pmm_alloc_contiguous>:
{
ffffffffea810a38:	12001c21 	and	w1, w1, #0xff
    if (count == 0)
ffffffffea810a3c:	34000040 	cbz	w0, ffffffffea810a44 <pmm_alloc_contiguous+0xc>
ffffffffea810a40:	17fffe06 	b	ffffffffea810258 <pmm_alloc_contiguous.part.0>
}
ffffffffea810a44:	d65f03c0 	ret

ffffffffea810a48 <mark_pages_in_use>:
extern int _end;

/* mark the physical pages backing a range of virtual as in use.
 * allocate the physical pages and throw them away */
static void mark_pages_in_use(vaddr_t va, size_t len)
{
ffffffffea810a48:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!

    struct list_node list;
    list_initialize(&list);

    /* make sure we are inclusive of all of the pages in the address range */
    len = PAGE_ALIGN(len + (va & (PAGE_SIZE - 1)));
ffffffffea810a4c:	913ffc21 	add	x1, x1, #0xfff
{
ffffffffea810a50:	910003fd 	mov	x29, sp
ffffffffea810a54:	f9000ff4 	str	x20, [sp, #24]
    len = PAGE_ALIGN(len + (va & (PAGE_SIZE - 1)));
ffffffffea810a58:	92402c14 	and	x20, x0, #0xfff
{
ffffffffea810a5c:	f90017f6 	str	x22, [sp, #40]
	list->prev = list->next = list;
ffffffffea810a60:	910143b6 	add	x22, x29, #0x50
ffffffffea810a64:	a9055bb6 	stp	x22, x22, [x29, #80]
    len = PAGE_ALIGN(len + (va & (PAGE_SIZE - 1)));
ffffffffea810a68:	8b010294 	add	x20, x20, x1
    va = ROUNDDOWN(va, PAGE_SIZE);

    LTRACEF("aligned va 0x%lx, len 0x%zx\n", va, len);

    for (size_t offset = 0; offset < len; offset += PAGE_SIZE) {
ffffffffea810a6c:	f274ce94 	ands	x20, x20, #0xfffffffffffff000
ffffffffea810a70:	540002e0 	b.eq	ffffffffea810acc <mark_pages_in_use+0x84>  // b.none
ffffffffea810a74:	f90013b5 	str	x21, [x29, #32]
ffffffffea810a78:	9274cc15 	and	x21, x0, #0xfffffffffffff000
ffffffffea810a7c:	f9001bb7 	str	x23, [x29, #48]
ffffffffea810a80:	aa1e03f7 	mov	x23, x30
ffffffffea810a84:	f9000bb3 	str	x19, [x29, #16]
ffffffffea810a88:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea810a8c:	d503201f 	nop
        uint flags;
        paddr_t pa;

        status_t err = arch_mmu_query(va + offset, &pa, &flags);
ffffffffea810a90:	910113a2 	add	x2, x29, #0x44
ffffffffea810a94:	910123a1 	add	x1, x29, #0x48
ffffffffea810a98:	8b1302a0 	add	x0, x21, x19
ffffffffea810a9c:	97ffcacd 	bl	ffffffffea8035d0 <arch_mmu_query>
        if (err >= 0) {
ffffffffea810aa0:	37f801e0 	tbnz	w0, #31, ffffffffea810adc <mark_pages_in_use+0x94>
            //LTRACEF("va 0x%x, pa 0x%x, flags 0x%x, err %d\n", va + offset, pa, flags, err);

            /* alloate the range, throw the results away */
            pmm_alloc_range(pa, 1, &list);
ffffffffea810aa4:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea810aa8:	aa1603e2 	mov	x2, x22
ffffffffea810aac:	52800021 	mov	w1, #0x1                   	// #1
    for (size_t offset = 0; offset < len; offset += PAGE_SIZE) {
ffffffffea810ab0:	91400673 	add	x19, x19, #0x1, lsl #12
            pmm_alloc_range(pa, 1, &list);
ffffffffea810ab4:	97ffff2d 	bl	ffffffffea810768 <pmm_alloc_range>
    for (size_t offset = 0; offset < len; offset += PAGE_SIZE) {
ffffffffea810ab8:	eb13029f 	cmp	x20, x19
ffffffffea810abc:	54fffea8 	b.hi	ffffffffea810a90 <mark_pages_in_use+0x48>  // b.pmore
ffffffffea810ac0:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea810ac4:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea810ac8:	f9401bb7 	ldr	x23, [x29, #48]
        } else {
            panic("Could not find pa for va 0x%lx\n", va);
        }
    }
}
ffffffffea810acc:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea810ad0:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea810ad4:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea810ad8:	d65f03c0 	ret
            panic("Could not find pa for va 0x%lx\n", va);
ffffffffea810adc:	f0000021 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea810ae0:	aa1503e2 	mov	x2, x21
ffffffffea810ae4:	911b2021 	add	x1, x1, #0x6c8
ffffffffea810ae8:	aa1703e0 	mov	x0, x23
ffffffffea810aec:	940003c7 	bl	ffffffffea811a08 <_panic>

ffffffffea810af0 <vm_init_preheap>:

static void vm_init_preheap(uint level)
{
ffffffffea810af0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    LTRACE_ENTRY;

    /* mark all of the kernel pages in use */
    LTRACEF("marking all kernel pages as used\n");
    mark_pages_in_use((vaddr_t)&_start, ((uintptr_t)&_end - (uintptr_t)&_start));
ffffffffea810af4:	90ffff80 	adrp	x0, ffffffffea800000 <_start>
ffffffffea810af8:	b0000261 	adrp	x1, ffffffffea85d000 <rb_data+0x18>
ffffffffea810afc:	91000000 	add	x0, x0, #0x0
ffffffffea810b00:	9104a021 	add	x1, x1, #0x128
{
ffffffffea810b04:	910003fd 	mov	x29, sp
    mark_pages_in_use((vaddr_t)&_start, ((uintptr_t)&_end - (uintptr_t)&_start));
ffffffffea810b08:	cb000021 	sub	x1, x1, x0
ffffffffea810b0c:	97ffffcf 	bl	ffffffffea810a48 <mark_pages_in_use>

    /* mark the physical pages used by the boot time allocator */
    if (boot_alloc_end != boot_alloc_start) {
ffffffffea810b10:	90000041 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea810b14:	90000040 	adrp	x0, ffffffffea818000 <_mem_phys_base>
ffffffffea810b18:	f9475021 	ldr	x1, [x1, #3744]
ffffffffea810b1c:	f9475400 	ldr	x0, [x0, #3752]
ffffffffea810b20:	eb00003f 	cmp	x1, x0
ffffffffea810b24:	54000080 	b.eq	ffffffffea810b34 <vm_init_preheap+0x44>  // b.none
        LTRACEF("marking boot alloc used from 0x%lx to 0x%lx\n", boot_alloc_start, boot_alloc_end);

        mark_pages_in_use(boot_alloc_start, boot_alloc_end - boot_alloc_start);
    }
}
ffffffffea810b28:	a8c17bfd 	ldp	x29, x30, [sp], #16
        mark_pages_in_use(boot_alloc_start, boot_alloc_end - boot_alloc_start);
ffffffffea810b2c:	cb000021 	sub	x1, x1, x0
ffffffffea810b30:	17ffffc6 	b	ffffffffea810a48 <mark_pages_in_use>
}
ffffffffea810b34:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea810b38:	d65f03c0 	ret
ffffffffea810b3c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810b40 <vm_init_postheap>:

static void vm_init_postheap(uint level)
{
ffffffffea810b40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea810b44:	910003fd 	mov	x29, sp
ffffffffea810b48:	f9000bf3 	str	x19, [sp, #16]

    vmm_init();

    /* create vmm regions to cover what is already there from the initial mapping table */
    struct mmu_initial_mapping *map = mmu_initial_mappings;
    while (map->size > 0) {
ffffffffea810b4c:	90000053 	adrp	x19, ffffffffea818000 <_mem_phys_base>
ffffffffea810b50:	91006273 	add	x19, x19, #0x18
    vmm_init();
ffffffffea810b54:	94000037 	bl	ffffffffea810c30 <vmm_init>
    while (map->size > 0) {
ffffffffea810b58:	f9400a62 	ldr	x2, [x19, #16]
ffffffffea810b5c:	b4000242 	cbz	x2, ffffffffea810ba4 <vm_init_postheap+0x64>
ffffffffea810b60:	f9000fb4 	str	x20, [x29, #24]
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY)) {
            vmm_reserve_space(vmm_get_kernel_aspace(), map->name, map->size, map->virt);
ffffffffea810b64:	b0000274 	adrp	x20, ffffffffea85d000 <rb_data+0x18>
ffffffffea810b68:	91034294 	add	x20, x20, #0xd0
ffffffffea810b6c:	14000004 	b	ffffffffea810b7c <vm_init_postheap+0x3c>
        }

        map++;
ffffffffea810b70:	9100a273 	add	x19, x19, #0x28
    while (map->size > 0) {
ffffffffea810b74:	f9400a62 	ldr	x2, [x19, #16]
ffffffffea810b78:	b4000142 	cbz	x2, ffffffffea810ba0 <vm_init_postheap+0x60>
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY)) {
ffffffffea810b7c:	b9401a60 	ldr	w0, [x19, #24]
ffffffffea810b80:	3707ff80 	tbnz	w0, #0, ffffffffea810b70 <vm_init_postheap+0x30>
            vmm_reserve_space(vmm_get_kernel_aspace(), map->name, map->size, map->virt);
ffffffffea810b84:	f9400663 	ldr	x3, [x19, #8]
        map++;
ffffffffea810b88:	9100a273 	add	x19, x19, #0x28
            vmm_reserve_space(vmm_get_kernel_aspace(), map->name, map->size, map->virt);
ffffffffea810b8c:	f85f8261 	ldur	x1, [x19, #-8]
ffffffffea810b90:	aa1403e0 	mov	x0, x20
ffffffffea810b94:	94000107 	bl	ffffffffea810fb0 <vmm_reserve_space>
    while (map->size > 0) {
ffffffffea810b98:	f9400a62 	ldr	x2, [x19, #16]
ffffffffea810b9c:	b5ffff02 	cbnz	x2, ffffffffea810b7c <vm_init_postheap+0x3c>
ffffffffea810ba0:	f9400fb4 	ldr	x20, [x29, #24]
    }
}
ffffffffea810ba4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea810ba8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea810bac:	d65f03c0 	ret

ffffffffea810bb0 <paddr_to_kvaddr>:

void *paddr_to_kvaddr(paddr_t pa)
{
    /* slow path to do reverse lookup */
    struct mmu_initial_mapping *map = mmu_initial_mappings;
    while (map->size > 0) {
ffffffffea810bb0:	90000041 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea810bb4:	91006021 	add	x1, x1, #0x18
ffffffffea810bb8:	f9400822 	ldr	x2, [x1, #16]
ffffffffea810bbc:	b40001a2 	cbz	x2, ffffffffea810bf0 <paddr_to_kvaddr+0x40>
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY) &&
ffffffffea810bc0:	b9401823 	ldr	w3, [x1, #24]
ffffffffea810bc4:	37000103 	tbnz	w3, #0, ffffffffea810be4 <paddr_to_kvaddr+0x34>
            pa >= map->phys &&
ffffffffea810bc8:	f9400024 	ldr	x4, [x1]
            pa <= map->phys + map->size - 1) {
ffffffffea810bcc:	d1000483 	sub	x3, x4, #0x1
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY) &&
ffffffffea810bd0:	eb00009f 	cmp	x4, x0
            pa <= map->phys + map->size - 1) {
ffffffffea810bd4:	8b020062 	add	x2, x3, x2
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY) &&
ffffffffea810bd8:	54000068 	b.hi	ffffffffea810be4 <paddr_to_kvaddr+0x34>  // b.pmore
            pa >= map->phys &&
ffffffffea810bdc:	eb00005f 	cmp	x2, x0
ffffffffea810be0:	540000c2 	b.cs	ffffffffea810bf8 <paddr_to_kvaddr+0x48>  // b.hs, b.nlast
            return (void *)(map->virt + (pa - map->phys));
        }
        map++;
ffffffffea810be4:	9100a021 	add	x1, x1, #0x28
    while (map->size > 0) {
ffffffffea810be8:	f9400822 	ldr	x2, [x1, #16]
ffffffffea810bec:	b5fffea2 	cbnz	x2, ffffffffea810bc0 <paddr_to_kvaddr+0x10>
    }
    return NULL;
ffffffffea810bf0:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea810bf4:	d65f03c0 	ret
            return (void *)(map->virt + (pa - map->phys));
ffffffffea810bf8:	f9400421 	ldr	x1, [x1, #8]
ffffffffea810bfc:	cb040024 	sub	x4, x1, x4
ffffffffea810c00:	8b000080 	add	x0, x4, x0
}
ffffffffea810c04:	d65f03c0 	ret

ffffffffea810c08 <kvaddr_to_paddr>:

paddr_t kvaddr_to_paddr(void *ptr)
{
ffffffffea810c08:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    status_t rc;
    paddr_t  pa;

    rc = arch_mmu_query((vaddr_t)ptr, &pa, NULL);
ffffffffea810c0c:	d2800002 	mov	x2, #0x0                   	// #0
{
ffffffffea810c10:	910003fd 	mov	x29, sp
    rc = arch_mmu_query((vaddr_t)ptr, &pa, NULL);
ffffffffea810c14:	910063a1 	add	x1, x29, #0x18
ffffffffea810c18:	97ffca6e 	bl	ffffffffea8035d0 <arch_mmu_query>
    if (rc)
        return (paddr_t) NULL;
    return pa;
ffffffffea810c1c:	7100001f 	cmp	w0, #0x0
ffffffffea810c20:	f9400fa1 	ldr	x1, [x29, #24]
}
ffffffffea810c24:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea810c28:	9a9f0020 	csel	x0, x1, xzr, eq  // eq = none
ffffffffea810c2c:	d65f03c0 	ret

ffffffffea810c30 <vmm_init>:
static mutex_t vmm_lock = MUTEX_INITIAL_VALUE(vmm_lock);

vmm_aspace_t _kernel_aspace;

void vmm_init(void)
{
ffffffffea810c30:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    /* initialize the kernel address space */
    strlcpy(_kernel_aspace.name, "kernel", sizeof(_kernel_aspace.name));
ffffffffea810c34:	d2800402 	mov	x2, #0x20                  	// #32
ffffffffea810c38:	f0000021 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea810c3c:	b0000260 	adrp	x0, ffffffffea85d000 <rb_data+0x18>
{
ffffffffea810c40:	910003fd 	mov	x29, sp
    strlcpy(_kernel_aspace.name, "kernel", sizeof(_kernel_aspace.name));
ffffffffea810c44:	911c0021 	add	x1, x1, #0x700
ffffffffea810c48:	91038000 	add	x0, x0, #0xe0
ffffffffea810c4c:	94000a13 	bl	ffffffffea813498 <strlcpy>
	item->next = list->next;
ffffffffea810c50:	90000041 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea810c54:	913be021 	add	x1, x1, #0xef8
    _kernel_aspace.base = KERNEL_ASPACE_BASE,
ffffffffea810c58:	b0000264 	adrp	x4, ffffffffea85d000 <rb_data+0x18>
ffffffffea810c5c:	91034080 	add	x0, x4, #0xd0
ffffffffea810c60:	b2638be6 	mov	x6, #0xffffffffe0000000    	// #-536870912
    _kernel_aspace.size = KERNEL_ASPACE_SIZE,
ffffffffea810c64:	d2a40005 	mov	x5, #0x20000000            	// #536870912
ffffffffea810c68:	f9400423 	ldr	x3, [x1, #8]
	list->prev = list->next = list;
ffffffffea810c6c:	b0000262 	adrp	x2, ffffffffea85d000 <rb_data+0x18>
	item->next = list->next;
ffffffffea810c70:	f9000403 	str	x3, [x0, #8]
	list->prev = list->next = list;
ffffffffea810c74:	91046042 	add	x2, x2, #0x118
ffffffffea810c78:	a9039406 	stp	x6, x5, [x0, #56]
ffffffffea810c7c:	a9048802 	stp	x2, x2, [x0, #72]
	item->prev = list;
ffffffffea810c80:	f9006881 	str	x1, [x4, #208]
	list->next->prev = item;
ffffffffea810c84:	f9000060 	str	x0, [x3]
	list->next = item;
ffffffffea810c88:	f9000420 	str	x0, [x1, #8]
    list_initialize(&_kernel_aspace.region_list);

    list_add_head(&aspace_list, &_kernel_aspace.node);
}
ffffffffea810c8c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea810c90:	d65f03c0 	ret
ffffffffea810c94:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810c98 <arch_mmu_pick_spot>:
__WEAK vaddr_t arch_mmu_pick_spot(vaddr_t base, uint prev_region_arch_mmu_flags,
                                  vaddr_t end,  uint next_region_arch_mmu_flags,
                                  vaddr_t align, size_t size, uint arch_mmu_flags)
{
    /* just align it by default */
    return ALIGN(base, align);
ffffffffea810c98:	d1000400 	sub	x0, x0, #0x1
ffffffffea810c9c:	8b040000 	add	x0, x0, x4
ffffffffea810ca0:	cb0403e4 	neg	x4, x4
}
ffffffffea810ca4:	8a040000 	and	x0, x0, x4
ffffffffea810ca8:	d65f03c0 	ret
ffffffffea810cac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810cb0 <alloc_region>:

/* allocate a region structure and stick it in the address space */
static vmm_region_t *alloc_region(vmm_aspace_t *aspace, const char *name, size_t size,
        vaddr_t vaddr, uint8_t align_pow2,
        uint vmm_flags, uint region_flags, uint arch_mmu_flags)
{
ffffffffea810cb0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea810cb4:	910003fd 	mov	x29, sp
ffffffffea810cb8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea810cbc:	aa0303f4 	mov	x20, x3
ffffffffea810cc0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea810cc4:	aa0203f6 	mov	x22, x2
ffffffffea810cc8:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea810ccc:	2a0503f5 	mov	w21, w5
ffffffffea810cd0:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea810cd4:	aa0003f7 	mov	x23, x0
ffffffffea810cd8:	f9002bfb 	str	x27, [sp, #80]
ffffffffea810cdc:	12001c99 	and	w25, w4, #0xff
ffffffffea810ce0:	2a0603fa 	mov	w26, w6
ffffffffea810ce4:	2a0703f8 	mov	w24, w7
    vmm_region_t *r = malloc(sizeof(vmm_region_t));
ffffffffea810ce8:	d2800b00 	mov	x0, #0x58                  	// #88
{
ffffffffea810cec:	aa0103fb 	mov	x27, x1
    vmm_region_t *r = malloc(sizeof(vmm_region_t));
ffffffffea810cf0:	940008d4 	bl	ffffffffea813040 <malloc>
ffffffffea810cf4:	aa0003f3 	mov	x19, x0
    if (!r)
ffffffffea810cf8:	b40006e0 	cbz	x0, ffffffffea810dd4 <alloc_region+0x124>
    strlcpy(r->name, name, sizeof(r->name));
ffffffffea810cfc:	d2800402 	mov	x2, #0x20                  	// #32
ffffffffea810d00:	aa1b03e1 	mov	x1, x27
ffffffffea810d04:	91004000 	add	x0, x0, #0x10
ffffffffea810d08:	940009e4 	bl	ffffffffea813498 <strlcpy>
    list_initialize(&r->page_list);
ffffffffea810d0c:	91012260 	add	x0, x19, #0x48
    r->arch_mmu_flags = arch_mmu_flags;
ffffffffea810d10:	2906627a 	stp	w26, w24, [x19, #48]
    r->size = size;
ffffffffea810d14:	a903da74 	stp	x20, x22, [x19, #56]
	list->prev = list->next = list;
ffffffffea810d18:	a9048260 	stp	x0, x0, [x19, #72]
    vmm_region_t *r = alloc_region_struct(name, vaddr, size, region_flags, arch_mmu_flags);
    if (!r)
        return NULL;

    /* if they ask us for a specific spot, put it there */
    if (vmm_flags & VMM_FLAG_VALLOC_SPECIFIC) {
ffffffffea810d1c:	360006d5 	tbz	w21, #0, ffffffffea810df4 <alloc_region+0x144>
    if (r->size == 0 || !is_region_inside_aspace(aspace, r->base, r->size)) {
ffffffffea810d20:	b4000556 	cbz	x22, ffffffffea810dc8 <alloc_region+0x118>
    if (!is_inside_aspace(aspace, vaddr))
ffffffffea810d24:	f9401ee0 	ldr	x0, [x23, #56]
    return (vaddr >= aspace->base && vaddr <= aspace->base + aspace->size - 1);
ffffffffea810d28:	eb00029f 	cmp	x20, x0
ffffffffea810d2c:	540004e3 	b.cc	ffffffffea810dc8 <alloc_region+0x118>  // b.lo, b.ul, b.last
ffffffffea810d30:	f94022e1 	ldr	x1, [x23, #64]
ffffffffea810d34:	8b010000 	add	x0, x0, x1
ffffffffea810d38:	d1000400 	sub	x0, x0, #0x1
ffffffffea810d3c:	eb00029f 	cmp	x20, x0
ffffffffea810d40:	54000448 	b.hi	ffffffffea810dc8 <alloc_region+0x118>  // b.pmore
    if (vaddr + size - 1 < vaddr)
ffffffffea810d44:	d10006d6 	sub	x22, x22, #0x1
ffffffffea810d48:	8b1402d6 	add	x22, x22, x20
ffffffffea810d4c:	eb16029f 	cmp	x20, x22
ffffffffea810d50:	540003c8 	b.hi	ffffffffea810dc8 <alloc_region+0x118>  // b.pmore
    if (vaddr + size - 1 > aspace->base + aspace->size - 1)
ffffffffea810d54:	eb16001f 	cmp	x0, x22
ffffffffea810d58:	54000383 	b.cc	ffffffffea810dc8 <alloc_region+0x118>  // b.lo, b.ul, b.last
	if (list->next != list) {
ffffffffea810d5c:	f9402ae0 	ldr	x0, [x23, #80]
    last = list_peek_head_type(&aspace->region_list, vmm_region_t, node);
ffffffffea810d60:	910122e2 	add	x2, x23, #0x48
ffffffffea810d64:	f100001f 	cmp	x0, #0x0
ffffffffea810d68:	fa401044 	ccmp	x2, x0, #0x4, ne  // ne = any
ffffffffea810d6c:	54001000 	b.eq	ffffffffea810f6c <alloc_region+0x2bc>  // b.none
    if (!last || r_end < last->base) {
ffffffffea810d70:	f9401c03 	ldr	x3, [x0, #56]
ffffffffea810d74:	eb16007f 	cmp	x3, x22
ffffffffea810d78:	54000fa8 	b.hi	ffffffffea810f6c <alloc_region+0x2bc>  // b.pmore
    list_for_every_entry(&aspace->region_list, last, vmm_region_t, node) {
ffffffffea810d7c:	eb00005f 	cmp	x2, x0
ffffffffea810d80:	54000061 	b.ne	ffffffffea810d8c <alloc_region+0xdc>  // b.any
ffffffffea810d84:	14000011 	b	ffffffffea810dc8 <alloc_region+0x118>
ffffffffea810d88:	f9401c03 	ldr	x3, [x0, #56]
        if (r->base > last->base + last->size - 1) {
ffffffffea810d8c:	f9402001 	ldr	x1, [x0, #64]
ffffffffea810d90:	d1000421 	sub	x1, x1, #0x1
ffffffffea810d94:	8b030021 	add	x1, x1, x3
ffffffffea810d98:	eb01029f 	cmp	x20, x1
ffffffffea810d9c:	54000109 	b.ls	ffffffffea810dbc <alloc_region+0x10c>  // b.plast
ffffffffea810da0:	f9400401 	ldr	x1, [x0, #8]
	if (item->next != list)
ffffffffea810da4:	eb01005f 	cmp	x2, x1
ffffffffea810da8:	54000f80 	b.eq	ffffffffea810f98 <alloc_region+0x2e8>  // b.none
            vmm_region_t *next = list_next_type(&aspace->region_list, &last->node, vmm_region_t, node);
ffffffffea810dac:	b4000f61 	cbz	x1, ffffffffea810f98 <alloc_region+0x2e8>
            if (!next || (r_end < next->base)) {
ffffffffea810db0:	f9401c23 	ldr	x3, [x1, #56]
ffffffffea810db4:	eb16007f 	cmp	x3, x22
ffffffffea810db8:	54000f08 	b.hi	ffffffffea810f98 <alloc_region+0x2e8>  // b.pmore
    list_for_every_entry(&aspace->region_list, last, vmm_region_t, node) {
ffffffffea810dbc:	f9400400 	ldr	x0, [x0, #8]
ffffffffea810dc0:	eb00005f 	cmp	x2, x0
ffffffffea810dc4:	54fffe21 	b.ne	ffffffffea810d88 <alloc_region+0xd8>  // b.any
        vaddr = alloc_spot(aspace, size, align_pow2, arch_mmu_flags, &before);
        LTRACEF("alloc_spot returns 0x%lx, before %p\n", vaddr, before);

        if (vaddr == (vaddr_t)-1) {
            LTRACEF("failed to find spot\n");
            free(r);
ffffffffea810dc8:	aa1303e0 	mov	x0, x19
            return NULL;
ffffffffea810dcc:	d2800013 	mov	x19, #0x0                   	// #0
            free(r);
ffffffffea810dd0:	940008b2 	bl	ffffffffea813098 <free>
        /* add it to the region list */
        list_add_after(before, &r->node);
    }

    return r;
}
ffffffffea810dd4:	aa1303e0 	mov	x0, x19
ffffffffea810dd8:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea810ddc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea810de0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea810de4:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea810de8:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea810dec:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea810df0:	d65f03c0 	ret
    vaddr_t align = 1UL << align_pow2;
ffffffffea810df4:	7100333f 	cmp	w25, #0xc
	if (list->next != list) {
ffffffffea810df8:	f9402af4 	ldr	x20, [x23, #80]
ffffffffea810dfc:	52800180 	mov	w0, #0xc                   	// #12
ffffffffea810e00:	1a802339 	csel	w25, w25, w0, cs  // cs = hs, nlast
                  list_peek_head_type(&aspace->region_list, vmm_region_t, node),
ffffffffea810e04:	910122fb 	add	x27, x23, #0x48
    vaddr_t align = 1UL << align_pow2;
ffffffffea810e08:	d2800020 	mov	x0, #0x1                   	// #1
                  list_peek_head_type(&aspace->region_list, vmm_region_t, node),
ffffffffea810e0c:	f100029f 	cmp	x20, #0x0
    vaddr_t align = 1UL << align_pow2;
ffffffffea810e10:	9ad92019 	lsl	x25, x0, x25
ffffffffea810e14:	f9401efa 	ldr	x26, [x23, #56]
                  list_peek_head_type(&aspace->region_list, vmm_region_t, node),
ffffffffea810e18:	fa541364 	ccmp	x27, x20, #0x4, ne  // ne = any
ffffffffea810e1c:	54000101 	b.ne	ffffffffea810e3c <alloc_region+0x18c>  // b.any
        if (gap_beg == (aspace->base + aspace->size))
ffffffffea810e20:	f94022f5 	ldr	x21, [x23, #64]
ffffffffea810e24:	8b150355 	add	x21, x26, x21
ffffffffea810e28:	eb15035f 	cmp	x26, x21
ffffffffea810e2c:	54fffce0 	b.eq	ffffffffea810dc8 <alloc_region+0x118>  // b.none
        gap_end = aspace->base + aspace->size - 1;
ffffffffea810e30:	d10006b5 	sub	x21, x21, #0x1
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea810e34:	52801003 	mov	w3, #0x80                  	// #128
ffffffffea810e38:	14000006 	b	ffffffffea810e50 <alloc_region+0x1a0>
        if (gap_beg == next->base)
ffffffffea810e3c:	f9401e95 	ldr	x21, [x20, #56]
ffffffffea810e40:	eb1a02bf 	cmp	x21, x26
ffffffffea810e44:	54000260 	b.eq	ffffffffea810e90 <alloc_region+0x1e0>  // b.none
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea810e48:	b9403683 	ldr	w3, [x20, #52]
        gap_end = next->base - 1;
ffffffffea810e4c:	d10006b5 	sub	x21, x21, #0x1
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea810e50:	2a1803e6 	mov	w6, w24
ffffffffea810e54:	aa1603e5 	mov	x5, x22
ffffffffea810e58:	aa1903e4 	mov	x4, x25
ffffffffea810e5c:	aa1503e2 	mov	x2, x21
ffffffffea810e60:	52801001 	mov	w1, #0x80                  	// #128
ffffffffea810e64:	aa1a03e0 	mov	x0, x26
ffffffffea810e68:	97ffff8c 	bl	ffffffffea810c98 <arch_mmu_pick_spot>
    if (*pva < gap_beg)
ffffffffea810e6c:	eb00035f 	cmp	x26, x0
ffffffffea810e70:	54fffac8 	b.hi	ffffffffea810dc8 <alloc_region+0x118>  // b.pmore
    if (*pva < gap_end && ((gap_end - *pva + 1) >= size)) {
ffffffffea810e74:	eb15001f 	cmp	x0, x21
ffffffffea810e78:	540000a2 	b.cs	ffffffffea810e8c <alloc_region+0x1dc>  // b.hs, b.nlast
ffffffffea810e7c:	910006b5 	add	x21, x21, #0x1
ffffffffea810e80:	cb0002b5 	sub	x21, x21, x0
ffffffffea810e84:	eb1502df 	cmp	x22, x21
ffffffffea810e88:	540003e9 	b.ls	ffffffffea810f04 <alloc_region+0x254>  // b.plast
ffffffffea810e8c:	f9402af4 	ldr	x20, [x23, #80]
    list_for_every_entry(&aspace->region_list, r, vmm_region_t, node) {
ffffffffea810e90:	eb14037f 	cmp	x27, x20
ffffffffea810e94:	54fff9a0 	b.eq	ffffffffea810dc8 <alloc_region+0x118>  // b.none
                      list_next_type(&aspace->region_list, &r->node, vmm_region_t, node),
ffffffffea810e98:	f9400680 	ldr	x0, [x20, #8]
ffffffffea810e9c:	a943ea81 	ldp	x1, x26, [x20, #56]
ffffffffea810ea0:	f100001f 	cmp	x0, #0x0
ffffffffea810ea4:	fa401364 	ccmp	x27, x0, #0x4, ne  // ne = any
ffffffffea810ea8:	8b01035a 	add	x26, x26, x1
ffffffffea810eac:	54000500 	b.eq	ffffffffea810f4c <alloc_region+0x29c>  // b.none
        if (gap_beg == next->base)
ffffffffea810eb0:	f9401c02 	ldr	x2, [x0, #56]
ffffffffea810eb4:	eb02035f 	cmp	x26, x2
ffffffffea810eb8:	54000460 	b.eq	ffffffffea810f44 <alloc_region+0x294>  // b.none
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea810ebc:	b9403403 	ldr	w3, [x0, #52]
        gap_end = next->base - 1;
ffffffffea810ec0:	d1000455 	sub	x21, x2, #0x1
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea810ec4:	b9403681 	ldr	w1, [x20, #52]
ffffffffea810ec8:	2a1803e6 	mov	w6, w24
ffffffffea810ecc:	aa1603e5 	mov	x5, x22
ffffffffea810ed0:	aa1903e4 	mov	x4, x25
ffffffffea810ed4:	aa1503e2 	mov	x2, x21
ffffffffea810ed8:	aa1a03e0 	mov	x0, x26
ffffffffea810edc:	97ffff6f 	bl	ffffffffea810c98 <arch_mmu_pick_spot>
    if (*pva < gap_beg)
ffffffffea810ee0:	eb00035f 	cmp	x26, x0
ffffffffea810ee4:	54fff728 	b.hi	ffffffffea810dc8 <alloc_region+0x118>  // b.pmore
    if (*pva < gap_end && ((gap_end - *pva + 1) >= size)) {
ffffffffea810ee8:	eb15001f 	cmp	x0, x21
ffffffffea810eec:	54000282 	b.cs	ffffffffea810f3c <alloc_region+0x28c>  // b.hs, b.nlast
ffffffffea810ef0:	910006a2 	add	x2, x21, #0x1
ffffffffea810ef4:	cb000042 	sub	x2, x2, x0
ffffffffea810ef8:	eb0202df 	cmp	x22, x2
ffffffffea810efc:	54000208 	b.hi	ffffffffea810f3c <alloc_region+0x28c>  // b.pmore
        *before = r ? &r->node : &aspace->region_list;
ffffffffea810f00:	aa1403fb 	mov	x27, x20
	item->next = list->next;
ffffffffea810f04:	f9400761 	ldr	x1, [x27, #8]
ffffffffea810f08:	a900067b 	stp	x27, x1, [x19]
        r->base = (vaddr_t)vaddr;
ffffffffea810f0c:	f9001e60 	str	x0, [x19, #56]
	list->next->prev = item;
ffffffffea810f10:	f9400760 	ldr	x0, [x27, #8]
}
ffffffffea810f14:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea810f18:	f9000013 	str	x19, [x0]
ffffffffea810f1c:	aa1303e0 	mov	x0, x19
	list->next = item;
ffffffffea810f20:	f9000773 	str	x19, [x27, #8]
ffffffffea810f24:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea810f28:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea810f2c:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea810f30:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea810f34:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea810f38:	d65f03c0 	ret
ffffffffea810f3c:	f9400694 	ldr	x20, [x20, #8]
ffffffffea810f40:	17ffffd4 	b	ffffffffea810e90 <alloc_region+0x1e0>
        if (gap_beg == next->base)
ffffffffea810f44:	aa0003f4 	mov	x20, x0
ffffffffea810f48:	17ffffd2 	b	ffffffffea810e90 <alloc_region+0x1e0>
        if (gap_beg == (aspace->base + aspace->size))
ffffffffea810f4c:	a9438af5 	ldp	x21, x2, [x23, #56]
ffffffffea810f50:	8b150042 	add	x2, x2, x21
ffffffffea810f54:	eb1a005f 	cmp	x2, x26
ffffffffea810f58:	54fff380 	b.eq	ffffffffea810dc8 <alloc_region+0x118>  // b.none
        gap_end = aspace->base + aspace->size - 1;
ffffffffea810f5c:	d1000455 	sub	x21, x2, #0x1
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea810f60:	52801003 	mov	w3, #0x80                  	// #128
ffffffffea810f64:	b9403681 	ldr	w1, [x20, #52]
ffffffffea810f68:	17ffffd8 	b	ffffffffea810ec8 <alloc_region+0x218>
	item->next = list->next;
ffffffffea810f6c:	a9000262 	stp	x2, x0, [x19]
	list->next->prev = item;
ffffffffea810f70:	f9000013 	str	x19, [x0]
}
ffffffffea810f74:	aa1303e0 	mov	x0, x19
	list->next = item;
ffffffffea810f78:	f9002af3 	str	x19, [x23, #80]
ffffffffea810f7c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea810f80:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea810f84:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea810f88:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea810f8c:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea810f90:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea810f94:	d65f03c0 	ret
	item->next = list->next;
ffffffffea810f98:	a9000660 	stp	x0, x1, [x19]
	list->next->prev = item;
ffffffffea810f9c:	f9400401 	ldr	x1, [x0, #8]
ffffffffea810fa0:	f9000033 	str	x19, [x1]
	list->next = item;
ffffffffea810fa4:	f9000413 	str	x19, [x0, #8]
ffffffffea810fa8:	17ffff8b 	b	ffffffffea810dd4 <alloc_region+0x124>
ffffffffea810fac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810fb0 <vmm_reserve_space>:

status_t vmm_reserve_space(vmm_aspace_t *aspace, const char *name, size_t size, vaddr_t vaddr)
{
ffffffffea810fb0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea810fb4:	910003fd 	mov	x29, sp
ffffffffea810fb8:	f9000ff4 	str	x20, [sp, #24]
ffffffffea810fbc:	aa0103f4 	mov	x20, x1
    DEBUG_ASSERT(aspace);
    DEBUG_ASSERT(IS_PAGE_ALIGNED(vaddr));
    DEBUG_ASSERT(IS_PAGE_ALIGNED(size));

    if (!name)
        name = "";
ffffffffea810fc0:	f100029f 	cmp	x20, #0x0
ffffffffea810fc4:	b0000021 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea810fc8:	911a4021 	add	x1, x1, #0x690
ffffffffea810fcc:	9a940034 	csel	x20, x1, x20, eq  // eq = none

    if (!aspace)
        return ERR_INVALID_ARGS;
    if (size == 0)
ffffffffea810fd0:	b4000702 	cbz	x2, ffffffffea8110b0 <vmm_reserve_space+0x100>
ffffffffea810fd4:	f9000bb3 	str	x19, [x29, #16]
ffffffffea810fd8:	aa0203f3 	mov	x19, x2
ffffffffea810fdc:	f90013b5 	str	x21, [x29, #32]
ffffffffea810fe0:	aa0303f5 	mov	x21, x3
ffffffffea810fe4:	f9001bb7 	str	x23, [x29, #48]
ffffffffea810fe8:	aa0003f7 	mov	x23, x0
        return NO_ERROR;
    if (!IS_PAGE_ALIGNED(vaddr) || !IS_PAGE_ALIGNED(size))
ffffffffea810fec:	aa030040 	orr	x0, x2, x3
ffffffffea810ff0:	f2402c1f 	tst	x0, #0xfff
ffffffffea810ff4:	54000801 	b.ne	ffffffffea8110f4 <vmm_reserve_space+0x144>  // b.any
        return ERR_INVALID_ARGS;

    if (!is_inside_aspace(aspace, vaddr))
ffffffffea810ff8:	f9401ee1 	ldr	x1, [x23, #56]
        return ERR_OUT_OF_RANGE;
ffffffffea810ffc:	12800480 	mov	w0, #0xffffffdb            	// #-37
    return (vaddr >= aspace->base && vaddr <= aspace->base + aspace->size - 1);
ffffffffea811000:	eb01007f 	cmp	x3, x1
ffffffffea811004:	540005e3 	b.cc	ffffffffea8110c0 <vmm_reserve_space+0x110>  // b.lo, b.ul, b.last
ffffffffea811008:	f94022e2 	ldr	x2, [x23, #64]
ffffffffea81100c:	f90017b6 	str	x22, [x29, #40]
ffffffffea811010:	8b010043 	add	x3, x2, x1
ffffffffea811014:	d1000463 	sub	x3, x3, #0x1
ffffffffea811018:	eb0302bf 	cmp	x21, x3
ffffffffea81101c:	54000608 	b.hi	ffffffffea8110dc <vmm_reserve_space+0x12c>  // b.pmore
    size_t offset = vaddr - aspace->base;
ffffffffea811020:	cb0102a0 	sub	x0, x21, x1
    if (offset + size < offset)
ffffffffea811024:	8b000261 	add	x1, x19, x0
ffffffffea811028:	eb01001f 	cmp	x0, x1
ffffffffea81102c:	54000069 	b.ls	ffffffffea811038 <vmm_reserve_space+0x88>  // b.plast
        size = ULONG_MAX - offset - 1;
ffffffffea811030:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
ffffffffea811034:	cb000033 	sub	x19, x1, x0
    if (offset + size >= aspace->size - 1)
ffffffffea811038:	d1000443 	sub	x3, x2, #0x1
        size = aspace->size - offset;
ffffffffea81103c:	cb000040 	sub	x0, x2, x0
ffffffffea811040:	eb03003f 	cmp	x1, x3
ffffffffea811044:	f0000036 	adrp	x22, ffffffffea818000 <_mem_phys_base>
ffffffffea811048:	913c22d6 	add	x22, x22, #0xf08
ffffffffea81104c:	9a932013 	csel	x19, x0, x19, cs  // cs = hs, nlast
ffffffffea811050:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea811054:	aa1603e0 	mov	x0, x22
ffffffffea811058:	97ffd224 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
    size = trim_to_aspace(aspace, vaddr, size);

    mutex_acquire(&vmm_lock);

    /* lookup how it's already mapped */
    uint arch_mmu_flags = 0;
ffffffffea81105c:	910143a2 	add	x2, x29, #0x50
    arch_mmu_query(vaddr, NULL, &arch_mmu_flags);
ffffffffea811060:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea811064:	aa1503e0 	mov	x0, x21
    uint arch_mmu_flags = 0;
ffffffffea811068:	b81fcc5f 	str	wzr, [x2, #-4]!
    arch_mmu_query(vaddr, NULL, &arch_mmu_flags);
ffffffffea81106c:	97ffc959 	bl	ffffffffea8035d0 <arch_mmu_query>

    /* build a new region structure */
    vmm_region_t *r = alloc_region(aspace, name, size, vaddr, 0, VMM_FLAG_VALLOC_SPECIFIC, VMM_REGION_FLAG_RESERVED, arch_mmu_flags);
ffffffffea811070:	b9404fa7 	ldr	w7, [x29, #76]
ffffffffea811074:	52800026 	mov	w6, #0x1                   	// #1
ffffffffea811078:	aa1303e2 	mov	x2, x19
ffffffffea81107c:	aa1503e3 	mov	x3, x21
ffffffffea811080:	2a0603e5 	mov	w5, w6
ffffffffea811084:	aa1403e1 	mov	x1, x20
ffffffffea811088:	52800004 	mov	w4, #0x0                   	// #0
ffffffffea81108c:	aa1703e0 	mov	x0, x23
ffffffffea811090:	97ffff08 	bl	ffffffffea810cb0 <alloc_region>
ffffffffea811094:	aa0003f3 	mov	x19, x0

    mutex_release(&vmm_lock);
ffffffffea811098:	aa1603e0 	mov	x0, x22
ffffffffea81109c:	97ffd23f 	bl	ffffffffea805998 <mutex_release>
    return r ? NO_ERROR : ERR_NO_MEMORY;
ffffffffea8110a0:	b40001d3 	cbz	x19, ffffffffea8110d8 <vmm_reserve_space+0x128>
ffffffffea8110a4:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8110a8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8110ac:	f9401bb7 	ldr	x23, [x29, #48]
        return NO_ERROR;
ffffffffea8110b0:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea8110b4:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea8110b8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8110bc:	d65f03c0 	ret
ffffffffea8110c0:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8110c4:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea8110c8:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea8110cc:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea8110d0:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8110d4:	d65f03c0 	ret
    return r ? NO_ERROR : ERR_NO_MEMORY;
ffffffffea8110d8:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea8110dc:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8110e0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8110e4:	f9401bb7 	ldr	x23, [x29, #48]
}
ffffffffea8110e8:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea8110ec:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8110f0:	d65f03c0 	ret
        return ERR_INVALID_ARGS;
ffffffffea8110f4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea8110f8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8110fc:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea811100:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea811104:	17ffffec 	b	ffffffffea8110b4 <vmm_reserve_space+0x104>

ffffffffea811108 <vmm_alloc_physical>:

status_t vmm_alloc_physical(vmm_aspace_t *aspace, const char *name, size_t size, void **ptr, uint8_t align_log2, paddr_t paddr, uint vmm_flags, uint arch_mmu_flags)
{
ffffffffea811108:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea81110c:	910003fd 	mov	x29, sp
ffffffffea811110:	f9000bf3 	str	x19, [sp, #16]
ffffffffea811114:	aa0103f3 	mov	x19, x1
    DEBUG_ASSERT(aspace);
    DEBUG_ASSERT(IS_PAGE_ALIGNED(paddr));
    DEBUG_ASSERT(IS_PAGE_ALIGNED(size));

    if (!name)
        name = "";
ffffffffea811118:	f100027f 	cmp	x19, #0x0
ffffffffea81111c:	90000021 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea811120:	911a4021 	add	x1, x1, #0x690
ffffffffea811124:	9a930033 	csel	x19, x1, x19, eq  // eq = none

    if (!aspace)
        return ERR_INVALID_ARGS;
    if (size == 0)
ffffffffea811128:	b40006a2 	cbz	x2, ffffffffea8111fc <vmm_alloc_physical+0xf4>
ffffffffea81112c:	f9000fb4 	str	x20, [x29, #24]
ffffffffea811130:	aa0203f4 	mov	x20, x2
ffffffffea811134:	f9001bb7 	str	x23, [x29, #48]
ffffffffea811138:	aa0503f7 	mov	x23, x5
ffffffffea81113c:	f90027ba 	str	x26, [x29, #72]
ffffffffea811140:	aa0003fa 	mov	x26, x0
        return NO_ERROR;
    if (!IS_PAGE_ALIGNED(paddr) || !IS_PAGE_ALIGNED(size))
ffffffffea811144:	aa050040 	orr	x0, x2, x5
ffffffffea811148:	f2402c1f 	tst	x0, #0xfff
ffffffffea81114c:	540008a1 	b.ne	ffffffffea811260 <vmm_alloc_physical+0x158>  // b.any
ffffffffea811150:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea811154:	aa0303f5 	mov	x21, x3
ffffffffea811158:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea81115c:	2a0603f6 	mov	w22, w6
ffffffffea811160:	f9002bbb 	str	x27, [x29, #80]
ffffffffea811164:	2a0703f8 	mov	w24, w7
ffffffffea811168:	12001c9b 	and	w27, w4, #0xff
        return ERR_INVALID_ARGS;

    /* if they're asking for a specific spot, copy the address */
    if (vmm_flags & VMM_FLAG_VALLOC_SPECIFIC) {
ffffffffea81116c:	36000536 	tbz	w22, #0, ffffffffea811210 <vmm_alloc_physical+0x108>
        /* can't ask for a specific spot and then not provide one */
        if (!ptr) {
ffffffffea811170:	b4000823 	cbz	x3, ffffffffea811274 <vmm_alloc_physical+0x16c>
ffffffffea811174:	f9002fbc 	str	x28, [x29, #88]
ffffffffea811178:	12800001 	mov	w1, #0xffffffff            	// #-1
            return ERR_INVALID_ARGS;
        }
        vaddr = (vaddr_t)*ptr;
ffffffffea81117c:	f940007c 	ldr	x28, [x3]
ffffffffea811180:	f0000039 	adrp	x25, ffffffffea818000 <_mem_phys_base>
ffffffffea811184:	913c2320 	add	x0, x25, #0xf08
ffffffffea811188:	97ffd1d8 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
    }

    mutex_acquire(&vmm_lock);

    /* allocate a region and put it in the aspace list */
    r = alloc_region(aspace, name, size, vaddr, align_log2, vmm_flags, VMM_REGION_FLAG_PHYSICAL, arch_mmu_flags);
ffffffffea81118c:	2a1803e7 	mov	w7, w24
ffffffffea811190:	52800046 	mov	w6, #0x2                   	// #2
ffffffffea811194:	2a1603e5 	mov	w5, w22
ffffffffea811198:	2a1b03e4 	mov	w4, w27
ffffffffea81119c:	aa1c03e3 	mov	x3, x28
ffffffffea8111a0:	aa1403e2 	mov	x2, x20
ffffffffea8111a4:	aa1303e1 	mov	x1, x19
ffffffffea8111a8:	aa1a03e0 	mov	x0, x26
ffffffffea8111ac:	97fffec1 	bl	ffffffffea810cb0 <alloc_region>
    if (!r) {
ffffffffea8111b0:	b4000520 	cbz	x0, ffffffffea811254 <vmm_alloc_physical+0x14c>
ffffffffea8111b4:	f9401c00 	ldr	x0, [x0, #56]
ffffffffea8111b8:	f9402fbc 	ldr	x28, [x29, #88]
        goto err_alloc_region;
    }

    /* return the vaddr if requested */
    if (ptr)
        *ptr = (void *)r->base;
ffffffffea8111bc:	f90002a0 	str	x0, [x21]

    /* map all of the pages */
    err = arch_mmu_map(r->base, paddr, size / PAGE_SIZE, arch_mmu_flags);
    LTRACEF("arch_mmu_map returns %d\n", err);

    ret = NO_ERROR;
ffffffffea8111c0:	52800013 	mov	w19, #0x0                   	// #0
    err = arch_mmu_map(r->base, paddr, size / PAGE_SIZE, arch_mmu_flags);
ffffffffea8111c4:	2a1803e3 	mov	w3, w24
ffffffffea8111c8:	d34cae82 	ubfx	x2, x20, #12, #32
ffffffffea8111cc:	aa1703e1 	mov	x1, x23
ffffffffea8111d0:	97ffca8a 	bl	ffffffffea803bf8 <arch_mmu_map>

err_alloc_region:
    mutex_release(&vmm_lock);
ffffffffea8111d4:	913c2320 	add	x0, x25, #0xf08
ffffffffea8111d8:	97ffd1f0 	bl	ffffffffea805998 <mutex_release>
    return ret;
ffffffffea8111dc:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea8111e0:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea8111e4:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea8111e8:	a944efba 	ldp	x26, x27, [x29, #72]
}
ffffffffea8111ec:	2a1303e0 	mov	w0, w19
ffffffffea8111f0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8111f4:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8111f8:	d65f03c0 	ret
        return NO_ERROR;
ffffffffea8111fc:	52800013 	mov	w19, #0x0                   	// #0
}
ffffffffea811200:	2a1303e0 	mov	w0, w19
ffffffffea811204:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea811208:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea81120c:	d65f03c0 	ret
ffffffffea811210:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea811214:	f0000039 	adrp	x25, ffffffffea818000 <_mem_phys_base>
ffffffffea811218:	913c2320 	add	x0, x25, #0xf08
ffffffffea81121c:	97ffd1b3 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
    r = alloc_region(aspace, name, size, vaddr, align_log2, vmm_flags, VMM_REGION_FLAG_PHYSICAL, arch_mmu_flags);
ffffffffea811220:	2a1803e7 	mov	w7, w24
ffffffffea811224:	52800046 	mov	w6, #0x2                   	// #2
ffffffffea811228:	2a1603e5 	mov	w5, w22
ffffffffea81122c:	2a1b03e4 	mov	w4, w27
ffffffffea811230:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea811234:	aa1403e2 	mov	x2, x20
ffffffffea811238:	aa1303e1 	mov	x1, x19
ffffffffea81123c:	aa1a03e0 	mov	x0, x26
ffffffffea811240:	97fffe9c 	bl	ffffffffea810cb0 <alloc_region>
    if (!r) {
ffffffffea811244:	b40000a0 	cbz	x0, ffffffffea811258 <vmm_alloc_physical+0x150>
ffffffffea811248:	f9401c00 	ldr	x0, [x0, #56]
    if (ptr)
ffffffffea81124c:	b4fffbb5 	cbz	x21, ffffffffea8111c0 <vmm_alloc_physical+0xb8>
ffffffffea811250:	17ffffdb 	b	ffffffffea8111bc <vmm_alloc_physical+0xb4>
ffffffffea811254:	f9402fbc 	ldr	x28, [x29, #88]
        ret = ERR_NO_MEMORY;
ffffffffea811258:	12800093 	mov	w19, #0xfffffffb            	// #-5
ffffffffea81125c:	17ffffde 	b	ffffffffea8111d4 <vmm_alloc_physical+0xcc>
        return ERR_INVALID_ARGS;
ffffffffea811260:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea811264:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea811268:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea81126c:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea811270:	17ffffdf 	b	ffffffffea8111ec <vmm_alloc_physical+0xe4>
ffffffffea811274:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea811278:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea81127c:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea811280:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea811284:	a944efba 	ldp	x26, x27, [x29, #72]
ffffffffea811288:	17ffffd9 	b	ffffffffea8111ec <vmm_alloc_physical+0xe4>
ffffffffea81128c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811290 <vmm_free_region>:

    return NULL;
}

status_t vmm_free_region(vmm_aspace_t *aspace, vaddr_t vaddr)
{
ffffffffea811290:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811294:	910003fd 	mov	x29, sp
ffffffffea811298:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea81129c:	aa0003f4 	mov	x20, x0
ffffffffea8112a0:	f90017f6 	str	x22, [sp, #40]
ffffffffea8112a4:	aa0103f5 	mov	x21, x1
ffffffffea8112a8:	f0000036 	adrp	x22, ffffffffea818000 <_mem_phys_base>
ffffffffea8112ac:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8112b0:	913c22c0 	add	x0, x22, #0xf08
ffffffffea8112b4:	97ffd18d 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
    if (!aspace)
ffffffffea8112b8:	b4000254 	cbz	x20, ffffffffea811300 <vmm_free_region+0x70>
ffffffffea8112bc:	f9000bb3 	str	x19, [x29, #16]
    list_for_every_entry(&aspace->region_list, r, vmm_region_t, node) {
ffffffffea8112c0:	91012283 	add	x3, x20, #0x48
ffffffffea8112c4:	f9402a93 	ldr	x19, [x20, #80]
ffffffffea8112c8:	eb13007f 	cmp	x3, x19
ffffffffea8112cc:	54000180 	b.eq	ffffffffea8112fc <vmm_free_region+0x6c>  // b.none
        if ((vaddr >= r->base) && (vaddr <= r->base + r->size - 1))
ffffffffea8112d0:	f9401e60 	ldr	x0, [x19, #56]
ffffffffea8112d4:	eb0002bf 	cmp	x21, x0
ffffffffea8112d8:	540000c3 	b.cc	ffffffffea8112f0 <vmm_free_region+0x60>  // b.lo, b.ul, b.last
ffffffffea8112dc:	f9402261 	ldr	x1, [x19, #64]
ffffffffea8112e0:	8b010002 	add	x2, x0, x1
ffffffffea8112e4:	d1000442 	sub	x2, x2, #0x1
ffffffffea8112e8:	eb0202bf 	cmp	x21, x2
ffffffffea8112ec:	54000189 	b.ls	ffffffffea81131c <vmm_free_region+0x8c>  // b.plast
    list_for_every_entry(&aspace->region_list, r, vmm_region_t, node) {
ffffffffea8112f0:	f9400673 	ldr	x19, [x19, #8]
ffffffffea8112f4:	eb03027f 	cmp	x19, x3
ffffffffea8112f8:	54fffec1 	b.ne	ffffffffea8112d0 <vmm_free_region+0x40>  // b.any
ffffffffea8112fc:	f9400bb3 	ldr	x19, [x29, #16]
    mutex_acquire(&vmm_lock);

    vmm_region_t *r = vmm_find_region (aspace, vaddr);
    if (!r) {
        mutex_release(&vmm_lock);
ffffffffea811300:	913c22c0 	add	x0, x22, #0xf08
ffffffffea811304:	97ffd1a5 	bl	ffffffffea805998 <mutex_release>
        return ERR_NOT_FOUND;
ffffffffea811308:	12800020 	mov	w0, #0xfffffffe            	// #-2

    /* free it */
    free (r);

    return NO_ERROR;
}
ffffffffea81130c:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea811310:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea811314:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811318:	d65f03c0 	ret
	item->next->prev = item->prev;
ffffffffea81131c:	a9400a63 	ldp	x3, x2, [x19]
	item->prev = item->next = 0;
ffffffffea811320:	aa1303f4 	mov	x20, x19
    arch_mmu_unmap(r->base, r->size / PAGE_SIZE);
ffffffffea811324:	d34cac21 	ubfx	x1, x1, #12, #32
	item->next->prev = item->prev;
ffffffffea811328:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea81132c:	f9400263 	ldr	x3, [x19]
ffffffffea811330:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea811334:	f900067f 	str	xzr, [x19, #8]
ffffffffea811338:	f804869f 	str	xzr, [x20], #72
ffffffffea81133c:	97ffca63 	bl	ffffffffea803cc8 <arch_mmu_unmap>
    mutex_release(&vmm_lock);
ffffffffea811340:	913c22c0 	add	x0, x22, #0xf08
ffffffffea811344:	97ffd195 	bl	ffffffffea805998 <mutex_release>
    pmm_free (&r->page_list);
ffffffffea811348:	aa1403e0 	mov	x0, x20
ffffffffea81134c:	97fffd63 	bl	ffffffffea8108d8 <pmm_free>
    free (r);
ffffffffea811350:	aa1303e0 	mov	x0, x19
ffffffffea811354:	94000751 	bl	ffffffffea813098 <free>
    return NO_ERROR;
ffffffffea811358:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea81135c:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea811360:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea811364:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea811368:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea81136c:	d65f03c0 	ret

ffffffffea811370 <__debug_stdio_fgetc>:
{
	return _dputs(s);
}

static int __debug_stdio_fgetc(void *ctx)
{
ffffffffea811370:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return platform_dgetc(c, true);
ffffffffea811374:	52800021 	mov	w1, #0x1                   	// #1
{
ffffffffea811378:	910003fd 	mov	x29, sp
	return platform_dgetc(c, true);
ffffffffea81137c:	91007fa0 	add	x0, x29, #0x1f
ffffffffea811380:	97ffc318 	bl	ffffffffea801fe0 <platform_dgetc>
	int err;

	err = input_char(&c);
	if (err < 0)
		return err;
	return (unsigned char)c;
ffffffffea811384:	7100001f 	cmp	w0, #0x0
ffffffffea811388:	39407fa1 	ldrb	w1, [x29, #31]
}
ffffffffea81138c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea811390:	1a80a020 	csel	w0, w1, w0, ge  // ge = tcont
ffffffffea811394:	d65f03c0 	ret

ffffffffea811398 <out_count>:
{
ffffffffea811398:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea81139c:	52800004 	mov	w4, #0x0                   	// #0
ffffffffea8113a0:	910003fd 	mov	x29, sp
ffffffffea8113a4:	a9025bf5 	stp	x21, x22, [sp, #32]
	list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
ffffffffea8113a8:	f0000035 	adrp	x21, ffffffffea818000 <_mem_phys_base>
ffffffffea8113ac:	913ee2b5 	add	x21, x21, #0xfb8
{
ffffffffea8113b0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8113b4:	aa0103f6 	mov	x22, x1
ffffffffea8113b8:	aa0003f4 	mov	x20, x0
	list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
ffffffffea8113bc:	f94006b3 	ldr	x19, [x21, #8]
ffffffffea8113c0:	eb15027f 	cmp	x19, x21
ffffffffea8113c4:	54000200 	b.eq	ffffffffea811404 <out_count+0x6c>  // b.none
		if (cb->print) {
ffffffffea8113c8:	f9400a63 	ldr	x3, [x19, #16]
			cb->print(cb, str, len);
ffffffffea8113cc:	aa1303e0 	mov	x0, x19
ffffffffea8113d0:	aa1603e2 	mov	x2, x22
ffffffffea8113d4:	aa1403e1 	mov	x1, x20
		if (cb->print) {
ffffffffea8113d8:	b4000063 	cbz	x3, ffffffffea8113e4 <out_count+0x4c>
			cb->print(cb, str, len);
ffffffffea8113dc:	d63f0060 	blr	x3
			reg_logger = 1;
ffffffffea8113e0:	52800024 	mov	w4, #0x1                   	// #1
	list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
ffffffffea8113e4:	f9400673 	ldr	x19, [x19, #8]
ffffffffea8113e8:	eb15027f 	cmp	x19, x21
ffffffffea8113ec:	54fffee1 	b.ne	ffffffffea8113c8 <out_count+0x30>  // b.any
	if(!reg_logger) {
ffffffffea8113f0:	340000a4 	cbz	w4, ffffffffea811404 <out_count+0x6c>
}
ffffffffea8113f4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8113f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8113fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811400:	d65f03c0 	ret
ffffffffea811404:	aa1403f3 	mov	x19, x20
ffffffffea811408:	8b160294 	add	x20, x20, x22
		for (i = 0; i < len; i++)
ffffffffea81140c:	b4ffff56 	cbz	x22, ffffffffea8113f4 <out_count+0x5c>
			platform_dputc(str[i]);
ffffffffea811410:	38401660 	ldrb	w0, [x19], #1
ffffffffea811414:	97ffc2d1 	bl	ffffffffea801f58 <platform_dputc>
		for (i = 0; i < len; i++)
ffffffffea811418:	eb14027f 	cmp	x19, x20
ffffffffea81141c:	54fffec0 	b.eq	ffffffffea8113f4 <out_count+0x5c>  // b.none
			platform_dputc(str[i]);
ffffffffea811420:	38401660 	ldrb	w0, [x19], #1
ffffffffea811424:	97ffc2cd 	bl	ffffffffea801f58 <platform_dputc>
		for (i = 0; i < len; i++)
ffffffffea811428:	eb14027f 	cmp	x19, x20
ffffffffea81142c:	54ffff21 	b.ne	ffffffffea811410 <out_count+0x78>  // b.any
ffffffffea811430:	17fffff1 	b	ffffffffea8113f4 <out_count+0x5c>
ffffffffea811434:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811438 <_dprintf_output_func>:

	return 0;
}

static int _dprintf_output_func(const char *str, size_t len, void *state)
{
ffffffffea811438:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea81143c:	910003fd 	mov	x29, sp
ffffffffea811440:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811444:	aa0003f4 	mov	x20, x0
	size_t n = strnlen(str, len);
ffffffffea811448:	9400085e 	bl	ffffffffea8135c0 <strnlen>
ffffffffea81144c:	aa0003f3 	mov	x19, x0

	out_count(str, n);
ffffffffea811450:	aa0003e1 	mov	x1, x0
ffffffffea811454:	aa1403e0 	mov	x0, x20
ffffffffea811458:	97ffffd0 	bl	ffffffffea811398 <out_count>
	return n;
}
ffffffffea81145c:	2a1303e0 	mov	w0, w19
ffffffffea811460:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811464:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea811468:	d65f03c0 	ret
ffffffffea81146c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811470 <register_print_callback>:
{
ffffffffea811470:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811474:	910003fd 	mov	x29, sp
ffffffffea811478:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81147c:	aa0003f3 	mov	x19, x0
ffffffffea811480:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811484:	d53b4220 	mrs	x0, daif
ffffffffea811488:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea81148c:	37380060 	tbnz	w0, #7, ffffffffea811498 <register_print_callback+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811490:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811494:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811498:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea81149c:	373002e0 	tbnz	w0, #6, ffffffffea8114f8 <register_print_callback+0x88>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea8114a0:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8114a4:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea8114a8:	f0000255 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8114ac:	913d02b5 	add	x21, x21, #0xf40
ffffffffea8114b0:	aa1503e0 	mov	x0, x21
ffffffffea8114b4:	97ffc52a 	bl	ffffffffea80295c <arch_spin_lock>
	item->next = list->next;
ffffffffea8114b8:	f0000021 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea8114bc:	913ee021 	add	x1, x1, #0xfb8
    arch_spin_unlock(lock);
ffffffffea8114c0:	aa1503e0 	mov	x0, x21
ffffffffea8114c4:	f9400422 	ldr	x2, [x1, #8]
ffffffffea8114c8:	a9000a61 	stp	x1, x2, [x19]
	list->next->prev = item;
ffffffffea8114cc:	f9400422 	ldr	x2, [x1, #8]
ffffffffea8114d0:	f9000053 	str	x19, [x2]
	list->next = item;
ffffffffea8114d4:	f9000433 	str	x19, [x1, #8]
ffffffffea8114d8:	97ffc529 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea8114dc:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8114e0:	36000054 	tbz	w20, #0, ffffffffea8114e8 <register_print_callback+0x78>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8114e4:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8114e8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8114ec:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8114f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8114f4:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8114f8:	f0000255 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8114fc:	913d02b5 	add	x21, x21, #0xf40
ffffffffea811500:	aa1503e0 	mov	x0, x21
ffffffffea811504:	97ffc516 	bl	ffffffffea80295c <arch_spin_lock>
	item->next = list->next;
ffffffffea811508:	f0000021 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea81150c:	913ee021 	add	x1, x1, #0xfb8
    arch_spin_unlock(lock);
ffffffffea811510:	aa1503e0 	mov	x0, x21
ffffffffea811514:	f9400422 	ldr	x2, [x1, #8]
ffffffffea811518:	a9000a61 	stp	x1, x2, [x19]
	list->next->prev = item;
ffffffffea81151c:	f9400422 	ldr	x2, [x1, #8]
ffffffffea811520:	f9000053 	str	x19, [x2]
	list->next = item;
ffffffffea811524:	f9000433 	str	x19, [x1, #8]
ffffffffea811528:	97ffc515 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea81152c:	17ffffed 	b	ffffffffea8114e0 <register_print_callback+0x70>

ffffffffea811530 <unregister_print_callback>:
{
ffffffffea811530:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811534:	910003fd 	mov	x29, sp
ffffffffea811538:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81153c:	aa0003f3 	mov	x19, x0
ffffffffea811540:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811544:	d53b4220 	mrs	x0, daif
ffffffffea811548:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea81154c:	37380060 	tbnz	w0, #7, ffffffffea811558 <unregister_print_callback+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811550:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811554:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811558:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea81155c:	373002a0 	tbnz	w0, #6, ffffffffea8115b0 <unregister_print_callback+0x80>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea811560:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea811564:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea811568:	f0000255 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea81156c:	913d02b5 	add	x21, x21, #0xf40
ffffffffea811570:	aa1503e0 	mov	x0, x21
ffffffffea811574:	97ffc4fa 	bl	ffffffffea80295c <arch_spin_lock>
	item->next->prev = item->prev;
ffffffffea811578:	a9400662 	ldp	x2, x1, [x19]
    arch_spin_unlock(lock);
ffffffffea81157c:	aa1503e0 	mov	x0, x21
ffffffffea811580:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea811584:	f9400262 	ldr	x2, [x19]
ffffffffea811588:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea81158c:	a9007e7f 	stp	xzr, xzr, [x19]
ffffffffea811590:	97ffc4fb 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea811594:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea811598:	36000054 	tbz	w20, #0, ffffffffea8115a0 <unregister_print_callback+0x70>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea81159c:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8115a0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8115a4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8115a8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8115ac:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8115b0:	f0000255 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8115b4:	913d02b5 	add	x21, x21, #0xf40
ffffffffea8115b8:	aa1503e0 	mov	x0, x21
ffffffffea8115bc:	97ffc4e8 	bl	ffffffffea80295c <arch_spin_lock>
	item->next->prev = item->prev;
ffffffffea8115c0:	a9400662 	ldp	x2, x1, [x19]
    arch_spin_unlock(lock);
ffffffffea8115c4:	aa1503e0 	mov	x0, x21
ffffffffea8115c8:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea8115cc:	f9400262 	ldr	x2, [x19]
ffffffffea8115d0:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea8115d4:	a9007e7f 	stp	xzr, xzr, [x19]
ffffffffea8115d8:	97ffc4e9 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea8115dc:	17ffffef 	b	ffffffffea811598 <unregister_print_callback+0x68>

ffffffffea8115e0 <_dputc>:
{
ffffffffea8115e0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea8115e4:	910003fd 	mov	x29, sp
ffffffffea8115e8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8115ec:	f90013f5 	str	x21, [sp, #32]
ffffffffea8115f0:	12001c15 	and	w21, w0, #0xff
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8115f4:	d53b4220 	mrs	x0, daif
ffffffffea8115f8:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8115fc:	37380060 	tbnz	w0, #7, ffffffffea811608 <_dputc+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811600:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811604:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811608:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea81160c:	37300280 	tbnz	w0, #6, ffffffffea81165c <_dputc+0x7c>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea811610:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea811614:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea811618:	f0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea81161c:	913d0294 	add	x20, x20, #0xf40
ffffffffea811620:	aa1403e0 	mov	x0, x20
ffffffffea811624:	97ffc4ce 	bl	ffffffffea80295c <arch_spin_lock>
ffffffffea811628:	910103a0 	add	x0, x29, #0x40
	out_count(&c, 1);
ffffffffea81162c:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea811630:	381ffc15 	strb	w21, [x0, #-1]!
ffffffffea811634:	97ffff59 	bl	ffffffffea811398 <out_count>
    arch_spin_unlock(lock);
ffffffffea811638:	aa1403e0 	mov	x0, x20
ffffffffea81163c:	97ffc4d0 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea811640:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea811644:	36000053 	tbz	w19, #0, ffffffffea81164c <_dputc+0x6c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea811648:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea81164c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811650:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea811654:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea811658:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea81165c:	f0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea811660:	913d0294 	add	x20, x20, #0xf40
ffffffffea811664:	aa1403e0 	mov	x0, x20
ffffffffea811668:	97ffc4bd 	bl	ffffffffea80295c <arch_spin_lock>
ffffffffea81166c:	910103a0 	add	x0, x29, #0x40
	out_count(&c, 1);
ffffffffea811670:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea811674:	381ffc15 	strb	w21, [x0, #-1]!
ffffffffea811678:	97ffff48 	bl	ffffffffea811398 <out_count>
    arch_spin_unlock(lock);
ffffffffea81167c:	aa1403e0 	mov	x0, x20
ffffffffea811680:	97ffc4bf 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea811684:	17fffff0 	b	ffffffffea811644 <_dputc+0x64>

ffffffffea811688 <__debug_stdio_fputc>:
{
ffffffffea811688:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	_dputc(c);
ffffffffea81168c:	2a0103e0 	mov	w0, w1
{
ffffffffea811690:	910003fd 	mov	x29, sp
	_dputc(c);
ffffffffea811694:	97ffffd3 	bl	ffffffffea8115e0 <_dputc>
}
ffffffffea811698:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea81169c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8116a0:	d65f03c0 	ret
ffffffffea8116a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8116a8 <_dputs>:
{
ffffffffea8116a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8116ac:	910003fd 	mov	x29, sp
ffffffffea8116b0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8116b4:	aa0003f4 	mov	x20, x0
ffffffffea8116b8:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8116bc:	d53b4220 	mrs	x0, daif
ffffffffea8116c0:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8116c4:	37380060 	tbnz	w0, #7, ffffffffea8116d0 <_dputs+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8116c8:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8116cc:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8116d0:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea8116d4:	373002c0 	tbnz	w0, #6, ffffffffea81172c <_dputs+0x84>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea8116d8:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8116dc:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea8116e0:	f0000255 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8116e4:	913d02b5 	add	x21, x21, #0xf40
ffffffffea8116e8:	aa1503e0 	mov	x0, x21
ffffffffea8116ec:	97ffc49c 	bl	ffffffffea80295c <arch_spin_lock>
	out_count(str, strlen(str));
ffffffffea8116f0:	aa1403e0 	mov	x0, x20
ffffffffea8116f4:	94000789 	bl	ffffffffea813518 <strlen>
ffffffffea8116f8:	aa0003e1 	mov	x1, x0
ffffffffea8116fc:	aa1403e0 	mov	x0, x20
ffffffffea811700:	97ffff26 	bl	ffffffffea811398 <out_count>
    arch_spin_unlock(lock);
ffffffffea811704:	aa1503e0 	mov	x0, x21
ffffffffea811708:	97ffc49d 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea81170c:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea811710:	36000053 	tbz	w19, #0, ffffffffea811718 <_dputs+0x70>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea811714:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea811718:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea81171c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea811720:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811724:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811728:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea81172c:	f0000255 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea811730:	913d02b5 	add	x21, x21, #0xf40
ffffffffea811734:	aa1503e0 	mov	x0, x21
ffffffffea811738:	97ffc489 	bl	ffffffffea80295c <arch_spin_lock>
	out_count(str, strlen(str));
ffffffffea81173c:	aa1403e0 	mov	x0, x20
ffffffffea811740:	94000776 	bl	ffffffffea813518 <strlen>
ffffffffea811744:	aa0003e1 	mov	x1, x0
ffffffffea811748:	aa1403e0 	mov	x0, x20
ffffffffea81174c:	97ffff13 	bl	ffffffffea811398 <out_count>
    arch_spin_unlock(lock);
ffffffffea811750:	aa1503e0 	mov	x0, x21
ffffffffea811754:	97ffc48a 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea811758:	17ffffee 	b	ffffffffea811710 <_dputs+0x68>
ffffffffea81175c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811760 <__debug_stdio_fputs>:
	return _dputs(s);
ffffffffea811760:	aa0103e0 	mov	x0, x1
ffffffffea811764:	17ffffd1 	b	ffffffffea8116a8 <_dputs>

ffffffffea811768 <_dwrite>:
{
ffffffffea811768:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea81176c:	910003fd 	mov	x29, sp
ffffffffea811770:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811774:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea811778:	aa0003f5 	mov	x21, x0
ffffffffea81177c:	aa0103f6 	mov	x22, x1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811780:	d53b4220 	mrs	x0, daif
ffffffffea811784:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea811788:	37380060 	tbnz	w0, #7, ffffffffea811794 <_dwrite+0x2c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea81178c:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811790:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811794:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea811798:	37300280 	tbnz	w0, #6, ffffffffea8117e8 <_dwrite+0x80>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea81179c:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8117a0:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea8117a4:	f0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8117a8:	913d0294 	add	x20, x20, #0xf40
ffffffffea8117ac:	aa1403e0 	mov	x0, x20
ffffffffea8117b0:	97ffc46b 	bl	ffffffffea80295c <arch_spin_lock>
	out_count(ptr, len);
ffffffffea8117b4:	aa1603e1 	mov	x1, x22
ffffffffea8117b8:	aa1503e0 	mov	x0, x21
ffffffffea8117bc:	97fffef7 	bl	ffffffffea811398 <out_count>
    arch_spin_unlock(lock);
ffffffffea8117c0:	aa1403e0 	mov	x0, x20
ffffffffea8117c4:	97ffc46e 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea8117c8:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8117cc:	36000053 	tbz	w19, #0, ffffffffea8117d4 <_dwrite+0x6c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8117d0:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8117d4:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8117d8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8117dc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8117e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8117e4:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8117e8:	f0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8117ec:	913d0294 	add	x20, x20, #0xf40
ffffffffea8117f0:	aa1403e0 	mov	x0, x20
ffffffffea8117f4:	97ffc45a 	bl	ffffffffea80295c <arch_spin_lock>
	out_count(ptr, len);
ffffffffea8117f8:	aa1603e1 	mov	x1, x22
ffffffffea8117fc:	aa1503e0 	mov	x0, x21
ffffffffea811800:	97fffee6 	bl	ffffffffea811398 <out_count>
    arch_spin_unlock(lock);
ffffffffea811804:	aa1403e0 	mov	x0, x20
ffffffffea811808:	97ffc45d 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea81180c:	17fffff0 	b	ffffffffea8117cc <_dwrite+0x64>

ffffffffea811810 <_dprintf>:

int _dprintf(const char *fmt, ...)
{
ffffffffea811810:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
	spin_lock_saved_state_t state;
	int err;
	va_list ap;

	va_start(ap, fmt);
ffffffffea811814:	128006e8 	mov	w8, #0xffffffc8            	// #-56
{
ffffffffea811818:	910003fd 	mov	x29, sp
	va_start(ap, fmt);
ffffffffea81181c:	9101c3a9 	add	x9, x29, #0x70
{
ffffffffea811820:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811824:	f90013f5 	str	x21, [sp, #32]
ffffffffea811828:	aa0003f5 	mov	x21, x0
	va_start(ap, fmt);
ffffffffea81182c:	f90033a9 	str	x9, [x29, #96]
ffffffffea811830:	9102c3a0 	add	x0, x29, #0xb0
ffffffffea811834:	a90503a0 	stp	x0, x0, [x29, #80]
ffffffffea811838:	290d7fa8 	stp	w8, wzr, [x29, #104]
{
ffffffffea81183c:	a9078ba1 	stp	x1, x2, [x29, #120]
ffffffffea811840:	a90893a3 	stp	x3, x4, [x29, #136]
ffffffffea811844:	a9099ba5 	stp	x5, x6, [x29, #152]
ffffffffea811848:	f90057a7 	str	x7, [x29, #168]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea81184c:	d53b4220 	mrs	x0, daif
ffffffffea811850:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea811854:	37380060 	tbnz	w0, #7, ffffffffea811860 <_dprintf+0x50>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811858:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea81185c:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811860:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea811864:	37300380 	tbnz	w0, #6, ffffffffea8118d4 <_dprintf+0xc4>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea811868:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea81186c:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea811870:	f0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea811874:	913d0294 	add	x20, x20, #0xf40
ffffffffea811878:	aa1403e0 	mov	x0, x20
ffffffffea81187c:	97ffc438 	bl	ffffffffea80295c <arch_spin_lock>
	spin_lock_save(&print_spin_lock, &state, PRINT_LOCK_FLAGS);
	err = _printf_engine(&_dprintf_output_func, NULL, fmt, ap);
ffffffffea811880:	a9451fa6 	ldp	x6, x7, [x29, #80]
ffffffffea811884:	aa1503e2 	mov	x2, x21
ffffffffea811888:	a94617a4 	ldp	x4, x5, [x29, #96]
ffffffffea81188c:	9100c3a3 	add	x3, x29, #0x30
ffffffffea811890:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea811894:	a9031fa6 	stp	x6, x7, [x29, #48]
ffffffffea811898:	a90417a4 	stp	x4, x5, [x29, #64]
ffffffffea81189c:	90000000 	adrp	x0, ffffffffea811000 <vmm_reserve_space+0x50>
ffffffffea8118a0:	9110e000 	add	x0, x0, #0x438
ffffffffea8118a4:	9400030f 	bl	ffffffffea8124e0 <_printf_engine>
ffffffffea8118a8:	2a0003f5 	mov	w21, w0
    arch_spin_unlock(lock);
ffffffffea8118ac:	aa1403e0 	mov	x0, x20
ffffffffea8118b0:	97ffc433 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea8118b4:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8118b8:	36000053 	tbz	w19, #0, ffffffffea8118c0 <_dprintf+0xb0>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8118bc:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&print_spin_lock, state, PRINT_LOCK_FLAGS);
	va_end(ap);

	return err;
}
ffffffffea8118c0:	2a1503e0 	mov	w0, w21
ffffffffea8118c4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8118c8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8118cc:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea8118d0:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8118d4:	f0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8118d8:	913d0294 	add	x20, x20, #0xf40
ffffffffea8118dc:	aa1403e0 	mov	x0, x20
ffffffffea8118e0:	97ffc41f 	bl	ffffffffea80295c <arch_spin_lock>
	err = _printf_engine(&_dprintf_output_func, NULL, fmt, ap);
ffffffffea8118e4:	a9451fa6 	ldp	x6, x7, [x29, #80]
ffffffffea8118e8:	aa1503e2 	mov	x2, x21
ffffffffea8118ec:	a94617a4 	ldp	x4, x5, [x29, #96]
ffffffffea8118f0:	9100c3a3 	add	x3, x29, #0x30
ffffffffea8118f4:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8118f8:	a9031fa6 	stp	x6, x7, [x29, #48]
ffffffffea8118fc:	a90417a4 	stp	x4, x5, [x29, #64]
ffffffffea811900:	90000000 	adrp	x0, ffffffffea811000 <vmm_reserve_space+0x50>
ffffffffea811904:	9110e000 	add	x0, x0, #0x438
ffffffffea811908:	940002f6 	bl	ffffffffea8124e0 <_printf_engine>
ffffffffea81190c:	2a0003f5 	mov	w21, w0
    arch_spin_unlock(lock);
ffffffffea811910:	aa1403e0 	mov	x0, x20
ffffffffea811914:	97ffc41a 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea811918:	17ffffe8 	b	ffffffffea8118b8 <_dprintf+0xa8>
ffffffffea81191c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811920 <_dvprintf>:

int _dvprintf(const char *fmt, va_list ap)
{
ffffffffea811920:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea811924:	910003fd 	mov	x29, sp
ffffffffea811928:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81192c:	aa0103f4 	mov	x20, x1
ffffffffea811930:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea811934:	aa0003f6 	mov	x22, x0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811938:	d53b4220 	mrs	x0, daif
ffffffffea81193c:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea811940:	37380060 	tbnz	w0, #7, ffffffffea81194c <_dvprintf+0x2c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811944:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811948:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea81194c:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea811950:	37300380 	tbnz	w0, #6, ffffffffea8119c0 <_dvprintf+0xa0>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea811954:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea811958:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea81195c:	f0000255 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea811960:	913d02b5 	add	x21, x21, #0xf40
ffffffffea811964:	aa1503e0 	mov	x0, x21
ffffffffea811968:	97ffc3fd 	bl	ffffffffea80295c <arch_spin_lock>
	spin_lock_saved_state_t state;
	int err;

	spin_lock_save(&print_spin_lock, &state, PRINT_LOCK_FLAGS);
	err = _printf_engine(&_dprintf_output_func, NULL, fmt, ap);
ffffffffea81196c:	a9401e86 	ldp	x6, x7, [x20]
ffffffffea811970:	9100c3a3 	add	x3, x29, #0x30
ffffffffea811974:	a9411684 	ldp	x4, x5, [x20, #16]
ffffffffea811978:	aa1603e2 	mov	x2, x22
ffffffffea81197c:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea811980:	a9031fa6 	stp	x6, x7, [x29, #48]
ffffffffea811984:	a90417a4 	stp	x4, x5, [x29, #64]
ffffffffea811988:	90000000 	adrp	x0, ffffffffea811000 <vmm_reserve_space+0x50>
ffffffffea81198c:	9110e000 	add	x0, x0, #0x438
ffffffffea811990:	940002d4 	bl	ffffffffea8124e0 <_printf_engine>
ffffffffea811994:	2a0003f4 	mov	w20, w0
    arch_spin_unlock(lock);
ffffffffea811998:	aa1503e0 	mov	x0, x21
ffffffffea81199c:	97ffc3f8 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea8119a0:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8119a4:	36000053 	tbz	w19, #0, ffffffffea8119ac <_dvprintf+0x8c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8119a8:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&print_spin_lock, state, PRINT_LOCK_FLAGS);

	return err;
}
ffffffffea8119ac:	2a1403e0 	mov	w0, w20
ffffffffea8119b0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8119b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8119b8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8119bc:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8119c0:	f0000255 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8119c4:	913d02b5 	add	x21, x21, #0xf40
ffffffffea8119c8:	aa1503e0 	mov	x0, x21
ffffffffea8119cc:	97ffc3e4 	bl	ffffffffea80295c <arch_spin_lock>
	err = _printf_engine(&_dprintf_output_func, NULL, fmt, ap);
ffffffffea8119d0:	a9401e86 	ldp	x6, x7, [x20]
ffffffffea8119d4:	9100c3a3 	add	x3, x29, #0x30
ffffffffea8119d8:	a9411684 	ldp	x4, x5, [x20, #16]
ffffffffea8119dc:	aa1603e2 	mov	x2, x22
ffffffffea8119e0:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8119e4:	a9031fa6 	stp	x6, x7, [x29, #48]
ffffffffea8119e8:	a90417a4 	stp	x4, x5, [x29, #64]
ffffffffea8119ec:	90000000 	adrp	x0, ffffffffea811000 <vmm_reserve_space+0x50>
ffffffffea8119f0:	9110e000 	add	x0, x0, #0x438
ffffffffea8119f4:	940002bb 	bl	ffffffffea8124e0 <_printf_engine>
ffffffffea8119f8:	2a0003f4 	mov	w20, w0
    arch_spin_unlock(lock);
ffffffffea8119fc:	aa1503e0 	mov	x0, x21
ffffffffea811a00:	97ffc3df 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea811a04:	17ffffe8 	b	ffffffffea8119a4 <_dvprintf+0x84>

ffffffffea811a08 <_panic>:
{
ffffffffea811a08:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
ffffffffea811a0c:	910003fd 	mov	x29, sp
ffffffffea811a10:	f9000bf3 	str	x19, [sp, #16]
ffffffffea811a14:	aa0103f3 	mov	x19, x1
	dprintf(ALWAYS, "panic (caller %p): ", caller);
ffffffffea811a18:	aa0003e1 	mov	x1, x0
ffffffffea811a1c:	d0000020 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
{
ffffffffea811a20:	a9060fa2 	stp	x2, x3, [x29, #96]
	dprintf(ALWAYS, "panic (caller %p): ", caller);
ffffffffea811a24:	911c2000 	add	x0, x0, #0x708
{
ffffffffea811a28:	a90717a4 	stp	x4, x5, [x29, #112]
ffffffffea811a2c:	a9081fa6 	stp	x6, x7, [x29, #128]
	dprintf(ALWAYS, "panic (caller %p): ", caller);
ffffffffea811a30:	97ffff78 	bl	ffffffffea811810 <_dprintf>
	va_start(ap, fmt);
ffffffffea811a34:	910243a0 	add	x0, x29, #0x90
ffffffffea811a38:	910183a1 	add	x1, x29, #0x60
ffffffffea811a3c:	a90403a0 	stp	x0, x0, [x29, #64]
ffffffffea811a40:	128005e0 	mov	w0, #0xffffffd0            	// #-48
ffffffffea811a44:	f9002ba1 	str	x1, [x29, #80]
	_dvprintf(fmt, ap);
ffffffffea811a48:	910083a1 	add	x1, x29, #0x20
	va_start(ap, fmt);
ffffffffea811a4c:	b9005ba0 	str	w0, [x29, #88]
	_dvprintf(fmt, ap);
ffffffffea811a50:	aa1303e0 	mov	x0, x19
	va_start(ap, fmt);
ffffffffea811a54:	b9005fbf 	str	wzr, [x29, #92]
	_dvprintf(fmt, ap);
ffffffffea811a58:	a94417a4 	ldp	x4, x5, [x29, #64]
ffffffffea811a5c:	a90217a4 	stp	x4, x5, [x29, #32]
ffffffffea811a60:	a9450fa2 	ldp	x2, x3, [x29, #80]
ffffffffea811a64:	a9030fa2 	stp	x2, x3, [x29, #48]
ffffffffea811a68:	97ffffae 	bl	ffffffffea811920 <_dvprintf>
	platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
ffffffffea811a6c:	52800121 	mov	w1, #0x9                   	// #9
ffffffffea811a70:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea811a74:	97ffd833 	bl	ffffffffea807b40 <platform_halt>

ffffffffea811a78 <__debug_stdio_vfprintf>:
{
ffffffffea811a78:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811a7c:	aa0103e0 	mov	x0, x1
ffffffffea811a80:	910003fd 	mov	x29, sp
	return _dvprintf(fmt, ap);
ffffffffea811a84:	a9401444 	ldp	x4, x5, [x2]
ffffffffea811a88:	910043a1 	add	x1, x29, #0x10
ffffffffea811a8c:	a9410c42 	ldp	x2, x3, [x2, #16]
ffffffffea811a90:	a90117a4 	stp	x4, x5, [x29, #16]
ffffffffea811a94:	a9020fa2 	stp	x2, x3, [x29, #32]
ffffffffea811a98:	97ffffa2 	bl	ffffffffea811920 <_dvprintf>
}
ffffffffea811a9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811aa0:	d65f03c0 	ret
ffffffffea811aa4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811aa8 <heap_insert_free_chunk>:
static ssize_t heap_grow(size_t len);

// try to insert this free chunk into the free list, consuming the chunk by merging it with
// nearby ones if possible. Returns base of whatever chunk it became in the list.
static struct free_heap_chunk *heap_insert_free_chunk(struct free_heap_chunk *chunk)
{
ffffffffea811aa8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811aac:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea811ab0:	910003fd 	mov	x29, sp
ffffffffea811ab4:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811ab8:	aa0003f3 	mov	x19, x0
ffffffffea811abc:	f90013f5 	str	x21, [sp, #32]
ffffffffea811ac0:	f0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea811ac4:	913d2295 	add	x21, x20, #0xf48
ffffffffea811ac8:	910082a0 	add	x0, x21, #0x20
ffffffffea811acc:	97ffcf87 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	struct free_heap_chunk *next_chunk;
	struct free_heap_chunk *last_chunk;

	mutex_acquire(&theheap.lock);

	theheap.remaining += chunk->len;
ffffffffea811ad0:	f9400a63 	ldr	x3, [x19, #16]

	// walk through the list, finding the node to insert before
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
ffffffffea811ad4:	910162a1 	add	x1, x21, #0x58
	theheap.remaining += chunk->len;
ffffffffea811ad8:	f9400aa2 	ldr	x2, [x21, #16]
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
ffffffffea811adc:	f94032a0 	ldr	x0, [x21, #96]
	theheap.remaining += chunk->len;
ffffffffea811ae0:	8b030042 	add	x2, x2, x3
ffffffffea811ae4:	f9000aa2 	str	x2, [x21, #16]
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
ffffffffea811ae8:	eb01001f 	cmp	x0, x1
ffffffffea811aec:	540000a1 	b.ne	ffffffffea811b00 <heap_insert_free_chunk+0x58>  // b.any
ffffffffea811af0:	14000022 	b	ffffffffea811b78 <heap_insert_free_chunk+0xd0>
ffffffffea811af4:	f9400400 	ldr	x0, [x0, #8]
ffffffffea811af8:	eb01001f 	cmp	x0, x1
ffffffffea811afc:	540003e0 	b.eq	ffffffffea811b78 <heap_insert_free_chunk+0xd0>  // b.none
		if (chunk < next_chunk) {
ffffffffea811b00:	eb00027f 	cmp	x19, x0
ffffffffea811b04:	54ffff82 	b.cs	ffffffffea811af4 <heap_insert_free_chunk+0x4c>  // b.hs, b.nlast
	item->prev = list->prev;
ffffffffea811b08:	f9400001 	ldr	x1, [x0]
	// walked off the end of the list, add it at the tail
	list_add_tail(&theheap.free_list, &chunk->node);

	// try to merge with the previous chunk
try_merge:
	last_chunk = list_prev_type(&theheap.free_list, &chunk->node, struct free_heap_chunk, node);
ffffffffea811b0c:	913d2282 	add	x2, x20, #0xf48
	item->next = list;
ffffffffea811b10:	a9000261 	stp	x1, x0, [x19]
ffffffffea811b14:	91016042 	add	x2, x2, #0x58
	list->prev->next = item;
ffffffffea811b18:	f9400001 	ldr	x1, [x0]
ffffffffea811b1c:	f9000433 	str	x19, [x1, #8]
	list->prev = item;
ffffffffea811b20:	f9000013 	str	x19, [x0]
ffffffffea811b24:	f9400261 	ldr	x1, [x19]
ffffffffea811b28:	f100003f 	cmp	x1, #0x0
ffffffffea811b2c:	fa421024 	ccmp	x1, x2, #0x4, ne  // ne = any
ffffffffea811b30:	540000c0 	b.eq	ffffffffea811b48 <heap_insert_free_chunk+0xa0>  // b.none
	if (last_chunk) {
		if ((vaddr_t)last_chunk + last_chunk->len == (vaddr_t)chunk) {
ffffffffea811b34:	f9400822 	ldr	x2, [x1, #16]
ffffffffea811b38:	8b020024 	add	x4, x1, x2
ffffffffea811b3c:	eb04027f 	cmp	x19, x4
ffffffffea811b40:	54000360 	b.eq	ffffffffea811bac <heap_insert_free_chunk+0x104>  // b.none
			chunk = last_chunk;
		}
	}

	// try to merge with the next chunk
	if (next_chunk) {
ffffffffea811b44:	b40000a0 	cbz	x0, ffffffffea811b58 <heap_insert_free_chunk+0xb0>
		if ((vaddr_t)chunk + chunk->len == (vaddr_t)next_chunk) {
ffffffffea811b48:	f9400a61 	ldr	x1, [x19, #16]
ffffffffea811b4c:	8b010262 	add	x2, x19, x1
ffffffffea811b50:	eb02001f 	cmp	x0, x2
ffffffffea811b54:	54000400 	b.eq	ffffffffea811bd4 <heap_insert_free_chunk+0x12c>  // b.none
			// remove them from the list
			list_delete(&next_chunk->node);
		}
	}

	mutex_release(&theheap.lock);
ffffffffea811b58:	913d2280 	add	x0, x20, #0xf48
ffffffffea811b5c:	91008000 	add	x0, x0, #0x20
ffffffffea811b60:	97ffcf8e 	bl	ffffffffea805998 <mutex_release>

	return chunk;
}
ffffffffea811b64:	aa1303e0 	mov	x0, x19
ffffffffea811b68:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea811b6c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811b70:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811b74:	d65f03c0 	ret
	item->prev = list->prev;
ffffffffea811b78:	913d2281 	add	x1, x20, #0xf48
ffffffffea811b7c:	aa0103e2 	mov	x2, x1
ffffffffea811b80:	f8458c44 	ldr	x4, [x2, #88]!
	item->next = list;
ffffffffea811b84:	a9000a64 	stp	x4, x2, [x19]
	list->prev->next = item;
ffffffffea811b88:	f9402c24 	ldr	x4, [x1, #88]
ffffffffea811b8c:	f9000493 	str	x19, [x4, #8]
	list->prev = item;
ffffffffea811b90:	f9002c33 	str	x19, [x1, #88]
	last_chunk = list_prev_type(&theheap.free_list, &chunk->node, struct free_heap_chunk, node);
ffffffffea811b94:	f9400261 	ldr	x1, [x19]
ffffffffea811b98:	f100003f 	cmp	x1, #0x0
ffffffffea811b9c:	fa421024 	ccmp	x1, x2, #0x4, ne  // ne = any
ffffffffea811ba0:	54fffca1 	b.ne	ffffffffea811b34 <heap_insert_free_chunk+0x8c>  // b.any
	if (next_chunk) {
ffffffffea811ba4:	b5fffd20 	cbnz	x0, ffffffffea811b48 <heap_insert_free_chunk+0xa0>
ffffffffea811ba8:	17ffffec 	b	ffffffffea811b58 <heap_insert_free_chunk+0xb0>
	item->next->prev = item->prev;
ffffffffea811bac:	f9400664 	ldr	x4, [x19, #8]
			last_chunk->len += chunk->len;
ffffffffea811bb0:	8b020063 	add	x3, x3, x2
ffffffffea811bb4:	f9000823 	str	x3, [x1, #16]
ffffffffea811bb8:	f9000081 	str	x1, [x4]
	item->prev->next = item->next;
ffffffffea811bbc:	f9400262 	ldr	x2, [x19]
ffffffffea811bc0:	f9000444 	str	x4, [x2, #8]
	item->prev = item->next = 0;
ffffffffea811bc4:	a9007e7f 	stp	xzr, xzr, [x19]
ffffffffea811bc8:	aa0103f3 	mov	x19, x1
	if (next_chunk) {
ffffffffea811bcc:	b5fffbe0 	cbnz	x0, ffffffffea811b48 <heap_insert_free_chunk+0xa0>
ffffffffea811bd0:	17ffffe2 	b	ffffffffea811b58 <heap_insert_free_chunk+0xb0>
	item->next->prev = item->prev;
ffffffffea811bd4:	a9400c04 	ldp	x4, x3, [x0]
			chunk->len += next_chunk->len;
ffffffffea811bd8:	f9400802 	ldr	x2, [x0, #16]
ffffffffea811bdc:	8b010041 	add	x1, x2, x1
ffffffffea811be0:	f9000a61 	str	x1, [x19, #16]
ffffffffea811be4:	f9000064 	str	x4, [x3]
	item->prev->next = item->next;
ffffffffea811be8:	f9400001 	ldr	x1, [x0]
ffffffffea811bec:	f9000423 	str	x3, [x1, #8]
	item->prev = item->next = 0;
ffffffffea811bf0:	a9007c1f 	stp	xzr, xzr, [x0]
	mutex_release(&theheap.lock);
ffffffffea811bf4:	913d2280 	add	x0, x20, #0xf48
ffffffffea811bf8:	91008000 	add	x0, x0, #0x20
ffffffffea811bfc:	97ffcf67 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea811c00:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea811c04:	aa1303e0 	mov	x0, x19
ffffffffea811c08:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811c0c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811c10:	d65f03c0 	ret
ffffffffea811c14:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811c18 <heap_free_delayed_list>:

	return chunk;
}

static void heap_free_delayed_list(void)
{
ffffffffea811c18:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea811c1c:	910003fd 	mov	x29, sp
ffffffffea811c20:	a90153f3 	stp	x19, x20, [sp, #16]
	list->prev = list->next = list;
ffffffffea811c24:	910103b3 	add	x19, x29, #0x40
ffffffffea811c28:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea811c2c:	a9044fb3 	stp	x19, x19, [x29, #64]
ffffffffea811c30:	f9001bf7 	str	x23, [sp, #48]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811c34:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea811c38:	37380620 	tbnz	w0, #7, ffffffffea811cfc <heap_free_delayed_list+0xe4>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811c3c:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea811c40:	f0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea811c44:	913d2296 	add	x22, x20, #0xf48
ffffffffea811c48:	9101e2d7 	add	x23, x22, #0x78
	if (list->next != list) {
ffffffffea811c4c:	9101a2d6 	add	x22, x22, #0x68
ffffffffea811c50:	aa1703e0 	mov	x0, x23
ffffffffea811c54:	97ffc342 	bl	ffffffffea80295c <arch_spin_lock>
ffffffffea811c58:	f94006c1 	ldr	x1, [x22, #8]
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811c5c:	52800035 	mov	w21, #0x1                   	// #1
ffffffffea811c60:	eb16003f 	cmp	x1, x22
ffffffffea811c64:	54000660 	b.eq	ffffffffea811d30 <heap_free_delayed_list+0x118>  // b.none
ffffffffea811c68:	913d2280 	add	x0, x20, #0xf48
ffffffffea811c6c:	9101a004 	add	x4, x0, #0x68
	item->next->prev = item->prev;
ffffffffea811c70:	a9400823 	ldp	x3, x2, [x1]
ffffffffea811c74:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea811c78:	f9400023 	ldr	x3, [x1]
ffffffffea811c7c:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea811c80:	f900043f 	str	xzr, [x1, #8]
	item->next = list->next;
ffffffffea811c84:	f94027a2 	ldr	x2, [x29, #72]
ffffffffea811c88:	a9000833 	stp	x19, x2, [x1]
	list->next->prev = item;
ffffffffea811c8c:	f94027a2 	ldr	x2, [x29, #72]
ffffffffea811c90:	f9000041 	str	x1, [x2]
	list->next = item;
ffffffffea811c94:	f90027a1 	str	x1, [x29, #72]
	if (list->next != list) {
ffffffffea811c98:	f9403801 	ldr	x1, [x0, #112]
ffffffffea811c9c:	eb04003f 	cmp	x1, x4
ffffffffea811ca0:	54fffe81 	b.ne	ffffffffea811c70 <heap_free_delayed_list+0x58>  // b.any
    arch_spin_unlock(lock);
ffffffffea811ca4:	9101e000 	add	x0, x0, #0x78
ffffffffea811ca8:	97ffc335 	bl	ffffffffea80297c <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea811cac:	34000195 	cbz	w21, ffffffffea811cdc <heap_free_delayed_list+0xc4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea811cb0:	d50342ff 	msr	daifclr, #0x2
ffffffffea811cb4:	f94027a1 	ldr	x1, [x29, #72]
ffffffffea811cb8:	eb13003f 	cmp	x1, x19
ffffffffea811cbc:	54000160 	b.eq	ffffffffea811ce8 <heap_free_delayed_list+0xd0>  // b.none
	item->next->prev = item->prev;
ffffffffea811cc0:	a9400823 	ldp	x3, x2, [x1]
	}
	spin_unlock_irqrestore(&theheap.delayed_free_lock, state);

	while ((chunk = list_remove_head_type(&list, struct free_heap_chunk, node))) {
		LTRACEF("freeing chunk %p\n", chunk);
		heap_insert_free_chunk(chunk);
ffffffffea811cc4:	aa0103e0 	mov	x0, x1
ffffffffea811cc8:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea811ccc:	f9400023 	ldr	x3, [x1]
ffffffffea811cd0:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea811cd4:	a9007c3f 	stp	xzr, xzr, [x1]
ffffffffea811cd8:	97ffff74 	bl	ffffffffea811aa8 <heap_insert_free_chunk>
	if (list->next != list) {
ffffffffea811cdc:	f94027a1 	ldr	x1, [x29, #72]
ffffffffea811ce0:	eb13003f 	cmp	x1, x19
ffffffffea811ce4:	54fffee1 	b.ne	ffffffffea811cc0 <heap_free_delayed_list+0xa8>  // b.any
	}
}
ffffffffea811ce8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811cec:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea811cf0:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea811cf4:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea811cf8:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea811cfc:	f0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea811d00:	913d2296 	add	x22, x20, #0xf48
ffffffffea811d04:	9101e2d7 	add	x23, x22, #0x78
ffffffffea811d08:	9101a2d6 	add	x22, x22, #0x68
ffffffffea811d0c:	aa1703e0 	mov	x0, x23
ffffffffea811d10:	97ffc313 	bl	ffffffffea80295c <arch_spin_lock>
ffffffffea811d14:	f94006c1 	ldr	x1, [x22, #8]
    spin_lock_saved_state_t state = 0;
ffffffffea811d18:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea811d1c:	eb16003f 	cmp	x1, x22
ffffffffea811d20:	54fffa41 	b.ne	ffffffffea811c68 <heap_free_delayed_list+0x50>  // b.any
    arch_spin_unlock(lock);
ffffffffea811d24:	aa1703e0 	mov	x0, x23
ffffffffea811d28:	97ffc315 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea811d2c:	17ffffec 	b	ffffffffea811cdc <heap_free_delayed_list+0xc4>
ffffffffea811d30:	aa1703e0 	mov	x0, x23
ffffffffea811d34:	97ffc312 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea811d38:	d50342ff 	msr	daifclr, #0x2
ffffffffea811d3c:	17ffffde 	b	ffffffffea811cb4 <heap_free_delayed_list+0x9c>

ffffffffea811d40 <heap_alloc>:

void *heap_alloc(size_t size, unsigned int alignment)
{
ffffffffea811d40:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea811d44:	910003fd 	mov	x29, sp
ffffffffea811d48:	a901d7f4 	stp	x20, x21, [sp, #24]
	return (list->next == list) ? true : false;
ffffffffea811d4c:	f0000255 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea811d50:	913d22a2 	add	x2, x21, #0xf48
ffffffffea811d54:	f9001bf7 	str	x23, [sp, #48]
ffffffffea811d58:	2a0103f7 	mov	w23, w1
#endif

	LTRACEF("size %zd, align %d\n", size, alignment);

	// deal with the pending free list
	if (unlikely(!list_is_empty(&theheap.delayed_free_list))) {
ffffffffea811d5c:	9101a043 	add	x3, x2, #0x68
ffffffffea811d60:	f9403841 	ldr	x1, [x2, #112]
ffffffffea811d64:	eb03003f 	cmp	x1, x3
ffffffffea811d68:	540014a1 	b.ne	ffffffffea811ffc <heap_alloc+0x2bc>  // b.any
		heap_free_delayed_list();
	}

	// alignment must be power of 2
	if (alignment & (alignment - 1))
ffffffffea811d6c:	510006e1 	sub	w1, w23, #0x1
ffffffffea811d70:	6a17003f 	tst	w1, w23
ffffffffea811d74:	54000a21 	b.ne	ffffffffea811eb8 <heap_alloc+0x178>  // b.any
		return NULL;

	// we always put a size field + base pointer + magic in front of the allocation
	size += sizeof(struct alloc_struct_begin);
ffffffffea811d78:	91004000 	add	x0, x0, #0x10
ffffffffea811d7c:	f9000bb3 	str	x19, [x29, #16]
	// in the spot
	if (size < sizeof(struct free_heap_chunk))
		size = sizeof(struct free_heap_chunk);

	// round up size to a multiple of native pointer size
	size = ROUNDUP(size, sizeof(void *));
ffffffffea811d80:	d2800313 	mov	x19, #0x18                  	// #24
ffffffffea811d84:	eb13001f 	cmp	x0, x19
ffffffffea811d88:	9a932013 	csel	x19, x0, x19, cs  // cs = hs, nlast
ffffffffea811d8c:	f90017b6 	str	x22, [x29, #40]
ffffffffea811d90:	91001e73 	add	x19, x19, #0x7
ffffffffea811d94:	927df273 	and	x19, x19, #0xfffffffffffffff8

	// deal with nonzero alignments
	if (alignment > 0) {
ffffffffea811d98:	35001237 	cbnz	w23, ffffffffea811fdc <heap_alloc+0x29c>
	mutex_release(&theheap.lock);

#if WITH_KERNEL_VM
	/* try to grow the heap if we can */
	if (ptr == NULL && retry_count == 0) {
		size_t growby = MAX(HEAP_GROW_SIZE, ROUNDUP(size, PAGE_SIZE));
ffffffffea811d9c:	913ffe62 	add	x2, x19, #0xfff
ffffffffea811da0:	d2a00020 	mov	x0, #0x10000               	// #65536
ffffffffea811da4:	9274cc42 	and	x2, x2, #0xfffffffffffff000
ffffffffea811da8:	913d22b4 	add	x20, x21, #0xf48
ffffffffea811dac:	eb00005f 	cmp	x2, x0
ffffffffea811db0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea811db4:	9a802042 	csel	x2, x2, x0, cs  // cs = hs, nlast
ffffffffea811db8:	91008280 	add	x0, x20, #0x20
}

static ssize_t heap_grow(size_t size)
{
#if WITH_KERNEL_VM
	size = ROUNDUP(size, PAGE_SIZE);
ffffffffea811dbc:	913ffc56 	add	x22, x2, #0xfff
ffffffffea811dc0:	97ffceca 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea811dc4:	f9403280 	ldr	x0, [x20, #96]
ffffffffea811dc8:	91016282 	add	x2, x20, #0x58

	void *ptr = pmm_alloc_kpages(size / PAGE_SIZE, NULL);
ffffffffea811dcc:	d34cfed4 	lsr	x20, x22, #12
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea811dd0:	eb02001f 	cmp	x0, x2
ffffffffea811dd4:	54000160 	b.eq	ffffffffea811e00 <heap_alloc+0xc0>  // b.none
		if (chunk->len >= size) {
ffffffffea811dd8:	f9400801 	ldr	x1, [x0, #16]
ffffffffea811ddc:	eb13003f 	cmp	x1, x19
ffffffffea811de0:	540000a3 	b.cc	ffffffffea811df4 <heap_alloc+0xb4>  // b.lo, b.ul, b.last
ffffffffea811de4:	1400003b 	b	ffffffffea811ed0 <heap_alloc+0x190>
ffffffffea811de8:	f9400801 	ldr	x1, [x0, #16]
ffffffffea811dec:	eb01027f 	cmp	x19, x1
ffffffffea811df0:	54000709 	b.ls	ffffffffea811ed0 <heap_alloc+0x190>  // b.plast
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea811df4:	f9400400 	ldr	x0, [x0, #8]
ffffffffea811df8:	eb02001f 	cmp	x0, x2
ffffffffea811dfc:	54ffff61 	b.ne	ffffffffea811de8 <heap_alloc+0xa8>  // b.any
	mutex_release(&theheap.lock);
ffffffffea811e00:	913d22a0 	add	x0, x21, #0xf48
	size = ROUNDUP(size, PAGE_SIZE);
ffffffffea811e04:	9274ced6 	and	x22, x22, #0xfffffffffffff000
	mutex_release(&theheap.lock);
ffffffffea811e08:	91008000 	add	x0, x0, #0x20
ffffffffea811e0c:	97ffcee3 	bl	ffffffffea805998 <mutex_release>
	void *ptr = pmm_alloc_kpages(size / PAGE_SIZE, NULL);
ffffffffea811e10:	2a1403e0 	mov	w0, w20
ffffffffea811e14:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea811e18:	97fffaf6 	bl	ffffffffea8109f0 <pmm_alloc_kpages>
ffffffffea811e1c:	aa0003f4 	mov	x20, x0
	if (!ptr) {
ffffffffea811e20:	b4000fe0 	cbz	x0, ffffffffea81201c <heap_alloc+0x2dc>
	chunk->len = len;
ffffffffea811e24:	f9000816 	str	x22, [x0, #16]
		return ERR_NO_MEMORY;
	}

	LTRACEF("growing heap by 0x%zx bytes, new ptr %p\n", size, ptr);

	heap_insert_free_chunk(heap_create_free_chunk(ptr, size, true));
ffffffffea811e28:	97ffff20 	bl	ffffffffea811aa8 <heap_insert_free_chunk>

	/* change the heap start and end variables */
	if ((uintptr_t)ptr < (uintptr_t)theheap.base)
ffffffffea811e2c:	f947a6a1 	ldr	x1, [x21, #3912]
ffffffffea811e30:	eb14003f 	cmp	x1, x20
ffffffffea811e34:	54000069 	b.ls	ffffffffea811e40 <heap_alloc+0x100>  // b.plast
		theheap.base = ptr;
ffffffffea811e38:	aa1403e1 	mov	x1, x20
ffffffffea811e3c:	f907a6b4 	str	x20, [x21, #3912]

	uintptr_t endptr = (uintptr_t)ptr + size;
	if (endptr > (uintptr_t)theheap.base + theheap.len) {
ffffffffea811e40:	913d22a2 	add	x2, x21, #0xf48
	uintptr_t endptr = (uintptr_t)ptr + size;
ffffffffea811e44:	8b160294 	add	x20, x20, x22
	if (endptr > (uintptr_t)theheap.base + theheap.len) {
ffffffffea811e48:	f9400440 	ldr	x0, [x2, #8]
ffffffffea811e4c:	8b000020 	add	x0, x1, x0
ffffffffea811e50:	eb00029f 	cmp	x20, x0
ffffffffea811e54:	54000ce8 	b.hi	ffffffffea811ff0 <heap_alloc+0x2b0>  // b.pmore
		if (err >= 0) {
ffffffffea811e58:	b7f80db6 	tbnz	x22, #63, ffffffffea81200c <heap_alloc+0x2cc>
ffffffffea811e5c:	913d22b4 	add	x20, x21, #0xf48
ffffffffea811e60:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea811e64:	91008280 	add	x0, x20, #0x20
ffffffffea811e68:	97ffcea0 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea811e6c:	91016282 	add	x2, x20, #0x58
ffffffffea811e70:	f9403280 	ldr	x0, [x20, #96]
ffffffffea811e74:	eb02001f 	cmp	x0, x2
ffffffffea811e78:	54000160 	b.eq	ffffffffea811ea4 <heap_alloc+0x164>  // b.none
		if (chunk->len >= size) {
ffffffffea811e7c:	f9400801 	ldr	x1, [x0, #16]
ffffffffea811e80:	eb01027f 	cmp	x19, x1
ffffffffea811e84:	540000a8 	b.hi	ffffffffea811e98 <heap_alloc+0x158>  // b.pmore
ffffffffea811e88:	14000012 	b	ffffffffea811ed0 <heap_alloc+0x190>
ffffffffea811e8c:	f9400801 	ldr	x1, [x0, #16]
ffffffffea811e90:	eb13003f 	cmp	x1, x19
ffffffffea811e94:	540001e2 	b.cs	ffffffffea811ed0 <heap_alloc+0x190>  // b.hs, b.nlast
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea811e98:	f9400400 	ldr	x0, [x0, #8]
ffffffffea811e9c:	eb02001f 	cmp	x0, x2
ffffffffea811ea0:	54ffff61 	b.ne	ffffffffea811e8c <heap_alloc+0x14c>  // b.any
	mutex_release(&theheap.lock);
ffffffffea811ea4:	913d22a0 	add	x0, x21, #0xf48
ffffffffea811ea8:	91008000 	add	x0, x0, #0x20
ffffffffea811eac:	97ffcebb 	bl	ffffffffea805998 <mutex_release>
ffffffffea811eb0:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea811eb4:	f94017b6 	ldr	x22, [x29, #40]
		return NULL;
ffffffffea811eb8:	d2800014 	mov	x20, #0x0                   	// #0
}
ffffffffea811ebc:	aa1403e0 	mov	x0, x20
ffffffffea811ec0:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea811ec4:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea811ec8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea811ecc:	d65f03c0 	ret
			struct list_node *next_node = list_next(&theheap.free_list, &chunk->node);
ffffffffea811ed0:	a9400806 	ldp	x6, x2, [x0]
	if (item->next != list)
ffffffffea811ed4:	913d22a3 	add	x3, x21, #0xf48
ffffffffea811ed8:	91016064 	add	x4, x3, #0x58
ffffffffea811edc:	91006265 	add	x5, x19, #0x18
ffffffffea811ee0:	eb04005f 	cmp	x2, x4
ffffffffea811ee4:	54000560 	b.eq	ffffffffea811f90 <heap_alloc+0x250>  // b.none
	item->next->prev = item->prev;
ffffffffea811ee8:	f9000046 	str	x6, [x2]
			if (chunk->len > size + sizeof(struct free_heap_chunk)) {
ffffffffea811eec:	eb05003f 	cmp	x1, x5
	item->prev->next = item->next;
ffffffffea811ef0:	f9400003 	ldr	x3, [x0]
ffffffffea811ef4:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea811ef8:	a9007c1f 	stp	xzr, xzr, [x0]
ffffffffea811efc:	54000569 	b.ls	ffffffffea811fa8 <heap_alloc+0x268>  // b.plast
				struct free_heap_chunk *newchunk = heap_create_free_chunk((uint8_t *)ptr + size, chunk->len - size, true);
ffffffffea811f00:	8b130003 	add	x3, x0, x19
	item->prev = list->prev;
ffffffffea811f04:	f9400044 	ldr	x4, [x2]
ffffffffea811f08:	cb130021 	sub	x1, x1, x19
	chunk->len = len;
ffffffffea811f0c:	f9000861 	str	x1, [x3, #16]
				chunk->len -= chunk->len - size;
ffffffffea811f10:	f9000813 	str	x19, [x0, #16]
ffffffffea811f14:	f8336804 	str	x4, [x0, x19]
	list->prev->next = item;
ffffffffea811f18:	f9400041 	ldr	x1, [x2]
	item->next = list;
ffffffffea811f1c:	f9000462 	str	x2, [x3, #8]
	list->prev->next = item;
ffffffffea811f20:	f9000423 	str	x3, [x1, #8]
	list->prev = item;
ffffffffea811f24:	f9000043 	str	x3, [x2]
				ptr = (void *)ROUNDUP((addr_t)ptr, (addr_t)alignment);
ffffffffea811f28:	2a1703e2 	mov	w2, w23
			ptr = (void *)((addr_t)ptr + sizeof(struct alloc_struct_begin));
ffffffffea811f2c:	91004014 	add	x20, x0, #0x10
				ptr = (void *)ROUNDUP((addr_t)ptr, (addr_t)alignment);
ffffffffea811f30:	d1000441 	sub	x1, x2, #0x1
			theheap.remaining -= size;
ffffffffea811f34:	913d22a3 	add	x3, x21, #0xf48
				ptr = (void *)ROUNDUP((addr_t)ptr, (addr_t)alignment);
ffffffffea811f38:	cb0203e2 	neg	x2, x2
ffffffffea811f3c:	8b140021 	add	x1, x1, x20
ffffffffea811f40:	710002ff 	cmp	w23, #0x0
ffffffffea811f44:	8a020021 	and	x1, x1, x2
ffffffffea811f48:	9a810294 	csel	x20, x20, x1, eq  // eq = none
			if (theheap.remaining < theheap.low_watermark) {
ffffffffea811f4c:	a9410861 	ldp	x1, x2, [x3, #16]
			as->size = size;
ffffffffea811f50:	a93f4e80 	stp	x0, x19, [x20, #-16]
			theheap.remaining -= size;
ffffffffea811f54:	cb130033 	sub	x19, x1, x19
ffffffffea811f58:	f9000873 	str	x19, [x3, #16]
			if (theheap.remaining < theheap.low_watermark) {
ffffffffea811f5c:	eb02027f 	cmp	x19, x2
ffffffffea811f60:	54000042 	b.cs	ffffffffea811f68 <heap_alloc+0x228>  // b.hs, b.nlast
				theheap.low_watermark = theheap.remaining;
ffffffffea811f64:	f9000c73 	str	x19, [x3, #24]
	mutex_release(&theheap.lock);
ffffffffea811f68:	913d22a0 	add	x0, x21, #0xf48
ffffffffea811f6c:	91008000 	add	x0, x0, #0x20
ffffffffea811f70:	97ffce8a 	bl	ffffffffea805998 <mutex_release>
ffffffffea811f74:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea811f78:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea811f7c:	aa1403e0 	mov	x0, x20
ffffffffea811f80:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea811f84:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea811f88:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea811f8c:	d65f03c0 	ret
	item->next->prev = item->prev;
ffffffffea811f90:	f9002c66 	str	x6, [x3, #88]
			if (chunk->len > size + sizeof(struct free_heap_chunk)) {
ffffffffea811f94:	eb05003f 	cmp	x1, x5
	item->prev->next = item->next;
ffffffffea811f98:	f9400004 	ldr	x4, [x0]
ffffffffea811f9c:	f9000482 	str	x2, [x4, #8]
	item->prev = item->next = 0;
ffffffffea811fa0:	a9007c1f 	stp	xzr, xzr, [x0]
ffffffffea811fa4:	54000068 	b.hi	ffffffffea811fb0 <heap_alloc+0x270>  // b.pmore
ffffffffea811fa8:	f9400813 	ldr	x19, [x0, #16]
ffffffffea811fac:	17ffffdf 	b	ffffffffea811f28 <heap_alloc+0x1e8>
				struct free_heap_chunk *newchunk = heap_create_free_chunk((uint8_t *)ptr + size, chunk->len - size, true);
ffffffffea811fb0:	8b130004 	add	x4, x0, x19
	item->prev = list->prev;
ffffffffea811fb4:	f9402c65 	ldr	x5, [x3, #88]
ffffffffea811fb8:	cb130021 	sub	x1, x1, x19
	chunk->len = len;
ffffffffea811fbc:	f9000881 	str	x1, [x4, #16]
				chunk->len -= chunk->len - size;
ffffffffea811fc0:	f9000813 	str	x19, [x0, #16]
ffffffffea811fc4:	f8336805 	str	x5, [x0, x19]
	item->next = list;
ffffffffea811fc8:	f9000482 	str	x2, [x4, #8]
	list->prev->next = item;
ffffffffea811fcc:	f9402c61 	ldr	x1, [x3, #88]
ffffffffea811fd0:	f9000424 	str	x4, [x1, #8]
	list->prev = item;
ffffffffea811fd4:	f9002c64 	str	x4, [x3, #88]
ffffffffea811fd8:	17ffffd4 	b	ffffffffea811f28 <heap_alloc+0x1e8>
ffffffffea811fdc:	710042ff 	cmp	w23, #0x10
ffffffffea811fe0:	52800200 	mov	w0, #0x10                  	// #16
ffffffffea811fe4:	1a8022f7 	csel	w23, w23, w0, cs  // cs = hs, nlast
		size += alignment;
ffffffffea811fe8:	8b374273 	add	x19, x19, w23, uxtw
ffffffffea811fec:	17ffff6c 	b	ffffffffea811d9c <heap_alloc+0x5c>
		theheap.len = (uintptr_t)endptr - (uintptr_t)theheap.base;
ffffffffea811ff0:	cb010294 	sub	x20, x20, x1
ffffffffea811ff4:	f9000454 	str	x20, [x2, #8]
ffffffffea811ff8:	17ffff98 	b	ffffffffea811e58 <heap_alloc+0x118>
ffffffffea811ffc:	f90027a0 	str	x0, [x29, #72]
		heap_free_delayed_list();
ffffffffea812000:	97ffff06 	bl	ffffffffea811c18 <heap_free_delayed_list>
ffffffffea812004:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea812008:	17ffff59 	b	ffffffffea811d6c <heap_alloc+0x2c>
ffffffffea81200c:	f9400bb3 	ldr	x19, [x29, #16]
		return NULL;
ffffffffea812010:	d2800014 	mov	x20, #0x0                   	// #0
ffffffffea812014:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea812018:	17ffffa9 	b	ffffffffea811ebc <heap_alloc+0x17c>
		TRACEF("failed to grow kernel heap by 0x%zx bytes\n", size);
ffffffffea81201c:	aa1603e3 	mov	x3, x22
ffffffffea812020:	b0000021 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea812024:	b0000020 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea812028:	528036c2 	mov	w2, #0x1b6                 	// #438
ffffffffea81202c:	911c8021 	add	x1, x1, #0x720
ffffffffea812030:	911cc000 	add	x0, x0, #0x730
ffffffffea812034:	940003db 	bl	ffffffffea812fa0 <_printf>
ffffffffea812038:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea81203c:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea812040:	17ffffcf 	b	ffffffffea811f7c <heap_alloc+0x23c>
ffffffffea812044:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812048 <heap_free>:
	if (ptr == 0)
ffffffffea812048:	b40000a0 	cbz	x0, ffffffffea81205c <heap_free+0x14>
	chunk->len = len;
ffffffffea81204c:	a97f0801 	ldp	x1, x2, [x0, #-16]
ffffffffea812050:	f9000822 	str	x2, [x1, #16]
	heap_insert_free_chunk(heap_create_free_chunk(as->ptr, as->size, true));
ffffffffea812054:	aa0103e0 	mov	x0, x1
ffffffffea812058:	17fffe94 	b	ffffffffea811aa8 <heap_insert_free_chunk>
}
ffffffffea81205c:	d65f03c0 	ret

ffffffffea812060 <heap_delayed_free>:
{
ffffffffea812060:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea812064:	910003fd 	mov	x29, sp
ffffffffea812068:	a90153f3 	stp	x19, x20, [sp, #16]
	chunk->len = len;
ffffffffea81206c:	a97f0013 	ldp	x19, x0, [x0, #-16]
{
ffffffffea812070:	f90013f5 	str	x21, [sp, #32]
	chunk->len = len;
ffffffffea812074:	f9000a60 	str	x0, [x19, #16]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea812078:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea81207c:	37380280 	tbnz	w0, #7, ffffffffea8120cc <heap_delayed_free+0x6c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea812080:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea812084:	d0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea812088:	913d2294 	add	x20, x20, #0xf48
ffffffffea81208c:	9101e295 	add	x21, x20, #0x78
ffffffffea812090:	aa1503e0 	mov	x0, x21
ffffffffea812094:	97ffc232 	bl	ffffffffea80295c <arch_spin_lock>
	item->next = list->next;
ffffffffea812098:	f9403a80 	ldr	x0, [x20, #112]
	item->prev = list;
ffffffffea81209c:	9101a281 	add	x1, x20, #0x68
	item->next = list->next;
ffffffffea8120a0:	a9000261 	stp	x1, x0, [x19]
    arch_spin_unlock(lock);
ffffffffea8120a4:	aa1503e0 	mov	x0, x21
	list->next->prev = item;
ffffffffea8120a8:	f9403a81 	ldr	x1, [x20, #112]
ffffffffea8120ac:	f9000033 	str	x19, [x1]
	list->next = item;
ffffffffea8120b0:	f9003a93 	str	x19, [x20, #112]
ffffffffea8120b4:	97ffc232 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8120b8:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8120bc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8120c0:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8120c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8120c8:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8120cc:	d0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea8120d0:	913d2294 	add	x20, x20, #0xf48
ffffffffea8120d4:	9101e295 	add	x21, x20, #0x78
ffffffffea8120d8:	aa1503e0 	mov	x0, x21
ffffffffea8120dc:	97ffc220 	bl	ffffffffea80295c <arch_spin_lock>
	item->next = list->next;
ffffffffea8120e0:	f9403a80 	ldr	x0, [x20, #112]
	item->prev = list;
ffffffffea8120e4:	9101a281 	add	x1, x20, #0x68
	item->next = list->next;
ffffffffea8120e8:	a9000261 	stp	x1, x0, [x19]
    arch_spin_unlock(lock);
ffffffffea8120ec:	aa1503e0 	mov	x0, x21
ffffffffea8120f0:	f94013f5 	ldr	x21, [sp, #32]
	list->next->prev = item;
ffffffffea8120f4:	f9403a81 	ldr	x1, [x20, #112]
ffffffffea8120f8:	f9000033 	str	x19, [x1]
	list->next = item;
ffffffffea8120fc:	f9003a93 	str	x19, [x20, #112]
ffffffffea812100:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812104:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea812108:	17ffc21d 	b	ffffffffea80297c <arch_spin_unlock>
ffffffffea81210c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812110 <heap_init>:
	return ERR_NO_MEMORY;
#endif
}

void heap_init(void)
{
ffffffffea812110:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea812114:	910003fd 	mov	x29, sp
ffffffffea812118:	a90153f3 	stp	x19, x20, [sp, #16]
	LTRACE_ENTRY;

	// create a mutex
	mutex_init(&theheap.lock);
ffffffffea81211c:	d0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea812120:	913d2293 	add	x19, x20, #0xf48
{
ffffffffea812124:	f90013f5 	str	x21, [sp, #32]
	mutex_init(&theheap.lock);
ffffffffea812128:	91008260 	add	x0, x19, #0x20
ffffffffea81212c:	aa1e03f5 	mov	x21, x30
ffffffffea812130:	97ffcde2 	bl	ffffffffea8058b8 <mutex_init>
	list->prev = list->next = list;
ffffffffea812134:	91016261 	add	x1, x19, #0x58
ffffffffea812138:	9101a260 	add	x0, x19, #0x68
ffffffffea81213c:	a9058661 	stp	x1, x1, [x19, #88]
	list_initialize(&theheap.delayed_free_list);
	spin_lock_init(&theheap.delayed_free_lock);

	// set the heap range
#if WITH_KERNEL_VM
	theheap.base = pmm_alloc_kpages(HEAP_GROW_SIZE / PAGE_SIZE, NULL);
ffffffffea812140:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea812144:	a9068260 	stp	x0, x0, [x19, #104]
ffffffffea812148:	52800200 	mov	w0, #0x10                  	// #16
    *lock = SPIN_LOCK_INITIAL_VALUE;
ffffffffea81214c:	f9003e7f 	str	xzr, [x19, #120]
ffffffffea812150:	97fffa28 	bl	ffffffffea8109f0 <pmm_alloc_kpages>
	theheap.len = HEAP_GROW_SIZE;
ffffffffea812154:	d2a00022 	mov	x2, #0x10000               	// #65536
	theheap.base = pmm_alloc_kpages(HEAP_GROW_SIZE / PAGE_SIZE, NULL);
ffffffffea812158:	f907a680 	str	x0, [x20, #3912]
	theheap.len = HEAP_GROW_SIZE;
ffffffffea81215c:	f9000662 	str	x2, [x19, #8]

	if (theheap.base == 0) {
ffffffffea812160:	b40000e0 	cbz	x0, ffffffffea81217c <heap_init+0x6c>
#else
	theheap.base = (void *)HEAP_START;
	theheap.len = HEAP_LEN;
#endif
	theheap.remaining = 0; // will get set by heap_insert_free_chunk()
	theheap.low_watermark = theheap.len;
ffffffffea812164:	a9010a7f 	stp	xzr, x2, [x19, #16]
	LTRACEF("base %p size %zd bytes\n", theheap.base, theheap.len);

	// create an initial free chunk
	heap_insert_free_chunk(heap_create_free_chunk(theheap.base, theheap.len, false));
}
ffffffffea812168:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81216c:	f94013f5 	ldr	x21, [sp, #32]
	chunk->len = len;
ffffffffea812170:	f9000802 	str	x2, [x0, #16]
}
ffffffffea812174:	a8c37bfd 	ldp	x29, x30, [sp], #48
	heap_insert_free_chunk(heap_create_free_chunk(theheap.base, theheap.len, false));
ffffffffea812178:	17fffe4c 	b	ffffffffea811aa8 <heap_insert_free_chunk>
		panic("HEAP: error allocating initial heap size\n");
ffffffffea81217c:	b0000021 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea812180:	aa1503e0 	mov	x0, x21
ffffffffea812184:	911da021 	add	x1, x1, #0x768
ffffffffea812188:	97fffe20 	bl	ffffffffea811a08 <_panic>
ffffffffea81218c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812190 <strtoul>:
	}

	return value;
}

unsigned long strtoul(const char *nptr, char **endptr, int base) {
ffffffffea812190:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	int neg = 0;
	unsigned long ret = 0;

	if (base < 0 || base == 1 || base > 36) {
ffffffffea812194:	7100045f 	cmp	w2, #0x1
unsigned long strtoul(const char *nptr, char **endptr, int base) {
ffffffffea812198:	910003fd 	mov	x29, sp
ffffffffea81219c:	f9000bf3 	str	x19, [sp, #16]
ffffffffea8121a0:	aa0003f3 	mov	x19, x0
ffffffffea8121a4:	f90013f5 	str	x21, [sp, #32]
	if (base < 0 || base == 1 || base > 36) {
ffffffffea8121a8:	1a9f17f5 	cset	w21, eq  // eq = none
ffffffffea8121ac:	7100905f 	cmp	w2, #0x24
ffffffffea8121b0:	1a9f97e0 	cset	w0, hi  // hi = pmore
ffffffffea8121b4:	2a0002b5 	orr	w21, w21, w0
ffffffffea8121b8:	34000155 	cbz	w21, ffffffffea8121e0 <strtoul+0x50>
		errno = EINVAL;
ffffffffea8121bc:	9400006f 	bl	ffffffffea812378 <__geterrno>
	if (neg && ret != ULONG_MAX) {
		ret = -ret;
	}

	return ret;
}
ffffffffea8121c0:	f9400bf3 	ldr	x19, [sp, #16]
		errno = EINVAL;
ffffffffea8121c4:	528002c2 	mov	w2, #0x16                  	// #22
ffffffffea8121c8:	b9000002 	str	w2, [x0]
		return 0;
ffffffffea8121cc:	d2800001 	mov	x1, #0x0                   	// #0
}
ffffffffea8121d0:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8121d4:	aa0103e0 	mov	x0, x1
ffffffffea8121d8:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8121dc:	d65f03c0 	ret
ffffffffea8121e0:	f9000fb4 	str	x20, [x29, #24]
ffffffffea8121e4:	2a0203f4 	mov	w20, w2
ffffffffea8121e8:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea8121ec:	aa0103f7 	mov	x23, x1
ffffffffea8121f0:	f9001fb8 	str	x24, [x29, #56]
ffffffffea8121f4:	14000002 	b	ffffffffea8121fc <strtoul+0x6c>
		nptr++;
ffffffffea8121f8:	91000673 	add	x19, x19, #0x1
	while (isspace(*nptr)) {
ffffffffea8121fc:	39400260 	ldrb	w0, [x19]
ffffffffea812200:	94000056 	bl	ffffffffea812358 <isspace>
ffffffffea812204:	35ffffa0 	cbnz	w0, ffffffffea8121f8 <strtoul+0x68>
	if (*nptr == '+') {
ffffffffea812208:	39400260 	ldrb	w0, [x19]
ffffffffea81220c:	7100ac1f 	cmp	w0, #0x2b
ffffffffea812210:	54000800 	b.eq	ffffffffea812310 <strtoul+0x180>  // b.none
	} else if (*nptr == '-') {
ffffffffea812214:	7100b41f 	cmp	w0, #0x2d
ffffffffea812218:	54000740 	b.eq	ffffffffea812300 <strtoul+0x170>  // b.none
	if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
ffffffffea81221c:	721b7a9f 	tst	w20, #0xffffffef
ffffffffea812220:	54000640 	b.eq	ffffffffea8122e8 <strtoul+0x158>  // b.none
		if (c >= 'A' && c <= 'Z') {
ffffffffea812224:	51010402 	sub	w2, w0, #0x41
		new_ret = ret * base;
ffffffffea812228:	93407e98 	sxtw	x24, w20
		if (c >= 'A' && c <= 'Z') {
ffffffffea81222c:	12001c42 	and	w2, w2, #0xff
		base = 10;
ffffffffea812230:	d2800001 	mov	x1, #0x0                   	// #0
			errno = ERANGE;
ffffffffea812234:	52800456 	mov	w22, #0x22                  	// #34
		if (c >= 'A' && c <= 'Z') {
ffffffffea812238:	7100645f 	cmp	w2, #0x19
ffffffffea81223c:	540002a8 	b.hi	ffffffffea812290 <strtoul+0x100>  // b.pmore
			v = c - 'A' + 10;
ffffffffea812240:	5100dc00 	sub	w0, w0, #0x37
		if (v < 0 || v >= base) {
ffffffffea812244:	6b00029f 	cmp	w20, w0
ffffffffea812248:	54000389 	b.ls	ffffffffea8122b8 <strtoul+0x128>  // b.plast
		new_ret = ret * base;
ffffffffea81224c:	9b017f02 	mul	x2, x24, x1
		if (new_ret / base != ret ||
ffffffffea812250:	9ad80843 	udiv	x3, x2, x24
ffffffffea812254:	eb01007f 	cmp	x3, x1
ffffffffea812258:	540000c1 	b.ne	ffffffffea812270 <strtoul+0xe0>  // b.any
		    new_ret + v < new_ret ||
ffffffffea81225c:	8b20c040 	add	x0, x2, w0, sxtw
ffffffffea812260:	eb02001f 	cmp	x0, x2
ffffffffea812264:	ba412824 	ccmn	x1, #0x1, #0x4, cs  // cs = hs, nlast
ffffffffea812268:	aa0003e1 	mov	x1, x0
ffffffffea81226c:	54000081 	b.ne	ffffffffea81227c <strtoul+0xec>  // b.any
			errno = ERANGE;
ffffffffea812270:	94000042 	bl	ffffffffea812378 <__geterrno>
ffffffffea812274:	b9000016 	str	w22, [x0]
			ret = ULONG_MAX;
ffffffffea812278:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
ffffffffea81227c:	38401e60 	ldrb	w0, [x19, #1]!
		if (c >= 'A' && c <= 'Z') {
ffffffffea812280:	51010402 	sub	w2, w0, #0x41
ffffffffea812284:	12001c42 	and	w2, w2, #0xff
ffffffffea812288:	7100645f 	cmp	w2, #0x19
ffffffffea81228c:	54fffda9 	b.ls	ffffffffea812240 <strtoul+0xb0>  // b.plast
		} else if (c >= 'a' && c <= 'z') {
ffffffffea812290:	51018402 	sub	w2, w0, #0x61
ffffffffea812294:	12001c42 	and	w2, w2, #0xff
ffffffffea812298:	7100645f 	cmp	w2, #0x19
ffffffffea81229c:	54000068 	b.hi	ffffffffea8122a8 <strtoul+0x118>  // b.pmore
			v = c - 'a' + 10;
ffffffffea8122a0:	51015c00 	sub	w0, w0, #0x57
ffffffffea8122a4:	17ffffe8 	b	ffffffffea812244 <strtoul+0xb4>
		} else if (c >= '0' && c <= '9') {
ffffffffea8122a8:	5100c000 	sub	w0, w0, #0x30
ffffffffea8122ac:	12001c02 	and	w2, w0, #0xff
ffffffffea8122b0:	7100245f 	cmp	w2, #0x9
ffffffffea8122b4:	54fffc89 	b.ls	ffffffffea812244 <strtoul+0xb4>  // b.plast
	if (neg && ret != ULONG_MAX) {
ffffffffea8122b8:	710002bf 	cmp	w21, #0x0
ffffffffea8122bc:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea8122c0:	f9401fb8 	ldr	x24, [x29, #56]
		ret = -ret;
ffffffffea8122c4:	ba411824 	ccmn	x1, #0x1, #0x4, ne  // ne = any
			*endptr = (char *) nptr;
ffffffffea8122c8:	f90002f3 	str	x19, [x23]
		ret = -ret;
ffffffffea8122cc:	da810421 	cneg	x1, x1, ne  // ne = any
ffffffffea8122d0:	a942dfb6 	ldp	x22, x23, [x29, #40]
}
ffffffffea8122d4:	aa0103e0 	mov	x0, x1
ffffffffea8122d8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8122dc:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8122e0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8122e4:	d65f03c0 	ret
	if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
ffffffffea8122e8:	7100c01f 	cmp	w0, #0x30
ffffffffea8122ec:	540001c0 	b.eq	ffffffffea812324 <strtoul+0x194>  // b.none
		base = 10;
ffffffffea8122f0:	7100029f 	cmp	w20, #0x0
ffffffffea8122f4:	52800141 	mov	w1, #0xa                   	// #10
ffffffffea8122f8:	1a811294 	csel	w20, w20, w1, ne  // ne = any
ffffffffea8122fc:	17ffffca 	b	ffffffffea812224 <strtoul+0x94>
ffffffffea812300:	39400660 	ldrb	w0, [x19, #1]
		nptr++;
ffffffffea812304:	52800035 	mov	w21, #0x1                   	// #1
ffffffffea812308:	91000673 	add	x19, x19, #0x1
ffffffffea81230c:	17ffffc4 	b	ffffffffea81221c <strtoul+0x8c>
ffffffffea812310:	39400660 	ldrb	w0, [x19, #1]
	if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
ffffffffea812314:	721b7a9f 	tst	w20, #0xffffffef
		nptr++;
ffffffffea812318:	91000673 	add	x19, x19, #0x1
	if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
ffffffffea81231c:	54fff841 	b.ne	ffffffffea812224 <strtoul+0x94>  // b.any
ffffffffea812320:	17fffff2 	b	ffffffffea8122e8 <strtoul+0x158>
ffffffffea812324:	39400661 	ldrb	w1, [x19, #1]
ffffffffea812328:	7101e03f 	cmp	w1, #0x78
ffffffffea81232c:	540000c0 	b.eq	ffffffffea812344 <strtoul+0x1b4>  // b.none
	} else if (base == 0 && nptr[0] == '0') {
ffffffffea812330:	35fff7b4 	cbnz	w20, ffffffffea812224 <strtoul+0x94>
		nptr++;
ffffffffea812334:	91000673 	add	x19, x19, #0x1
ffffffffea812338:	2a0103e0 	mov	w0, w1
		base = 8;
ffffffffea81233c:	52800114 	mov	w20, #0x8                   	// #8
		nptr++;
ffffffffea812340:	17ffffb9 	b	ffffffffea812224 <strtoul+0x94>
ffffffffea812344:	39400a60 	ldrb	w0, [x19, #2]
		base = 16;
ffffffffea812348:	52800214 	mov	w20, #0x10                  	// #16
		nptr += 2;
ffffffffea81234c:	91000a73 	add	x19, x19, #0x2
ffffffffea812350:	17ffffb5 	b	ffffffffea812224 <strtoul+0x94>
ffffffffea812354:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812358 <isspace>:
	return (c == ' ' || c == '\t');
}

int isspace(int c)
{
	return (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v');
ffffffffea812358:	7100801f 	cmp	w0, #0x20
ffffffffea81235c:	540000a0 	b.eq	ffffffffea812370 <isspace+0x18>  // b.none
ffffffffea812360:	51002400 	sub	w0, w0, #0x9
ffffffffea812364:	7100101f 	cmp	w0, #0x4
ffffffffea812368:	1a9f87e0 	cset	w0, ls  // ls = plast
}
ffffffffea81236c:	d65f03c0 	ret
	return (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v');
ffffffffea812370:	52800020 	mov	w0, #0x1                   	// #1
}
ffffffffea812374:	d65f03c0 	ret

ffffffffea812378 <__geterrno>:
/* TODO: pull from kernel TLS or some other thread local storage */
static int _errno;

int *__geterrno(void)
{
    return &_errno;
ffffffffea812378:	d0000240 	adrp	x0, ffffffffea85c000 <idle_threads+0xeb0>
}
ffffffffea81237c:	913f2000 	add	x0, x0, #0xfc8
ffffffffea812380:	d65f03c0 	ret
ffffffffea812384:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812388 <_vsnprintf_output>:
static int _vsnprintf_output(const char *str, size_t len, void *state)
{
	struct _output_args *args = state;

	size_t count = 0;
	while (count < len && *str) {
ffffffffea812388:	b40002c1 	cbz	x1, ffffffffea8123e0 <_vsnprintf_output+0x58>
ffffffffea81238c:	39400003 	ldrb	w3, [x0]
ffffffffea812390:	34000283 	cbz	w3, ffffffffea8123e0 <_vsnprintf_output+0x58>
	size_t count = 0;
ffffffffea812394:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea812398:	14000003 	b	ffffffffea8123a4 <_vsnprintf_output+0x1c>
	while (count < len && *str) {
ffffffffea81239c:	38636804 	ldrb	w4, [x0, x3]
ffffffffea8123a0:	340001c4 	cbz	w4, ffffffffea8123d8 <_vsnprintf_output+0x50>
		if (args->pos < args->len) {
ffffffffea8123a4:	a9409045 	ldp	x5, x4, [x2, #8]
			args->outstr[args->pos++] = *str;
ffffffffea8123a8:	91000486 	add	x6, x4, #0x1
		if (args->pos < args->len) {
ffffffffea8123ac:	eb05009f 	cmp	x4, x5
ffffffffea8123b0:	540000a2 	b.cs	ffffffffea8123c4 <_vsnprintf_output+0x3c>  // b.hs, b.nlast
			args->outstr[args->pos++] = *str;
ffffffffea8123b4:	f9000846 	str	x6, [x2, #16]
ffffffffea8123b8:	f9400045 	ldr	x5, [x2]
ffffffffea8123bc:	38636806 	ldrb	w6, [x0, x3]
ffffffffea8123c0:	382468a6 	strb	w6, [x5, x4]
		}

		str++;
		count++;
ffffffffea8123c4:	91000463 	add	x3, x3, #0x1
	while (count < len && *str) {
ffffffffea8123c8:	eb03003f 	cmp	x1, x3
ffffffffea8123cc:	54fffe81 	b.ne	ffffffffea81239c <_vsnprintf_output+0x14>  // b.any
ffffffffea8123d0:	2a0103e0 	mov	w0, w1
	}

	return count;
}
ffffffffea8123d4:	d65f03c0 	ret
ffffffffea8123d8:	2a0303e0 	mov	w0, w3
ffffffffea8123dc:	d65f03c0 	ret
	while (count < len && *str) {
ffffffffea8123e0:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea8123e4:	d65f03c0 	ret

ffffffffea8123e8 <longlong_to_string.constprop.0>:
	int negative = 0;
ffffffffea8123e8:	52800009 	mov	w9, #0x0                   	// #0
	if ((flag & SIGNEDFLAG) && (long long)n < 0) {
ffffffffea8123ec:	36500042 	tbz	w2, #10, ffffffffea8123f4 <longlong_to_string.constprop.0+0xc>
ffffffffea8123f0:	b7f80481 	tbnz	x1, #63, ffffffffea812480 <longlong_to_string.constprop.0+0x98>
	buf[--pos] = 0;
ffffffffea8123f4:	39007c1f 	strb	wzr, [x0, #31]
	while (n >= 10) {
ffffffffea8123f8:	f100243f 	cmp	x1, #0x9
ffffffffea8123fc:	540004e9 	b.ls	ffffffffea812498 <longlong_to_string.constprop.0+0xb0>  // b.plast
		int digit = n % 10;
ffffffffea812400:	b202e7e8 	mov	x8, #0xcccccccccccccccc    	// #-3689348814741910324
	buf[--pos] = 0;
ffffffffea812404:	d28003e7 	mov	x7, #0x1f                  	// #31
		int digit = n % 10;
ffffffffea812408:	f29999a8 	movk	x8, #0xcccd
ffffffffea81240c:	14000002 	b	ffffffffea812414 <longlong_to_string.constprop.0+0x2c>
		buf[--pos] = digit + '0';
ffffffffea812410:	aa0603e7 	mov	x7, x6
		int digit = n % 10;
ffffffffea812414:	9bc87c25 	umulh	x5, x1, x8
		buf[--pos] = digit + '0';
ffffffffea812418:	d10004e6 	sub	x6, x7, #0x1
		int digit = n % 10;
ffffffffea81241c:	d343fca4 	lsr	x4, x5, #3
ffffffffea812420:	8b040884 	add	x4, x4, x4, lsl #2
ffffffffea812424:	cb040424 	sub	x4, x1, x4, lsl #1
		n /= 10;
ffffffffea812428:	d343fca1 	lsr	x1, x5, #3
		buf[--pos] = digit + '0';
ffffffffea81242c:	1100c084 	add	w4, w4, #0x30
ffffffffea812430:	38266804 	strb	w4, [x0, x6]
	while (n >= 10) {
ffffffffea812434:	f100243f 	cmp	x1, #0x9
ffffffffea812438:	54fffec8 	b.hi	ffffffffea812410 <longlong_to_string.constprop.0+0x28>  // b.pmore
ffffffffea81243c:	d10008e7 	sub	x7, x7, #0x2
	buf[--pos] = n + '0';
ffffffffea812440:	1100c021 	add	w1, w1, #0x30
ffffffffea812444:	38276801 	strb	w1, [x0, x7]
ffffffffea812448:	8b070000 	add	x0, x0, x7
	if (negative)
ffffffffea81244c:	35000149 	cbnz	w9, ffffffffea812474 <longlong_to_string.constprop.0+0x8c>
	else if ((flag & SHOWSIGNFLAG))
ffffffffea812450:	374800c2 	tbnz	w2, #9, ffffffffea812468 <longlong_to_string.constprop.0+0x80>
		*signchar = ' ';
ffffffffea812454:	f273005f 	tst	x2, #0x2000
ffffffffea812458:	52800401 	mov	w1, #0x20                  	// #32
ffffffffea81245c:	1a9f1021 	csel	w1, w1, wzr, ne  // ne = any
ffffffffea812460:	39000061 	strb	w1, [x3]
}
ffffffffea812464:	d65f03c0 	ret
		*signchar = '+';
ffffffffea812468:	52800561 	mov	w1, #0x2b                  	// #43
ffffffffea81246c:	39000061 	strb	w1, [x3]
}
ffffffffea812470:	d65f03c0 	ret
		*signchar = '-';
ffffffffea812474:	528005a1 	mov	w1, #0x2d                  	// #45
ffffffffea812478:	39000061 	strb	w1, [x3]
}
ffffffffea81247c:	d65f03c0 	ret
	buf[--pos] = 0;
ffffffffea812480:	39007c1f 	strb	wzr, [x0, #31]
		n = -n;
ffffffffea812484:	cb0103e1 	neg	x1, x1
		negative = 1;
ffffffffea812488:	52800029 	mov	w9, #0x1                   	// #1
	while (n >= 10) {
ffffffffea81248c:	f100243f 	cmp	x1, #0x9
ffffffffea812490:	54fffb88 	b.hi	ffffffffea812400 <longlong_to_string.constprop.0+0x18>  // b.pmore
ffffffffea812494:	d503201f 	nop
ffffffffea812498:	d28003c7 	mov	x7, #0x1e                  	// #30
ffffffffea81249c:	17ffffe9 	b	ffffffffea812440 <longlong_to_string.constprop.0+0x58>

ffffffffea8124a0 <longlong_to_hexstring.constprop.1>:
	const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
ffffffffea8124a0:	7218005f 	tst	w2, #0x100
ffffffffea8124a4:	b0000023 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea8124a8:	b0000024 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea8124ac:	91216063 	add	x3, x3, #0x858
ffffffffea8124b0:	9121a084 	add	x4, x4, #0x868
ffffffffea8124b4:	91007802 	add	x2, x0, #0x1e
ffffffffea8124b8:	9a831084 	csel	x4, x4, x3, ne  // ne = any
	buf[--pos] = 0;
ffffffffea8124bc:	39007c1f 	strb	wzr, [x0, #31]
		unsigned int digit = u % 16;
ffffffffea8124c0:	12000c23 	and	w3, w1, #0xf
		buf[--pos] = table[digit];
ffffffffea8124c4:	aa0203e0 	mov	x0, x2
		u /= 16;
ffffffffea8124c8:	d344fc21 	lsr	x1, x1, #4
		buf[--pos] = table[digit];
ffffffffea8124cc:	38634883 	ldrb	w3, [x4, w3, uxtw]
ffffffffea8124d0:	381ff443 	strb	w3, [x2], #-1
	} while (u != 0);
ffffffffea8124d4:	b5ffff61 	cbnz	x1, ffffffffea8124c0 <longlong_to_hexstring.constprop.1+0x20>
}
ffffffffea8124d8:	d65f03c0 	ret
ffffffffea8124dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8124e0 <_printf_engine>:
		str[wlen] = '\0';
	return wlen;
}

int _printf_engine(_printf_engine_output_func out, void *state, const char *fmt, va_list ap)
{
ffffffffea8124e0:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
ffffffffea8124e4:	910003fd 	mov	x29, sp
ffffffffea8124e8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8124ec:	aa0003f4 	mov	x20, x0
ffffffffea8124f0:	aa0203e0 	mov	x0, x2
ffffffffea8124f4:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8124f8:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea8124fc:	aa0103f5 	mov	x21, x1
ffffffffea812500:	b9401878 	ldr	w24, [x3, #24]
		/* grab the next format character */
		c = *fmt++;
		if (c == 0)
			break;

		switch (c) {
ffffffffea812504:	b0000036 	adrp	x22, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea812508:	a9400477 	ldp	x23, x1, [x3]
{
ffffffffea81250c:	f9002ffc 	str	x28, [sp, #88]
ffffffffea812510:	f9003ba1 	str	x1, [x29, #112]
	size_t chars_written = 0;
ffffffffea812514:	d2800013 	mov	x19, #0x0                   	// #0
		while ((c = *fmt++) != 0) {
ffffffffea812518:	39400001 	ldrb	w1, [x0]
		switch (c) {
ffffffffea81251c:	911e52d6 	add	x22, x22, #0x794
		signchar = '\0';
ffffffffea812520:	39023fbf 	strb	wzr, [x29, #143]
		while ((c = *fmt++) != 0) {
ffffffffea812524:	9100041c 	add	x28, x0, #0x1
ffffffffea812528:	34001101 	cbz	w1, ffffffffea812748 <_printf_engine+0x268>
			if (c == '%')
ffffffffea81252c:	7100943f 	cmp	w1, #0x25
ffffffffea812530:	54000081 	b.ne	ffffffffea812540 <_printf_engine+0x60>  // b.any
ffffffffea812534:	1400000f 	b	ffffffffea812570 <_printf_engine+0x90>
ffffffffea812538:	7100945f 	cmp	w2, #0x25
ffffffffea81253c:	540001e0 	b.eq	ffffffffea812578 <_printf_engine+0x98>  // b.none
ffffffffea812540:	cb000381 	sub	x1, x28, x0
		while ((c = *fmt++) != 0) {
ffffffffea812544:	38401782 	ldrb	w2, [x28], #1
ffffffffea812548:	35ffff82 	cbnz	w2, ffffffffea812538 <_printf_engine+0x58>
		OUTPUT_STRING(s, string_len);
ffffffffea81254c:	aa1503e2 	mov	x2, x21
ffffffffea812550:	d63f0280 	blr	x20
ffffffffea812554:	36f82780 	tbz	w0, #31, ffffffffea812a44 <_printf_engine+0x564>
#undef OUTPUT_STRING
#undef OUTPUT_CHAR

exit:
	return (err < 0) ? err : (int)chars_written;
}
ffffffffea812558:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81255c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea812560:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea812564:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea812568:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea81256c:	d65f03c0 	ret
		string_len = 0;
ffffffffea812570:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea812574:	d503201f 	nop
		OUTPUT_STRING(s, string_len);
ffffffffea812578:	aa1503e2 	mov	x2, x21
ffffffffea81257c:	d63f0280 	blr	x20
ffffffffea812580:	37fffec0 	tbnz	w0, #31, ffffffffea812558 <_printf_engine+0x78>
ffffffffea812584:	8b20c273 	add	x19, x19, w0, sxtw
ffffffffea812588:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea81258c:	f9002bbb 	str	x27, [x29, #80]
		flags = 0;
ffffffffea812590:	52800019 	mov	w25, #0x0                   	// #0
		format_num = 0;
ffffffffea812594:	5280001b 	mov	w27, #0x0                   	// #0
		c = *fmt++;
ffffffffea812598:	3840179a 	ldrb	w26, [x28], #1
		if (c == 0)
ffffffffea81259c:	34001b3a 	cbz	w26, ffffffffea812900 <_printf_engine+0x420>
		switch (c) {
ffffffffea8125a0:	51008340 	sub	w0, w26, #0x20
ffffffffea8125a4:	7101681f 	cmp	w0, #0x5a
ffffffffea8125a8:	540002e9 	b.ls	ffffffffea812604 <_printf_engine+0x124>  // b.plast
				OUTPUT_CHAR('%');
ffffffffea8125ac:	528004a0 	mov	w0, #0x25                  	// #37
ffffffffea8125b0:	390223a0 	strb	w0, [x29, #136]
ffffffffea8125b4:	aa1503e2 	mov	x2, x21
ffffffffea8125b8:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8125bc:	910223a0 	add	x0, x29, #0x88
ffffffffea8125c0:	d63f0280 	blr	x20
ffffffffea8125c4:	2a0003f9 	mov	w25, w0
ffffffffea8125c8:	37f82040 	tbnz	w0, #31, ffffffffea8129d0 <_printf_engine+0x4f0>
				OUTPUT_CHAR(c);
ffffffffea8125cc:	390223ba 	strb	w26, [x29, #136]
ffffffffea8125d0:	aa1503e2 	mov	x2, x21
ffffffffea8125d4:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8125d8:	910223a0 	add	x0, x29, #0x88
ffffffffea8125dc:	d63f0280 	blr	x20
ffffffffea8125e0:	36f818c0 	tbz	w0, #31, ffffffffea8128f8 <_printf_engine+0x418>
ffffffffea8125e4:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea8125e8:	f9402bbb 	ldr	x27, [x29, #80]
}
ffffffffea8125ec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8125f0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8125f4:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8125f8:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea8125fc:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea812600:	d65f03c0 	ret
		switch (c) {
ffffffffea812604:	78605ac0 	ldrh	w0, [x22, w0, uxtw #1]
ffffffffea812608:	10000061 	adr	x1, ffffffffea812614 <_printf_engine+0x134>
ffffffffea81260c:	8b20a820 	add	x0, x1, w0, sxth #2
ffffffffea812610:	d61f0000 	br	x0
				flags |= CAPSFLAG;
ffffffffea812614:	32180339 	orr	w25, w25, #0x100
				n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
ffffffffea812618:	360806b9 	tbz	w25, #1, ffffffffea8126ec <_printf_engine+0x20c>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea81261c:	37f82a58 	tbnz	w24, #31, ffffffffea812b64 <_printf_engine+0x684>
ffffffffea812620:	91003ee1 	add	x1, x23, #0xf
ffffffffea812624:	aa1703e0 	mov	x0, x23
ffffffffea812628:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea81262c:	f9400001 	ldr	x1, [x0]
				s = longlong_to_hexstring(num_buffer, n, sizeof(num_buffer), flags);
ffffffffea812630:	2a1903e2 	mov	w2, w25
ffffffffea812634:	910243a0 	add	x0, x29, #0x90
ffffffffea812638:	97ffff9a 	bl	ffffffffea8124a0 <longlong_to_hexstring.constprop.1>
ffffffffea81263c:	aa0003fa 	mov	x26, x0
				if (flags & ALTFLAG) {
ffffffffea812640:	36380299 	tbz	w25, #7, ffffffffea812690 <_printf_engine+0x1b0>
					OUTPUT_CHAR('0');
ffffffffea812644:	52800600 	mov	w0, #0x30                  	// #48
ffffffffea812648:	390223a0 	strb	w0, [x29, #136]
ffffffffea81264c:	aa1503e2 	mov	x2, x21
ffffffffea812650:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea812654:	910223a0 	add	x0, x29, #0x88
ffffffffea812658:	d63f0280 	blr	x20
ffffffffea81265c:	37fffc40 	tbnz	w0, #31, ffffffffea8125e4 <_printf_engine+0x104>
					OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
ffffffffea812660:	f278033f 	tst	x25, #0x100
ffffffffea812664:	52800b01 	mov	w1, #0x58                  	// #88
					OUTPUT_CHAR('0');
ffffffffea812668:	8b20c273 	add	x19, x19, w0, sxtw
					OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
ffffffffea81266c:	52800f00 	mov	w0, #0x78                  	// #120
ffffffffea812670:	1a810000 	csel	w0, w0, w1, eq  // eq = none
ffffffffea812674:	390223a0 	strb	w0, [x29, #136]
ffffffffea812678:	aa1503e2 	mov	x2, x21
ffffffffea81267c:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea812680:	910223a0 	add	x0, x29, #0x88
ffffffffea812684:	d63f0280 	blr	x20
ffffffffea812688:	37fffae0 	tbnz	w0, #31, ffffffffea8125e4 <_printf_engine+0x104>
ffffffffea81268c:	8b20c273 	add	x19, x19, w0, sxtw
		if (flags & LEFTFORMATFLAG) {
ffffffffea812690:	36580ab9 	tbz	w25, #11, ffffffffea8127e4 <_printf_engine+0x304>
			OUTPUT_STRING(s, SIZE_MAX);
ffffffffea812694:	aa1503e2 	mov	x2, x21
ffffffffea812698:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
ffffffffea81269c:	aa1a03e0 	mov	x0, x26
ffffffffea8126a0:	d63f0280 	blr	x20
ffffffffea8126a4:	37fffa00 	tbnz	w0, #31, ffffffffea8125e4 <_printf_engine+0x104>
			uint written = err;
ffffffffea8126a8:	2a0003f9 	mov	w25, w0
			OUTPUT_STRING(s, SIZE_MAX);
ffffffffea8126ac:	8b20c273 	add	x19, x19, w0, sxtw
			for (; format_num > written; format_num--)
ffffffffea8126b0:	6b00037f 	cmp	w27, w0
ffffffffea8126b4:	540003c9 	b.ls	ffffffffea81272c <_printf_engine+0x24c>  // b.plast
				OUTPUT_CHAR(' ');
ffffffffea8126b8:	5280041a 	mov	w26, #0x20                  	// #32
ffffffffea8126bc:	14000005 	b	ffffffffea8126d0 <_printf_engine+0x1f0>
			for (; format_num > written; format_num--)
ffffffffea8126c0:	5100077b 	sub	w27, w27, #0x1
				OUTPUT_CHAR(' ');
ffffffffea8126c4:	8b20c273 	add	x19, x19, w0, sxtw
			for (; format_num > written; format_num--)
ffffffffea8126c8:	6b1b033f 	cmp	w25, w27
ffffffffea8126cc:	54000300 	b.eq	ffffffffea81272c <_printf_engine+0x24c>  // b.none
				OUTPUT_CHAR(' ');
ffffffffea8126d0:	390223ba 	strb	w26, [x29, #136]
ffffffffea8126d4:	aa1503e2 	mov	x2, x21
ffffffffea8126d8:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8126dc:	910223a0 	add	x0, x29, #0x88
ffffffffea8126e0:	d63f0280 	blr	x20
ffffffffea8126e4:	36fffee0 	tbz	w0, #31, ffffffffea8126c0 <_printf_engine+0x1e0>
ffffffffea8126e8:	17ffffbf 	b	ffffffffea8125e4 <_printf_engine+0x104>
				    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
ffffffffea8126ec:	3707f999 	tbnz	w25, #0, ffffffffea81261c <_printf_engine+0x13c>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea8126f0:	361811b9 	tbz	w25, #3, ffffffffea812924 <_printf_engine+0x444>
ffffffffea8126f4:	37f83bd8 	tbnz	w24, #31, ffffffffea812e6c <_printf_engine+0x98c>
ffffffffea8126f8:	aa1703e0 	mov	x0, x23
ffffffffea8126fc:	91002ee1 	add	x1, x23, #0xb
ffffffffea812700:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea812704:	39400001 	ldrb	w1, [x0]
ffffffffea812708:	17ffffca 	b	ffffffffea812630 <_printf_engine+0x150>
				OUTPUT_CHAR('%');
ffffffffea81270c:	528004a0 	mov	w0, #0x25                  	// #37
				uc = va_arg(ap, unsigned int);
ffffffffea812710:	390223a0 	strb	w0, [x29, #136]
				OUTPUT_CHAR(uc);
ffffffffea812714:	aa1503e2 	mov	x2, x21
ffffffffea812718:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea81271c:	910223a0 	add	x0, x29, #0x88
ffffffffea812720:	d63f0280 	blr	x20
ffffffffea812724:	37fff600 	tbnz	w0, #31, ffffffffea8125e4 <_printf_engine+0x104>
				OUTPUT_CHAR(c);
ffffffffea812728:	8b20c273 	add	x19, x19, w0, sxtw
{
ffffffffea81272c:	aa1c03e0 	mov	x0, x28
		signchar = '\0';
ffffffffea812730:	39023fbf 	strb	wzr, [x29, #143]
{
ffffffffea812734:	a9446bb9 	ldp	x25, x26, [x29, #64]
		while ((c = *fmt++) != 0) {
ffffffffea812738:	9100041c 	add	x28, x0, #0x1
ffffffffea81273c:	39400001 	ldrb	w1, [x0]
{
ffffffffea812740:	f9402bbb 	ldr	x27, [x29, #80]
		while ((c = *fmt++) != 0) {
ffffffffea812744:	35ffef41 	cbnz	w1, ffffffffea81252c <_printf_engine+0x4c>
		string_len = 0;
ffffffffea812748:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea81274c:	17ffff80 	b	ffffffffea81254c <_printf_engine+0x6c>
					flags |= LONGLONGFLAG;
ffffffffea812750:	321f0320 	orr	w0, w25, #0x2
ffffffffea812754:	f240033f 	tst	x25, #0x1
ffffffffea812758:	1a991019 	csel	w25, w0, w25, ne  // ne = any
				flags |= LONGFLAG;
ffffffffea81275c:	32000339 	orr	w25, w25, #0x1
				goto next_format;
ffffffffea812760:	17ffff8e 	b	ffffffffea812598 <_printf_engine+0xb8>
				flags |= LONGFLAG | ALTFLAG;
ffffffffea812764:	52801020 	mov	w0, #0x81                  	// #129
ffffffffea812768:	2a000339 	orr	w25, w25, w0
				n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
ffffffffea81276c:	360ffc19 	tbz	w25, #1, ffffffffea8126ec <_printf_engine+0x20c>
ffffffffea812770:	17ffffab 	b	ffffffffea81261c <_printf_engine+0x13c>
				flags |= PTRDIFFFLAG;
ffffffffea812774:	321a0339 	orr	w25, w25, #0x40
				goto next_format;
ffffffffea812778:	17ffff88 	b	ffffffffea812598 <_printf_engine+0xb8>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
ffffffffea81277c:	36080af9 	tbz	w25, #1, ffffffffea8128d8 <_printf_engine+0x3f8>
				    (flags & INTMAXFLAG) ? va_arg(ap, uintmax_t) :
ffffffffea812780:	37f82678 	tbnz	w24, #31, ffffffffea812c4c <_printf_engine+0x76c>
ffffffffea812784:	aa1703e0 	mov	x0, x23
ffffffffea812788:	91003ee1 	add	x1, x23, #0xf
ffffffffea81278c:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea812790:	f9400001 	ldr	x1, [x0]
ffffffffea812794:	1400000e 	b	ffffffffea8127cc <_printf_engine+0x2ec>
				flags |= SIZETFLAG;
ffffffffea812798:	321c0339 	orr	w25, w25, #0x10
				goto next_format;
ffffffffea81279c:	17ffff7f 	b	ffffffffea812598 <_printf_engine+0xb8>
				flags |= ALTFLAG;
ffffffffea8127a0:	32190339 	orr	w25, w25, #0x80
				goto next_format;
ffffffffea8127a4:	17ffff7d 	b	ffffffffea812598 <_printf_engine+0xb8>
				flags |= BLANKPOSFLAG;
ffffffffea8127a8:	32130339 	orr	w25, w25, #0x2000
				goto next_format;
ffffffffea8127ac:	17ffff7b 	b	ffffffffea812598 <_printf_engine+0xb8>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea8127b0:	36080859 	tbz	w25, #1, ffffffffea8128b8 <_printf_engine+0x3d8>
				    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
ffffffffea8127b4:	37f829d8 	tbnz	w24, #31, ffffffffea812cec <_printf_engine+0x80c>
ffffffffea8127b8:	aa1703e0 	mov	x0, x23
ffffffffea8127bc:	91003ee1 	add	x1, x23, #0xf
ffffffffea8127c0:	927df037 	and	x23, x1, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea8127c4:	f9400001 	ldr	x1, [x0]
				flags |= SIGNEDFLAG;
ffffffffea8127c8:	32160339 	orr	w25, w25, #0x400
				s = longlong_to_string(num_buffer, n, sizeof(num_buffer), flags, &signchar);
ffffffffea8127cc:	91023fa3 	add	x3, x29, #0x8f
ffffffffea8127d0:	2a1903e2 	mov	w2, w25
ffffffffea8127d4:	910243a0 	add	x0, x29, #0x90
ffffffffea8127d8:	97ffff04 	bl	ffffffffea8123e8 <longlong_to_string.constprop.0>
ffffffffea8127dc:	aa0003fa 	mov	x26, x0
		if (flags & LEFTFORMATFLAG) {
ffffffffea8127e0:	375ff5b9 	tbnz	w25, #11, ffffffffea812694 <_printf_engine+0x1b4>
			string_len = strlen(s);
ffffffffea8127e4:	aa1a03e0 	mov	x0, x26
ffffffffea8127e8:	9400034c 	bl	ffffffffea813518 <strlen>
ffffffffea8127ec:	f9003fa0 	str	x0, [x29, #120]
ffffffffea8127f0:	12140321 	and	w1, w25, #0x1000
			if (signchar != '\0' && format_num > 0)
ffffffffea8127f4:	39423fa0 	ldrb	w0, [x29, #143]
ffffffffea8127f8:	b9006fa1 	str	w1, [x29, #108]
ffffffffea8127fc:	35000f40 	cbnz	w0, ffffffffea8129e4 <_printf_engine+0x504>
			for (; format_num > string_len; format_num--)
ffffffffea812800:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea812804:	eb3b401f 	cmp	x0, w27, uxtw
ffffffffea812808:	54000222 	b.cs	ffffffffea81284c <_printf_engine+0x36c>  // b.hs, b.nlast
ffffffffea81280c:	b9406fa0 	ldr	w0, [x29, #108]
ffffffffea812810:	52800619 	mov	w25, #0x30                  	// #48
ffffffffea812814:	7100001f 	cmp	w0, #0x0
ffffffffea812818:	52800400 	mov	w0, #0x20                  	// #32
ffffffffea81281c:	1a801339 	csel	w25, w25, w0, ne  // ne = any
				OUTPUT_CHAR(flags & LEADZEROFLAG ? '0' : ' ');
ffffffffea812820:	390223b9 	strb	w25, [x29, #136]
ffffffffea812824:	aa1503e2 	mov	x2, x21
ffffffffea812828:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea81282c:	910223a0 	add	x0, x29, #0x88
ffffffffea812830:	d63f0280 	blr	x20
ffffffffea812834:	37ffed80 	tbnz	w0, #31, ffffffffea8125e4 <_printf_engine+0x104>
ffffffffea812838:	8b20c273 	add	x19, x19, w0, sxtw
			for (; format_num > string_len; format_num--)
ffffffffea81283c:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea812840:	5100077b 	sub	w27, w27, #0x1
ffffffffea812844:	eb3b401f 	cmp	x0, w27, uxtw
ffffffffea812848:	54fffec3 	b.cc	ffffffffea812820 <_printf_engine+0x340>  // b.lo, b.ul, b.last
			if (!(flags & LEADZEROFLAG) && signchar != '\0')
ffffffffea81284c:	b9406fa0 	ldr	w0, [x29, #108]
ffffffffea812850:	34001220 	cbz	w0, ffffffffea812a94 <_printf_engine+0x5b4>
			OUTPUT_STRING(s, SIZE_MAX);
ffffffffea812854:	aa1503e2 	mov	x2, x21
ffffffffea812858:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
ffffffffea81285c:	aa1a03e0 	mov	x0, x26
ffffffffea812860:	d63f0280 	blr	x20
ffffffffea812864:	37ffec00 	tbnz	w0, #31, ffffffffea8125e4 <_printf_engine+0x104>
ffffffffea812868:	17ffffb0 	b	ffffffffea812728 <_printf_engine+0x248>
					flags |= HALFHALFFLAG;
ffffffffea81286c:	321d0320 	orr	w0, w25, #0x8
ffffffffea812870:	f27e033f 	tst	x25, #0x4
ffffffffea812874:	1a991019 	csel	w25, w0, w25, ne  // ne = any
				flags |= HALFFLAG;
ffffffffea812878:	321e0339 	orr	w25, w25, #0x4
				goto next_format;
ffffffffea81287c:	17ffff47 	b	ffffffffea812598 <_printf_engine+0xb8>
				flags |= LEFTFORMATFLAG;
ffffffffea812880:	32150339 	orr	w25, w25, #0x800
				goto next_format;
ffffffffea812884:	17ffff45 	b	ffffffffea812598 <_printf_engine+0xb8>
				if (c == '0' && format_num == 0)
ffffffffea812888:	7100c35f 	cmp	w26, #0x30
				format_num *= 10;
ffffffffea81288c:	0b1b0b60 	add	w0, w27, w27, lsl #2
					flags |= LEADZEROFLAG;
ffffffffea812890:	7a400b60 	ccmp	w27, #0x0, #0x0, eq  // eq = none
ffffffffea812894:	32140321 	orr	w1, w25, #0x1000
				format_num += c - '0';
ffffffffea812898:	5100c345 	sub	w5, w26, #0x30
					flags |= LEADZEROFLAG;
ffffffffea81289c:	1a990039 	csel	w25, w1, w25, eq  // eq = none
				format_num += c - '0';
ffffffffea8128a0:	0b0004bb 	add	w27, w5, w0, lsl #1
				goto next_format;
ffffffffea8128a4:	17ffff3d 	b	ffffffffea812598 <_printf_engine+0xb8>
				flags |= SHOWSIGNFLAG;
ffffffffea8128a8:	32170339 	orr	w25, w25, #0x200
				goto next_format;
ffffffffea8128ac:	17ffff3b 	b	ffffffffea812598 <_printf_engine+0xb8>
				flags |= INTMAXFLAG;
ffffffffea8128b0:	321b0339 	orr	w25, w25, #0x20
				goto next_format;
ffffffffea8128b4:	17ffff39 	b	ffffffffea812598 <_printf_engine+0xb8>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea8128b8:	3707f7f9 	tbnz	w25, #0, ffffffffea8127b4 <_printf_engine+0x2d4>
ffffffffea8128bc:	36180d19 	tbz	w25, #3, ffffffffea812a5c <_printf_engine+0x57c>
				    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
ffffffffea8128c0:	37f81358 	tbnz	w24, #31, ffffffffea812b28 <_printf_engine+0x648>
ffffffffea8128c4:	aa1703e0 	mov	x0, x23
ffffffffea8128c8:	91002ee1 	add	x1, x23, #0xb
ffffffffea8128cc:	927df037 	and	x23, x1, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea8128d0:	39800001 	ldrsb	x1, [x0]
ffffffffea8128d4:	17ffffbd 	b	ffffffffea8127c8 <_printf_engine+0x2e8>
				    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
ffffffffea8128d8:	3707f559 	tbnz	w25, #0, ffffffffea812780 <_printf_engine+0x2a0>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea8128dc:	36180cf9 	tbz	w25, #3, ffffffffea812a78 <_printf_engine+0x598>
ffffffffea8128e0:	37f81a58 	tbnz	w24, #31, ffffffffea812c28 <_printf_engine+0x748>
ffffffffea8128e4:	aa1703e0 	mov	x0, x23
ffffffffea8128e8:	91002ee1 	add	x1, x23, #0xb
ffffffffea8128ec:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea8128f0:	39400001 	ldrb	w1, [x0]
ffffffffea8128f4:	17ffffb6 	b	ffffffffea8127cc <_printf_engine+0x2ec>
				OUTPUT_CHAR('%');
ffffffffea8128f8:	8b39c273 	add	x19, x19, w25, sxtw
ffffffffea8128fc:	17ffff8b 	b	ffffffffea812728 <_printf_engine+0x248>
ffffffffea812900:	a9446bb9 	ldp	x25, x26, [x29, #64]
	return (err < 0) ? err : (int)chars_written;
ffffffffea812904:	2a1303e0 	mov	w0, w19
ffffffffea812908:	f9402bbb 	ldr	x27, [x29, #80]
}
ffffffffea81290c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812910:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea812914:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea812918:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea81291c:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea812920:	d65f03c0 	ret
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea812924:	371004b9 	tbnz	w25, #2, ffffffffea8129b8 <_printf_engine+0x4d8>
				    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
ffffffffea812928:	3727e7b9 	tbnz	w25, #4, ffffffffea81261c <_printf_engine+0x13c>
				    (flags & INTMAXFLAG) ? va_arg(ap, uintmax_t) :
ffffffffea81292c:	372fe799 	tbnz	w25, #5, ffffffffea81261c <_printf_engine+0x13c>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812930:	3737e779 	tbnz	w25, #6, ffffffffea81261c <_printf_engine+0x13c>
				    va_arg(ap, unsigned int);
ffffffffea812934:	37f80e98 	tbnz	w24, #31, ffffffffea812b04 <_printf_engine+0x624>
ffffffffea812938:	aa1703e0 	mov	x0, x23
ffffffffea81293c:	91002ee1 	add	x1, x23, #0xb
ffffffffea812940:	927df037 	and	x23, x1, #0xfffffffffffffff8
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812944:	b9400001 	ldr	w1, [x0]
ffffffffea812948:	17ffff3a 	b	ffffffffea812630 <_printf_engine+0x150>
				ptr = va_arg(ap, void *);
ffffffffea81294c:	37f81ed8 	tbnz	w24, #31, ffffffffea812d24 <_printf_engine+0x844>
ffffffffea812950:	91003ee1 	add	x1, x23, #0xf
ffffffffea812954:	aa1703e0 	mov	x0, x23
ffffffffea812958:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea81295c:	f9400000 	ldr	x0, [x0]
				if (flags & LONGLONGFLAG)
ffffffffea812960:	370803f9 	tbnz	w25, #1, ffffffffea8129dc <_printf_engine+0x4fc>
				else if (flags & LONGFLAG)
ffffffffea812964:	370003d9 	tbnz	w25, #0, ffffffffea8129dc <_printf_engine+0x4fc>
				else if (flags & HALFHALFFLAG)
ffffffffea812968:	36180759 	tbz	w25, #3, ffffffffea812a50 <_printf_engine+0x570>
					*(signed char *)ptr = chars_written;
ffffffffea81296c:	39000013 	strb	w19, [x0]
ffffffffea812970:	17ffff6f 	b	ffffffffea81272c <_printf_engine+0x24c>
				uc = va_arg(ap, unsigned int);
ffffffffea812974:	37f81498 	tbnz	w24, #31, ffffffffea812c04 <_printf_engine+0x724>
ffffffffea812978:	aa1703e0 	mov	x0, x23
ffffffffea81297c:	91002ee1 	add	x1, x23, #0xb
ffffffffea812980:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea812984:	b9400000 	ldr	w0, [x0]
ffffffffea812988:	17ffff62 	b	ffffffffea812710 <_printf_engine+0x230>
				s = va_arg(ap, const char *);
ffffffffea81298c:	37f818f8 	tbnz	w24, #31, ffffffffea812ca8 <_printf_engine+0x7c8>
ffffffffea812990:	91003ee1 	add	x1, x23, #0xf
ffffffffea812994:	aa1703e0 	mov	x0, x23
ffffffffea812998:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea81299c:	f940001a 	ldr	x26, [x0]
					s = "<null>";
ffffffffea8129a0:	b0000020 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea8129a4:	91214000 	add	x0, x0, #0x850
				flags &= ~LEADZEROFLAG; /* doesn't make sense for strings */
ffffffffea8129a8:	12137b39 	and	w25, w25, #0xffffefff
					s = "<null>";
ffffffffea8129ac:	f100035f 	cmp	x26, #0x0
ffffffffea8129b0:	9a9a001a 	csel	x26, x0, x26, eq  // eq = none
				goto _output_string;
ffffffffea8129b4:	17ffff37 	b	ffffffffea812690 <_printf_engine+0x1b0>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea8129b8:	37f81678 	tbnz	w24, #31, ffffffffea812c84 <_printf_engine+0x7a4>
ffffffffea8129bc:	aa1703e0 	mov	x0, x23
ffffffffea8129c0:	91002ee1 	add	x1, x23, #0xb
ffffffffea8129c4:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea8129c8:	79400001 	ldrh	w1, [x0]
ffffffffea8129cc:	17ffff19 	b	ffffffffea812630 <_printf_engine+0x150>
ffffffffea8129d0:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea8129d4:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea8129d8:	17fffee0 	b	ffffffffea812558 <_printf_engine+0x78>
					*(size_t *)ptr = chars_written;
ffffffffea8129dc:	f9000013 	str	x19, [x0]
ffffffffea8129e0:	17ffff53 	b	ffffffffea81272c <_printf_engine+0x24c>
			if (signchar != '\0' && format_num > 0)
ffffffffea8129e4:	340001db 	cbz	w27, ffffffffea812a1c <_printf_engine+0x53c>
				format_num--;
ffffffffea8129e8:	5100077b 	sub	w27, w27, #0x1
			if (flags & LEADZEROFLAG && signchar != '\0')
ffffffffea8129ec:	34001ac1 	cbz	w1, ffffffffea812d44 <_printf_engine+0x864>
				OUTPUT_CHAR(signchar);
ffffffffea8129f0:	390223a0 	strb	w0, [x29, #136]
ffffffffea8129f4:	aa1503e2 	mov	x2, x21
ffffffffea8129f8:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8129fc:	910223a0 	add	x0, x29, #0x88
ffffffffea812a00:	d63f0280 	blr	x20
ffffffffea812a04:	37ffdf00 	tbnz	w0, #31, ffffffffea8125e4 <_printf_engine+0x104>
ffffffffea812a08:	8b20c273 	add	x19, x19, w0, sxtw
			for (; format_num > string_len; format_num--)
ffffffffea812a0c:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea812a10:	eb3b401f 	cmp	x0, w27, uxtw
ffffffffea812a14:	54ffefc3 	b.cc	ffffffffea81280c <_printf_engine+0x32c>  // b.lo, b.ul, b.last
ffffffffea812a18:	17ffff8f 	b	ffffffffea812854 <_printf_engine+0x374>
			if (flags & LEADZEROFLAG && signchar != '\0')
ffffffffea812a1c:	b9406fa1 	ldr	w1, [x29, #108]
ffffffffea812a20:	35fffe81 	cbnz	w1, ffffffffea8129f0 <_printf_engine+0x510>
				OUTPUT_CHAR(signchar);
ffffffffea812a24:	390223a0 	strb	w0, [x29, #136]
ffffffffea812a28:	aa1503e2 	mov	x2, x21
ffffffffea812a2c:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea812a30:	910223a0 	add	x0, x29, #0x88
ffffffffea812a34:	d63f0280 	blr	x20
ffffffffea812a38:	37ffdd60 	tbnz	w0, #31, ffffffffea8125e4 <_printf_engine+0x104>
ffffffffea812a3c:	8b20c273 	add	x19, x19, w0, sxtw
ffffffffea812a40:	17ffff85 	b	ffffffffea812854 <_printf_engine+0x374>
		OUTPUT_STRING(s, string_len);
ffffffffea812a44:	8b20c273 	add	x19, x19, w0, sxtw
	return (err < 0) ? err : (int)chars_written;
ffffffffea812a48:	2a1303e0 	mov	w0, w19
ffffffffea812a4c:	17ffffb0 	b	ffffffffea81290c <_printf_engine+0x42c>
				else if (flags & HALFFLAG)
ffffffffea812a50:	36100299 	tbz	w25, #2, ffffffffea812aa0 <_printf_engine+0x5c0>
					*(short *)ptr = chars_written;
ffffffffea812a54:	79000013 	strh	w19, [x0]
ffffffffea812a58:	17ffff35 	b	ffffffffea81272c <_printf_engine+0x24c>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812a5c:	36100299 	tbz	w25, #2, ffffffffea812aac <_printf_engine+0x5cc>
				    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
ffffffffea812a60:	37f81858 	tbnz	w24, #31, ffffffffea812d68 <_printf_engine+0x888>
ffffffffea812a64:	aa1703e0 	mov	x0, x23
ffffffffea812a68:	91002ee1 	add	x1, x23, #0xb
ffffffffea812a6c:	927df037 	and	x23, x1, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812a70:	79800001 	ldrsh	x1, [x0]
ffffffffea812a74:	17ffff55 	b	ffffffffea8127c8 <_printf_engine+0x2e8>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea812a78:	36100319 	tbz	w25, #2, ffffffffea812ad8 <_printf_engine+0x5f8>
ffffffffea812a7c:	37f81cd8 	tbnz	w24, #31, ffffffffea812e14 <_printf_engine+0x934>
ffffffffea812a80:	aa1703e0 	mov	x0, x23
ffffffffea812a84:	91002ee1 	add	x1, x23, #0xb
ffffffffea812a88:	927df037 	and	x23, x1, #0xfffffffffffffff8
ffffffffea812a8c:	79400001 	ldrh	w1, [x0]
ffffffffea812a90:	17ffff4f 	b	ffffffffea8127cc <_printf_engine+0x2ec>
ffffffffea812a94:	39423fa0 	ldrb	w0, [x29, #143]
			if (!(flags & LEADZEROFLAG) && signchar != '\0')
ffffffffea812a98:	35fffc60 	cbnz	w0, ffffffffea812a24 <_printf_engine+0x544>
ffffffffea812a9c:	17ffff6e 	b	ffffffffea812854 <_printf_engine+0x374>
				else if (flags & SIZETFLAG)
ffffffffea812aa0:	3727f9f9 	tbnz	w25, #4, ffffffffea8129dc <_printf_engine+0x4fc>
					*(int *)ptr = chars_written;
ffffffffea812aa4:	b9000013 	str	w19, [x0]
ffffffffea812aa8:	17ffff21 	b	ffffffffea81272c <_printf_engine+0x24c>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812aac:	3727e859 	tbnz	w25, #4, ffffffffea8127b4 <_printf_engine+0x2d4>
ffffffffea812ab0:	372fe839 	tbnz	w25, #5, ffffffffea8127b4 <_printf_engine+0x2d4>
ffffffffea812ab4:	363018d9 	tbz	w25, #6, ffffffffea812dcc <_printf_engine+0x8ec>
				    (flags & PTRDIFFFLAG) ? va_arg(ap, ptrdiff_t) :
ffffffffea812ab8:	37f817f8 	tbnz	w24, #31, ffffffffea812db4 <_printf_engine+0x8d4>
ffffffffea812abc:	91003ee0 	add	x0, x23, #0xf
ffffffffea812ac0:	2a1803e2 	mov	w2, w24
ffffffffea812ac4:	927df000 	and	x0, x0, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812ac8:	f94002e1 	ldr	x1, [x23]
ffffffffea812acc:	2a0203f8 	mov	w24, w2
ffffffffea812ad0:	aa0003f7 	mov	x23, x0
ffffffffea812ad4:	17ffff3d 	b	ffffffffea8127c8 <_printf_engine+0x2e8>
				    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
ffffffffea812ad8:	3727e559 	tbnz	w25, #4, ffffffffea812780 <_printf_engine+0x2a0>
				    (flags & INTMAXFLAG) ? va_arg(ap, uintmax_t) :
ffffffffea812adc:	372fe539 	tbnz	w25, #5, ffffffffea812780 <_printf_engine+0x2a0>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812ae0:	36300539 	tbz	w25, #6, ffffffffea812b84 <_printf_engine+0x6a4>
ffffffffea812ae4:	37f80358 	tbnz	w24, #31, ffffffffea812b4c <_printf_engine+0x66c>
ffffffffea812ae8:	91003ee0 	add	x0, x23, #0xf
ffffffffea812aec:	2a1803e2 	mov	w2, w24
ffffffffea812af0:	927df000 	and	x0, x0, #0xfffffffffffffff8
ffffffffea812af4:	f94002e1 	ldr	x1, [x23]
ffffffffea812af8:	2a0203f8 	mov	w24, w2
ffffffffea812afc:	aa0003f7 	mov	x23, x0
ffffffffea812b00:	17ffff33 	b	ffffffffea8127cc <_printf_engine+0x2ec>
				    va_arg(ap, unsigned int);
ffffffffea812b04:	11002301 	add	w1, w24, #0x8
ffffffffea812b08:	7100003f 	cmp	w1, #0x0
ffffffffea812b0c:	540004cd 	b.le	ffffffffea812ba4 <_printf_engine+0x6c4>
ffffffffea812b10:	aa1703e0 	mov	x0, x23
ffffffffea812b14:	91002ee2 	add	x2, x23, #0xb
ffffffffea812b18:	2a0103f8 	mov	w24, w1
ffffffffea812b1c:	927df057 	and	x23, x2, #0xfffffffffffffff8
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812b20:	b9400001 	ldr	w1, [x0]
ffffffffea812b24:	17fffec3 	b	ffffffffea812630 <_printf_engine+0x150>
				    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
ffffffffea812b28:	11002301 	add	w1, w24, #0x8
ffffffffea812b2c:	7100003f 	cmp	w1, #0x0
ffffffffea812b30:	5400044d 	b.le	ffffffffea812bb8 <_printf_engine+0x6d8>
ffffffffea812b34:	aa1703e0 	mov	x0, x23
ffffffffea812b38:	91002ee2 	add	x2, x23, #0xb
ffffffffea812b3c:	2a0103f8 	mov	w24, w1
ffffffffea812b40:	927df057 	and	x23, x2, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812b44:	39800001 	ldrsb	x1, [x0]
ffffffffea812b48:	17ffff20 	b	ffffffffea8127c8 <_printf_engine+0x2e8>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812b4c:	11002302 	add	w2, w24, #0x8
ffffffffea812b50:	7100005f 	cmp	w2, #0x0
ffffffffea812b54:	5400044d 	b.le	ffffffffea812bdc <_printf_engine+0x6fc>
ffffffffea812b58:	91003ee0 	add	x0, x23, #0xf
ffffffffea812b5c:	927df000 	and	x0, x0, #0xfffffffffffffff8
ffffffffea812b60:	17ffffe5 	b	ffffffffea812af4 <_printf_engine+0x614>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812b64:	11002301 	add	w1, w24, #0x8
ffffffffea812b68:	7100003f 	cmp	w1, #0x0
ffffffffea812b6c:	5400030d 	b.le	ffffffffea812bcc <_printf_engine+0x6ec>
ffffffffea812b70:	91003ee2 	add	x2, x23, #0xf
ffffffffea812b74:	aa1703e0 	mov	x0, x23
ffffffffea812b78:	2a0103f8 	mov	w24, w1
ffffffffea812b7c:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812b80:	17fffeab 	b	ffffffffea81262c <_printf_engine+0x14c>
				    va_arg(ap, unsigned int);
ffffffffea812b84:	37f80358 	tbnz	w24, #31, ffffffffea812bec <_printf_engine+0x70c>
ffffffffea812b88:	91002ee0 	add	x0, x23, #0xb
ffffffffea812b8c:	2a1803e2 	mov	w2, w24
ffffffffea812b90:	927df000 	and	x0, x0, #0xfffffffffffffff8
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812b94:	b94002e1 	ldr	w1, [x23]
ffffffffea812b98:	2a0203f8 	mov	w24, w2
ffffffffea812b9c:	aa0003f7 	mov	x23, x0
ffffffffea812ba0:	17ffff0b 	b	ffffffffea8127cc <_printf_engine+0x2ec>
				    va_arg(ap, unsigned int);
ffffffffea812ba4:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812ba8:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812bac:	2a0103f8 	mov	w24, w1
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812bb0:	b9400001 	ldr	w1, [x0]
ffffffffea812bb4:	17fffe9f 	b	ffffffffea812630 <_printf_engine+0x150>
				    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
ffffffffea812bb8:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812bbc:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812bc0:	2a0103f8 	mov	w24, w1
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812bc4:	39800001 	ldrsb	x1, [x0]
ffffffffea812bc8:	17ffff00 	b	ffffffffea8127c8 <_printf_engine+0x2e8>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812bcc:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812bd0:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812bd4:	2a0103f8 	mov	w24, w1
ffffffffea812bd8:	17fffe95 	b	ffffffffea81262c <_printf_engine+0x14c>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea812bdc:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea812be0:	aa1703e0 	mov	x0, x23
ffffffffea812be4:	8b38c037 	add	x23, x1, w24, sxtw
ffffffffea812be8:	17ffffc3 	b	ffffffffea812af4 <_printf_engine+0x614>
				    va_arg(ap, unsigned int);
ffffffffea812bec:	11002302 	add	w2, w24, #0x8
ffffffffea812bf0:	7100005f 	cmp	w2, #0x0
ffffffffea812bf4:	5400122d 	b.le	ffffffffea812e38 <_printf_engine+0x958>
ffffffffea812bf8:	91002ee0 	add	x0, x23, #0xb
ffffffffea812bfc:	927df000 	and	x0, x0, #0xfffffffffffffff8
ffffffffea812c00:	17ffffe5 	b	ffffffffea812b94 <_printf_engine+0x6b4>
				uc = va_arg(ap, unsigned int);
ffffffffea812c04:	11002301 	add	w1, w24, #0x8
ffffffffea812c08:	7100003f 	cmp	w1, #0x0
ffffffffea812c0c:	54000c0d 	b.le	ffffffffea812d8c <_printf_engine+0x8ac>
ffffffffea812c10:	aa1703e0 	mov	x0, x23
ffffffffea812c14:	91002ee2 	add	x2, x23, #0xb
ffffffffea812c18:	2a0103f8 	mov	w24, w1
ffffffffea812c1c:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812c20:	b9400000 	ldr	w0, [x0]
ffffffffea812c24:	17fffebb 	b	ffffffffea812710 <_printf_engine+0x230>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea812c28:	11002301 	add	w1, w24, #0x8
ffffffffea812c2c:	7100003f 	cmp	w1, #0x0
ffffffffea812c30:	540013ad 	b.le	ffffffffea812ea4 <_printf_engine+0x9c4>
ffffffffea812c34:	aa1703e0 	mov	x0, x23
ffffffffea812c38:	91002ee2 	add	x2, x23, #0xb
ffffffffea812c3c:	2a0103f8 	mov	w24, w1
ffffffffea812c40:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812c44:	39400001 	ldrb	w1, [x0]
ffffffffea812c48:	17fffee1 	b	ffffffffea8127cc <_printf_engine+0x2ec>
				    (flags & INTMAXFLAG) ? va_arg(ap, uintmax_t) :
ffffffffea812c4c:	11002301 	add	w1, w24, #0x8
ffffffffea812c50:	7100003f 	cmp	w1, #0x0
ffffffffea812c54:	540000ed 	b.le	ffffffffea812c70 <_printf_engine+0x790>
ffffffffea812c58:	aa1703e0 	mov	x0, x23
ffffffffea812c5c:	91003ee2 	add	x2, x23, #0xf
ffffffffea812c60:	2a0103f8 	mov	w24, w1
ffffffffea812c64:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812c68:	f9400001 	ldr	x1, [x0]
ffffffffea812c6c:	17fffed8 	b	ffffffffea8127cc <_printf_engine+0x2ec>
ffffffffea812c70:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812c74:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812c78:	2a0103f8 	mov	w24, w1
ffffffffea812c7c:	f9400001 	ldr	x1, [x0]
ffffffffea812c80:	17fffed3 	b	ffffffffea8127cc <_printf_engine+0x2ec>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea812c84:	11002301 	add	w1, w24, #0x8
ffffffffea812c88:	7100003f 	cmp	w1, #0x0
ffffffffea812c8c:	540001ed 	b.le	ffffffffea812cc8 <_printf_engine+0x7e8>
ffffffffea812c90:	aa1703e0 	mov	x0, x23
ffffffffea812c94:	91002ee2 	add	x2, x23, #0xb
ffffffffea812c98:	2a0103f8 	mov	w24, w1
ffffffffea812c9c:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812ca0:	79400001 	ldrh	w1, [x0]
ffffffffea812ca4:	17fffe63 	b	ffffffffea812630 <_printf_engine+0x150>
				s = va_arg(ap, const char *);
ffffffffea812ca8:	11002301 	add	w1, w24, #0x8
ffffffffea812cac:	7100003f 	cmp	w1, #0x0
ffffffffea812cb0:	5400016d 	b.le	ffffffffea812cdc <_printf_engine+0x7fc>
ffffffffea812cb4:	91003ee2 	add	x2, x23, #0xf
ffffffffea812cb8:	aa1703e0 	mov	x0, x23
ffffffffea812cbc:	2a0103f8 	mov	w24, w1
ffffffffea812cc0:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812cc4:	17ffff36 	b	ffffffffea81299c <_printf_engine+0x4bc>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea812cc8:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812ccc:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812cd0:	2a0103f8 	mov	w24, w1
ffffffffea812cd4:	79400001 	ldrh	w1, [x0]
ffffffffea812cd8:	17fffe56 	b	ffffffffea812630 <_printf_engine+0x150>
				s = va_arg(ap, const char *);
ffffffffea812cdc:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812ce0:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812ce4:	2a0103f8 	mov	w24, w1
ffffffffea812ce8:	17ffff2d 	b	ffffffffea81299c <_printf_engine+0x4bc>
				    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
ffffffffea812cec:	11002301 	add	w1, w24, #0x8
ffffffffea812cf0:	7100003f 	cmp	w1, #0x0
ffffffffea812cf4:	540000ed 	b.le	ffffffffea812d10 <_printf_engine+0x830>
ffffffffea812cf8:	aa1703e0 	mov	x0, x23
ffffffffea812cfc:	91003ee2 	add	x2, x23, #0xf
ffffffffea812d00:	2a0103f8 	mov	w24, w1
ffffffffea812d04:	927df057 	and	x23, x2, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812d08:	f9400001 	ldr	x1, [x0]
ffffffffea812d0c:	17fffeaf 	b	ffffffffea8127c8 <_printf_engine+0x2e8>
				    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
ffffffffea812d10:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812d14:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812d18:	2a0103f8 	mov	w24, w1
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812d1c:	f9400001 	ldr	x1, [x0]
ffffffffea812d20:	17fffeaa 	b	ffffffffea8127c8 <_printf_engine+0x2e8>
				ptr = va_arg(ap, void *);
ffffffffea812d24:	11002301 	add	w1, w24, #0x8
ffffffffea812d28:	7100003f 	cmp	w1, #0x0
ffffffffea812d2c:	5400016d 	b.le	ffffffffea812d58 <_printf_engine+0x878>
ffffffffea812d30:	91003ee2 	add	x2, x23, #0xf
ffffffffea812d34:	aa1703e0 	mov	x0, x23
ffffffffea812d38:	2a0103f8 	mov	w24, w1
ffffffffea812d3c:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812d40:	17ffff07 	b	ffffffffea81295c <_printf_engine+0x47c>
			for (; format_num > string_len; format_num--)
ffffffffea812d44:	f9403fa1 	ldr	x1, [x29, #120]
ffffffffea812d48:	eb3b403f 	cmp	x1, w27, uxtw
ffffffffea812d4c:	54ffd603 	b.cc	ffffffffea81280c <_printf_engine+0x32c>  // b.lo, b.ul, b.last
			if (!(flags & LEADZEROFLAG) && signchar != '\0')
ffffffffea812d50:	35ffe6a0 	cbnz	w0, ffffffffea812a24 <_printf_engine+0x544>
ffffffffea812d54:	17fffec0 	b	ffffffffea812854 <_printf_engine+0x374>
				ptr = va_arg(ap, void *);
ffffffffea812d58:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812d5c:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812d60:	2a0103f8 	mov	w24, w1
ffffffffea812d64:	17fffefe 	b	ffffffffea81295c <_printf_engine+0x47c>
				    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
ffffffffea812d68:	11002301 	add	w1, w24, #0x8
ffffffffea812d6c:	7100003f 	cmp	w1, #0x0
ffffffffea812d70:	5400018d 	b.le	ffffffffea812da0 <_printf_engine+0x8c0>
ffffffffea812d74:	aa1703e0 	mov	x0, x23
ffffffffea812d78:	91002ee2 	add	x2, x23, #0xb
ffffffffea812d7c:	2a0103f8 	mov	w24, w1
ffffffffea812d80:	927df057 	and	x23, x2, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812d84:	79800001 	ldrsh	x1, [x0]
ffffffffea812d88:	17fffe90 	b	ffffffffea8127c8 <_printf_engine+0x2e8>
				uc = va_arg(ap, unsigned int);
ffffffffea812d8c:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812d90:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812d94:	2a0103f8 	mov	w24, w1
ffffffffea812d98:	b9400000 	ldr	w0, [x0]
ffffffffea812d9c:	17fffe5d 	b	ffffffffea812710 <_printf_engine+0x230>
				    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
ffffffffea812da0:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812da4:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812da8:	2a0103f8 	mov	w24, w1
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812dac:	79800001 	ldrsh	x1, [x0]
ffffffffea812db0:	17fffe86 	b	ffffffffea8127c8 <_printf_engine+0x2e8>
				    (flags & PTRDIFFFLAG) ? va_arg(ap, ptrdiff_t) :
ffffffffea812db4:	11002302 	add	w2, w24, #0x8
ffffffffea812db8:	7100005f 	cmp	w2, #0x0
ffffffffea812dbc:	5400018d 	b.le	ffffffffea812dec <_printf_engine+0x90c>
ffffffffea812dc0:	91003ee0 	add	x0, x23, #0xf
ffffffffea812dc4:	927df000 	and	x0, x0, #0xfffffffffffffff8
ffffffffea812dc8:	17ffff40 	b	ffffffffea812ac8 <_printf_engine+0x5e8>
				    va_arg(ap, int);
ffffffffea812dcc:	37f80198 	tbnz	w24, #31, ffffffffea812dfc <_printf_engine+0x91c>
ffffffffea812dd0:	91002ee0 	add	x0, x23, #0xb
ffffffffea812dd4:	2a1803e2 	mov	w2, w24
ffffffffea812dd8:	927df000 	and	x0, x0, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea812ddc:	b98002e1 	ldrsw	x1, [x23]
ffffffffea812de0:	2a0203f8 	mov	w24, w2
ffffffffea812de4:	aa0003f7 	mov	x23, x0
ffffffffea812de8:	17fffe78 	b	ffffffffea8127c8 <_printf_engine+0x2e8>
				    (flags & PTRDIFFFLAG) ? va_arg(ap, ptrdiff_t) :
ffffffffea812dec:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea812df0:	aa1703e0 	mov	x0, x23
ffffffffea812df4:	8b38c037 	add	x23, x1, w24, sxtw
ffffffffea812df8:	17ffff34 	b	ffffffffea812ac8 <_printf_engine+0x5e8>
				    va_arg(ap, int);
ffffffffea812dfc:	11002302 	add	w2, w24, #0x8
ffffffffea812e00:	7100005f 	cmp	w2, #0x0
ffffffffea812e04:	5400022d 	b.le	ffffffffea812e48 <_printf_engine+0x968>
ffffffffea812e08:	91002ee0 	add	x0, x23, #0xb
ffffffffea812e0c:	927df000 	and	x0, x0, #0xfffffffffffffff8
ffffffffea812e10:	17fffff3 	b	ffffffffea812ddc <_printf_engine+0x8fc>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea812e14:	11002301 	add	w1, w24, #0x8
ffffffffea812e18:	7100003f 	cmp	w1, #0x0
ffffffffea812e1c:	540001ed 	b.le	ffffffffea812e58 <_printf_engine+0x978>
ffffffffea812e20:	aa1703e0 	mov	x0, x23
ffffffffea812e24:	91002ee2 	add	x2, x23, #0xb
ffffffffea812e28:	2a0103f8 	mov	w24, w1
ffffffffea812e2c:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812e30:	79400001 	ldrh	w1, [x0]
ffffffffea812e34:	17fffe66 	b	ffffffffea8127cc <_printf_engine+0x2ec>
				    va_arg(ap, unsigned int);
ffffffffea812e38:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea812e3c:	aa1703e0 	mov	x0, x23
ffffffffea812e40:	8b38c037 	add	x23, x1, w24, sxtw
ffffffffea812e44:	17ffff54 	b	ffffffffea812b94 <_printf_engine+0x6b4>
				    va_arg(ap, int);
ffffffffea812e48:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea812e4c:	aa1703e0 	mov	x0, x23
ffffffffea812e50:	8b38c037 	add	x23, x1, w24, sxtw
ffffffffea812e54:	17ffffe2 	b	ffffffffea812ddc <_printf_engine+0x8fc>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea812e58:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812e5c:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812e60:	2a0103f8 	mov	w24, w1
ffffffffea812e64:	79400001 	ldrh	w1, [x0]
ffffffffea812e68:	17fffe59 	b	ffffffffea8127cc <_printf_engine+0x2ec>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea812e6c:	11002301 	add	w1, w24, #0x8
ffffffffea812e70:	7100003f 	cmp	w1, #0x0
ffffffffea812e74:	540000ed 	b.le	ffffffffea812e90 <_printf_engine+0x9b0>
ffffffffea812e78:	aa1703e0 	mov	x0, x23
ffffffffea812e7c:	91002ee2 	add	x2, x23, #0xb
ffffffffea812e80:	2a0103f8 	mov	w24, w1
ffffffffea812e84:	927df057 	and	x23, x2, #0xfffffffffffffff8
ffffffffea812e88:	39400001 	ldrb	w1, [x0]
ffffffffea812e8c:	17fffde9 	b	ffffffffea812630 <_printf_engine+0x150>
ffffffffea812e90:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812e94:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812e98:	2a0103f8 	mov	w24, w1
ffffffffea812e9c:	39400001 	ldrb	w1, [x0]
ffffffffea812ea0:	17fffde4 	b	ffffffffea812630 <_printf_engine+0x150>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea812ea4:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea812ea8:	8b38c000 	add	x0, x0, w24, sxtw
ffffffffea812eac:	2a0103f8 	mov	w24, w1
ffffffffea812eb0:	39400001 	ldrb	w1, [x0]
ffffffffea812eb4:	17fffe46 	b	ffffffffea8127cc <_printf_engine+0x2ec>

ffffffffea812eb8 <vsnprintf>:
{
ffffffffea812eb8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea812ebc:	910003fd 	mov	x29, sp
	wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
ffffffffea812ec0:	a9401464 	ldp	x4, x5, [x3]
{
ffffffffea812ec4:	a90153f3 	stp	x19, x20, [sp, #16]
	args.len = len;
ffffffffea812ec8:	a90487a0 	stp	x0, x1, [x29, #72]
{
ffffffffea812ecc:	aa0103f4 	mov	x20, x1
ffffffffea812ed0:	aa0003f3 	mov	x19, x0
	args.pos = 0;
ffffffffea812ed4:	f9002fbf 	str	xzr, [x29, #88]
	wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
ffffffffea812ed8:	a9410460 	ldp	x0, x1, [x3, #16]
ffffffffea812edc:	a90217a4 	stp	x4, x5, [x29, #32]
ffffffffea812ee0:	a90307a0 	stp	x0, x1, [x29, #48]
ffffffffea812ee4:	910083a3 	add	x3, x29, #0x20
ffffffffea812ee8:	910123a1 	add	x1, x29, #0x48
ffffffffea812eec:	90000000 	adrp	x0, ffffffffea812000 <heap_alloc+0x2c0>
ffffffffea812ef0:	910e2000 	add	x0, x0, #0x388
ffffffffea812ef4:	97fffd7b 	bl	ffffffffea8124e0 <_printf_engine>
	if (args.pos >= len)
ffffffffea812ef8:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea812efc:	eb14003f 	cmp	x1, x20
ffffffffea812f00:	540000a2 	b.cs	ffffffffea812f14 <vsnprintf+0x5c>  // b.hs, b.nlast
		str[wlen] = '\0';
ffffffffea812f04:	3820ca7f 	strb	wzr, [x19, w0, sxtw]
}
ffffffffea812f08:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812f0c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea812f10:	d65f03c0 	ret
		str[len-1] = '\0';
ffffffffea812f14:	8b140273 	add	x19, x19, x20
ffffffffea812f18:	381ff27f 	sturb	wzr, [x19, #-1]
}
ffffffffea812f1c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812f20:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea812f24:	d65f03c0 	ret

ffffffffea812f28 <snprintf>:
{
ffffffffea812f28:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea812f2c:	910003fd 	mov	x29, sp
	va_start(ap, fmt);
ffffffffea812f30:	910203a8 	add	x8, x29, #0x80
ffffffffea812f34:	910143a9 	add	x9, x29, #0x50
ffffffffea812f38:	a90323a8 	stp	x8, x8, [x29, #48]
ffffffffea812f3c:	128004e8 	mov	w8, #0xffffffd8            	// #-40
ffffffffea812f40:	f90023a9 	str	x9, [x29, #64]
ffffffffea812f44:	b9004ba8 	str	w8, [x29, #72]
ffffffffea812f48:	b9004fbf 	str	wzr, [x29, #76]
	err = vsnprintf(str, len, fmt, ap);
ffffffffea812f4c:	a9432faa 	ldp	x10, x11, [x29, #48]
ffffffffea812f50:	a9012faa 	stp	x10, x11, [x29, #16]
ffffffffea812f54:	a94427a8 	ldp	x8, x9, [x29, #64]
ffffffffea812f58:	a90227a8 	stp	x8, x9, [x29, #32]
{
ffffffffea812f5c:	a90593a3 	stp	x3, x4, [x29, #88]
	err = vsnprintf(str, len, fmt, ap);
ffffffffea812f60:	910043a3 	add	x3, x29, #0x10
{
ffffffffea812f64:	a9069ba5 	stp	x5, x6, [x29, #104]
ffffffffea812f68:	f9003fa7 	str	x7, [x29, #120]
	err = vsnprintf(str, len, fmt, ap);
ffffffffea812f6c:	97ffffd3 	bl	ffffffffea812eb8 <vsnprintf>
}
ffffffffea812f70:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea812f74:	d65f03c0 	ret

ffffffffea812f78 <rand>:
	randseed ^= enp;
}

int rand(void)
{
	return (randseed = randseed * 1664525 + 1013904223);
ffffffffea812f78:	d0000021 	adrp	x1, ffffffffea818000 <_mem_phys_base>
ffffffffea812f7c:	528cc1a3 	mov	w3, #0x660d                	// #26125
ffffffffea812f80:	529e6be2 	mov	w2, #0xf35f                	// #62303
ffffffffea812f84:	72a00323 	movk	w3, #0x19, lsl #16
ffffffffea812f88:	b94fc820 	ldr	w0, [x1, #4040]
ffffffffea812f8c:	72a78dc2 	movk	w2, #0x3c6e, lsl #16
ffffffffea812f90:	1b030800 	madd	w0, w0, w3, w2
ffffffffea812f94:	b90fc820 	str	w0, [x1, #4040]
}
ffffffffea812f98:	d65f03c0 	ret
ffffffffea812f9c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812fa0 <_printf>:
	va_end(ap);
	return err;
}

int _printf(const char *fmt, ...)
{
ffffffffea812fa0:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea812fa4:	d0000028 	adrp	x8, ffffffffea818000 <_mem_phys_base>
ffffffffea812fa8:	913d0108 	add	x8, x8, #0xf40
{
ffffffffea812fac:	910003fd 	mov	x29, sp
	va_list ap;
	int err;

	va_start(ap, fmt);
ffffffffea812fb0:	9102c3a9 	add	x9, x29, #0xb0
ffffffffea812fb4:	9101c3aa 	add	x10, x29, #0x70
ffffffffea812fb8:	a90327a9 	stp	x9, x9, [x29, #48]
ffffffffea812fbc:	128006e9 	mov	w9, #0xffffffc8            	// #-56
ffffffffea812fc0:	f90023aa 	str	x10, [x29, #64]
{
ffffffffea812fc4:	f9003fa1 	str	x1, [x29, #120]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea812fc8:	aa0003e1 	mov	x1, x0
	va_start(ap, fmt);
ffffffffea812fcc:	b9004fbf 	str	wzr, [x29, #76]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea812fd0:	f9401500 	ldr	x0, [x8, #40]
ffffffffea812fd4:	f940250c 	ldr	x12, [x8, #72]
	va_start(ap, fmt);
ffffffffea812fd8:	b9004ba9 	str	w9, [x29, #72]
ffffffffea812fdc:	a9432faa 	ldp	x10, x11, [x29, #48]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea812fe0:	a9012faa 	stp	x10, x11, [x29, #16]
ffffffffea812fe4:	a94427a8 	ldp	x8, x9, [x29, #64]
ffffffffea812fe8:	a90227a8 	stp	x8, x9, [x29, #32]
{
ffffffffea812fec:	a9080fa2 	stp	x2, x3, [x29, #128]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea812ff0:	910043a2 	add	x2, x29, #0x10
{
ffffffffea812ff4:	a90917a4 	stp	x4, x5, [x29, #144]
ffffffffea812ff8:	a90a1fa6 	stp	x6, x7, [x29, #160]
ffffffffea812ffc:	a9052faa 	stp	x10, x11, [x29, #80]
ffffffffea813000:	a90627a8 	stp	x8, x9, [x29, #96]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813004:	d63f0180 	blr	x12
	err = vfprintf(stdout, fmt, ap);
	va_end(ap);

	return err;
}
ffffffffea813008:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea81300c:	d65f03c0 	ret

ffffffffea813010 <__guard_setup>:

#include <rand.h>

unsigned int __stack_chk_guard = 0xaff;

static void __attribute__((constructor)) __guard_setup (void){
ffffffffea813010:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea813014:	910003fd 	mov	x29, sp
ffffffffea813018:	f9000bf3 	str	x19, [sp, #16]
        /* 
         * included for future use. rand.h must be seeded and -fstack_protector must be disabled in
         * stack contexts preceeding this call.
         */
  	if ( __stack_chk_guard == 0U )
ffffffffea81301c:	b0000033 	adrp	x19, ffffffffea818000 <_mem_phys_base>
ffffffffea813020:	b94fce60 	ldr	w0, [x19, #4044]
ffffffffea813024:	35000060 	cbnz	w0, ffffffffea813030 <__guard_setup+0x20>
  		__stack_chk_guard = rand();
ffffffffea813028:	97ffffd4 	bl	ffffffffea812f78 <rand>
ffffffffea81302c:	b90fce60 	str	w0, [x19, #4044]
}
ffffffffea813030:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea813034:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea813038:	d65f03c0 	ret
ffffffffea81303c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813040 <malloc>:
#include <string.h>
#include <lib/heap.h>

void *malloc(size_t size)
{
	return heap_alloc(size, 0);
ffffffffea813040:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea813044:	17fffb3f 	b	ffffffffea811d40 <heap_alloc>

ffffffffea813048 <memalign>:
}

void *memalign(size_t boundary, size_t size)
{
ffffffffea813048:	aa0103e2 	mov	x2, x1
	return heap_alloc(size, boundary);
ffffffffea81304c:	2a0003e1 	mov	w1, w0
ffffffffea813050:	aa0203e0 	mov	x0, x2
ffffffffea813054:	17fffb3b 	b	ffffffffea811d40 <heap_alloc>

ffffffffea813058 <calloc>:
}

void *calloc(size_t count, size_t size)
{
ffffffffea813058:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea81305c:	910003fd 	mov	x29, sp
ffffffffea813060:	a90153f3 	stp	x19, x20, [sp, #16]
	void *ptr;
	size_t realsize = count * size;
ffffffffea813064:	9b017c14 	mul	x20, x0, x1

	ptr = heap_alloc(realsize, 0);
ffffffffea813068:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea81306c:	aa1403e0 	mov	x0, x20
ffffffffea813070:	97fffb34 	bl	ffffffffea811d40 <heap_alloc>
ffffffffea813074:	aa0003f3 	mov	x19, x0
	if (!ptr)
ffffffffea813078:	b4000080 	cbz	x0, ffffffffea813088 <calloc+0x30>
		return NULL;

	memset(ptr, 0, realsize);
ffffffffea81307c:	aa1403e2 	mov	x2, x20
ffffffffea813080:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea813084:	940000c3 	bl	ffffffffea813390 <memset>
	return ptr;
}
ffffffffea813088:	aa1303e0 	mov	x0, x19
ffffffffea81308c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea813090:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea813094:	d65f03c0 	ret

ffffffffea813098 <free>:
	return p;
}

void free(void *ptr)
{
	return heap_free(ptr);
ffffffffea813098:	17fffbec 	b	ffffffffea812048 <heap_free>
ffffffffea81309c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8130a0 <memcpy>:
{
	char *d = (char *)dest;
	const char *s = (const char *)src;
	int len;

	if (count == 0 || dest == src)
ffffffffea8130a0:	f100005f 	cmp	x2, #0x0
ffffffffea8130a4:	fa411004 	ccmp	x0, x1, #0x4, ne  // ne = any
ffffffffea8130a8:	540006e0 	b.eq	ffffffffea813184 <memcpy+0xe4>  // b.none
		return dest;

	if (((long)d | (long)s) & lmask) {
ffffffffea8130ac:	aa010003 	orr	x3, x0, x1
ffffffffea8130b0:	aa0003e4 	mov	x4, x0
ffffffffea8130b4:	f240087f 	tst	x3, #0x7
ffffffffea8130b8:	540002e0 	b.eq	ffffffffea813114 <memcpy+0x74>  // b.none
		// src and/or dest do not align on word boundary
		if ((((long)d ^ (long)s) & lmask) || (count < lsize))
ffffffffea8130bc:	ca010003 	eor	x3, x0, x1
ffffffffea8130c0:	f240087f 	tst	x3, #0x7
ffffffffea8130c4:	fa470840 	ccmp	x2, #0x7, #0x0, eq  // eq = none
ffffffffea8130c8:	54000608 	b.hi	ffffffffea813188 <memcpy+0xe8>  // b.pmore
			len = count; // copy the rest of the buffer with the byte mover
ffffffffea8130cc:	2a0203e3 	mov	w3, w2
		else
			len = lsize - ((long)d & lmask); // move the ptrs up to a word boundary

		count -= len;
ffffffffea8130d0:	cb22c042 	sub	x2, x2, w2, sxtw
		for (; len > 0; len--)
ffffffffea8130d4:	7100007f 	cmp	w3, #0x0
ffffffffea8130d8:	540001ed 	b.le	ffffffffea813114 <memcpy+0x74>
ffffffffea8130dc:	51000466 	sub	w6, w3, #0x1
{
ffffffffea8130e0:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea8130e4:	aa0603e5 	mov	x5, x6
ffffffffea8130e8:	910004c6 	add	x6, x6, #0x1
ffffffffea8130ec:	d503201f 	nop
			*d++ = *s++;
ffffffffea8130f0:	38636824 	ldrb	w4, [x1, x3]
ffffffffea8130f4:	38236804 	strb	w4, [x0, x3]
ffffffffea8130f8:	91000463 	add	x3, x3, #0x1
		for (; len > 0; len--)
ffffffffea8130fc:	eb06007f 	cmp	x3, x6
ffffffffea813100:	54ffff81 	b.ne	ffffffffea8130f0 <memcpy+0x50>  // b.any
ffffffffea813104:	93407ca3 	sxtw	x3, w5
ffffffffea813108:	91000463 	add	x3, x3, #0x1
ffffffffea81310c:	8b030004 	add	x4, x0, x3
ffffffffea813110:	8b030021 	add	x1, x1, x3
	}
	for (len = count / lsize; len > 0; len--) {
ffffffffea813114:	d343fc43 	lsr	x3, x2, #3
ffffffffea813118:	7100007f 	cmp	w3, #0x0
ffffffffea81311c:	540001ed 	b.le	ffffffffea813158 <memcpy+0xb8>
ffffffffea813120:	51000466 	sub	w6, w3, #0x1
ffffffffea813124:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea813128:	d37d7cc7 	ubfiz	x7, x6, #3, #32
ffffffffea81312c:	910020e7 	add	x7, x7, #0x8
		*(word *)d = *(word *)s;
ffffffffea813130:	f8636825 	ldr	x5, [x1, x3]
ffffffffea813134:	f8236885 	str	x5, [x4, x3]
ffffffffea813138:	91002063 	add	x3, x3, #0x8
	for (len = count / lsize; len > 0; len--) {
ffffffffea81313c:	eb07007f 	cmp	x3, x7
ffffffffea813140:	54ffff81 	b.ne	ffffffffea813130 <memcpy+0x90>  // b.any
ffffffffea813144:	93407cc3 	sxtw	x3, w6
ffffffffea813148:	91000463 	add	x3, x3, #0x1
ffffffffea81314c:	d37df063 	lsl	x3, x3, #3
ffffffffea813150:	8b030084 	add	x4, x4, x3
ffffffffea813154:	8b030021 	add	x1, x1, x3
		d += lsize;
		s += lsize;
	}
	for (len = count & lmask; len > 0; len--)
ffffffffea813158:	72000842 	ands	w2, w2, #0x7
ffffffffea81315c:	54000140 	b.eq	ffffffffea813184 <memcpy+0xe4>  // b.none
ffffffffea813160:	51000443 	sub	w3, w2, #0x1
ffffffffea813164:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea813168:	91000463 	add	x3, x3, #0x1
ffffffffea81316c:	d503201f 	nop
		*d++ = *s++;
ffffffffea813170:	38626825 	ldrb	w5, [x1, x2]
ffffffffea813174:	38226885 	strb	w5, [x4, x2]
ffffffffea813178:	91000442 	add	x2, x2, #0x1
	for (len = count & lmask; len > 0; len--)
ffffffffea81317c:	eb03005f 	cmp	x2, x3
ffffffffea813180:	54ffff81 	b.ne	ffffffffea813170 <memcpy+0xd0>  // b.any

	return dest;
}
ffffffffea813184:	d65f03c0 	ret
			len = lsize - ((long)d & lmask); // move the ptrs up to a word boundary
ffffffffea813188:	12000804 	and	w4, w0, #0x7
ffffffffea81318c:	52800103 	mov	w3, #0x8                   	// #8
ffffffffea813190:	4b040063 	sub	w3, w3, w4
		count -= len;
ffffffffea813194:	cb23c042 	sub	x2, x2, w3, sxtw
ffffffffea813198:	17ffffd1 	b	ffffffffea8130dc <memcpy+0x3c>
ffffffffea81319c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8131a0 <memmove>:
{
	char *d = (char *)dest;
	const char *s = (const char *)src;
	int len;

	if (count == 0 || dest == src)
ffffffffea8131a0:	f100005f 	cmp	x2, #0x0
ffffffffea8131a4:	fa411004 	ccmp	x0, x1, #0x4, ne  // ne = any
ffffffffea8131a8:	54000720 	b.eq	ffffffffea81328c <memmove+0xec>  // b.none
		return dest;

	if ((long)d < (long)s) {
ffffffffea8131ac:	eb01001f 	cmp	x0, x1
ffffffffea8131b0:	5400070a 	b.ge	ffffffffea813290 <memmove+0xf0>  // b.tcont
		if (((long)d | (long)s) & lmask) {
ffffffffea8131b4:	aa010003 	orr	x3, x0, x1
ffffffffea8131b8:	aa0003e4 	mov	x4, x0
ffffffffea8131bc:	f240087f 	tst	x3, #0x7
ffffffffea8131c0:	540002e0 	b.eq	ffffffffea81321c <memmove+0x7c>  // b.none
			// src and/or dest do not align on word boundary
			if ((((long)d ^ (long)s) & lmask) || (count < lsize))
ffffffffea8131c4:	ca010003 	eor	x3, x0, x1
ffffffffea8131c8:	f240087f 	tst	x3, #0x7
ffffffffea8131cc:	fa470840 	ccmp	x2, #0x7, #0x0, eq  // eq = none
ffffffffea8131d0:	54000d48 	b.hi	ffffffffea813378 <memmove+0x1d8>  // b.pmore
				len = count; // copy the rest of the buffer with the byte mover
ffffffffea8131d4:	2a0203e3 	mov	w3, w2
			else
				len = lsize - ((long)d & lmask); // move the ptrs up to a word boundary

			count -= len;
ffffffffea8131d8:	cb22c042 	sub	x2, x2, w2, sxtw
			for (; len > 0; len--)
ffffffffea8131dc:	7100007f 	cmp	w3, #0x0
ffffffffea8131e0:	540001ed 	b.le	ffffffffea81321c <memmove+0x7c>
ffffffffea8131e4:	51000466 	sub	w6, w3, #0x1
{
ffffffffea8131e8:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea8131ec:	aa0603e5 	mov	x5, x6
ffffffffea8131f0:	910004c6 	add	x6, x6, #0x1
ffffffffea8131f4:	d503201f 	nop
				*d++ = *s++;
ffffffffea8131f8:	38636824 	ldrb	w4, [x1, x3]
ffffffffea8131fc:	38236804 	strb	w4, [x0, x3]
ffffffffea813200:	91000463 	add	x3, x3, #0x1
			for (; len > 0; len--)
ffffffffea813204:	eb06007f 	cmp	x3, x6
ffffffffea813208:	54ffff81 	b.ne	ffffffffea8131f8 <memmove+0x58>  // b.any
ffffffffea81320c:	93407ca3 	sxtw	x3, w5
ffffffffea813210:	91000463 	add	x3, x3, #0x1
ffffffffea813214:	8b030004 	add	x4, x0, x3
ffffffffea813218:	8b030021 	add	x1, x1, x3
		}
		for (len = count / lsize; len > 0; len--) {
ffffffffea81321c:	d343fc43 	lsr	x3, x2, #3
ffffffffea813220:	7100007f 	cmp	w3, #0x0
ffffffffea813224:	540001ed 	b.le	ffffffffea813260 <memmove+0xc0>
ffffffffea813228:	51000466 	sub	w6, w3, #0x1
ffffffffea81322c:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea813230:	d37d7cc7 	ubfiz	x7, x6, #3, #32
ffffffffea813234:	910020e7 	add	x7, x7, #0x8
			*(word *)d = *(word *)s;
ffffffffea813238:	f8636825 	ldr	x5, [x1, x3]
ffffffffea81323c:	f8236885 	str	x5, [x4, x3]
ffffffffea813240:	91002063 	add	x3, x3, #0x8
		for (len = count / lsize; len > 0; len--) {
ffffffffea813244:	eb07007f 	cmp	x3, x7
ffffffffea813248:	54ffff81 	b.ne	ffffffffea813238 <memmove+0x98>  // b.any
ffffffffea81324c:	93407cc3 	sxtw	x3, w6
ffffffffea813250:	91000463 	add	x3, x3, #0x1
ffffffffea813254:	d37df063 	lsl	x3, x3, #3
ffffffffea813258:	8b030084 	add	x4, x4, x3
ffffffffea81325c:	8b030021 	add	x1, x1, x3
			d += lsize;
			s += lsize;
		}
		for (len = count & lmask; len > 0; len--)
ffffffffea813260:	72000842 	ands	w2, w2, #0x7
ffffffffea813264:	54000140 	b.eq	ffffffffea81328c <memmove+0xec>  // b.none
ffffffffea813268:	51000445 	sub	w5, w2, #0x1
ffffffffea81326c:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea813270:	910004a5 	add	x5, x5, #0x1
ffffffffea813274:	d503201f 	nop
			*d++ = *s++;
ffffffffea813278:	38626823 	ldrb	w3, [x1, x2]
ffffffffea81327c:	38226883 	strb	w3, [x4, x2]
ffffffffea813280:	91000442 	add	x2, x2, #0x1
		for (len = count & lmask; len > 0; len--)
ffffffffea813284:	eb05005f 	cmp	x2, x5
ffffffffea813288:	54ffff81 	b.ne	ffffffffea813278 <memmove+0xd8>  // b.any
		for (len = count & lmask; len > 0; len--)
			*--d = *--s;
	}

	return dest;
}
ffffffffea81328c:	d65f03c0 	ret
		d += count;
ffffffffea813290:	8b020004 	add	x4, x0, x2
		s += count;
ffffffffea813294:	8b020021 	add	x1, x1, x2
		if (((long)d | (long)s) & lmask) {
ffffffffea813298:	aa010083 	orr	x3, x4, x1
ffffffffea81329c:	f240087f 	tst	x3, #0x7
ffffffffea8132a0:	540002e0 	b.eq	ffffffffea8132fc <memmove+0x15c>  // b.none
			if ((((long)d ^ (long)s) & lmask) || (count <= lsize))
ffffffffea8132a4:	ca010083 	eor	x3, x4, x1
				len = count;
ffffffffea8132a8:	12000885 	and	w5, w4, #0x7
			if ((((long)d ^ (long)s) & lmask) || (count <= lsize))
ffffffffea8132ac:	f240087f 	tst	x3, #0x7
				len = count;
ffffffffea8132b0:	fa480840 	ccmp	x2, #0x8, #0x0, eq  // eq = none
ffffffffea8132b4:	1a859045 	csel	w5, w2, w5, ls  // ls = plast
			for (; len > 0; len--)
ffffffffea8132b8:	710000bf 	cmp	w5, #0x0
			count -= len;
ffffffffea8132bc:	cb25c042 	sub	x2, x2, w5, sxtw
			for (; len > 0; len--)
ffffffffea8132c0:	540001ed 	b.le	ffffffffea8132fc <memmove+0x15c>
ffffffffea8132c4:	510004a3 	sub	w3, w5, #0x1
ffffffffea8132c8:	92800027 	mov	x7, #0xfffffffffffffffe    	// #-2
ffffffffea8132cc:	cb0300e7 	sub	x7, x7, x3
ffffffffea8132d0:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
ffffffffea8132d4:	d503201f 	nop
				*--d = *--s;
ffffffffea8132d8:	38636826 	ldrb	w6, [x1, x3]
ffffffffea8132dc:	38236886 	strb	w6, [x4, x3]
ffffffffea8132e0:	d1000463 	sub	x3, x3, #0x1
			for (; len > 0; len--)
ffffffffea8132e4:	eb07007f 	cmp	x3, x7
ffffffffea8132e8:	54ffff81 	b.ne	ffffffffea8132d8 <memmove+0x138>  // b.any
ffffffffea8132ec:	4b0503e5 	neg	w5, w5
ffffffffea8132f0:	93407ca5 	sxtw	x5, w5
ffffffffea8132f4:	8b050084 	add	x4, x4, x5
ffffffffea8132f8:	8b050021 	add	x1, x1, x5
		for (len = count / lsize; len > 0; len--) {
ffffffffea8132fc:	d343fc43 	lsr	x3, x2, #3
ffffffffea813300:	7100007f 	cmp	w3, #0x0
ffffffffea813304:	5400022d 	b.le	ffffffffea813348 <memmove+0x1a8>
ffffffffea813308:	51000467 	sub	w7, w3, #0x1
ffffffffea81330c:	928000e3 	mov	x3, #0xfffffffffffffff8    	// #-8
ffffffffea813310:	aa0703e6 	mov	x6, x7
ffffffffea813314:	cb070fe7 	neg	x7, x7, lsl #3
ffffffffea813318:	d10040e7 	sub	x7, x7, #0x10
ffffffffea81331c:	d503201f 	nop
			*(word *)d = *(word *)s;
ffffffffea813320:	f8636825 	ldr	x5, [x1, x3]
ffffffffea813324:	f8236885 	str	x5, [x4, x3]
ffffffffea813328:	d1002063 	sub	x3, x3, #0x8
		for (len = count / lsize; len > 0; len--) {
ffffffffea81332c:	eb07007f 	cmp	x3, x7
ffffffffea813330:	54ffff81 	b.ne	ffffffffea813320 <memmove+0x180>  // b.any
ffffffffea813334:	93407cc3 	sxtw	x3, w6
ffffffffea813338:	aa2303e3 	mvn	x3, x3
ffffffffea81333c:	d37df063 	lsl	x3, x3, #3
ffffffffea813340:	8b030084 	add	x4, x4, x3
ffffffffea813344:	8b030021 	add	x1, x1, x3
		for (len = count & lmask; len > 0; len--)
ffffffffea813348:	72000842 	ands	w2, w2, #0x7
ffffffffea81334c:	54fffa00 	b.eq	ffffffffea81328c <memmove+0xec>  // b.none
ffffffffea813350:	51000442 	sub	w2, w2, #0x1
ffffffffea813354:	92800025 	mov	x5, #0xfffffffffffffffe    	// #-2
ffffffffea813358:	cb0200a5 	sub	x5, x5, x2
ffffffffea81335c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
			*--d = *--s;
ffffffffea813360:	38626823 	ldrb	w3, [x1, x2]
ffffffffea813364:	38226883 	strb	w3, [x4, x2]
ffffffffea813368:	d1000442 	sub	x2, x2, #0x1
		for (len = count & lmask; len > 0; len--)
ffffffffea81336c:	eb05005f 	cmp	x2, x5
ffffffffea813370:	54ffff81 	b.ne	ffffffffea813360 <memmove+0x1c0>  // b.any
}
ffffffffea813374:	d65f03c0 	ret
				len = lsize - ((long)d & lmask); // move the ptrs up to a word boundary
ffffffffea813378:	12000804 	and	w4, w0, #0x7
ffffffffea81337c:	52800103 	mov	w3, #0x8                   	// #8
ffffffffea813380:	4b040063 	sub	w3, w3, w4
			count -= len;
ffffffffea813384:	cb23c042 	sub	x2, x2, w3, sxtw
ffffffffea813388:	17ffff97 	b	ffffffffea8131e4 <memmove+0x44>
ffffffffea81338c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813390 <memset>:

void *
memset(void *s, int c, size_t count)
{
	char *xs = (char *) s;
	size_t len = (-(size_t)s) & (sizeof(size_t)-1);
ffffffffea813390:	cb0003e5 	neg	x5, x0
	char *xs = (char *) s;
ffffffffea813394:	aa0003e3 	mov	x3, x0
	size_t len = (-(size_t)s) & (sizeof(size_t)-1);
ffffffffea813398:	924008a5 	and	x5, x5, #0x7
	size_t cc = c & 0xff;

	if ( count > len ) {
ffffffffea81339c:	eb0200bf 	cmp	x5, x2
ffffffffea8133a0:	54000282 	b.cs	ffffffffea8133f0 <memset+0x60>  // b.hs, b.nlast
	size_t cc = c & 0xff;
ffffffffea8133a4:	92401c24 	and	x4, x1, #0xff
		count -= len;
ffffffffea8133a8:	cb050042 	sub	x2, x2, x5
		cc |= cc << 8;
ffffffffea8133ac:	aa042084 	orr	x4, x4, x4, lsl #8
		cc |= cc << 16;
ffffffffea8133b0:	aa044084 	orr	x4, x4, x4, lsl #16
		if (sizeof(size_t) == 8)
			cc |= (uint64_t)cc << 32; // should be optimized out on 32 bit machines
ffffffffea8133b4:	aa048084 	orr	x4, x4, x4, lsl #32

		// write to non-aligned memory byte-wise
		for ( ; len > 0; len-- )
ffffffffea8133b8:	b40000e5 	cbz	x5, ffffffffea8133d4 <memset+0x44>
ffffffffea8133bc:	12001c26 	and	w6, w1, #0xff
ffffffffea8133c0:	8b050005 	add	x5, x0, x5
ffffffffea8133c4:	d503201f 	nop
			*xs++ = c;
ffffffffea8133c8:	38001466 	strb	w6, [x3], #1
		for ( ; len > 0; len-- )
ffffffffea8133cc:	eb0300bf 	cmp	x5, x3
ffffffffea8133d0:	54ffffc1 	b.ne	ffffffffea8133c8 <memset+0x38>  // b.any

		// write to aligned memory dword-wise
		for ( len = count/sizeof(size_t); len > 0; len-- ) {
ffffffffea8133d4:	d343fc45 	lsr	x5, x2, #3
ffffffffea8133d8:	b40000a5 	cbz	x5, ffffffffea8133ec <memset+0x5c>
ffffffffea8133dc:	8b050c65 	add	x5, x3, x5, lsl #3
			*((size_t *)xs) = (size_t)cc;
ffffffffea8133e0:	f8008464 	str	x4, [x3], #8
		for ( len = count/sizeof(size_t); len > 0; len-- ) {
ffffffffea8133e4:	eb0300bf 	cmp	x5, x3
ffffffffea8133e8:	54ffffc1 	b.ne	ffffffffea8133e0 <memset+0x50>  // b.any
			xs += sizeof(size_t);
		}

		count &= sizeof(size_t)-1;
ffffffffea8133ec:	92400842 	and	x2, x2, #0x7
	}

	// write remaining bytes
	for ( ; count > 0; count-- )
ffffffffea8133f0:	b40000e2 	cbz	x2, ffffffffea81340c <memset+0x7c>
ffffffffea8133f4:	12001c21 	and	w1, w1, #0xff
ffffffffea8133f8:	8b020062 	add	x2, x3, x2
ffffffffea8133fc:	d503201f 	nop
		*xs++ = c;
ffffffffea813400:	38001461 	strb	w1, [x3], #1
	for ( ; count > 0; count-- )
ffffffffea813404:	eb03005f 	cmp	x2, x3
ffffffffea813408:	54ffffc1 	b.ne	ffffffffea813400 <memset+0x70>  // b.any

	return s;
}
ffffffffea81340c:	d65f03c0 	ret

ffffffffea813410 <strcmp>:
#include <string.h>
#include <sys/types.h>

int
strcmp(char const *cs, char const *ct)
{
ffffffffea813410:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea813414:	14000002 	b	ffffffffea81341c <strcmp+0xc>
	signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
ffffffffea813418:	34000124 	cbz	w4, ffffffffea81343c <strcmp+0x2c>
ffffffffea81341c:	38636804 	ldrb	w4, [x0, x3]
ffffffffea813420:	38636822 	ldrb	w2, [x1, x3]
ffffffffea813424:	91000463 	add	x3, x3, #0x1
ffffffffea813428:	4b020082 	sub	w2, w4, w2
ffffffffea81342c:	13001c42 	sxtb	w2, w2
ffffffffea813430:	34ffff42 	cbz	w2, ffffffffea813418 <strcmp+0x8>
ffffffffea813434:	2a0203e0 	mov	w0, w2
			break;
	}

	return __res;
}
ffffffffea813438:	d65f03c0 	ret
ffffffffea81343c:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea813440:	d65f03c0 	ret
ffffffffea813444:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813448 <strdup>:
#include <stdlib.h>
#include <string.h>

char *
strdup(const char *str)
{
ffffffffea813448:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea81344c:	910003fd 	mov	x29, sp
ffffffffea813450:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea813454:	f90013f5 	str	x21, [sp, #32]
ffffffffea813458:	aa0003f5 	mov	x21, x0
	size_t len;
	char *copy;

	len = strlen(str) + 1;
ffffffffea81345c:	9400002f 	bl	ffffffffea813518 <strlen>
ffffffffea813460:	91000414 	add	x20, x0, #0x1
	copy = malloc(len);
ffffffffea813464:	aa1403e0 	mov	x0, x20
ffffffffea813468:	97fffef6 	bl	ffffffffea813040 <malloc>
ffffffffea81346c:	aa0003f3 	mov	x19, x0
	if (copy == NULL)
ffffffffea813470:	b4000080 	cbz	x0, ffffffffea813480 <strdup+0x38>
		return NULL;
	memcpy(copy, str, len);
ffffffffea813474:	aa1403e2 	mov	x2, x20
ffffffffea813478:	aa1503e1 	mov	x1, x21
ffffffffea81347c:	97ffff09 	bl	ffffffffea8130a0 <memcpy>
	return copy;
}
ffffffffea813480:	aa1303e0 	mov	x0, x19
ffffffffea813484:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea813488:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81348c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea813490:	d65f03c0 	ret
ffffffffea813494:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813498 <strlcpy>:
size_t
strlcpy(char *dst, char const *src, size_t s)
{
	size_t i= 0;

	if (!s) {
ffffffffea813498:	b4000362 	cbz	x2, ffffffffea813504 <strlcpy+0x6c>
{
ffffffffea81349c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
		return strlen(src);
	}

	for (i= 0; ((i< s-1) && src[i]); i++) {
ffffffffea8134a0:	f1000442 	subs	x2, x2, #0x1
{
ffffffffea8134a4:	910003fd 	mov	x29, sp
ffffffffea8134a8:	f9000bf3 	str	x19, [sp, #16]
	for (i= 0; ((i< s-1) && src[i]); i++) {
ffffffffea8134ac:	54000300 	b.eq	ffffffffea81350c <strlcpy+0x74>  // b.none
ffffffffea8134b0:	aa0103e3 	mov	x3, x1
ffffffffea8134b4:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea8134b8:	aa0003e5 	mov	x5, x0
ffffffffea8134bc:	38401464 	ldrb	w4, [x3], #1
ffffffffea8134c0:	35000084 	cbnz	w4, ffffffffea8134d0 <strlcpy+0x38>
ffffffffea8134c4:	14000009 	b	ffffffffea8134e8 <strlcpy+0x50>
ffffffffea8134c8:	38401464 	ldrb	w4, [x3], #1
ffffffffea8134cc:	340000e4 	cbz	w4, ffffffffea8134e8 <strlcpy+0x50>
		dst[i]= src[i];
ffffffffea8134d0:	38336804 	strb	w4, [x0, x19]
	for (i= 0; ((i< s-1) && src[i]); i++) {
ffffffffea8134d4:	91000673 	add	x19, x19, #0x1
ffffffffea8134d8:	aa0303e1 	mov	x1, x3
ffffffffea8134dc:	8b130005 	add	x5, x0, x19
ffffffffea8134e0:	eb02027f 	cmp	x19, x2
ffffffffea8134e4:	54ffff21 	b.ne	ffffffffea8134c8 <strlcpy+0x30>  // b.any
	}

	dst[i]= 0;
ffffffffea8134e8:	390000bf 	strb	wzr, [x5]

	return i + strlen(src+i);
ffffffffea8134ec:	aa0103e0 	mov	x0, x1
ffffffffea8134f0:	9400000a 	bl	ffffffffea813518 <strlen>
}
ffffffffea8134f4:	8b130000 	add	x0, x0, x19
ffffffffea8134f8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8134fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea813500:	d65f03c0 	ret
		return strlen(src);
ffffffffea813504:	aa0103e0 	mov	x0, x1
ffffffffea813508:	14000004 	b	ffffffffea813518 <strlen>
	for (i= 0; ((i< s-1) && src[i]); i++) {
ffffffffea81350c:	aa0003e5 	mov	x5, x0
ffffffffea813510:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea813514:	17fffff5 	b	ffffffffea8134e8 <strlcpy+0x50>

ffffffffea813518 <strlen>:
#include <string.h>
#include <sys/types.h>

size_t
strlen(char const *s)
{
ffffffffea813518:	aa0003e2 	mov	x2, x0
	size_t i;

	i= 0;
	while (s[i]) {
ffffffffea81351c:	39400000 	ldrb	w0, [x0]
ffffffffea813520:	340000c0 	cbz	w0, ffffffffea813538 <strlen+0x20>
	i= 0;
ffffffffea813524:	d2800000 	mov	x0, #0x0                   	// #0
		i+= 1;
ffffffffea813528:	91000400 	add	x0, x0, #0x1
	while (s[i]) {
ffffffffea81352c:	38606841 	ldrb	w1, [x2, x0]
ffffffffea813530:	35ffffc1 	cbnz	w1, ffffffffea813528 <strlen+0x10>
	}

	return i;
}
ffffffffea813534:	d65f03c0 	ret
	i= 0;
ffffffffea813538:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea81353c:	d65f03c0 	ret

ffffffffea813540 <strncpy>:
char *
strncpy(char *dest, char const *src, size_t count)
{
	char *tmp = dest;

	while (count-- && (*dest++ = *src++) != '\0')
ffffffffea813540:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea813544:	14000005 	b	ffffffffea813558 <strncpy+0x18>
ffffffffea813548:	38636824 	ldrb	w4, [x1, x3]
ffffffffea81354c:	38236804 	strb	w4, [x0, x3]
ffffffffea813550:	91000463 	add	x3, x3, #0x1
ffffffffea813554:	34000064 	cbz	w4, ffffffffea813560 <strncpy+0x20>
ffffffffea813558:	eb02007f 	cmp	x3, x2
ffffffffea81355c:	54ffff61 	b.ne	ffffffffea813548 <strncpy+0x8>  // b.any
		;

	return tmp;
}
ffffffffea813560:	d65f03c0 	ret
ffffffffea813564:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813568 <strncmp>:
int
strncmp(char const *cs, char const *ct, size_t count)
{
	signed char __res = 0;

	while (count > 0) {
ffffffffea813568:	b4000242 	cbz	x2, ffffffffea8135b0 <strncmp+0x48>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
ffffffffea81356c:	39400004 	ldrb	w4, [x0]
ffffffffea813570:	39400023 	ldrb	w3, [x1]
ffffffffea813574:	4b030083 	sub	w3, w4, w3
ffffffffea813578:	13001c63 	sxtb	w3, w3
ffffffffea81357c:	350001e3 	cbnz	w3, ffffffffea8135b8 <strncmp+0x50>
ffffffffea813580:	34000184 	cbz	w4, ffffffffea8135b0 <strncmp+0x48>
ffffffffea813584:	d2800024 	mov	x4, #0x1                   	// #1
ffffffffea813588:	14000008 	b	ffffffffea8135a8 <strncmp+0x40>
ffffffffea81358c:	38646805 	ldrb	w5, [x0, x4]
ffffffffea813590:	38646823 	ldrb	w3, [x1, x4]
ffffffffea813594:	91000484 	add	x4, x4, #0x1
ffffffffea813598:	4b0300a3 	sub	w3, w5, w3
ffffffffea81359c:	13001c63 	sxtb	w3, w3
ffffffffea8135a0:	350000c3 	cbnz	w3, ffffffffea8135b8 <strncmp+0x50>
ffffffffea8135a4:	34000065 	cbz	w5, ffffffffea8135b0 <strncmp+0x48>
	while (count > 0) {
ffffffffea8135a8:	eb04005f 	cmp	x2, x4
ffffffffea8135ac:	54ffff01 	b.ne	ffffffffea81358c <strncmp+0x24>  // b.any
ffffffffea8135b0:	52800000 	mov	w0, #0x0                   	// #0
			break;
		count--;
	}

	return __res;
}
ffffffffea8135b4:	d65f03c0 	ret
ffffffffea8135b8:	2a0303e0 	mov	w0, w3
ffffffffea8135bc:	d65f03c0 	ret

ffffffffea8135c0 <strnlen>:
#include <string.h>
#include <sys/types.h>

size_t
strnlen(char const *s, size_t count)
{
ffffffffea8135c0:	aa0003e3 	mov	x3, x0
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
ffffffffea8135c4:	b4000181 	cbz	x1, ffffffffea8135f4 <strnlen+0x34>
ffffffffea8135c8:	39400002 	ldrb	w2, [x0]
ffffffffea8135cc:	34000142 	cbz	w2, ffffffffea8135f4 <strnlen+0x34>
ffffffffea8135d0:	8b010001 	add	x1, x0, x1
ffffffffea8135d4:	14000003 	b	ffffffffea8135e0 <strnlen+0x20>
ffffffffea8135d8:	39400002 	ldrb	w2, [x0]
ffffffffea8135dc:	34000082 	cbz	w2, ffffffffea8135ec <strnlen+0x2c>
ffffffffea8135e0:	91000400 	add	x0, x0, #0x1
ffffffffea8135e4:	eb01001f 	cmp	x0, x1
ffffffffea8135e8:	54ffff81 	b.ne	ffffffffea8135d8 <strnlen+0x18>  // b.any
ffffffffea8135ec:	cb030000 	sub	x0, x0, x3
		;
	return sc - s;
}
ffffffffea8135f0:	d65f03c0 	ret
	for (sc = s; count-- && *sc != '\0'; ++sc)
ffffffffea8135f4:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea8135f8:	d65f03c0 	ret
ffffffffea8135fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813600 <arm64_syscall>:
 * r0-r1/x0    = return value (r0 only if 32-bit retval)
 * r12/x12     = syscall number, expected to be trashed.
 * syscalls run with interrupts enabled
 */
FUNCTION (arm64_syscall)
	push	x0, x30
ffffffffea813600:	a9bf7be0 	stp	x0, x30, [sp, #-16]!
	ldr	w12, [x0, #(12 << 3)]
ffffffffea813604:	b940600c 	ldr	w12, [x0, #96]

	msr	daifclr, #DAIF_MASK_IAF
ffffffffea813608:	d50347ff 	msr	daifclr, #0x7

	ldr	x14, =nr_syscalls
ffffffffea81360c:	580001ee 	ldr	x14, ffffffffea813648 <arm64_syscall+0x48>
	ldr	x14, [x14]
ffffffffea813610:	f94001ce 	ldr	x14, [x14]
	cmp	x12, x14
ffffffffea813614:	eb0e019f 	cmp	x12, x14
	b.hs	.Lundefined
ffffffffea813618:	54000082 	b.cs	ffffffffea813628 <arm64_syscall+0x28>  // b.hs, b.nlast
	ldr	x14, =syscall_table
ffffffffea81361c:	580001ae 	ldr	x14, ffffffffea813650 <arm64_syscall+0x50>
	ldr	x14, [x14, x12, lsl#3]
ffffffffea813620:	f86c79ce 	ldr	x14, [x14, x12, lsl #3]
	cbnz	x14, .Ldefined
ffffffffea813624:	b500004e 	cbnz	x14, ffffffffea81362c <arm64_syscall+0x2c>
.Lundefined:
	ldr	x14,=sys_undefined
ffffffffea813628:	5800018e 	ldr	x14, ffffffffea813658 <arm64_syscall+0x58>
.Ldefined:
	ldp	x2, x3, [x0, #16]
ffffffffea81362c:	a9410c02 	ldp	x2, x3, [x0, #16]
	ldp	x0, x1, [x0]
ffffffffea813630:	a9400400 	ldp	x0, x1, [x0]
	blr	x14
ffffffffea813634:	d63f01c0 	blr	x14

	msr	daifset, #DAIF_MASK_IAF
ffffffffea813638:	d50347df 	msr	daifset, #0x7

	pop	x1, x30
ffffffffea81363c:	a8c17be1 	ldp	x1, x30, [sp], #16

	str	x0, [x1, 0]
ffffffffea813640:	f9000020 	str	x0, [x1]

	ret
ffffffffea813644:	d65f03c0 	ret
ffffffffea813648:	ea818fd0 	.word	0xea818fd0
ffffffffea81364c:	ffffffff 	.word	0xffffffff
ffffffffea813650:	ea817878 	.word	0xea817878
ffffffffea813654:	ffffffff 	.word	0xffffffff
ffffffffea813658:	ea813660 	.word	0xea813660
ffffffffea81365c:	ffffffff 	.word	0xffffffff

ffffffffea813660 <sys_undefined>:

long sys_undefined(int num)
{
	dprintf(SPEW, "%p invalid syscall %d requested\n", get_current_thread(), num);
	return ERR_NOT_SUPPORTED;
}
ffffffffea813660:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
ffffffffea813664:	d65f03c0 	ret

ffffffffea813668 <arch_copy_to_user>:
#include <arch/asm_macros.h>
#include <err.h>

/* status_t arch_copy_to_user(user_addr_t udest, const void *ksrc, size_t len) */
FUNCTION(arch_copy_to_user)
	cbz	x2, .Larch_copy_to_user_done
ffffffffea813668:	b40000c2 	cbz	x2, ffffffffea813680 <arch_copy_to_user+0x18>
.Larch_copy_to_user_loop:
	ldrb	w9, [x1], #1
ffffffffea81366c:	38401429 	ldrb	w9, [x1], #1

	set_fault_handler	.Larch_copy_to_user_fault
	sttrb	w9, [x0]
ffffffffea813670:	38000809 	sttrb	w9, [x0]

	add	x0, x0, #1
ffffffffea813674:	91000400 	add	x0, x0, #0x1
	subs	x2, x2, #1
ffffffffea813678:	f1000442 	subs	x2, x2, #0x1
	b.hi	.Larch_copy_to_user_loop
ffffffffea81367c:	54ffff88 	b.hi	ffffffffea81366c <arch_copy_to_user+0x4>  // b.pmore
.Larch_copy_to_user_done:
	mov	x0, #0
ffffffffea813680:	d2800000 	mov	x0, #0x0                   	// #0
	ret
ffffffffea813684:	d65f03c0 	ret

ffffffffea813688 <arch_copy_from_user>:

/* status_t arch_copy_from_user(void *kdest, user_addr_t usrc, size_t len) */
FUNCTION(arch_copy_from_user)
	cbz	x2, .Larch_copy_to_user_done
ffffffffea813688:	b4ffffc2 	cbz	x2, ffffffffea813680 <arch_copy_to_user+0x18>
.Larch_copy_from_user_loop:
	set_fault_handler	.Larch_copy_from_user_fault
	ldtrb	w9, [x1]
ffffffffea81368c:	38400829 	ldtrb	w9, [x1]

	add	x1, x1, #1
ffffffffea813690:	91000421 	add	x1, x1, #0x1
	strb	w9, [x0], #1
ffffffffea813694:	38001409 	strb	w9, [x0], #1
	subs	x2, x2, #1
ffffffffea813698:	f1000442 	subs	x2, x2, #0x1
	b.hi	.Larch_copy_from_user_loop
ffffffffea81369c:	54ffff88 	b.hi	ffffffffea81368c <arch_copy_from_user+0x4>  // b.pmore
.Larch_copy_from_user_done:
	mov	x0, #0
ffffffffea8136a0:	d2800000 	mov	x0, #0x0                   	// #0
	ret
ffffffffea8136a4:	d65f03c0 	ret

ffffffffea8136a8 <arch_strlcpy_from_user>:

/* ssize_t arch_strlcpy_from_user(char *kdst, user_addr_t usrc, size_t len) */
FUNCTION(arch_strlcpy_from_user)
	mov	x10, x1
ffffffffea8136a8:	aa0103ea 	mov	x10, x1
.Larch_strlcpy_from_user_loop:
	set_fault_handler	.Larch_strlcpy_from_user_fault
	ldtrb	w9, [x1]
ffffffffea8136ac:	38400829 	ldtrb	w9, [x1]

	cmp	w9, #0
ffffffffea8136b0:	7100013f 	cmp	w9, #0x0
	cinc	x1, x1, ne
ffffffffea8136b4:	9a810421 	cinc	x1, x1, ne  // ne = any

	cbz	x2, .Larch_strlcpy_from_user_dst_full
ffffffffea8136b8:	b4000082 	cbz	x2, ffffffffea8136c8 <arch_strlcpy_from_user+0x20>
	subs	x2, x2, #1
ffffffffea8136bc:	f1000442 	subs	x2, x2, #0x1
	csel	w11, w9, wzr, hi
ffffffffea8136c0:	1a9f812b 	csel	w11, w9, wzr, hi  // hi = pmore
	strb	w11, [x0], #1
ffffffffea8136c4:	3800140b 	strb	w11, [x0], #1
.Larch_strlcpy_from_user_dst_full:
	cbnz	w9, .Larch_strlcpy_from_user_loop
ffffffffea8136c8:	35ffff29 	cbnz	w9, ffffffffea8136ac <arch_strlcpy_from_user+0x4>

	sub	x0, x1, x10
ffffffffea8136cc:	cb0a0020 	sub	x0, x1, x10
	ret
ffffffffea8136d0:	d65f03c0 	ret

.Larch_strlcpy_from_user_fault:
	cbz	x2, .Larch_copy_to_user_fault
ffffffffea8136d4:	b4000082 	cbz	x2, ffffffffea8136e4 <arch_strlcpy_from_user+0x3c>
.Larch_copy_from_user_fault:
	strb	wzr, [x0], #1
ffffffffea8136d8:	3800141f 	strb	wzr, [x0], #1
	subs	x2, x2, #1
ffffffffea8136dc:	f1000442 	subs	x2, x2, #0x1
	b.hi	.Larch_copy_from_user_fault
ffffffffea8136e0:	54ffffc8 	b.hi	ffffffffea8136d8 <arch_strlcpy_from_user+0x30>  // b.pmore
.Larch_copy_to_user_fault:
	mov	x0, #ERR_FAULT
ffffffffea8136e4:	928004e0 	mov	x0, #0xffffffffffffffd8    	// #-40
	ret
ffffffffea8136e8:	d65f03c0 	ret
ffffffffea8136ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8136f0 <uthread_find_va_space_ns>:
{
}


static vaddr_t uthread_find_va_space_ns(uthread_t *ut, size_t size, u_int align)
{
ffffffffea8136f0:	aa0003e9 	mov	x9, x0
	vaddr_t start, end;
	uthread_map_t *mp;

	/* get first suitable address */
	start = ROUNDDOWN(MAX_USR_VA - size, align);
ffffffffea8136f4:	4b0203e2 	neg	w2, w2
ffffffffea8136f8:	d2a04003 	mov	x3, #0x2000000             	// #33554432
ffffffffea8136fc:	cb010063 	sub	x3, x3, x1
	end = start + size;

	mp = list_peek_tail_type (&ut->map_list, uthread_map_t, node);
ffffffffea813700:	91006007 	add	x7, x0, #0x18
	start = ROUNDDOWN(MAX_USR_VA - size, align);
ffffffffea813704:	8a020060 	and	x0, x3, x2
	if (list->prev != list) {
ffffffffea813708:	f9400d24 	ldr	x4, [x9, #24]
	end = start + size;
ffffffffea81370c:	8b000028 	add	x8, x1, x0
	mp = list_peek_tail_type (&ut->map_list, uthread_map_t, node);
ffffffffea813710:	f100009f 	cmp	x4, #0x0
ffffffffea813714:	fa4410e4 	ccmp	x7, x4, #0x4, ne  // ne = any
ffffffffea813718:	540000c1 	b.ne	ffffffffea813730 <uthread_find_va_space_ns+0x40>  // b.any

		/* get prev list item */
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
	}

	if (start < ut->start_stack || start > end) {
ffffffffea81371c:	f9400121 	ldr	x1, [x9]
ffffffffea813720:	eb00003f 	cmp	x1, x0
		return (vaddr_t) NULL;
ffffffffea813724:	fa489002 	ccmp	x0, x8, #0x2, ls  // ls = plast
ffffffffea813728:	9a9f9000 	csel	x0, x0, xzr, ls  // ls = plast
	}
	return start;
}
ffffffffea81372c:	d65f03c0 	ret
	while (mp) {
ffffffffea813730:	f1006086 	subs	x6, x4, #0x18
ffffffffea813734:	54ffff40 	b.eq	ffffffffea81371c <uthread_find_va_space_ns+0x2c>  // b.none
		if (start >= mp->vaddr + mp->size) { /* found gap */
ffffffffea813738:	a97e9483 	ldp	x3, x5, [x4, #-24]
ffffffffea81373c:	8b050065 	add	x5, x3, x5
ffffffffea813740:	eb05001f 	cmp	x0, x5
ffffffffea813744:	54000243 	b.cc	ffffffffea81378c <uthread_find_va_space_ns+0x9c>  // b.lo, b.ul, b.last
ffffffffea813748:	14000015 	b	ffffffffea81379c <uthread_find_va_space_ns+0xac>
		start = MIN(start, ROUNDDOWN((mp->vaddr - size), align));
ffffffffea81374c:	cb010063 	sub	x3, x3, x1
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
ffffffffea813750:	f9400cc4 	ldr	x4, [x6, #24]
		start = MIN(start, ROUNDDOWN((mp->vaddr - size), align));
ffffffffea813754:	8a020063 	and	x3, x3, x2
ffffffffea813758:	eb03001f 	cmp	x0, x3
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
ffffffffea81375c:	d1006086 	sub	x6, x4, #0x18
		start = MIN(start, ROUNDDOWN((mp->vaddr - size), align));
ffffffffea813760:	9a839000 	csel	x0, x0, x3, ls  // ls = plast
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
ffffffffea813764:	f100009f 	cmp	x4, #0x0
		end = start + size;
ffffffffea813768:	8b000028 	add	x8, x1, x0
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
ffffffffea81376c:	fa4410e4 	ccmp	x7, x4, #0x4, ne  // ne = any
ffffffffea813770:	54fffd60 	b.eq	ffffffffea81371c <uthread_find_va_space_ns+0x2c>  // b.none
	while (mp) {
ffffffffea813774:	f100609f 	cmp	x4, #0x18
ffffffffea813778:	54fffd20 	b.eq	ffffffffea81371c <uthread_find_va_space_ns+0x2c>  // b.none
		if (start >= mp->vaddr + mp->size) { /* found gap */
ffffffffea81377c:	a97e9483 	ldp	x3, x5, [x4, #-24]
ffffffffea813780:	8b050065 	add	x5, x3, x5
ffffffffea813784:	eb0000bf 	cmp	x5, x0
ffffffffea813788:	540000a9 	b.ls	ffffffffea81379c <uthread_find_va_space_ns+0xac>  // b.plast
		if (!(mp->flags & UTM_NS_MEM)) {
ffffffffea81378c:	b85f8084 	ldur	w4, [x4, #-8]
ffffffffea813790:	3737fde4 	tbnz	w4, #6, ffffffffea81374c <uthread_find_va_space_ns+0x5c>
		return (vaddr_t) NULL;
ffffffffea813794:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea813798:	d65f03c0 	ret
			if (start >= ut->ns_va_bottom) {
ffffffffea81379c:	f9403121 	ldr	x1, [x9, #96]
ffffffffea8137a0:	eb00003f 	cmp	x1, x0
ffffffffea8137a4:	54fffbc9 	b.ls	ffffffffea81371c <uthread_find_va_space_ns+0x2c>  // b.plast
			if (ROUNDDOWN(start, UT_MAP_ALIGN_1MB) < mp->vaddr + mp->size) {
ffffffffea8137a8:	926cac01 	and	x1, x0, #0xfffffffffff00000
ffffffffea8137ac:	eb05003f 	cmp	x1, x5
ffffffffea8137b0:	54fffb62 	b.cs	ffffffffea81371c <uthread_find_va_space_ns+0x2c>  // b.hs, b.nlast
		return (vaddr_t) NULL;
ffffffffea8137b4:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea8137b8:	17fffff8 	b	ffffffffea813798 <uthread_find_va_space_ns+0xa8>
ffffffffea8137bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8137c0 <uthread_find_va_space_sec>:
static vaddr_t uthread_find_va_space_sec(uthread_t *ut, size_t size, u_int align)
{
	vaddr_t start, end;
	uthread_map_t *mp;

	start = ROUNDUP(ut->start_stack, align);
ffffffffea8137c0:	f9400004 	ldr	x4, [x0]
ffffffffea8137c4:	51000448 	sub	w8, w2, #0x1
	end = start + size;

	/* find first fit */
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8137c8:	f9401006 	ldr	x6, [x0, #32]
	start = ROUNDUP(ut->start_stack, align);
ffffffffea8137cc:	4b0203e2 	neg	w2, w2
ffffffffea8137d0:	8b040104 	add	x4, x8, x4
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8137d4:	d10060c5 	sub	x5, x6, #0x18
	start = ROUNDUP(ut->start_stack, align);
ffffffffea8137d8:	8a020084 	and	x4, x4, x2
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8137dc:	eb05001f 	cmp	x0, x5
	end = start + size;
ffffffffea8137e0:	8b010083 	add	x3, x4, x1
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8137e4:	54000260 	b.eq	ffffffffea813830 <uthread_find_va_space_sec+0x70>  // b.none
		if (end <= mp->vaddr) {
ffffffffea8137e8:	f85e80c6 	ldur	x6, [x6, #-24]
ffffffffea8137ec:	eb06007f 	cmp	x3, x6
ffffffffea8137f0:	540000a8 	b.hi	ffffffffea813804 <uthread_find_va_space_sec+0x44>  // b.pmore
ffffffffea8137f4:	1400000f 	b	ffffffffea813830 <uthread_find_va_space_sec+0x70>
ffffffffea8137f8:	f85e80e6 	ldur	x6, [x7, #-24]
ffffffffea8137fc:	eb0300df 	cmp	x6, x3
ffffffffea813800:	54000182 	b.cs	ffffffffea813830 <uthread_find_va_space_sec+0x70>  // b.hs, b.nlast
			break;
		}
		start = MAX(start, ROUNDUP((mp->vaddr + mp->size), align));
ffffffffea813804:	f94004a3 	ldr	x3, [x5, #8]
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea813808:	f94010a7 	ldr	x7, [x5, #32]
		start = MAX(start, ROUNDUP((mp->vaddr + mp->size), align));
ffffffffea81380c:	8b030103 	add	x3, x8, x3
ffffffffea813810:	8b060063 	add	x3, x3, x6
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea813814:	d10060e5 	sub	x5, x7, #0x18
		start = MAX(start, ROUNDUP((mp->vaddr + mp->size), align));
ffffffffea813818:	8a020063 	and	x3, x3, x2
ffffffffea81381c:	eb03009f 	cmp	x4, x3
ffffffffea813820:	9a832084 	csel	x4, x4, x3, cs  // cs = hs, nlast
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea813824:	eb05001f 	cmp	x0, x5
		end = start + size;
ffffffffea813828:	8b040023 	add	x3, x1, x4
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea81382c:	54fffe61 	b.ne	ffffffffea8137f8 <uthread_find_va_space_sec+0x38>  // b.any
	}

	if (end > ut->ns_va_bottom || start > end) {
ffffffffea813830:	f9403000 	ldr	x0, [x0, #96]
ffffffffea813834:	eb03001f 	cmp	x0, x3
		return (vaddr_t) NULL;
ffffffffea813838:	fa442060 	ccmp	x3, x4, #0x0, cs  // cs = hs, nlast
	}
	return start;
}
ffffffffea81383c:	9a9f2080 	csel	x0, x4, xzr, cs  // cs = hs, nlast
ffffffffea813840:	d65f03c0 	ret
ffffffffea813844:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813848 <uthread_free_maps>:
}

static void uthread_free_maps(uthread_t *ut)
{
	uthread_map_t *mp, *tmp;
	list_for_every_entry_safe(&ut->map_list, mp, tmp,
ffffffffea813848:	f9401001 	ldr	x1, [x0, #32]
ffffffffea81384c:	d1006021 	sub	x1, x1, #0x18
ffffffffea813850:	f9401022 	ldr	x2, [x1, #32]
ffffffffea813854:	eb01001f 	cmp	x0, x1
ffffffffea813858:	540002a0 	b.eq	ffffffffea8138ac <uthread_free_maps+0x64>  // b.none
{
ffffffffea81385c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea813860:	910003fd 	mov	x29, sp
ffffffffea813864:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea813868:	aa0003f4 	mov	x20, x0
ffffffffea81386c:	d1006053 	sub	x19, x2, #0x18
	item->next->prev = item->prev;
ffffffffea813870:	f9400c23 	ldr	x3, [x1, #24]
			uthread_map_t, node) {
		list_delete(&mp->node);
		free(mp);
ffffffffea813874:	aa0103e0 	mov	x0, x1
ffffffffea813878:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea81387c:	f9400c23 	ldr	x3, [x1, #24]
ffffffffea813880:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea813884:	a901fc3f 	stp	xzr, xzr, [x1, #24]
ffffffffea813888:	97fffe04 	bl	ffffffffea813098 <free>
	list_for_every_entry_safe(&ut->map_list, mp, tmp,
ffffffffea81388c:	f9401262 	ldr	x2, [x19, #32]
ffffffffea813890:	aa1303e1 	mov	x1, x19
ffffffffea813894:	eb13029f 	cmp	x20, x19
ffffffffea813898:	d1006053 	sub	x19, x2, #0x18
ffffffffea81389c:	54fffea1 	b.ne	ffffffffea813870 <uthread_free_maps+0x28>  // b.any
	}
}
ffffffffea8138a0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8138a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8138a8:	d65f03c0 	ret
ffffffffea8138ac:	d65f03c0 	ret

ffffffffea8138b0 <uthread_map_alloc>:
{
ffffffffea8138b0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	ASSERT(!(size & (PAGE_SIZE - 1)));
ffffffffea8138b4:	f2402c9f 	tst	x4, #0xfff
{
ffffffffea8138b8:	910003fd 	mov	x29, sp
	ASSERT(!(size & (PAGE_SIZE - 1)));
ffffffffea8138bc:	54000f01 	b.ne	ffffffffea813a9c <uthread_map_alloc+0x1ec>  // b.any
ffffffffea8138c0:	f9000fb4 	str	x20, [x29, #24]
ffffffffea8138c4:	aa0003f4 	mov	x20, x0
ffffffffea8138c8:	a902dfb6 	stp	x22, x23, [x29, #40]
	if (vaddr + size <= vaddr) {
ffffffffea8138cc:	8b020080 	add	x0, x4, x2
ffffffffea8138d0:	aa0403f6 	mov	x22, x4
ffffffffea8138d4:	aa0203f7 	mov	x23, x2
ffffffffea8138d8:	eb02001f 	cmp	x0, x2
ffffffffea8138dc:	54000fc9 	b.ls	ffffffffea813ad4 <uthread_map_alloc+0x224>  // b.plast
ffffffffea8138e0:	f9000bb3 	str	x19, [x29, #16]
ffffffffea8138e4:	f90013b5 	str	x21, [x29, #32]
ffffffffea8138e8:	aa0103f5 	mov	x21, x1
ffffffffea8138ec:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea8138f0:	aa0303f9 	mov	x25, x3
ffffffffea8138f4:	a904efba 	stp	x26, x27, [x29, #72]
ffffffffea8138f8:	2a0503f8 	mov	w24, w5
ffffffffea8138fc:	2a0603fa 	mov	w26, w6
	if (flags & UTM_PHYS_CONTIG) {
ffffffffea813900:	372807d8 	tbnz	w24, #5, ffffffffea8139f8 <uthread_map_alloc+0x148>
ffffffffea813904:	d34cac9b 	ubfx	x27, x4, #12, #32
ffffffffea813908:	91001760 	add	x0, x27, #0x5
ffffffffea81390c:	d37df000 	lsl	x0, x0, #3
	mp = malloc(sizeof(uthread_map_t) + (npages * sizeof(mp->pfn_list[0])));
ffffffffea813910:	97fffdcc 	bl	ffffffffea813040 <malloc>
ffffffffea813914:	aa0003f3 	mov	x19, x0
	if (!mp) {
ffffffffea813918:	b40007a0 	cbz	x0, ffffffffea813a0c <uthread_map_alloc+0x15c>
	mp->size = size;
ffffffffea81391c:	a9005a77 	stp	x23, x22, [x19]
	memcpy(mp->pfn_list, pfn_list, npages*sizeof(paddr_t));
ffffffffea813920:	d37df362 	lsl	x2, x27, #3
	mp->align = align;
ffffffffea813924:	29026a78 	stp	w24, w26, [x19, #16]
	memcpy(mp->pfn_list, pfn_list, npages*sizeof(paddr_t));
ffffffffea813928:	aa1903e1 	mov	x1, x25
ffffffffea81392c:	9100a000 	add	x0, x0, #0x28
ffffffffea813930:	97fffddc 	bl	ffffffffea8130a0 <memcpy>
	if ((mp->flags & UTM_NS_MEM) && (mp->vaddr < ut->ns_va_bottom)) {
ffffffffea813934:	b9401260 	ldr	w0, [x19, #16]
	new_ns = ut->ns_va_bottom;
ffffffffea813938:	f9403284 	ldr	x4, [x20, #96]
	if ((mp->flags & UTM_NS_MEM) && (mp->vaddr < ut->ns_va_bottom)) {
ffffffffea81393c:	363000a0 	tbz	w0, #6, ffffffffea813950 <uthread_map_alloc+0xa0>
ffffffffea813940:	f9400260 	ldr	x0, [x19]
		new_ns = ROUNDDOWN(mp->vaddr, UT_MAP_ALIGN_1MB);
ffffffffea813944:	926cac01 	and	x1, x0, #0xfffffffffff00000
ffffffffea813948:	eb04001f 	cmp	x0, x4
ffffffffea81394c:	9a843024 	csel	x4, x1, x4, cc  // cc = lo, ul, last
	list_for_every_entry(&ut->map_list, mp_lst, uthread_map_t, node) {
ffffffffea813950:	f9401281 	ldr	x1, [x20, #32]
ffffffffea813954:	d1006022 	sub	x2, x1, #0x18
ffffffffea813958:	eb02029f 	cmp	x20, x2
ffffffffea81395c:	540002a0 	b.eq	ffffffffea8139b0 <uthread_map_alloc+0x100>  // b.none
		if (mp_lst->vaddr > mp->vaddr) {
ffffffffea813960:	f85e8020 	ldur	x0, [x1, #-24]
ffffffffea813964:	f9400263 	ldr	x3, [x19]
ffffffffea813968:	eb03001f 	cmp	x0, x3
ffffffffea81396c:	540007e8 	b.hi	ffffffffea813a68 <uthread_map_alloc+0x1b8>  // b.pmore
			if (mp->vaddr < (mp_lst->vaddr + mp_lst->size)) {
ffffffffea813970:	f85f0021 	ldur	x1, [x1, #-16]
ffffffffea813974:	8b010000 	add	x0, x0, x1
ffffffffea813978:	eb03001f 	cmp	x0, x3
ffffffffea81397c:	54000129 	b.ls	ffffffffea8139a0 <uthread_map_alloc+0xf0>  // b.plast
ffffffffea813980:	14000036 	b	ffffffffea813a58 <uthread_map_alloc+0x1a8>
		if (mp_lst->vaddr > mp->vaddr) {
ffffffffea813984:	f85e8020 	ldur	x0, [x1, #-24]
ffffffffea813988:	eb00007f 	cmp	x3, x0
ffffffffea81398c:	540006e3 	b.cc	ffffffffea813a68 <uthread_map_alloc+0x1b8>  // b.lo, b.ul, b.last
			if (mp->vaddr < (mp_lst->vaddr + mp_lst->size)) {
ffffffffea813990:	f85f0021 	ldur	x1, [x1, #-16]
ffffffffea813994:	8b010000 	add	x0, x0, x1
ffffffffea813998:	eb00007f 	cmp	x3, x0
ffffffffea81399c:	540005e3 	b.cc	ffffffffea813a58 <uthread_map_alloc+0x1a8>  // b.lo, b.ul, b.last
	list_for_every_entry(&ut->map_list, mp_lst, uthread_map_t, node) {
ffffffffea8139a0:	f9401041 	ldr	x1, [x2, #32]
ffffffffea8139a4:	d1006022 	sub	x2, x1, #0x18
ffffffffea8139a8:	eb02029f 	cmp	x20, x2
ffffffffea8139ac:	54fffec1 	b.ne	ffffffffea813984 <uthread_map_alloc+0xd4>  // b.any
	item->prev = list->prev;
ffffffffea8139b0:	aa1403e1 	mov	x1, x20
	list_add_tail(&ut->map_list, &mp->node);
ffffffffea8139b4:	91006260 	add	x0, x19, #0x18
ffffffffea8139b8:	f8418c22 	ldr	x2, [x1, #24]!
	item->next = list;
ffffffffea8139bc:	a9018662 	stp	x2, x1, [x19, #24]
	ut->ns_va_bottom = new_ns;
ffffffffea8139c0:	f9003284 	str	x4, [x20, #96]
	list->prev->next = item;
ffffffffea8139c4:	f9000440 	str	x0, [x2, #8]
	list->prev = item;
ffffffffea8139c8:	f9000e80 	str	x0, [x20, #24]
	return NO_ERROR;
ffffffffea8139cc:	52800000 	mov	w0, #0x0                   	// #0
	if (mpp) {
ffffffffea8139d0:	b4000355 	cbz	x21, ffffffffea813a38 <uthread_map_alloc+0x188>
ffffffffea8139d4:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea8139d8:	a944efba 	ldp	x26, x27, [x29, #72]
		*mpp = mp;
ffffffffea8139dc:	f90002b3 	str	x19, [x21]
ffffffffea8139e0:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea8139e4:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea8139e8:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea8139ec:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea8139f0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8139f4:	d65f03c0 	ret
ffffffffea8139f8:	d2800600 	mov	x0, #0x30                  	// #48
ffffffffea8139fc:	d280003b 	mov	x27, #0x1                   	// #1
	mp = malloc(sizeof(uthread_map_t) + (npages * sizeof(mp->pfn_list[0])));
ffffffffea813a00:	97fffd90 	bl	ffffffffea813040 <malloc>
ffffffffea813a04:	aa0003f3 	mov	x19, x0
	if (!mp) {
ffffffffea813a08:	b5fff8a0 	cbnz	x0, ffffffffea81391c <uthread_map_alloc+0x6c>
		err = ERR_NO_MEMORY;
ffffffffea813a0c:	12800080 	mov	w0, #0xfffffffb            	// #-5
	if (mpp) {
ffffffffea813a10:	b4000155 	cbz	x21, ffffffffea813a38 <uthread_map_alloc+0x188>
ffffffffea813a14:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea813a18:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea813a1c:	a944efba 	ldp	x26, x27, [x29, #72]
		*mpp = NULL;
ffffffffea813a20:	f90002bf 	str	xzr, [x21]
ffffffffea813a24:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea813a28:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea813a2c:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea813a30:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea813a34:	d65f03c0 	ret
ffffffffea813a38:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea813a3c:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea813a40:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea813a44:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea813a48:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea813a4c:	a944efba 	ldp	x26, x27, [x29, #72]
ffffffffea813a50:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea813a54:	d65f03c0 	ret
	free(mp);
ffffffffea813a58:	aa1303e0 	mov	x0, x19
ffffffffea813a5c:	97fffd8f 	bl	ffffffffea813098 <free>
ffffffffea813a60:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea813a64:	17ffffeb 	b	ffffffffea813a10 <uthread_map_alloc+0x160>
			if((mp->vaddr + mp->size) > mp_lst->vaddr) {
ffffffffea813a68:	f9400661 	ldr	x1, [x19, #8]
ffffffffea813a6c:	8b010063 	add	x3, x3, x1
ffffffffea813a70:	eb00007f 	cmp	x3, x0
ffffffffea813a74:	54ffff28 	b.hi	ffffffffea813a58 <uthread_map_alloc+0x1a8>  // b.pmore
	item->prev = list->prev;
ffffffffea813a78:	aa0203e1 	mov	x1, x2
			list_add_before(&mp_lst->node, &mp->node);
ffffffffea813a7c:	91006260 	add	x0, x19, #0x18
ffffffffea813a80:	f8418c23 	ldr	x3, [x1, #24]!
	item->next = list;
ffffffffea813a84:	a9018663 	stp	x3, x1, [x19, #24]
	list->prev->next = item;
ffffffffea813a88:	f9400c41 	ldr	x1, [x2, #24]
			ut->ns_va_bottom = new_ns;
ffffffffea813a8c:	f9003284 	str	x4, [x20, #96]
ffffffffea813a90:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea813a94:	f9000c40 	str	x0, [x2, #24]
ffffffffea813a98:	17ffffcd 	b	ffffffffea8139cc <uthread_map_alloc+0x11c>
	ASSERT(!(size & (PAGE_SIZE - 1)));
ffffffffea813a9c:	90000024 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea813aa0:	90000022 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea813aa4:	d0000001 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea813aa8:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea813aac:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea813ab0:	91284084 	add	x4, x4, #0xa10
ffffffffea813ab4:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea813ab8:	52801463 	mov	w3, #0xa3                  	// #163
ffffffffea813abc:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea813ac0:	9128c042 	add	x2, x2, #0xa30
ffffffffea813ac4:	91330021 	add	x1, x1, #0xcc0
ffffffffea813ac8:	aa1e03e0 	mov	x0, x30
ffffffffea813acc:	f9002bbb 	str	x27, [x29, #80]
ffffffffea813ad0:	97fff7ce 	bl	ffffffffea811a08 <_panic>
		return ERR_INVALID_ARGS;
ffffffffea813ad4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea813ad8:	17ffffd4 	b	ffffffffea813a28 <uthread_map_alloc+0x178>
ffffffffea813adc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813ae0 <uthread_init>:
	list->prev = list->next = list;
ffffffffea813ae0:	b0000241 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea813ae4:	913f4020 	add	x0, x1, #0xfd0
ffffffffea813ae8:	f907e820 	str	x0, [x1, #4048]
ffffffffea813aec:	f9000400 	str	x0, [x0, #8]
#endif

static void uthread_init(uint level)
{
	list_initialize(&uthread_list);
	arch_uthread_init();
ffffffffea813af0:	14000242 	b	ffffffffea8143f8 <arch_uthread_init>
ffffffffea813af4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813af8 <uthread_start>:
	if (!ut || !ut->thread) {
ffffffffea813af8:	b4000080 	cbz	x0, ffffffffea813b08 <uthread_start+0x10>
ffffffffea813afc:	f9403c00 	ldr	x0, [x0, #120]
ffffffffea813b00:	b4000040 	cbz	x0, ffffffffea813b08 <uthread_start+0x10>
	return thread_resume(ut->thread);
ffffffffea813b04:	17ffc9f1 	b	ffffffffea8062c8 <thread_resume>
}
ffffffffea813b08:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea813b0c:	d65f03c0 	ret

ffffffffea813b10 <uthread_exit>:
{
ffffffffea813b10:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea813b14:	910003fd 	mov	x29, sp
ffffffffea813b18:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea813b1c:	2a0003f4 	mov	w20, w0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea813b20:	d538d080 	mrs	x0, tpidr_el1
#define THREAD_UNLOCK(state) spin_unlock_irqrestore(&thread_lock, state)

/* thread local storage */
static inline __ALWAYS_INLINE uintptr_t tls_get(uint entry)
{
	return get_current_thread()->tls[entry];
ffffffffea813b24:	f9415813 	ldr	x19, [x0, #688]
	if (ut) {
ffffffffea813b28:	b4000173 	cbz	x19, ffffffffea813b54 <uthread_exit+0x44>
		uthread_free_maps(ut);
ffffffffea813b2c:	aa1303e0 	mov	x0, x19
ffffffffea813b30:	97ffff46 	bl	ffffffffea813848 <uthread_free_maps>
		free(ut->stack);
ffffffffea813b34:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea813b38:	97fffd58 	bl	ffffffffea813098 <free>
		arch_uthread_free(ut);
ffffffffea813b3c:	aa1303e0 	mov	x0, x19
ffffffffea813b40:	94000268 	bl	ffffffffea8144e0 <arch_uthread_free>
		free(ut);
ffffffffea813b44:	aa1303e0 	mov	x0, x19
ffffffffea813b48:	97fffd54 	bl	ffffffffea813098 <free>
	thread_exit(retcode);
ffffffffea813b4c:	2a1403e0 	mov	w0, w20
ffffffffea813b50:	97ffcce2 	bl	ffffffffea806ed8 <thread_exit>
ffffffffea813b54:	d538d083 	mrs	x3, tpidr_el1
		TRACEF("WARNING: unexpected call on kernel thread %s!",
ffffffffea813b58:	90000021 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea813b5c:	90000020 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea813b60:	910ae063 	add	x3, x3, #0x2b8
ffffffffea813b64:	52802f42 	mov	w2, #0x17a                 	// #378
ffffffffea813b68:	91266021 	add	x1, x1, #0x998
ffffffffea813b6c:	91276000 	add	x0, x0, #0x9d8
ffffffffea813b70:	97fffd0c 	bl	ffffffffea812fa0 <_printf>
ffffffffea813b74:	17fffff6 	b	ffffffffea813b4c <uthread_exit+0x3c>

ffffffffea813b78 <uthread_context_switch>:
	arch_uthread_context_switch(old_ut, new_ut);
ffffffffea813b78:	f9415800 	ldr	x0, [x0, #688]
ffffffffea813b7c:	f9415821 	ldr	x1, [x1, #688]
ffffffffea813b80:	14000230 	b	ffffffffea814440 <arch_uthread_context_switch>
ffffffffea813b84:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813b88 <uthread_map>:
{
ffffffffea813b88:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea813b8c:	910003fd 	mov	x29, sp
ffffffffea813b90:	a9025bf5 	stp	x21, x22, [sp, #32]
	mutex_acquire(&ut->mmap_lock);
ffffffffea813b94:	9100a016 	add	x22, x0, #0x28
{
ffffffffea813b98:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea813b9c:	2a0403f5 	mov	w21, w4
ffffffffea813ba0:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea813ba4:	aa0003f3 	mov	x19, x0
ffffffffea813ba8:	aa0103f7 	mov	x23, x1
ffffffffea813bac:	aa0203f8 	mov	x24, x2
ffffffffea813bb0:	f90023f9 	str	x25, [sp, #64]
ffffffffea813bb4:	aa0303f4 	mov	x20, x3
ffffffffea813bb8:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea813bbc:	aa1603e0 	mov	x0, x22
ffffffffea813bc0:	2a0503f9 	mov	w25, w5
ffffffffea813bc4:	97ffc749 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	if (!ut || !pfn_list || !vaddrp) {
ffffffffea813bc8:	f100031f 	cmp	x24, #0x0
	uthread_map_t *mp = NULL;
ffffffffea813bcc:	f9002fbf 	str	xzr, [x29, #88]
	if (!ut || !pfn_list || !vaddrp) {
ffffffffea813bd0:	fa401ae4 	ccmp	x23, #0x0, #0x4, ne  // ne = any
ffffffffea813bd4:	fa401a64 	ccmp	x19, #0x0, #0x4, ne  // ne = any
ffffffffea813bd8:	54000500 	b.eq	ffffffffea813c78 <uthread_map+0xf0>  // b.none
	if((size & (PAGE_SIZE - 1))) {
ffffffffea813bdc:	f2402e9f 	tst	x20, #0xfff
ffffffffea813be0:	54000501 	b.ne	ffffffffea813c80 <uthread_map+0xf8>  // b.any
	if(!(flags & UTM_FIXED)) {
ffffffffea813be4:	36400315 	tbz	w21, #8, ffffffffea813c44 <uthread_map+0xbc>
ffffffffea813be8:	f94002e2 	ldr	x2, [x23]
	err = uthread_map_alloc(ut, &mp, *vaddrp, pfn_list, size, flags, align);
ffffffffea813bec:	aa1403e4 	mov	x4, x20
ffffffffea813bf0:	2a1903e6 	mov	w6, w25
ffffffffea813bf4:	2a1503e5 	mov	w5, w21
ffffffffea813bf8:	aa1803e3 	mov	x3, x24
ffffffffea813bfc:	910163a1 	add	x1, x29, #0x58
ffffffffea813c00:	aa1303e0 	mov	x0, x19
ffffffffea813c04:	97ffff2b 	bl	ffffffffea8138b0 <uthread_map_alloc>
ffffffffea813c08:	2a0003f4 	mov	w20, w0
	if(err) {
ffffffffea813c0c:	350000a0 	cbnz	w0, ffffffffea813c20 <uthread_map+0x98>
	err = arch_uthread_map(ut, mp);
ffffffffea813c10:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea813c14:	aa1303e0 	mov	x0, x19
ffffffffea813c18:	94000256 	bl	ffffffffea814570 <arch_uthread_map>
ffffffffea813c1c:	2a0003f4 	mov	w20, w0
	mutex_release(&ut->mmap_lock);
ffffffffea813c20:	aa1603e0 	mov	x0, x22
ffffffffea813c24:	97ffc75d 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea813c28:	2a1403e0 	mov	w0, w20
ffffffffea813c2c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea813c30:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea813c34:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea813c38:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea813c3c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea813c40:	d65f03c0 	ret
		return uthread_find_va_space_ns(ut, size, align);
ffffffffea813c44:	2a1903e2 	mov	w2, w25
ffffffffea813c48:	aa1403e1 	mov	x1, x20
ffffffffea813c4c:	aa1303e0 	mov	x0, x19
	if (flags & UTM_NS_MEM) {
ffffffffea813c50:	373000f5 	tbnz	w21, #6, ffffffffea813c6c <uthread_map+0xe4>
		return uthread_find_va_space_sec(ut, size, align);
ffffffffea813c54:	97fffedb 	bl	ffffffffea8137c0 <uthread_find_va_space_sec>
ffffffffea813c58:	aa0003e2 	mov	x2, x0
		*vaddrp = uthread_find_va_space(ut, size, flags, align);
ffffffffea813c5c:	f90002e2 	str	x2, [x23]
		if (!(*vaddrp)) {
ffffffffea813c60:	b5fffc62 	cbnz	x2, ffffffffea813bec <uthread_map+0x64>
			err = ERR_NO_MEMORY;
ffffffffea813c64:	12800094 	mov	w20, #0xfffffffb            	// #-5
ffffffffea813c68:	17ffffee 	b	ffffffffea813c20 <uthread_map+0x98>
		return uthread_find_va_space_ns(ut, size, align);
ffffffffea813c6c:	97fffea1 	bl	ffffffffea8136f0 <uthread_find_va_space_ns>
ffffffffea813c70:	aa0003e2 	mov	x2, x0
ffffffffea813c74:	17fffffa 	b	ffffffffea813c5c <uthread_map+0xd4>
		err = ERR_INVALID_ARGS;
ffffffffea813c78:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea813c7c:	17ffffe9 	b	ffffffffea813c20 <uthread_map+0x98>
		err = ERR_NOT_VALID;
ffffffffea813c80:	128000d4 	mov	w20, #0xfffffff9            	// #-7
ffffffffea813c84:	17ffffe7 	b	ffffffffea813c20 <uthread_map+0x98>

ffffffffea813c88 <uthread_create>:
{
ffffffffea813c88:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea813c8c:	910003fd 	mov	x29, sp
ffffffffea813c90:	f9000bf3 	str	x19, [sp, #16]
ffffffffea813c94:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea813c98:	aa0303f7 	mov	x23, x3
ffffffffea813c9c:	a903e7f8 	stp	x24, x25, [sp, #56]
ffffffffea813ca0:	aa0403f6 	mov	x22, x4
ffffffffea813ca4:	a904effa 	stp	x26, x27, [sp, #72]
ffffffffea813ca8:	aa0003f8 	mov	x24, x0
ffffffffea813cac:	aa0103fb 	mov	x27, x1
ffffffffea813cb0:	2a0203f9 	mov	w25, w2
ffffffffea813cb4:	aa0503fa 	mov	x26, x5
	ut = (uthread_t *)calloc(1, sizeof(uthread_t));
ffffffffea813cb8:	d2801501 	mov	x1, #0xa8                  	// #168
ffffffffea813cbc:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea813cc0:	97fffce6 	bl	ffffffffea813058 <calloc>
ffffffffea813cc4:	aa0003f3 	mov	x19, x0
	if (!ut) {
ffffffffea813cc8:	b40009a0 	cbz	x0, ffffffffea813dfc <uthread_create+0x174>
ffffffffea813ccc:	a901d7b4 	stp	x20, x21, [x29, #24]
	list_initialize(&ut->map_list);
ffffffffea813cd0:	91006000 	add	x0, x0, #0x18
ffffffffea813cd4:	f9002fbc 	str	x28, [x29, #88]
ffffffffea813cd8:	a9018260 	stp	x0, x0, [x19, #24]
	mutex_init(&ut->mmap_lock);
ffffffffea813cdc:	9100a260 	add	x0, x19, #0x28
ffffffffea813ce0:	97ffc6f6 	bl	ffffffffea8058b8 <mutex_init>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea813ce4:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea813ce8:	37380980 	tbnz	w0, #7, ffffffffea813e18 <uthread_create+0x190>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea813cec:	d50342df 	msr	daifset, #0x2
	next_utid++;
ffffffffea813cf0:	b0000255 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
    arch_spin_lock(lock);
ffffffffea813cf4:	b0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea813cf8:	913f829c 	add	x28, x20, #0xfe0
ffffffffea813cfc:	aa1c03e0 	mov	x0, x28
ffffffffea813d00:	97ffbb17 	bl	ffffffffea80295c <arch_spin_lock>
ffffffffea813d04:	b94fcea1 	ldr	w1, [x21, #4044]
    arch_spin_unlock(lock);
ffffffffea813d08:	aa1c03e0 	mov	x0, x28
ffffffffea813d0c:	11000421 	add	w1, w1, #0x1
ffffffffea813d10:	b90fcea1 	str	w1, [x21, #4044]
ffffffffea813d14:	97ffbb1a 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea813d18:	d50342ff 	msr	daifclr, #0x2
	ut->id = uthread_alloc_utid();
ffffffffea813d1c:	b94fcea0 	ldr	w0, [x21, #4044]
	ut->stack = memalign(PAGE_SIZE, stack_size);
ffffffffea813d20:	aa1603e1 	mov	x1, x22
	ut->entry = entry;
ffffffffea813d24:	f900067b 	str	x27, [x19, #8]
	ut->id = uthread_alloc_utid();
ffffffffea813d28:	b9006a60 	str	w0, [x19, #104]
	ut->ns_va_bottom = MAX_USR_VA;
ffffffffea813d2c:	d2a04000 	mov	x0, #0x2000000             	// #33554432
ffffffffea813d30:	f9003260 	str	x0, [x19, #96]
	ut->stack = memalign(PAGE_SIZE, stack_size);
ffffffffea813d34:	d2820000 	mov	x0, #0x1000                	// #4096
	ut->private_data = private_data;
ffffffffea813d38:	f9004a7a 	str	x26, [x19, #144]
	ut->stack = memalign(PAGE_SIZE, stack_size);
ffffffffea813d3c:	97fffcc3 	bl	ffffffffea813048 <memalign>
ffffffffea813d40:	f9000a60 	str	x0, [x19, #16]
	if(!ut->stack) {
ffffffffea813d44:	b4000b00 	cbz	x0, ffffffffea813ea4 <uthread_create+0x21c>
	stack_bot = start_stack - stack_size;
ffffffffea813d48:	cb1602e1 	sub	x1, x23, x22
ffffffffea813d4c:	f90033a1 	str	x1, [x29, #96]
ffffffffea813d50:	97fff3ae 	bl	ffffffffea810c08 <kvaddr_to_paddr>
ffffffffea813d54:	9101c3a2 	add	x2, x29, #0x70
	return uthread_map(ut, vaddrp, &paddr, size, flags, align);
ffffffffea813d58:	52820005 	mov	w5, #0x1000                	// #4096
ffffffffea813d5c:	52802664 	mov	w4, #0x133                 	// #307
ffffffffea813d60:	aa1603e3 	mov	x3, x22
ffffffffea813d64:	910183a1 	add	x1, x29, #0x60
ffffffffea813d68:	f81f8c40 	str	x0, [x2, #-8]!
ffffffffea813d6c:	aa1303e0 	mov	x0, x19
ffffffffea813d70:	97ffff86 	bl	ffffffffea813b88 <uthread_map>
	if (err) {
ffffffffea813d74:	35000940 	cbnz	w0, ffffffffea813e9c <uthread_create+0x214>
	ut->start_stack = start_stack;
ffffffffea813d78:	f9000277 	str	x23, [x19]
	ut->thread = thread_create(name,
ffffffffea813d7c:	b0000001 	adrp	x1, ffffffffea814000 <uthread_pmm_alloc_and_map+0x128>
ffffffffea813d80:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea813d84:	2a1903e3 	mov	w3, w25
ffffffffea813d88:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea813d8c:	91100021 	add	x1, x1, #0x400
ffffffffea813d90:	aa1803e0 	mov	x0, x24
ffffffffea813d94:	97ffc8ed 	bl	ffffffffea806148 <thread_create>
ffffffffea813d98:	f9003e60 	str	x0, [x19, #120]
	if (!ut->thread) {
ffffffffea813d9c:	b40007c0 	cbz	x0, ffffffffea813e94 <uthread_create+0x20c>
	err = arch_uthread_create(ut);
ffffffffea813da0:	aa1303e0 	mov	x0, x19
ffffffffea813da4:	940001c9 	bl	ffffffffea8144c8 <arch_uthread_create>
	if (err) {
ffffffffea813da8:	35000760 	cbnz	w0, ffffffffea813e94 <uthread_create+0x20c>
	ut->thread->tls[TLS_ENTRY_UTHREAD] = (uintptr_t) ut;
ffffffffea813dac:	f9403e60 	ldr	x0, [x19, #120]
ffffffffea813db0:	f9015813 	str	x19, [x0, #688]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea813db4:	d53b4220 	mrs	x0, daif
ffffffffea813db8:	91020275 	add	x21, x19, #0x80
ffffffffea813dbc:	37380440 	tbnz	w0, #7, ffffffffea813e44 <uthread_create+0x1bc>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea813dc0:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea813dc4:	913f8294 	add	x20, x20, #0xfe0
ffffffffea813dc8:	aa1403e0 	mov	x0, x20
ffffffffea813dcc:	97ffbae4 	bl	ffffffffea80295c <arch_spin_lock>
	item->next = list->next;
ffffffffea813dd0:	b0000241 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea813dd4:	913f4021 	add	x1, x1, #0xfd0
    arch_spin_unlock(lock);
ffffffffea813dd8:	aa1403e0 	mov	x0, x20
ffffffffea813ddc:	f9400422 	ldr	x2, [x1, #8]
ffffffffea813de0:	a9080a61 	stp	x1, x2, [x19, #128]
	list->next->prev = item;
ffffffffea813de4:	f9000055 	str	x21, [x2]
	list->next = item;
ffffffffea813de8:	f9000435 	str	x21, [x1, #8]
ffffffffea813dec:	97ffbae4 	bl	ffffffffea80297c <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea813df0:	d50342ff 	msr	daifclr, #0x2
ffffffffea813df4:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea813df8:	f9402fbc 	ldr	x28, [x29, #88]
}
ffffffffea813dfc:	aa1303e0 	mov	x0, x19
ffffffffea813e00:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea813e04:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea813e08:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea813e0c:	a944effa 	ldp	x26, x27, [sp, #72]
ffffffffea813e10:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea813e14:	d65f03c0 	ret
	next_utid++;
ffffffffea813e18:	b0000255 	adrp	x21, ffffffffea85c000 <idle_threads+0xeb0>
    arch_spin_lock(lock);
ffffffffea813e1c:	b0000254 	adrp	x20, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea813e20:	913f829c 	add	x28, x20, #0xfe0
ffffffffea813e24:	aa1c03e0 	mov	x0, x28
ffffffffea813e28:	97ffbacd 	bl	ffffffffea80295c <arch_spin_lock>
ffffffffea813e2c:	b94fcea1 	ldr	w1, [x21, #4044]
    arch_spin_unlock(lock);
ffffffffea813e30:	aa1c03e0 	mov	x0, x28
ffffffffea813e34:	11000421 	add	w1, w1, #0x1
ffffffffea813e38:	b90fcea1 	str	w1, [x21, #4044]
ffffffffea813e3c:	97ffbad0 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea813e40:	17ffffb7 	b	ffffffffea813d1c <uthread_create+0x94>
    arch_spin_lock(lock);
ffffffffea813e44:	913f8294 	add	x20, x20, #0xfe0
ffffffffea813e48:	aa1403e0 	mov	x0, x20
ffffffffea813e4c:	97ffbac4 	bl	ffffffffea80295c <arch_spin_lock>
	item->next = list->next;
ffffffffea813e50:	b0000241 	adrp	x1, ffffffffea85c000 <idle_threads+0xeb0>
ffffffffea813e54:	913f4021 	add	x1, x1, #0xfd0
    arch_spin_unlock(lock);
ffffffffea813e58:	aa1403e0 	mov	x0, x20
ffffffffea813e5c:	f9400422 	ldr	x2, [x1, #8]
ffffffffea813e60:	a9080a61 	stp	x1, x2, [x19, #128]
	list->next->prev = item;
ffffffffea813e64:	f9000055 	str	x21, [x2]
	list->next = item;
ffffffffea813e68:	f9000435 	str	x21, [x1, #8]
ffffffffea813e6c:	97ffbac4 	bl	ffffffffea80297c <arch_spin_unlock>
ffffffffea813e70:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea813e74:	a941d7b4 	ldp	x20, x21, [x29, #24]
}
ffffffffea813e78:	aa1303e0 	mov	x0, x19
ffffffffea813e7c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea813e80:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea813e84:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea813e88:	a944effa 	ldp	x26, x27, [sp, #72]
ffffffffea813e8c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea813e90:	d65f03c0 	ret
	uthread_free_maps(ut);
ffffffffea813e94:	aa1303e0 	mov	x0, x19
ffffffffea813e98:	97fffe6c 	bl	ffffffffea813848 <uthread_free_maps>
	free(ut->stack);
ffffffffea813e9c:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea813ea0:	97fffc7e 	bl	ffffffffea813098 <free>
	free(ut);
ffffffffea813ea4:	aa1303e0 	mov	x0, x19
	return NULL;
ffffffffea813ea8:	d2800013 	mov	x19, #0x0                   	// #0
	free(ut);
ffffffffea813eac:	97fffc7b 	bl	ffffffffea813098 <free>
ffffffffea813eb0:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea813eb4:	a941d7b4 	ldp	x20, x21, [x29, #24]
}
ffffffffea813eb8:	aa1303e0 	mov	x0, x19
ffffffffea813ebc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea813ec0:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea813ec4:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea813ec8:	a944effa 	ldp	x26, x27, [sp, #72]
ffffffffea813ecc:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea813ed0:	d65f03c0 	ret
ffffffffea813ed4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813ed8 <uthread_pmm_alloc_and_map>:
{
ffffffffea813ed8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea813edc:	910003fd 	mov	x29, sp
ffffffffea813ee0:	a90153f3 	stp	x19, x20, [sp, #16]
	struct list_node page_list = LIST_INITIAL_VALUE(page_list);
ffffffffea813ee4:	910183b4 	add	x20, x29, #0x60
ffffffffea813ee8:	a90653b4 	stp	x20, x20, [x29, #96]
	if (vaddr == NULL)
ffffffffea813eec:	b4000da1 	cbz	x1, ffffffffea8140a0 <uthread_pmm_alloc_and_map+0x1c8>
ffffffffea813ef0:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea813ef4:	aa0103f6 	mov	x22, x1
ffffffffea813ef8:	113ffc42 	add	w2, w2, #0xfff
ffffffffea813efc:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea813f00:	f90027ba 	str	x26, [x29, #72]
ffffffffea813f04:	12144c57 	and	w23, w2, #0xfffff000
	*vaddr = NULL;
ffffffffea813f08:	f90002df 	str	xzr, [x22]
ffffffffea813f0c:	2a0403f9 	mov	w25, w4
ffffffffea813f10:	530c7ef3 	lsr	w19, w23, #12
ffffffffea813f14:	aa0003f8 	mov	x24, x0
	allocated = pmm_alloc_pages(count, &page_list);
ffffffffea813f18:	aa1403e1 	mov	x1, x20
ffffffffea813f1c:	2a1303e0 	mov	w0, w19
ffffffffea813f20:	2a0303fa 	mov	w26, w3
ffffffffea813f24:	97fff1cb 	bl	ffffffffea810650 <pmm_alloc_pages>
	if (allocated != count) {
ffffffffea813f28:	6b00027f 	cmp	w19, w0
ffffffffea813f2c:	54000240 	b.eq	ffffffffea813f74 <uthread_pmm_alloc_and_map+0x9c>  // b.none
		dprintf(ALWAYS, "%s: Failed to allocate enough pages (allocated %d, needed %d)\n",
ffffffffea813f30:	90000024 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea813f34:	90000021 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea813f38:	2a1303e3 	mov	w3, w19
ffffffffea813f3c:	2a0003e2 	mov	w2, w0
ffffffffea813f40:	9126a021 	add	x1, x1, #0x9a8
ffffffffea813f44:	91294080 	add	x0, x4, #0xa50
	status_t sts = -1;
ffffffffea813f48:	12800013 	mov	w19, #0xffffffff            	// #-1
		dprintf(ALWAYS, "%s: Failed to allocate enough pages (allocated %d, needed %d)\n",
ffffffffea813f4c:	97fff631 	bl	ffffffffea811810 <_dprintf>
	pmm_free(&page_list);
ffffffffea813f50:	aa1403e0 	mov	x0, x20
ffffffffea813f54:	97fff261 	bl	ffffffffea8108d8 <pmm_free>
	return sts;
ffffffffea813f58:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea813f5c:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea813f60:	f94027ba 	ldr	x26, [x29, #72]
}
ffffffffea813f64:	2a1303e0 	mov	w0, w19
ffffffffea813f68:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea813f6c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea813f70:	d65f03c0 	ret
	pfn_list = malloc(count * sizeof(*pfn_list));
ffffffffea813f74:	d37d4e73 	ubfiz	x19, x19, #3, #20
ffffffffea813f78:	f9002bbb 	str	x27, [x29, #80]
ffffffffea813f7c:	aa1303e0 	mov	x0, x19
ffffffffea813f80:	97fffc30 	bl	ffffffffea813040 <malloc>
ffffffffea813f84:	aa0003fb 	mov	x27, x0
	if (pfn_list == NULL) {
ffffffffea813f88:	b40007a0 	cbz	x0, ffffffffea81407c <uthread_pmm_alloc_and_map+0x1a4>
	list_for_every_entry(&page_list, page, vm_page_t, node) {
ffffffffea813f8c:	f94037b3 	ldr	x19, [x29, #104]
ffffffffea813f90:	eb14027f 	cmp	x19, x20
ffffffffea813f94:	540001e0 	b.eq	ffffffffea813fd0 <uthread_pmm_alloc_and_map+0xf8>  // b.none
ffffffffea813f98:	f90013b5 	str	x21, [x29, #32]
ffffffffea813f9c:	f9002fbc 	str	x28, [x29, #88]
	i = 0;
ffffffffea813fa0:	5280001c 	mov	w28, #0x0                   	// #0
ffffffffea813fa4:	d503201f 	nop
		pfn_list[i] = page_to_address(page);
ffffffffea813fa8:	2a1c03f5 	mov	w21, w28
ffffffffea813fac:	aa1303e0 	mov	x0, x19
ffffffffea813fb0:	97fff130 	bl	ffffffffea810470 <page_to_address>
	list_for_every_entry(&page_list, page, vm_page_t, node) {
ffffffffea813fb4:	f9400673 	ldr	x19, [x19, #8]
		pfn_list[i] = page_to_address(page);
ffffffffea813fb8:	1100079c 	add	w28, w28, #0x1
ffffffffea813fbc:	f8357b60 	str	x0, [x27, x21, lsl #3]
	list_for_every_entry(&page_list, page, vm_page_t, node) {
ffffffffea813fc0:	eb14027f 	cmp	x19, x20
ffffffffea813fc4:	54ffff21 	b.ne	ffffffffea813fa8 <uthread_pmm_alloc_and_map+0xd0>  // b.any
ffffffffea813fc8:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea813fcc:	f9402fbc 	ldr	x28, [x29, #88]
	if (flags & MMAP_FLAG_DEVICE_MEM)
ffffffffea813fd0:	360801da 	tbz	w26, #1, ffffffffea814008 <uthread_pmm_alloc_and_map+0x130>
	sts = uthread_map(ut, vaddr, pfn_list, alloc_size,
ffffffffea813fd4:	2a1903e5 	mov	w5, w25
ffffffffea813fd8:	52804064 	mov	w4, #0x203                 	// #515
ffffffffea813fdc:	aa1703e3 	mov	x3, x23
ffffffffea813fe0:	aa1b03e2 	mov	x2, x27
ffffffffea813fe4:	aa1603e1 	mov	x1, x22
ffffffffea813fe8:	aa1803e0 	mov	x0, x24
ffffffffea813fec:	97fffee7 	bl	ffffffffea813b88 <uthread_map>
ffffffffea813ff0:	2a0003f3 	mov	w19, w0
	if (sts) {
ffffffffea813ff4:	35000300 	cbnz	w0, ffffffffea814054 <uthread_pmm_alloc_and_map+0x17c>
		arch_clean_cache_range(*vaddr, alloc_size);
ffffffffea813ff8:	f94002c0 	ldr	x0, [x22]
ffffffffea813ffc:	aa1703e1 	mov	x1, x23
ffffffffea814000:	97ffba61 	bl	ffffffffea802984 <arch_clean_cache_range>
ffffffffea814004:	1400000a 	b	ffffffffea81402c <uthread_pmm_alloc_and_map+0x154>
	sts = uthread_map(ut, vaddr, pfn_list, alloc_size,
ffffffffea814008:	2a1903e5 	mov	w5, w25
ffffffffea81400c:	52800064 	mov	w4, #0x3                   	// #3
ffffffffea814010:	aa1703e3 	mov	x3, x23
ffffffffea814014:	aa1b03e2 	mov	x2, x27
ffffffffea814018:	aa1603e1 	mov	x1, x22
ffffffffea81401c:	aa1803e0 	mov	x0, x24
ffffffffea814020:	97fffeda 	bl	ffffffffea813b88 <uthread_map>
ffffffffea814024:	2a0003f3 	mov	w19, w0
	if (sts) {
ffffffffea814028:	35000160 	cbnz	w0, ffffffffea814054 <uthread_pmm_alloc_and_map+0x17c>
	free(pfn_list);
ffffffffea81402c:	aa1b03e0 	mov	x0, x27
	return 0;
ffffffffea814030:	52800013 	mov	w19, #0x0                   	// #0
	free(pfn_list);
ffffffffea814034:	97fffc19 	bl	ffffffffea813098 <free>
}
ffffffffea814038:	2a1303e0 	mov	w0, w19
	return 0;
ffffffffea81403c:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea814040:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea814044:	a944efba 	ldp	x26, x27, [x29, #72]
}
ffffffffea814048:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81404c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea814050:	d65f03c0 	ret
		dprintf(ALWAYS, "%s: Mapping failed with Error: %x\n",
ffffffffea814054:	2a1303e2 	mov	w2, w19
ffffffffea814058:	f0000001 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea81405c:	9126a021 	add	x1, x1, #0x9a8
ffffffffea814060:	f0000000 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea814064:	912b2000 	add	x0, x0, #0xac8
ffffffffea814068:	97fff5ea 	bl	ffffffffea811810 <_dprintf>
	free(pfn_list);
ffffffffea81406c:	aa1b03e0 	mov	x0, x27
ffffffffea814070:	97fffc0a 	bl	ffffffffea813098 <free>
ffffffffea814074:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea814078:	17ffffb6 	b	ffffffffea813f50 <uthread_pmm_alloc_and_map+0x78>
		dprintf(ALWAYS, "%s: malloc failed. Unable to allocate pfn (size %lu)\n",
ffffffffea81407c:	aa1303e2 	mov	x2, x19
ffffffffea814080:	f0000001 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea814084:	f0000000 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea814088:	9126a021 	add	x1, x1, #0x9a8
ffffffffea81408c:	912a4000 	add	x0, x0, #0xa90
	status_t sts = -1;
ffffffffea814090:	12800013 	mov	w19, #0xffffffff            	// #-1
		dprintf(ALWAYS, "%s: malloc failed. Unable to allocate pfn (size %lu)\n",
ffffffffea814094:	97fff5df 	bl	ffffffffea811810 <_dprintf>
		goto err_free_pages;
ffffffffea814098:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea81409c:	17ffffad 	b	ffffffffea813f50 <uthread_pmm_alloc_and_map+0x78>
		return ERR_INVALID_ARGS;
ffffffffea8140a0:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea8140a4:	17ffffb0 	b	ffffffffea813f64 <uthread_pmm_alloc_and_map+0x8c>

ffffffffea8140a8 <uthread_unmap>:
{
ffffffffea8140a8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea8140ac:	910003fd 	mov	x29, sp
ffffffffea8140b0:	a9025bf5 	stp	x21, x22, [sp, #32]
	mutex_acquire(&ut->mmap_lock);
ffffffffea8140b4:	9100a016 	add	x22, x0, #0x28
{
ffffffffea8140b8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8140bc:	aa0003f5 	mov	x21, x0
ffffffffea8140c0:	aa0103f4 	mov	x20, x1
ffffffffea8140c4:	aa0203f3 	mov	x19, x2
ffffffffea8140c8:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8140cc:	aa1603e0 	mov	x0, x22
ffffffffea8140d0:	f9001bf7 	str	x23, [sp, #48]
ffffffffea8140d4:	97ffc605 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	if (!ut || !vaddr) {
ffffffffea8140d8:	f10002bf 	cmp	x21, #0x0
ffffffffea8140dc:	fa401a84 	ccmp	x20, #0x0, #0x4, ne  // ne = any
ffffffffea8140e0:	54000b20 	b.eq	ffffffffea814244 <uthread_unmap+0x19c>  // b.none
	if (vaddr + size < vaddr) {
ffffffffea8140e4:	8b130282 	add	x2, x20, x19
ffffffffea8140e8:	eb02029f 	cmp	x20, x2
ffffffffea8140ec:	54000228 	b.hi	ffffffffea814130 <uthread_unmap+0x88>  // b.pmore
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8140f0:	f94012b3 	ldr	x19, [x21, #32]
ffffffffea8140f4:	d1006273 	sub	x19, x19, #0x18
ffffffffea8140f8:	eb1302bf 	cmp	x21, x19
ffffffffea8140fc:	540001a0 	b.eq	ffffffffea814130 <uthread_unmap+0x88>  // b.none
		if ((mp->vaddr <= vaddr) &&
ffffffffea814100:	f9400260 	ldr	x0, [x19]
ffffffffea814104:	eb00029f 	cmp	x20, x0
ffffffffea814108:	540000c3 	b.cc	ffffffffea814120 <uthread_unmap+0x78>  // b.lo, b.ul, b.last
		    (vaddr < mp->vaddr + mp->size) &&
ffffffffea81410c:	f9400661 	ldr	x1, [x19, #8]
ffffffffea814110:	8b010000 	add	x0, x0, x1
ffffffffea814114:	eb00029f 	cmp	x20, x0
ffffffffea814118:	fa403042 	ccmp	x2, x0, #0x2, cc  // cc = lo, ul, last
ffffffffea81411c:	540001c9 	b.ls	ffffffffea814154 <uthread_unmap+0xac>  // b.plast
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea814120:	f9401273 	ldr	x19, [x19, #32]
ffffffffea814124:	d1006273 	sub	x19, x19, #0x18
ffffffffea814128:	eb1302bf 	cmp	x21, x19
ffffffffea81412c:	54fffea1 	b.ne	ffffffffea814100 <uthread_unmap+0x58>  // b.any
		err = ERR_NOT_FOUND;
ffffffffea814130:	12800037 	mov	w23, #0xfffffffe            	// #-2
	mutex_release(&ut->mmap_lock);
ffffffffea814134:	aa1603e0 	mov	x0, x22
ffffffffea814138:	97ffc618 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea81413c:	2a1703e0 	mov	w0, w23
ffffffffea814140:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea814144:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814148:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea81414c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea814150:	d65f03c0 	ret
	err = arch_uthread_unmap(ut, mp);
ffffffffea814154:	aa1303e1 	mov	x1, x19
ffffffffea814158:	aa1503e0 	mov	x0, x21
ffffffffea81415c:	94000197 	bl	ffffffffea8147b8 <arch_uthread_unmap>
ffffffffea814160:	2a0003f7 	mov	w23, w0
	if (err) {
ffffffffea814164:	35fffe80 	cbnz	w0, ffffffffea814134 <uthread_unmap+0x8c>
	if (mp->flags & MMAP_FLAG_DEVICE_MEM) {
ffffffffea814168:	b9401262 	ldr	w2, [x19, #16]
ffffffffea81416c:	36080242 	tbz	w2, #1, ffffffffea8141b4 <uthread_unmap+0x10c>
		for (i = 0; i < (mp->size / PAGE_SIZE); i++) {
ffffffffea814170:	f9400660 	ldr	x0, [x19, #8]
ffffffffea814174:	eb4033ff 	negs	xzr, x0, lsr #12
ffffffffea814178:	540001e0 	b.eq	ffffffffea8141b4 <uthread_unmap+0x10c>  // b.none
ffffffffea81417c:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea814180:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea814184:	d503201f 	nop
			vm_page_t *page = address_to_page(mp->pfn_list[i]);
ffffffffea814188:	8b000e60 	add	x0, x19, x0, lsl #3
		for (i = 0; i < (mp->size / PAGE_SIZE); i++) {
ffffffffea81418c:	11000694 	add	w20, w20, #0x1
			vm_page_t *page = address_to_page(mp->pfn_list[i]);
ffffffffea814190:	f9401400 	ldr	x0, [x0, #40]
ffffffffea814194:	97fff0d3 	bl	ffffffffea8104e0 <address_to_page>
			if (page) {
ffffffffea814198:	b4000040 	cbz	x0, ffffffffea8141a0 <uthread_unmap+0xf8>
				pmm_free_page(page);
ffffffffea81419c:	97fff20b 	bl	ffffffffea8109c8 <pmm_free_page>
		for (i = 0; i < (mp->size / PAGE_SIZE); i++) {
ffffffffea8141a0:	f9400661 	ldr	x1, [x19, #8]
ffffffffea8141a4:	2a1403e0 	mov	w0, w20
ffffffffea8141a8:	eb41301f 	cmp	x0, x1, lsr #12
ffffffffea8141ac:	54fffee3 	b.cc	ffffffffea814188 <uthread_unmap+0xe0>  // b.lo, b.ul, b.last
ffffffffea8141b0:	b9401262 	ldr	w2, [x19, #16]
ffffffffea8141b4:	a9418660 	ldp	x0, x1, [x19, #24]
	if (mp->flags & UTM_NS_MEM) {
ffffffffea8141b8:	36300142 	tbz	w2, #6, ffffffffea8141e0 <uthread_unmap+0x138>
		item = list_prev_type(&ut->map_list, &mp->node,
ffffffffea8141bc:	910062a2 	add	x2, x21, #0x18
ffffffffea8141c0:	f100001f 	cmp	x0, #0x0
ffffffffea8141c4:	fa401044 	ccmp	x2, x0, #0x4, ne  // ne = any
ffffffffea8141c8:	54000281 	b.ne	ffffffffea814218 <uthread_unmap+0x170>  // b.any
			item = list_next_type(&ut->map_list, &mp->node,
ffffffffea8141cc:	f100003f 	cmp	x1, #0x0
ffffffffea8141d0:	fa411044 	ccmp	x2, x1, #0x4, ne  // ne = any
ffffffffea8141d4:	540002c1 	b.ne	ffffffffea81422c <uthread_unmap+0x184>  // b.any
				ut->ns_va_bottom = MAX_USR_VA;
ffffffffea8141d8:	d2a04002 	mov	x2, #0x2000000             	// #33554432
ffffffffea8141dc:	f90032a2 	str	x2, [x21, #96]
	item->next->prev = item->prev;
ffffffffea8141e0:	f9000020 	str	x0, [x1]
	free(mp);
ffffffffea8141e4:	aa1303e0 	mov	x0, x19
	item->prev->next = item->next;
ffffffffea8141e8:	f9400e62 	ldr	x2, [x19, #24]
ffffffffea8141ec:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea8141f0:	a901fe7f 	stp	xzr, xzr, [x19, #24]
ffffffffea8141f4:	97fffba9 	bl	ffffffffea813098 <free>
	mutex_release(&ut->mmap_lock);
ffffffffea8141f8:	aa1603e0 	mov	x0, x22
ffffffffea8141fc:	97ffc5e7 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea814200:	2a1703e0 	mov	w0, w23
ffffffffea814204:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea814208:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81420c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea814210:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea814214:	d65f03c0 	ret
		if (!item || (item->flags & UTM_NS_MEM) == 0) {
ffffffffea814218:	f100601f 	cmp	x0, #0x18
ffffffffea81421c:	54fffd80 	b.eq	ffffffffea8141cc <uthread_unmap+0x124>  // b.none
ffffffffea814220:	b85f8003 	ldur	w3, [x0, #-8]
ffffffffea814224:	3637fd43 	tbz	w3, #6, ffffffffea8141cc <uthread_unmap+0x124>
ffffffffea814228:	17ffffee 	b	ffffffffea8141e0 <uthread_unmap+0x138>
			if (item) {
ffffffffea81422c:	f100603f 	cmp	x1, #0x18
ffffffffea814230:	54fffd40 	b.eq	ffffffffea8141d8 <uthread_unmap+0x130>  // b.none
				ut->ns_va_bottom = ROUNDDOWN(item->vaddr,
ffffffffea814234:	f85e8022 	ldur	x2, [x1, #-24]
ffffffffea814238:	926cac42 	and	x2, x2, #0xfffffffffff00000
ffffffffea81423c:	f90032a2 	str	x2, [x21, #96]
ffffffffea814240:	17ffffe8 	b	ffffffffea8141e0 <uthread_unmap+0x138>
		err = ERR_INVALID_ARGS;
ffffffffea814244:	128000f7 	mov	w23, #0xfffffff8            	// #-8
ffffffffea814248:	17ffffbb 	b	ffffffffea814134 <uthread_unmap+0x8c>
ffffffffea81424c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814250 <uthread_is_valid_range>:
{
ffffffffea814250:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea814254:	910003fd 	mov	x29, sp
ffffffffea814258:	a9025bf5 	stp	x21, x22, [sp, #32]
	mutex_acquire(&ut->mmap_lock);
ffffffffea81425c:	9100a016 	add	x22, x0, #0x28
{
ffffffffea814260:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea814264:	aa0003f5 	mov	x21, x0
ffffffffea814268:	aa0103f4 	mov	x20, x1
ffffffffea81426c:	aa0203f3 	mov	x19, x2
ffffffffea814270:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea814274:	aa1603e0 	mov	x0, x22
ffffffffea814278:	97ffc59c 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	if (vaddr + size < vaddr) {
ffffffffea81427c:	8b130282 	add	x2, x20, x19
ffffffffea814280:	eb02029f 	cmp	x20, x2
ffffffffea814284:	54000288 	b.hi	ffffffffea8142d4 <uthread_is_valid_range+0x84>  // b.pmore
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea814288:	f94012a1 	ldr	x1, [x21, #32]
ffffffffea81428c:	d1006021 	sub	x1, x1, #0x18
ffffffffea814290:	eb0102bf 	cmp	x21, x1
ffffffffea814294:	54000200 	b.eq	ffffffffea8142d4 <uthread_is_valid_range+0x84>  // b.none
		if ((mp->vaddr <= vaddr) &&
ffffffffea814298:	f9400020 	ldr	x0, [x1]
ffffffffea81429c:	eb00029f 	cmp	x20, x0
ffffffffea8142a0:	54000123 	b.cc	ffffffffea8142c4 <uthread_is_valid_range+0x74>  // b.lo, b.ul, b.last
		    (vaddr < mp->vaddr + mp->size) &&
ffffffffea8142a4:	f9400423 	ldr	x3, [x1, #8]
ffffffffea8142a8:	8b030000 	add	x0, x0, x3
ffffffffea8142ac:	eb00005f 	cmp	x2, x0
ffffffffea8142b0:	1a9f87e3 	cset	w3, ls  // ls = plast
		if ((mp->vaddr <= vaddr) &&
ffffffffea8142b4:	eb00029f 	cmp	x20, x0
ffffffffea8142b8:	1a9f27f3 	cset	w19, cc  // cc = lo, ul, last
		    (vaddr < mp->vaddr + mp->size) &&
ffffffffea8142bc:	6a130073 	ands	w19, w3, w19
ffffffffea8142c0:	540000c1 	b.ne	ffffffffea8142d8 <uthread_is_valid_range+0x88>  // b.any
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8142c4:	f9401021 	ldr	x1, [x1, #32]
ffffffffea8142c8:	d1006021 	sub	x1, x1, #0x18
ffffffffea8142cc:	eb0102bf 	cmp	x21, x1
ffffffffea8142d0:	54fffe41 	b.ne	ffffffffea814298 <uthread_is_valid_range+0x48>  // b.any
ffffffffea8142d4:	52800013 	mov	w19, #0x0                   	// #0
	mutex_release(&ut->mmap_lock);
ffffffffea8142d8:	aa1603e0 	mov	x0, x22
ffffffffea8142dc:	97ffc5af 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea8142e0:	2a1303e0 	mov	w0, w19
ffffffffea8142e4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8142e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8142ec:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8142f0:	d65f03c0 	ret
ffffffffea8142f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8142f8 <uthread_virt_to_phys>:
{
ffffffffea8142f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8142fc:	910003fd 	mov	x29, sp
ffffffffea814300:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea814304:	aa0003f5 	mov	x21, x0
	mutex_acquire(&ut->mmap_lock);
ffffffffea814308:	9100a016 	add	x22, x0, #0x28
{
ffffffffea81430c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea814310:	aa1603e0 	mov	x0, x22
ffffffffea814314:	aa0103f3 	mov	x19, x1
ffffffffea814318:	aa0203f4 	mov	x20, x2
ffffffffea81431c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea814320:	97ffc572 	bl	ffffffffea8058e8 <mutex_acquire_timeout>
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea814324:	f94012a0 	ldr	x0, [x21, #32]
ffffffffea814328:	d1006000 	sub	x0, x0, #0x18
ffffffffea81432c:	eb0002bf 	cmp	x21, x0
ffffffffea814330:	540001a0 	b.eq	ffffffffea814364 <uthread_virt_to_phys+0x6c>  // b.none
ffffffffea814334:	d503201f 	nop
		if ((mp->vaddr <= vaddr) &&
ffffffffea814338:	f9400001 	ldr	x1, [x0]
ffffffffea81433c:	eb01027f 	cmp	x19, x1
ffffffffea814340:	540000a3 	b.cc	ffffffffea814354 <uthread_virt_to_phys+0x5c>  // b.lo, b.ul, b.last
		    (vaddr < mp->vaddr + mp->size) &&
ffffffffea814344:	f9400403 	ldr	x3, [x0, #8]
ffffffffea814348:	8b030023 	add	x3, x1, x3
		if ((mp->vaddr <= vaddr) &&
ffffffffea81434c:	eb03027f 	cmp	x19, x3
ffffffffea814350:	540001a3 	b.cc	ffffffffea814384 <uthread_virt_to_phys+0x8c>  // b.lo, b.ul, b.last
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea814354:	f9401000 	ldr	x0, [x0, #32]
ffffffffea814358:	d1006000 	sub	x0, x0, #0x18
ffffffffea81435c:	eb0002bf 	cmp	x21, x0
ffffffffea814360:	54fffec1 	b.ne	ffffffffea814338 <uthread_virt_to_phys+0x40>  // b.any
		err = ERR_INVALID_ARGS;
ffffffffea814364:	128000f5 	mov	w21, #0xfffffff8            	// #-8
	mutex_release(&ut->mmap_lock);
ffffffffea814368:	aa1603e0 	mov	x0, x22
ffffffffea81436c:	97ffc58b 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea814370:	2a1503e0 	mov	w0, w21
ffffffffea814374:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814378:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea81437c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea814380:	d65f03c0 	ret
	if (mp->flags & UTM_PHYS_CONTIG) {
ffffffffea814384:	b9401002 	ldr	w2, [x0, #16]
ffffffffea814388:	37280202 	tbnz	w2, #5, ffffffffea8143c8 <uthread_virt_to_phys+0xd0>
		uint32_t pg = (vaddr - mp->vaddr) / PAGE_SIZE;
ffffffffea81438c:	cb010261 	sub	x1, x19, x1
		*paddr = mp->pfn_list[pg] + offset;
ffffffffea814390:	92402e73 	and	x19, x19, #0xfff
	err = NO_ERROR;
ffffffffea814394:	52800015 	mov	w21, #0x0                   	// #0
		*paddr = mp->pfn_list[pg] + offset;
ffffffffea814398:	d34cac21 	ubfx	x1, x1, #12, #32
ffffffffea81439c:	8b010c00 	add	x0, x0, x1, lsl #3
ffffffffea8143a0:	f9401400 	ldr	x0, [x0, #40]
ffffffffea8143a4:	8b130013 	add	x19, x0, x19
ffffffffea8143a8:	f9000293 	str	x19, [x20]
	mutex_release(&ut->mmap_lock);
ffffffffea8143ac:	aa1603e0 	mov	x0, x22
ffffffffea8143b0:	97ffc57a 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea8143b4:	2a1503e0 	mov	w0, w21
ffffffffea8143b8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8143bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8143c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8143c4:	d65f03c0 	ret
		*paddr = mp->pfn_list[0] + (vaddr - mp->vaddr);
ffffffffea8143c8:	f9401400 	ldr	x0, [x0, #40]
	err = NO_ERROR;
ffffffffea8143cc:	52800015 	mov	w21, #0x0                   	// #0
		*paddr = mp->pfn_list[0] + (vaddr - mp->vaddr);
ffffffffea8143d0:	cb010001 	sub	x1, x0, x1
	mutex_release(&ut->mmap_lock);
ffffffffea8143d4:	aa1603e0 	mov	x0, x22
		*paddr = mp->pfn_list[0] + (vaddr - mp->vaddr);
ffffffffea8143d8:	8b130033 	add	x19, x1, x19
ffffffffea8143dc:	f9000293 	str	x19, [x20]
	mutex_release(&ut->mmap_lock);
ffffffffea8143e0:	97ffc56e 	bl	ffffffffea805998 <mutex_release>
}
ffffffffea8143e4:	2a1503e0 	mov	w0, w21
ffffffffea8143e8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8143ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8143f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8143f4:	d65f03c0 	ret

ffffffffea8143f8 <arch_uthread_init>:

#define USER_PAGE_MASK	(USER_PAGE_SIZE - 1)

void arch_uthread_init(void)
{
}
ffffffffea8143f8:	d65f03c0 	ret
ffffffffea8143fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814400 <arch_uthread_startup>:
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea814400:	d538d080 	mrs	x0, tpidr_el1

void arch_uthread_startup(void)
{
	struct uthread *ut = (struct uthread *) tls_get(TLS_ENTRY_UTHREAD);
ffffffffea814404:	f9415800 	ldr	x0, [x0, #688]
	register uint64_t sp_usr asm("x2") = ROUNDDOWN(ut->start_stack, 8);
ffffffffea814408:	a9400c02 	ldp	x2, x3, [x0]
ffffffffea81440c:	927df042 	and	x2, x2, #0xfffffffffffffff8
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea814410:	d50342df 	msr	daifset, #0x2
	register uint64_t entry asm("x3") = ut->entry;

	arch_disable_ints();
	__asm__ volatile(
ffffffffea814414:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea814418:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea81441c:	aa0203ed 	mov	x13, x2
ffffffffea814420:	aa0303ee 	mov	x14, x3
ffffffffea814424:	d2800209 	mov	x9, #0x10                  	// #16
ffffffffea814428:	d5184009 	msr	spsr_el1, x9
ffffffffea81442c:	d5184023 	msr	elr_el1, x3
ffffffffea814430:	d69f03e0 	eret
ffffffffea814434:	d503379f 	dsb	nsh
ffffffffea814438:	d5033fdf 	isb
		"isb\n"
		:
		: [stack]"r" (sp_usr), [entry]"r" (entry)
		: "x0", "x1", "memory"
	);
}
ffffffffea81443c:	d65f03c0 	ret

ffffffffea814440 <arch_uthread_context_switch>:

void arch_uthread_context_switch(struct uthread *old_ut, struct uthread *new_ut)
{
	paddr_t pgd;

	if (old_ut && !new_ut) {
ffffffffea814440:	f100001f 	cmp	x0, #0x0
ffffffffea814444:	fa401820 	ccmp	x1, #0x0, #0x0, ne  // ne = any
ffffffffea814448:	540000e1 	b.ne	ffffffffea814464 <arch_uthread_context_switch+0x24>  // b.any
		ARM64_WRITE_SYSREG(tcr_el1, MMU_TCR_FLAGS_KERNEL);
ffffffffea81444c:	d286b4e0 	mov	x0, #0x35a7                	// #13735
ffffffffea814450:	f2b6a460 	movk	x0, #0xb523, lsl #16
ffffffffea814454:	f2c00040 	movk	x0, #0x2, lsl #32
ffffffffea814458:	d5182040 	msr	tcr_el1, x0
ffffffffea81445c:	d5033fdf 	isb
ffffffffea814460:	d65f03c0 	ret
	}

	if (new_ut) {
ffffffffea814464:	b4000301 	cbz	x1, ffffffffea8144c4 <arch_uthread_context_switch+0x84>
{
ffffffffea814468:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea81446c:	910003fd 	mov	x29, sp
ffffffffea814470:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea814474:	aa0003f4 	mov	x20, x0
ffffffffea814478:	f9403820 	ldr	x0, [x1, #112]
ffffffffea81447c:	aa0103f3 	mov	x19, x1
ffffffffea814480:	97fff1e2 	bl	ffffffffea810c08 <kvaddr_to_paddr>
		pgd = vaddr_to_paddr(new_ut->page_table);
		ARM64_WRITE_SYSREG(ttbr0_el1, (paddr_t)new_ut->arch.asid << 48 | pgd);
ffffffffea814484:	b9409a61 	ldr	w1, [x19, #152]
ffffffffea814488:	aa01c000 	orr	x0, x0, x1, lsl #48
ffffffffea81448c:	d5182000 	msr	ttbr0_el1, x0
ffffffffea814490:	d5033fdf 	isb
		if (!old_ut)
ffffffffea814494:	b4000094 	cbz	x20, ffffffffea8144a4 <arch_uthread_context_switch+0x64>
			ARM64_WRITE_SYSREG(tcr_el1, MMU_TCR_FLAGS_USER);
	}
}
ffffffffea814498:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81449c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8144a0:	d65f03c0 	ret
			ARM64_WRITE_SYSREG(tcr_el1, MMU_TCR_FLAGS_USER);
ffffffffea8144a4:	d286a4e0 	mov	x0, #0x3527                	// #13607
ffffffffea8144a8:	f2b6a460 	movk	x0, #0xb523, lsl #16
ffffffffea8144ac:	f2c00040 	movk	x0, #0x2, lsl #32
ffffffffea8144b0:	d5182040 	msr	tcr_el1, x0
ffffffffea8144b4:	d5033fdf 	isb
}
ffffffffea8144b8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8144bc:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8144c0:	d65f03c0 	ret
ffffffffea8144c4:	d65f03c0 	ret

ffffffffea8144c8 <arch_uthread_create>:

status_t arch_uthread_create(struct uthread *ut)
{
ffffffffea8144c8:	aa0003e1 	mov	x1, x0

	ut->arch.asid = ut->id;
	ut->arch.uthread = ut;

	return err;
}
ffffffffea8144cc:	52800000 	mov	w0, #0x0                   	// #0
	ut->arch.asid = ut->id;
ffffffffea8144d0:	b9406822 	ldr	w2, [x1, #104]
ffffffffea8144d4:	b9009822 	str	w2, [x1, #152]
	ut->arch.uthread = ut;
ffffffffea8144d8:	f9005021 	str	x1, [x1, #160]
}
ffffffffea8144dc:	d65f03c0 	ret

ffffffffea8144e0 <arch_uthread_free>:

void arch_uthread_free(struct uthread *ut)
{
ffffffffea8144e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	arm64_mmu_unmap(0, 1UL << MMU_USER_SIZE_SHIFT,
ffffffffea8144e4:	52800185 	mov	w5, #0xc                   	// #12
ffffffffea8144e8:	528002a4 	mov	w4, #0x15                  	// #21
ffffffffea8144ec:	52800323 	mov	w3, #0x19                  	// #25
{
ffffffffea8144f0:	910003fd 	mov	x29, sp
ffffffffea8144f4:	f9000bf3 	str	x19, [sp, #16]
ffffffffea8144f8:	aa0003f3 	mov	x19, x0
	arm64_mmu_unmap(0, 1UL << MMU_USER_SIZE_SHIFT,
ffffffffea8144fc:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea814500:	d2a04001 	mov	x1, #0x2000000             	// #33554432
ffffffffea814504:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea814508:	b9409a67 	ldr	w7, [x19, #152]
ffffffffea81450c:	f9403a66 	ldr	x6, [x19, #112]
ffffffffea814510:	97ffbd90 	bl	ffffffffea803b50 <arm64_mmu_unmap>
	                0, MMU_USER_SIZE_SHIFT,
	                MMU_USER_TOP_SHIFT, MMU_USER_PAGE_SIZE_SHIFT,
	                ut->page_table, ut->arch.asid);

	free(ut->page_table);
ffffffffea814514:	f9403a60 	ldr	x0, [x19, #112]
}
ffffffffea814518:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea81451c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(ut->page_table);
ffffffffea814520:	17fffade 	b	ffffffffea813098 <free>
ffffffffea814524:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814528 <arm64_uthread_allocate_page_table>:

status_t arm64_uthread_allocate_page_table(struct uthread *ut)
{
ffffffffea814528:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	size_t page_table_size;

	page_table_size = MMU_USER_PAGE_TABLE_ENTRIES_TOP * sizeof(pte_t);

	ut->page_table = memalign(page_table_size, page_table_size);
ffffffffea81452c:	d2801001 	mov	x1, #0x80                  	// #128
{
ffffffffea814530:	910003fd 	mov	x29, sp
ffffffffea814534:	f9000bf3 	str	x19, [sp, #16]
ffffffffea814538:	aa0003f3 	mov	x19, x0
	ut->page_table = memalign(page_table_size, page_table_size);
ffffffffea81453c:	aa0103e0 	mov	x0, x1
ffffffffea814540:	97fffac2 	bl	ffffffffea813048 <memalign>
ffffffffea814544:	f9003a60 	str	x0, [x19, #112]
	if (!ut->page_table) {
ffffffffea814548:	b4000100 	cbz	x0, ffffffffea814568 <arm64_uthread_allocate_page_table+0x40>
		return ERR_NO_MEMORY;
	}
	memset(ut->page_table, 0, page_table_size);
ffffffffea81454c:	d2801002 	mov	x2, #0x80                  	// #128
ffffffffea814550:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea814554:	97fffb8f 	bl	ffffffffea813390 <memset>

	LTRACEF("id %d, user page table %p, size %ld\n",
	        ut->id, ut->page_table, page_table_size);

	return NO_ERROR;
ffffffffea814558:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea81455c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea814560:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea814564:	d65f03c0 	ret
		return ERR_NO_MEMORY;
ffffffffea814568:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea81456c:	17fffffc 	b	ffffffffea81455c <arm64_uthread_allocate_page_table+0x34>

ffffffffea814570 <arch_uthread_map>:

status_t arch_uthread_map(struct uthread *ut, struct uthread_map *mp)
{
ffffffffea814570:	d101c3ff 	sub	sp, sp, #0x70
ffffffffea814574:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea814578:	910043fd 	add	x29, sp, #0x10
ffffffffea81457c:	f9001ff6 	str	x22, [sp, #56]
ffffffffea814580:	aa0103f6 	mov	x22, x1
	paddr_t pg, pte_attr;
	size_t entry_size;
	status_t err = NO_ERROR;

	if (!ut->page_table) {
ffffffffea814584:	f9403801 	ldr	x1, [x0, #112]
{
ffffffffea814588:	a902d7f4 	stp	x20, x21, [sp, #40]
ffffffffea81458c:	aa0003f5 	mov	x21, x0
ffffffffea814590:	f90033fb 	str	x27, [sp, #96]
ffffffffea814594:	aa1e03f4 	mov	x20, x30
	if (!ut->page_table) {
ffffffffea814598:	b4000de1 	cbz	x1, ffffffffea814754 <arch_uthread_map+0x1e4>
ffffffffea81459c:	f9000bb3 	str	x19, [x29, #16]
ffffffffea8145a0:	f90027ba 	str	x26, [x29, #72]
		if (err) {
			return err;
		}
	}

	ASSERT(!(mp->size & USER_PAGE_MASK));
ffffffffea8145a4:	f94006d3 	ldr	x19, [x22, #8]
ffffffffea8145a8:	f2402e7a 	ands	x26, x19, #0xfff
ffffffffea8145ac:	54000dc1 	b.ne	ffffffffea814764 <arch_uthread_map+0x1f4>  // b.any

	pte_attr = MMU_PTE_ATTR_NON_GLOBAL | MMU_PTE_ATTR_AF;

	pte_attr |= (mp->flags & UTM_NS_MEM) ? MMU_PTE_ATTR_NON_SECURE : 0;
ffffffffea8145b0:	b94012c1 	ldr	w1, [x22, #16]

	pte_attr |= (mp->flags & UTM_W) ? MMU_PTE_ATTR_AP_P_RW_U_RW :
ffffffffea8145b4:	d2801802 	mov	x2, #0xc0                  	// #192
ffffffffea8145b8:	f90023b9 	str	x25, [x29, #64]
ffffffffea8145bc:	d2800819 	mov	x25, #0x40                  	// #64
	pte_attr |= (mp->flags & UTM_NS_MEM) ? MMU_PTE_ATTR_NON_SECURE : 0;
ffffffffea8145c0:	53017c20 	lsr	w0, w1, #1
	pte_attr |= (mp->flags & UTM_W) ? MMU_PTE_ATTR_AP_P_RW_U_RW :
ffffffffea8145c4:	f27f003f 	tst	x1, #0x2
	pte_attr |= (mp->flags & UTM_NS_MEM) ? MMU_PTE_ATTR_NON_SECURE : 0;
ffffffffea8145c8:	121b0000 	and	w0, w0, #0x20
	pte_attr |= (mp->flags & UTM_W) ? MMU_PTE_ATTR_AP_P_RW_U_RW :
ffffffffea8145cc:	9a821339 	csel	x25, x25, x2, ne  // ne = any
	pte_attr |= (mp->flags & UTM_NS_MEM) ? MMU_PTE_ATTR_NON_SECURE : 0;
ffffffffea8145d0:	32160400 	orr	w0, w0, #0xc00
	pte_attr |= (mp->flags & UTM_W) ? MMU_PTE_ATTR_AP_P_RW_U_RW :
ffffffffea8145d4:	aa000339 	orr	x25, x25, x0
	 * is not speculatively prefeched as an instruction,
	 * these mappings should always be tagged as execute-never.
	 *
	 * The code block below always asserts this
	 */
	if (mp->flags & UTM_IO) {
ffffffffea8145d8:	36380841 	tbz	w1, #7, ffffffffea8146e0 <arch_uthread_map+0x170>
		pte_attr |= MMU_PTE_ATTR_STRONGLY_ORDERED;
		/* Explictly check that IO mem is not tagged as executable */
		ASSERT(!(mp->flags & UTM_X));
ffffffffea8145dc:	37100da1 	tbnz	w1, #2, ffffffffea814790 <arch_uthread_map+0x220>

	/*
	 * Mark execute-never unless explicitly flagged as UTM_X.
	 * Mark NS memory as execute-never always.
	 */
	if ( !(mp->flags & UTM_X) || (mp->flags & UTM_NS_MEM) )
ffffffffea8145e0:	52800880 	mov	w0, #0x44                  	// #68
ffffffffea8145e4:	0a000020 	and	w0, w1, w0
	    pte_attr |= (MMU_PTE_ATTR_UXN | MMU_PTE_ATTR_PXN);
ffffffffea8145e8:	7100101f 	cmp	w0, #0x4
ffffffffea8145ec:	b24b0720 	orr	x0, x25, #0x60000000000000
ffffffffea8145f0:	9a991019 	csel	x25, x0, x25, ne  // ne = any

	entry_size = (mp->flags & UTM_PHYS_CONTIG) ? mp->size : USER_PAGE_SIZE;
ffffffffea8145f4:	37280a61 	tbnz	w1, #5, ffffffffea814740 <arch_uthread_map+0x1d0>
	for (pg = 0; pg < (mp->size / entry_size); pg++) {
ffffffffea8145f8:	f13ffe7f 	cmp	x19, #0xfff
ffffffffea8145fc:	540008e9 	b.ls	ffffffffea814718 <arch_uthread_map+0x1a8>  // b.plast
ffffffffea814600:	a90363b7 	stp	x23, x24, [x29, #48]
	entry_size = (mp->flags & UTM_PHYS_CONTIG) ? mp->size : USER_PAGE_SIZE;
ffffffffea814604:	d2820013 	mov	x19, #0x1000                	// #4096
ffffffffea814608:	9100a2d8 	add	x24, x22, #0x28
ffffffffea81460c:	d2800017 	mov	x23, #0x0                   	// #0
ffffffffea814610:	d2800014 	mov	x20, #0x0                   	// #0
ffffffffea814614:	14000008 	b	ffffffffea814634 <arch_uthread_map+0xc4>
	for (pg = 0; pg < (mp->size / entry_size); pg++) {
ffffffffea814618:	f94006c0 	ldr	x0, [x22, #8]
ffffffffea81461c:	91000694 	add	x20, x20, #0x1
ffffffffea814620:	8b1302f7 	add	x23, x23, x19
ffffffffea814624:	91002318 	add	x24, x24, #0x8
ffffffffea814628:	9ad30800 	udiv	x0, x0, x19
ffffffffea81462c:	eb14001f 	cmp	x0, x20
ffffffffea814630:	54000729 	b.ls	ffffffffea814714 <arch_uthread_map+0x1a4>  // b.plast
		err = arm64_mmu_map(mp->vaddr + pg * entry_size,
ffffffffea814634:	f9400301 	ldr	x1, [x24]
ffffffffea814638:	52800187 	mov	w7, #0xc                   	// #12
ffffffffea81463c:	b9409aa2 	ldr	w2, [x21, #152]
ffffffffea814640:	528002a6 	mov	w6, #0x15                  	// #21
ffffffffea814644:	f9403aa3 	ldr	x3, [x21, #112]
ffffffffea814648:	52800325 	mov	w5, #0x19                  	// #25
ffffffffea81464c:	f94002c0 	ldr	x0, [x22]
ffffffffea814650:	d2800004 	mov	x4, #0x0                   	// #0
ffffffffea814654:	f90003e3 	str	x3, [sp]
ffffffffea814658:	aa1903e3 	mov	x3, x25
ffffffffea81465c:	b9000be2 	str	w2, [sp, #8]
ffffffffea814660:	8b0002e0 	add	x0, x23, x0
ffffffffea814664:	aa1303e2 	mov	x2, x19
ffffffffea814668:	97ffbd0c 	bl	ffffffffea803a98 <arm64_mmu_map>
ffffffffea81466c:	2a0003fb 	mov	w27, w0
		                    mp->pfn_list[pg], entry_size, pte_attr,
		                    0, MMU_USER_SIZE_SHIFT, MMU_USER_TOP_SHIFT,
		                    MMU_USER_PAGE_SIZE_SHIFT,
		                    ut->page_table, ut->arch.asid);
		if (err) {
ffffffffea814670:	34fffd40 	cbz	w0, ffffffffea814618 <arch_uthread_map+0xa8>
	}

	return NO_ERROR;

err_undo_maps:
	for(u_int p = 0; p < pg; p++) {
ffffffffea814674:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea814678:	b4000214 	cbz	x20, ffffffffea8146b8 <arch_uthread_map+0x148>
ffffffffea81467c:	d503201f 	nop
		arm64_mmu_unmap(mp->vaddr + p * entry_size, entry_size,
ffffffffea814680:	f94002c0 	ldr	x0, [x22]
	for(u_int p = 0; p < pg; p++) {
ffffffffea814684:	110006f7 	add	w23, w23, #0x1
		arm64_mmu_unmap(mp->vaddr + p * entry_size, entry_size,
ffffffffea814688:	b9409aa7 	ldr	w7, [x21, #152]
ffffffffea81468c:	52800185 	mov	w5, #0xc                   	// #12
ffffffffea814690:	f9403aa6 	ldr	x6, [x21, #112]
ffffffffea814694:	528002a4 	mov	w4, #0x15                  	// #21
ffffffffea814698:	52800323 	mov	w3, #0x19                  	// #25
ffffffffea81469c:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea8146a0:	9b1a0260 	madd	x0, x19, x26, x0
ffffffffea8146a4:	aa1303e1 	mov	x1, x19
	for(u_int p = 0; p < pg; p++) {
ffffffffea8146a8:	2a1703fa 	mov	w26, w23
		arm64_mmu_unmap(mp->vaddr + p * entry_size, entry_size,
ffffffffea8146ac:	97ffbd29 	bl	ffffffffea803b50 <arm64_mmu_unmap>
	for(u_int p = 0; p < pg; p++) {
ffffffffea8146b0:	eb14035f 	cmp	x26, x20
ffffffffea8146b4:	54fffe63 	b.cc	ffffffffea814680 <arch_uthread_map+0x110>  // b.lo, b.ul, b.last
ffffffffea8146b8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8146bc:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea8146c0:	a9446bb9 	ldp	x25, x26, [x29, #64]
		                MMU_USER_TOP_SHIFT, MMU_USER_PAGE_SIZE_SHIFT,
		                ut->page_table, ut->arch.asid);
	}

	return err;
}
ffffffffea8146c4:	2a1b03e0 	mov	w0, w27
ffffffffea8146c8:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea8146cc:	a942d7f4 	ldp	x20, x21, [sp, #40]
ffffffffea8146d0:	f9401ff6 	ldr	x22, [sp, #56]
ffffffffea8146d4:	f94033fb 	ldr	x27, [sp, #96]
ffffffffea8146d8:	9101c3ff 	add	sp, sp, #0x70
ffffffffea8146dc:	d65f03c0 	ret
	} else if (mp->flags & UTM_DEVICE) {
ffffffffea8146e0:	36480341 	tbz	w1, #9, ffffffffea814748 <arch_uthread_map+0x1d8>
		pte_attr |= MMU_PTE_ATTR_DEVICE;
ffffffffea8146e4:	b27e0339 	orr	x25, x25, #0x4
		ASSERT(!(mp->flags & UTM_X));
ffffffffea8146e8:	3617f7c1 	tbz	w1, #2, ffffffffea8145e0 <arch_uthread_map+0x70>
ffffffffea8146ec:	f0000004 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea8146f0:	f0000002 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea8146f4:	b0000001 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea8146f8:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea8146fc:	912d0084 	add	x4, x4, #0xb40
ffffffffea814700:	52801423 	mov	w3, #0xa1                  	// #161
ffffffffea814704:	912c4042 	add	x2, x2, #0xb10
ffffffffea814708:	91330021 	add	x1, x1, #0xcc0
ffffffffea81470c:	aa1403e0 	mov	x0, x20
ffffffffea814710:	97fff4be 	bl	ffffffffea811a08 <_panic>
ffffffffea814714:	a94363b7 	ldp	x23, x24, [x29, #48]
	return NO_ERROR;
ffffffffea814718:	5280001b 	mov	w27, #0x0                   	// #0
ffffffffea81471c:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea814720:	2a1b03e0 	mov	w0, w27
ffffffffea814724:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea814728:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea81472c:	a942d7f4 	ldp	x20, x21, [sp, #40]
ffffffffea814730:	f9401ff6 	ldr	x22, [sp, #56]
ffffffffea814734:	f94033fb 	ldr	x27, [sp, #96]
ffffffffea814738:	9101c3ff 	add	sp, sp, #0x70
ffffffffea81473c:	d65f03c0 	ret
ffffffffea814740:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea814744:	17ffffb1 	b	ffffffffea814608 <arch_uthread_map+0x98>
		pte_attr |= MMU_PTE_ATTR_NORMAL_MEMORY;
ffffffffea814748:	d2806100 	mov	x0, #0x308                 	// #776
ffffffffea81474c:	aa000339 	orr	x25, x25, x0
ffffffffea814750:	17ffffa4 	b	ffffffffea8145e0 <arch_uthread_map+0x70>
		err = arm64_uthread_allocate_page_table(ut);
ffffffffea814754:	97ffff75 	bl	ffffffffea814528 <arm64_uthread_allocate_page_table>
ffffffffea814758:	2a0003fb 	mov	w27, w0
		if (err) {
ffffffffea81475c:	34fff200 	cbz	w0, ffffffffea81459c <arch_uthread_map+0x2c>
ffffffffea814760:	17ffffd9 	b	ffffffffea8146c4 <arch_uthread_map+0x154>
	ASSERT(!(mp->size & USER_PAGE_MASK));
ffffffffea814764:	f0000004 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea814768:	f0000002 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea81476c:	b0000001 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea814770:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea814774:	912bc084 	add	x4, x4, #0xaf0
ffffffffea814778:	52801103 	mov	w3, #0x88                  	// #136
ffffffffea81477c:	912c4042 	add	x2, x2, #0xb10
ffffffffea814780:	91330021 	add	x1, x1, #0xcc0
ffffffffea814784:	aa1403e0 	mov	x0, x20
ffffffffea814788:	f90023b9 	str	x25, [x29, #64]
ffffffffea81478c:	97fff49f 	bl	ffffffffea811a08 <_panic>
		ASSERT(!(mp->flags & UTM_X));
ffffffffea814790:	f0000004 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea814794:	f0000002 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.2829+0xd0>
ffffffffea814798:	b0000001 	adrp	x1, ffffffffea815000 <__fault_handler_table_start>
ffffffffea81479c:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea8147a0:	912d0084 	add	x4, x4, #0xb40
ffffffffea8147a4:	528013a3 	mov	w3, #0x9d                  	// #157
ffffffffea8147a8:	912c4042 	add	x2, x2, #0xb10
ffffffffea8147ac:	91330021 	add	x1, x1, #0xcc0
ffffffffea8147b0:	aa1403e0 	mov	x0, x20
ffffffffea8147b4:	97fff495 	bl	ffffffffea811a08 <_panic>

ffffffffea8147b8 <arch_uthread_unmap>:

status_t arch_uthread_unmap(struct uthread *ut, struct uthread_map *mp)
{
	return arm64_mmu_unmap(mp->vaddr, mp->size, 0, MMU_USER_SIZE_SHIFT,
ffffffffea8147b8:	b9409807 	ldr	w7, [x0, #152]
ffffffffea8147bc:	52800185 	mov	w5, #0xc                   	// #12
ffffffffea8147c0:	f9403806 	ldr	x6, [x0, #112]
ffffffffea8147c4:	528002a4 	mov	w4, #0x15                  	// #21
ffffffffea8147c8:	a9400420 	ldp	x0, x1, [x1]
ffffffffea8147cc:	52800323 	mov	w3, #0x19                  	// #25
ffffffffea8147d0:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea8147d4:	17ffbcdf 	b	ffffffffea803b50 <arm64_mmu_unmap>
